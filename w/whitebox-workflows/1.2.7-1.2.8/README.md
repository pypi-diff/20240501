# Comparing `tmp/whitebox_workflows-1.2.7-cp38-abi3-win_amd64.whl.zip` & `tmp/whitebox_workflows-1.2.8-cp38-abi3-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,18 @@
-Zip file size: 9030768 bytes, number of entries: 16
--rw-r--r--  4.6 unx    12529 b- defN 24-Apr-15 17:47 whitebox_workflows-1.2.7.dist-info/METADATA
--rw-r--r--  4.6 unx       94 b- defN 24-Apr-15 17:47 whitebox_workflows-1.2.7.dist-info/WHEEL
--rw-r--r--  4.6 unx      163 b- defN 24-Apr-15 17:47 whitebox_workflows-1.2.7.dist-info/license_files/LICENSE.txt
--rw-r--r--  4.6 unx        0 b- defN 24-Apr-15 17:47 whitebox_workflows/py.typed
--rw-r--r--  4.6 unx     8450 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/horton_ratios.py
--rw-r--r--  4.6 unx     1786 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/improved_ground_point_filter.py
--rw-r--r--  4.6 unx     2158 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/nibble.py
--rw-r--r--  4.6 unx     1852 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/ridge_and_valley_vectors.py
--rw-r--r--  4.6 unx     1045 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/scripts.py
--rw-r--r--  4.6 unx      967 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/sieve.py
--rw-r--r--  4.6 unx      890 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/utils.py
--rw-r--r--  4.6 unx        0 b- defN 24-Apr-15 17:47 whitebox_workflows/scripts/__init__.py
--rw-r--r--  4.6 unx    91975 b- defN 24-Apr-15 17:47 whitebox_workflows/whitebox_workflows.pyi
--rw-r--r--  4.6 unx    15349 b- defN 24-Apr-15 17:47 whitebox_workflows/__init__.py
--rwxr-xr-x  4.6 unx 30193664 b- defN 24-Apr-15 17:47 whitebox_workflows/whitebox_workflows.pyd
--rw-r--r--  4.6 unx     1513 b- defN 24-Apr-15 17:47 whitebox_workflows-1.2.7.dist-info/RECORD
-16 files, 30332435 bytes uncompressed, 9028212 bytes compressed:  70.2%
+Zip file size: 9036959 bytes, number of entries: 16
+-rw-r--r--  4.6 unx    12667 b- defN 24-May-01 12:18 whitebox_workflows-1.2.8.dist-info/METADATA
+-rw-r--r--  4.6 unx       94 b- defN 24-May-01 12:18 whitebox_workflows-1.2.8.dist-info/WHEEL
+-rw-r--r--  4.6 unx      163 b- defN 24-May-01 12:18 whitebox_workflows-1.2.8.dist-info/license_files/LICENSE.txt
+-rw-r--r--  4.6 unx        0 b- defN 24-May-01 12:18 whitebox_workflows/py.typed
+-rw-r--r--  4.6 unx     8450 b- defN 24-May-01 12:18 whitebox_workflows/scripts/horton_ratios.py
+-rw-r--r--  4.6 unx     1910 b- defN 24-May-01 12:18 whitebox_workflows/scripts/improved_ground_point_filter.py
+-rw-r--r--  4.6 unx     2158 b- defN 24-May-01 12:18 whitebox_workflows/scripts/nibble.py
+-rw-r--r--  4.6 unx     1852 b- defN 24-May-01 12:18 whitebox_workflows/scripts/ridge_and_valley_vectors.py
+-rw-r--r--  4.6 unx     1045 b- defN 24-May-01 12:18 whitebox_workflows/scripts/scripts.py
+-rw-r--r--  4.6 unx      967 b- defN 24-May-01 12:18 whitebox_workflows/scripts/sieve.py
+-rw-r--r--  4.6 unx      890 b- defN 24-May-01 12:18 whitebox_workflows/scripts/utils.py
+-rw-r--r--  4.6 unx        0 b- defN 24-May-01 12:18 whitebox_workflows/scripts/__init__.py
+-rw-r--r--  4.6 unx    92231 b- defN 24-May-01 12:18 whitebox_workflows/whitebox_workflows.pyi
+-rw-r--r--  4.6 unx    15665 b- defN 24-May-01 12:18 whitebox_workflows/__init__.py
+-rwxr-xr-x  4.6 unx 30218752 b- defN 24-May-01 12:18 whitebox_workflows/whitebox_workflows.pyd
+-rw-r--r--  4.6 unx     1513 b- defN 24-May-01 12:18 whitebox_workflows-1.2.8.dist-info/RECORD
+16 files, 30358357 bytes uncompressed, 9034403 bytes compressed:  70.2%
```

## zipnote {}

```diff
@@ -1,14 +1,14 @@
-Filename: whitebox_workflows-1.2.7.dist-info/METADATA
+Filename: whitebox_workflows-1.2.8.dist-info/METADATA
 Comment: 
 
-Filename: whitebox_workflows-1.2.7.dist-info/WHEEL
+Filename: whitebox_workflows-1.2.8.dist-info/WHEEL
 Comment: 
 
-Filename: whitebox_workflows-1.2.7.dist-info/license_files/LICENSE.txt
+Filename: whitebox_workflows-1.2.8.dist-info/license_files/LICENSE.txt
 Comment: 
 
 Filename: whitebox_workflows/py.typed
 Comment: 
 
 Filename: whitebox_workflows/scripts/horton_ratios.py
 Comment: 
@@ -39,11 +39,11 @@
 
 Filename: whitebox_workflows/__init__.py
 Comment: 
 
 Filename: whitebox_workflows/whitebox_workflows.pyd
 Comment: 
 
-Filename: whitebox_workflows-1.2.7.dist-info/RECORD
+Filename: whitebox_workflows-1.2.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## whitebox_workflows/scripts/improved_ground_point_filter.py

```diff
@@ -4,48 +4,55 @@
 
 def improved_ground_point_filter(
         wbe: WbEnvironmentBase, 
         input: Lidar, 
         block_size = 1.0, # in xy units
         max_building_size = 150.0, # in xy units
         slope_threshold = 15.0,
-        elev_threshold = 0.15
+        elev_threshold = 0.15,
+        classify = False,
+        preserve_classes = False
     ) -> Lidar:
     if wbe.license_type != LicenseType.WbWPro:
         raise LicenseError()
     
     reset_verbose = wbe.verbose
     if wbe.verbose:
         print_tool_header("improved_ground_point_filter")
         print("\nPerforming operation...")
 
     wbe.verbose = False # suppress the output from each of the workflow components
 
     max_building_size = ceil(max_building_size / block_size) # max_building_size expressed in cell
 
-    # print('Finding min z points...')
-    grd_pts = wbe.filter_lidar_by_percentile(input, 0.0, 1.0)
+    grd_pts = wbe.filter_lidar_by_percentile(input, 0.0, block_size)
 
-    # print('TINing...')
     tin = wbe.lidar_tin_gridding(
         input_lidar=grd_pts,
         interpolation_parameter="z",
         returns_included='all',
         cell_size=block_size, 
         excluded_classes=None
     )
 
-    # print('Finding and removing low-point noise...')
-    tin2 = wbe.fill_pits(tin)
+    tin2 = wbe.fill_pits(tin) # Handle any low-noise points
     tin = (tin2 - tin).con(f'value > {elev_threshold*2.0}', tin2, tin)
 
-    # print('Removing off-terrain objects....')
     dtm = wbe.remove_off_terrain_objects(tin, filter_size=max_building_size, slope_threshold=slope_threshold)
 
-    grd_pts = wbe.filter_lidar_by_reference_surface(input_lidar=input, ref_surface=dtm, threshold=elev_threshold)
+    grd_pts = wbe.filter_lidar_by_reference_surface(
+        input_lidar=input, 
+        ref_surface=dtm, 
+        query='within',
+        threshold=elev_threshold, 
+        classify=classify, 
+        true_class_value=2, 
+        false_class_value=1, 
+        preserve_classes=preserve_classes
+    )
     
     if grd_pts.header.get_num_points() == 0:
         raise Exception("No ground points were detected")
 
     wbe.verbose = reset_verbose
 
     return grd_pts
```

## whitebox_workflows/whitebox_workflows.pyi

```diff
@@ -1426,18 +1426,20 @@
 
 	def fill_pits(self, dem: Raster) -> Raster: ...
 
 	def filter_lidar(self, statement: str, input_lidar: Optional[Lidar]) -> Optional[Lidar]: ...
 
 	def filter_lidar_by_percentile(self, input_lidar: Optional[Lidar],  percentile: float = 0.0, block_size: float = 1.0) -> Optional[Lidar]: ...
 
-	def filter_lidar_by_reference_surface(self, input_lidar: Lidar, ref_surface: Raster, query: str = "within", threshold: float = 0.0) -> Lidar: ...
+	def filter_lidar_by_reference_surface(self, input_lidar: Lidar, ref_surface: Raster, query: str = "within", threshold: float = 0.0, classify: bool = False, true_class_value: int = 2, false_class_value: int = 1, preserve_classes: bool = False) -> Lidar: ...
 
 	def filter_lidar_classes(self, input: Lidar, exclusion_classes: List[int]) -> Lidar: ...
 
+	def filter_lidar_noise(self, input: Lidar) -> Lidar: ...
+
 	def filter_lidar_scan_angles(self, in_lidar: Lidar, threshold: int) -> Lidar: ...
 
 	def filter_raster_features_by_area(self, input: Raster, threshold: int, zero_background: bool = False) -> Raster: ...
 
 	def find_flightline_edge_points(self, in_lidar: Lidar) -> Lidar: ...
 
 	def find_lowest_or_highest_points(self, raster: Raster, output_type: str = "lowest") -> Vector: ...
@@ -1542,15 +1544,15 @@
 
 	def image_slider(self, left_raster: Raster, right_raster: Raster, output_html_file: str, left_palette: WbPalette = WbPalette.Grey, left_reverse_palette: bool = False, left_label: str = "",  right_palette: WbPalette = WbPalette.Grey, right_reverse_palette: bool = False, right_label: str = "", image_height: int = 600) -> None: ...
 
 	def image_stack_profile(self, images: List[Raster], points: Vector, output_html_file: str) -> None: ...
 
 	def impoundment_size_index(self, dem: Raster, max_dam_length: float, output_mean: bool = False, output_max: bool = False, output_volume: bool = False, output_area: bool = False, output_height: bool = False) -> Tuple[Optional[Raster], Optional[Raster], Optional[Raster], Optional[Raster], Optional[Raster]]: ...
 
-	def improved_ground_point_filter(self, input: Lidar, block_size = 1.0, max_building_size = 150.0, slope_threshold = 15.0, elev_threshold = 0.15) -> Lidar: ...
+	def improved_ground_point_filter(self, input: Lidar, block_size: float = 1.0, max_building_size: float = 150.0, slope_threshold: float = 15.0, elev_threshold: float = 0.15, classify: bool = False, preserve_classes: bool = False) -> Lidar: ...
 
 	def individual_tree_detection(self, input_lidar: Optional[Lidar],  min_search_radius: float = 1.0, min_height: float = 0.0, max_search_radius: Optional[float] = None, max_height: Optional[float] = None, only_use_veg: bool = False) -> Optional[Vector]: ...
 
 	def insert_dams(self, dem: Raster, dam_points: Vector, dam_length: float) -> Raster: ...
 
 	def isobasins(self, dem: Raster, target_size: float, connections: bool = False, csv_file: str = "" ) -> Raster: ...
 
@@ -1842,20 +1844,20 @@
 
 	def percentage_contrast_stretch(self, raster: Raster, clip: float = 1.0, tail: str = "both", num_tones: int = 256) -> Raster: ...
 
 	def percentile_filter(self, raster: Raster, filter_size_x: int = 11, filter_size_y: int = 11, sig_digits: int = 2) -> Raster: ...
 
 	def perimeter_area_ratio(self, input: Vector) -> Vector: ...
 
+	def phi_coefficient(self, raster1: Raster, raster2: Raster, output_html_file: str) -> None: ...
+
 	def pick_from_list(self, input_rasters: List[Raster], pos_input: Raster) -> Raster: ...
 
 	def piecewise_contrast_stretch(self, raster: Raster, transformation_statement: str, num_greytones: float = 1024.0) -> Raster: ...
 
-	def phi_coefficient(self, raster1: Raster, raster2: Raster, output_html_file: str) -> None: ...
-
 	def plan_curvature(self, dem: Raster, log_transform: bool = False, z_factor: float = 1.0) -> Raster: ...
 
 	def polygon_area(self, input: Vector) -> Vector: ...
 
 	def polygon_long_axis(self, input: Vector) -> Vector: ...
 
 	def polygon_perimeter(self, input: Vector) -> Vector: ...
```

## whitebox_workflows/__init__.py

```diff
@@ -215,15 +215,15 @@
 # Function Signature
 ```python
 def sieve(self, input_raster: Raster, threshold: int = 1, zero_background: bool = False) -> Raster: ...
 ```
         '''
         return sieve(self, input_raster, threshold, zero_background)
     
-    def improved_ground_point_filter(self, input: Lidar, block_size = 1.0, max_building_size = 150.0, slope_threshold = 15.0, elev_threshold = 0.15) -> Lidar:
+    def improved_ground_point_filter(self, input: Lidar, block_size: float = 1.0, max_building_size: float = 150.0, slope_threshold: float = 15.0, elev_threshold: float = 0.15, classify: bool = False, preserve_classes: bool = False) -> Lidar:
         '''Use of this function requires a license for Whitebox Workflows for Python Professional (WbW-Pro).
 Please visit www.whiteboxgeo.com to purchase a license.
 
 This function provides a faster alternative to the `lidar_ground_point_filter` algorithm, provided in the free
 version of Whitebox Workflows, for the extraction of ground points from within a LiDAR point cloud. The algorithm
 works by placing a grid overtop of the point cloud of a specified resolution (`block_size`, in xy-units) and identifying the
 subset of lidar points associated with the lowest position in each block. A raster surface is then created by 
@@ -233,22 +233,24 @@
 (`input`) that are within a specified absolute vertical distance (`elev_threshold`) of this surface model.
 
 Conceptually, this method of ground-point filtering is somewhat similar in concept to the cloth-simulation approach of 
 Zhang et al. (2016). The difference is that the cloth is first fitted to the minimum surface with infinite flexibility 
 and then the rigidity of the cloth is subsequently increased, via the identification and removal of OTOs from the minimal 
 surface. The `slope_threshold` parameter effectively controls the eventual rigidity of the fitted surface.
 
+By default, the tool will return a point cloud containing only the subset of points in the input dataset that coincide
+with the idenfitied ground points. Setting the `classify` parameter to True modifies this behaviour such that the output
+point cloud will contain all of the points within the input dataset, but will have the classification value of identified
+ground points set to '2' (i.e., the ground class value) and all other points will be set to '1' (i.e., the unclassified
+class value). By setting the `preserve_classes` paramter to True, all non-ground points in the output cloud will have
+the same classes as the corresponding point class values in the input dataset.
+
 Compared with the `lidar_ground_point_filter` algorithm, the `improved_ground_point_filter` algorithm is generally far faster and is
 able to more effectively remove points associated with larger buildings. Removing large buildings from point clouds with the 
 `lidar_ground_point_filter` algorithm requires use of very large search distances, which slows the operation considerably.
-However, `lidar_ground_point_filter` is perhaps more flexible overall because it provides the option to either extract
-ground points or simply to classify them. The `improved_ground_point_filter` function, by comparison, only allows for the 
-extraction of ground points (i.e., filtering) and not the classification of ground points. Thus, this function is more suited
-to the efficient creation of ground point clouds of bare-earth digital elevation models (i.e., digital terrain models) from
-unclassified LiDAR data assets.
 
 As a comparison of the two available methods, one test tile of LiDAR containing numerous large buildings and abundant 
 vegetation required 600.5 seconds to process on the test system using the `lidar_ground_point_filter` algorithm 
 (removing all but the largest buildings) and 9.8 seconds to process using the `improved_ground_point_filter` algorithm 
 (with complete building removal), i.e., 61x faster.
 
 The original test LiDAR tile, containing abundant vegetation and buildings:
@@ -270,11 +272,11 @@
 method based on cloth simulation. Remote sensing, 8(6), 501.
 
 # See Also:
 <a href='https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#lidar_ground_point_filter'>lidar_ground_point_filter</a>
 
 # Function Signature
 ```python
-def improved_ground_point_filter(self, input: Lidar, block_size = 1.0, max_building_size = 150.0, slope_threshold = 15.0, elev_threshold = 0.15) -> Lidar: ...
+def improved_ground_point_filter(self, input: Lidar, block_size = 1.0, max_building_size = 150.0, slope_threshold = 15.0, elev_threshold = 0.15, , classify = False, preserve_classes = False) -> Lidar: ...
 ```
         '''
-        return improved_ground_point_filter(self, input, block_size, max_building_size, slope_threshold, elev_threshold)
+        return improved_ground_point_filter(self, input, block_size, max_building_size, slope_threshold, elev_threshold, classify, preserve_classes)
```

## Comparing `whitebox_workflows-1.2.7.dist-info/METADATA` & `whitebox_workflows-1.2.8.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: whitebox_workflows
-Version: 1.2.7
+Version: 1.2.8
 Classifier: Programming Language :: Rust
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 License-File: LICENSE.txt
 Summary: whitebox_workflows is a Python library for advanced spatial analysis.
 Keywords: spatial analysis,GIS,remote sensing
 Author: Whitebox Geospatial Inc.
@@ -152,14 +152,18 @@
         lidar_out.add_point(point_data, time)
 
 wbe.write_lidar(lidar_out, "new_lidar.laz")
 ```
 
 ## Release history
 
+## Version 1.2.8 (May 1, 2024)
+- Minor release fixing bug in lidar_join function.
+- Updated a number of libraries to newer versions.
+
 ## Version 1.2.7 (April 15, 2024)
 - Added the filter_lidar_by_percentile function, which extracts a subset of points from an 
   input LiDAR point cloud that correspond to a user-specified percentile of the points within 
   the local neighbourhood.
 - Added the filter_lidar_by_reference_surface function, which extract a subset of points from an 
   input LiDAR point cloud that satisfy a query relation with a user-specified raster reference surface.
 - Added the improved_ground_point_filter function, which identifies and extracts ground points from
```

## Comparing `whitebox_workflows-1.2.7.dist-info/RECORD` & `whitebox_workflows-1.2.8.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-whitebox_workflows-1.2.7.dist-info/METADATA,sha256=j4zIFq_-x-HiQT3kB56rnxvNZofn9hiE0cWkbkoPgFU,12529
-whitebox_workflows-1.2.7.dist-info/WHEEL,sha256=_-pO1V0R3bpcg5FhWC82Cl79freIhF1O9I5uv0may5k,94
-whitebox_workflows-1.2.7.dist-info/license_files/LICENSE.txt,sha256=uBmnn03dDa5bOiHwTs9qtqcTwrWnhNbulJZYGJUJGyc,163
+whitebox_workflows-1.2.8.dist-info/METADATA,sha256=KfiZYsu33UgYCFJGOLjMbn7pvK5fnrLuD7dacx-m2hE,12667
+whitebox_workflows-1.2.8.dist-info/WHEEL,sha256=_-pO1V0R3bpcg5FhWC82Cl79freIhF1O9I5uv0may5k,94
+whitebox_workflows-1.2.8.dist-info/license_files/LICENSE.txt,sha256=uBmnn03dDa5bOiHwTs9qtqcTwrWnhNbulJZYGJUJGyc,163
 whitebox_workflows/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 whitebox_workflows/scripts/horton_ratios.py,sha256=Rk93Flpuq4xfwtUrZDOKm0fHg9G-zhqMUnDGHuSSWTQ,8450
-whitebox_workflows/scripts/improved_ground_point_filter.py,sha256=x-rITNHQM2rOPxCVEkMzKoVlbVNXHQojCl1g4zwSRrE,1786
+whitebox_workflows/scripts/improved_ground_point_filter.py,sha256=UiIFtcbtArI68WVTsp3yl7K13SBmGPzU6Wqpmoe8100,1910
 whitebox_workflows/scripts/nibble.py,sha256=NhcgqqC_5efH0LQPgUeUHncqSRQOkE4ERGUg-VEKYo0,2158
 whitebox_workflows/scripts/ridge_and_valley_vectors.py,sha256=ipLbFdRY3l0D1cyQ6BY5bsTUR5hjNihcl8msc9CSux0,1852
 whitebox_workflows/scripts/scripts.py,sha256=B1t8uiSjyZc1JbLbeKCflhtSfF5JirVLhBk9LiTdtUk,1045
 whitebox_workflows/scripts/sieve.py,sha256=kdHFJvjJT_YpF02GHuB1rwO5YLL7IQovWUhWkVoQDJc,967
 whitebox_workflows/scripts/utils.py,sha256=OGx5UiGeVmdoyQ1ft-zb91UvSWC1CfAmM3p3S_Me-eg,890
 whitebox_workflows/scripts/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-whitebox_workflows/whitebox_workflows.pyi,sha256=zfGq94OXn5BSMjUj1ZWVABkW_7fgt5fX6_uql-EKblk,91975
-whitebox_workflows/__init__.py,sha256=g0Eu2T4ZCeD19Z8qfUOVMf7VygOm_htkvuwI8x1YJ4w,15349
-whitebox_workflows/whitebox_workflows.pyd,sha256=geqyjItuYbbvtZ65D7DN4rvUt3ZbsvpA6dnspfJCqUk,30193664
-whitebox_workflows-1.2.7.dist-info/RECORD,,
+whitebox_workflows/whitebox_workflows.pyi,sha256=E5aRfrKJvqIGeeh-mn-2f4LCnBRzO5MJ0ftifNpRMxY,92231
+whitebox_workflows/__init__.py,sha256=r3d-64QbfxVpCFcKLJmDTzgRETC0hCnl5N7qVG4tRfM,15665
+whitebox_workflows/whitebox_workflows.pyd,sha256=ZuWp7kY7BBMYsih57Pgylb5eAPvGk2_U8211JGrjYwU,30218752
+whitebox_workflows-1.2.8.dist-info/RECORD,,
```

