# Comparing `tmp/agixt-1.5.6-py3-none-any.whl.zip` & `tmp/agixt-1.5.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,21 @@
-Zip file size: 35341 bytes, number of entries: 19
--rw-r--r--  2.0 unx     3466 b- defN 24-Apr-29 12:01 agixt/ApiClient.py
--rw-r--r--  2.0 unx     8584 b- defN 24-Apr-29 12:01 agixt/Chains.py
--rw-r--r--  2.0 unx    10260 b- defN 24-Apr-29 12:01 agixt/DBConnection.py
--rw-r--r--  2.0 unx      863 b- defN 24-Apr-29 12:01 agixt/Defaults.py
--rw-r--r--  2.0 unx     9608 b- defN 24-Apr-29 12:01 agixt/Extensions.py
--rw-r--r--  2.0 unx    32804 b- defN 24-Apr-29 12:01 agixt/Interactions.py
--rw-r--r--  2.0 unx    23597 b- defN 24-Apr-29 12:01 agixt/Memories.py
--rw-r--r--  2.0 unx     5228 b- defN 24-Apr-29 12:01 agixt/Models.py
--rw-r--r--  2.0 unx     3780 b- defN 24-Apr-29 12:01 agixt/Providers.py
--rw-r--r--  2.0 unx     6315 b- defN 24-Apr-29 12:01 agixt/Tuning.py
--rw-r--r--  2.0 unx      626 b- defN 24-Apr-29 12:01 agixt/Tunnel.py
--rw-r--r--  2.0 unx    13286 b- defN 24-Apr-29 12:01 agixt/Websearch.py
--rw-r--r--  2.0 unx       32 b- defN 24-Apr-29 12:01 agixt/__init__.py
--rw-r--r--  2.0 unx     1849 b- defN 24-Apr-29 12:01 agixt/app.py
--rw-r--r--  2.0 unx     1087 b- defN 24-Apr-29 12:01 agixt-1.5.6.dist-info/LICENSE
--rw-r--r--  2.0 unx    11418 b- defN 24-Apr-29 12:01 agixt-1.5.6.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-29 12:01 agixt-1.5.6.dist-info/WHEEL
--rw-r--r--  2.0 unx        6 b- defN 24-Apr-29 12:01 agixt-1.5.6.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1412 b- defN 24-Apr-29 12:01 agixt-1.5.6.dist-info/RECORD
-19 files, 134313 bytes uncompressed, 33101 bytes compressed:  75.4%
+Zip file size: 36996 bytes, number of entries: 19
+-rw-r--r--  2.0 unx     3821 b- defN 24-May-01 01:44 agixt/ApiClient.py
+-rw-r--r--  2.0 unx     8584 b- defN 24-May-01 01:44 agixt/Chains.py
+-rw-r--r--  2.0 unx    10260 b- defN 24-May-01 01:44 agixt/DBConnection.py
+-rw-r--r--  2.0 unx      863 b- defN 24-May-01 01:44 agixt/Defaults.py
+-rw-r--r--  2.0 unx     9608 b- defN 24-May-01 01:44 agixt/Extensions.py
+-rw-r--r--  2.0 unx    38231 b- defN 24-May-01 01:44 agixt/Interactions.py
+-rw-r--r--  2.0 unx    23597 b- defN 24-May-01 01:44 agixt/Memories.py
+-rw-r--r--  2.0 unx     5228 b- defN 24-May-01 01:44 agixt/Models.py
+-rw-r--r--  2.0 unx     3780 b- defN 24-May-01 01:44 agixt/Providers.py
+-rw-r--r--  2.0 unx     6315 b- defN 24-May-01 01:44 agixt/Tuning.py
+-rw-r--r--  2.0 unx      626 b- defN 24-May-01 01:44 agixt/Tunnel.py
+-rw-r--r--  2.0 unx    13286 b- defN 24-May-01 01:44 agixt/Websearch.py
+-rw-r--r--  2.0 unx       32 b- defN 24-May-01 01:44 agixt/__init__.py
+-rw-r--r--  2.0 unx     1849 b- defN 24-May-01 01:44 agixt/app.py
+-rw-r--r--  2.0 unx     1087 b- defN 24-May-01 01:44 agixt-1.5.7.dist-info/LICENSE
+-rw-r--r--  2.0 unx    11418 b- defN 24-May-01 01:44 agixt-1.5.7.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-01 01:44 agixt-1.5.7.dist-info/WHEEL
+-rw-r--r--  2.0 unx        6 b- defN 24-May-01 01:44 agixt-1.5.7.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1412 b- defN 24-May-01 01:44 agixt-1.5.7.dist-info/RECORD
+19 files, 140095 bytes uncompressed, 34756 bytes compressed:  75.2%
```

## zipnote {}

```diff
@@ -36,23 +36,23 @@
 
 Filename: agixt/__init__.py
 Comment: 
 
 Filename: agixt/app.py
 Comment: 
 
-Filename: agixt-1.5.6.dist-info/LICENSE
+Filename: agixt-1.5.7.dist-info/LICENSE
 Comment: 
 
-Filename: agixt-1.5.6.dist-info/METADATA
+Filename: agixt-1.5.7.dist-info/METADATA
 Comment: 
 
-Filename: agixt-1.5.6.dist-info/WHEEL
+Filename: agixt-1.5.7.dist-info/WHEEL
 Comment: 
 
-Filename: agixt-1.5.6.dist-info/top_level.txt
+Filename: agixt-1.5.7.dist-info/top_level.txt
 Comment: 
 
-Filename: agixt-1.5.6.dist-info/RECORD
+Filename: agixt-1.5.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## agixt/ApiClient.py

```diff
@@ -78,21 +78,29 @@
 
 
 def get_api_client(authorization: str = Header(None)):
     authorization = str(authorization).replace("Bearer ", "").replace("bearer ", "")
     return AGiXTSDK(base_uri="http://localhost:7437", api_key=authorization)
 
 
-def is_admin(email: str, api_key: str = None):
-    global DB_CONNECTED, AGIXT_API_KEY
+def is_admin(email: str = "USER", api_key: str = None):
+    load_dotenv()
+    AGIXT_API_KEY = os.getenv("AGIXT_API_KEY", "")
+    DB_CONNECTED = (
+        True if os.getenv("DB_CONNECTED", "false").lower() == "true" else False
+    )
     if DB_CONNECTED != True:
         return True
     if api_key is None:
         api_key = ""
     api_key = api_key.replace("Bearer ", "").replace("bearer ", "")
     if AGIXT_API_KEY == api_key:
         return True
     if DB_CONNECTED == True:
         from db.User import is_agixt_admin
 
+        if email == "" or email is None or email == "None":
+            email = os.getenv("DEFAULT_USER", "USER")
+            if email == "" or email is None or email == "None":
+                email = "USER"
         return is_agixt_admin(email=email, api_key=api_key)
     return False
```

## agixt/Interactions.py

```diff
@@ -1,26 +1,29 @@
 import os
 import re
 import regex
 import json
 import time
 import logging
 import tiktoken
+import base64
+import uuid
 from datetime import datetime
 from readers.website import WebsiteReader
 from readers.file import FileReader
 from readers.youtube import YoutubeReader
 from Websearch import Websearch
 from Extensions import Extensions
 from ApiClient import (
     Agent,
     Prompts,
     Chain,
     log_interaction,
     get_conversation,
+    AGIXT_URI,
 )
 from Defaults import DEFAULT_USER
 
 
 def get_tokens(text: str) -> int:
     encoding = tiktoken.get_encoding("cl100k_base")
     num_tokens = len(encoding.encode(text))
@@ -245,14 +248,15 @@
         if "conversation_name" in kwargs:
             conversation_name = kwargs["conversation_name"]
         if conversation_name == "":
             conversation_name = f"{str(datetime.now())} Conversation"
         conversation = get_conversation(
             agent_name=self.agent_name,
             conversation_name=conversation_name,
+            user=self.user,
         )
         if "conversation_results" in kwargs:
             conversation_results = int(kwargs["conversation_results"])
         else:
             conversation_results = int(top_results) if top_results > 0 else 5
         conversation_history = ""
         if "interactions" in conversation:
@@ -406,15 +410,14 @@
         step_number: int = 0,
         shots: int = 1,
         disable_memory: bool = True,
         conversation_name: str = "",
         browse_links: bool = False,
         persist_context_in_history: bool = False,
         images: list = [],
-        create_image: bool = False,
         **kwargs,
     ):
         for setting in self.agent.AGENT_CONFIG["settings"]:
             if setting not in kwargs:
                 kwargs[setting] = self.agent.AGENT_CONFIG["settings"][setting]
         if shots == 0:
             shots = 1
@@ -447,15 +450,16 @@
                 websearch_depth = int(kwargs["websearch_depth"])
             except:
                 websearch_depth = 3
             del kwargs["websearch_depth"]
         if "conversation_name" in kwargs:
             conversation_name = kwargs["conversation_name"]
         if conversation_name == "":
-            conversation_name = f"{str(datetime.now())} Conversation"
+            clean_datetime = re.sub(r"[^a-zA-Z0-9]", "", str(datetime.now()))
+            conversation_name = f"{clean_datetime} Conversation"
         if "WEBSEARCH_TIMEOUT" in kwargs:
             try:
                 websearch_timeout = int(kwargs["WEBSEARCH_TIMEOUT"])
             except:
                 websearch_timeout = 0
         else:
             websearch_timeout = 0
@@ -489,79 +493,86 @@
                                             (
                                                 text_content,
                                                 link_list,
                                             ) = await self.agent_memory.write_website_to_memory(
                                                 url=sublink[1]
                                             )
                                             i = i + 1
+        logging.info(f"Made it to websearch: {websearch}")
         if websearch:
             if user_input == "":
                 if "primary_objective" in kwargs and "task" in kwargs:
                     search_string = f"Primary Objective: {kwargs['primary_objective']}\n\nTask: {kwargs['task']}"
                 else:
                     search_string = ""
             else:
                 search_string = user_input
             if search_string != "":
-                await self.websearch.websearch_agent(
-                    user_input=search_string,
-                    websearch_depth=websearch_depth,
-                    websearch_timeout=websearch_timeout,
-                )
+                try:
+                    await self.websearch.websearch_agent(
+                        user_input=search_string,
+                        websearch_depth=websearch_depth,
+                        websearch_timeout=websearch_timeout,
+                    )
+                except:
+                    logging.warning("Failed to websearch.")
+        logging.info(f"Made it past websearch: {websearch}")
         vision_response = ""
         if "vision_provider" in self.agent.AGENT_CONFIG["settings"]:
             vision_provider = self.agent.AGENT_CONFIG["settings"]["vision_provider"]
             if images != [] and vision_provider != "None" and vision_provider != "":
                 try:
                     vision_response = await self.agent.inference(
                         prompt=user_input, tokens=tokens, images=images
                     )
                 except:
-                    pass
+                    logging.warning("Failed to get vision response.")
+        logging.info(f"Made it past vision: {vision_response}")
         image_response = ""
-        if create_image:
-            try:
-                sd_prompt = self.ApiClient.prompt_agent(
-                    agent_name=self.agent_name,
-                    prompt_name="AGiXT SD Generator_V3",
-                    prompt_args={
-                        "user_input": user_input,
-                        "conversation_name": "AGiXT Terminal",
-                    },
-                )
-                image_response = await self.agent.generate_image(prompt=sd_prompt)
-            except:
-                pass
+        logging.info(f"Made it past image generation: {image_response}")
+        logging.info(f"User Input: {user_input}")
+        logging.info(f"Context Results: {context_results}")
+        logging.info(f"Prompt: {prompt}")
+        logging.info(f"Chain Name: {chain_name}")
+        logging.info(f"Step Number: {step_number}")
+        logging.info(f"Conversation Name: {conversation_name}")
+        logging.info(f"Websearch: {websearch}")
+        logging.info(f"Vision Response: {vision_response}")
+        logging.info(f"kwargs: {kwargs}")
         formatted_prompt, unformatted_prompt, tokens = await self.format_prompt(
             user_input=user_input,
             top_results=int(context_results),
             prompt=prompt,
             chain_name=chain_name,
             step_number=step_number,
             conversation_name=conversation_name,
             websearch=websearch,
             vision_response=vision_response,
             **kwargs,
         )
+        logging.info(f"Formatted Prompt: {formatted_prompt}")
+        logging.info(f"Unformatted Prompt: {unformatted_prompt}")
         log_message = (
             user_input
             if user_input != "" and persist_context_in_history == False
             else formatted_prompt
         )
         log_interaction(
             agent_name=self.agent_name,
             conversation_name=conversation_name,
             role="USER",
             message=log_message,
             user=self.user,
         )
+        logging.info(f"Logged Interaction: {log_message}")
         try:
             self.response = await self.agent.inference(
                 prompt=formatted_prompt, tokens=tokens
             )
+            logging.info(f"Response: {self.response}")
         except Exception as e:
             # Log the error with the full traceback for the provider
             error = ""
             for err in e:
                 error += f"{err.args}\n{err.name}\n{err.msg}\n"
             logging.error(f"{self.agent.PROVIDER} Error: {error}")
             logging.info(f"PROMPT CONTENT: {formatted_prompt}")
@@ -571,92 +582,155 @@
                 self.failures == 0
                 logging.info("Failed to get a response 5 times in a row.")
                 return None
             logging.info(f"Retrying in 10 seconds...")
             time.sleep(10)
             if context_results > 0:
                 context_results = context_results - 1
-            return self.ApiClient.prompt_agent(
-                agent_name=self.agent_name,
+            prompt_args = {
+                "chain_name": chain_name,
+                "step_number": step_number,
+                "shots": shots,
+                "disable_memory": disable_memory,
+                "user_input": user_input,
+                "context_results": context_results,
+                "conversation_name": conversation_name,
+                **kwargs,
+            }
+            return await self.run(
                 prompt_name=prompt,
-                prompt_args={
-                    "chain_name": chain_name,
-                    "step_number": step_number,
-                    "shots": shots,
-                    "disable_memory": disable_memory,
-                    "user_input": user_input,
-                    "context_results": context_results,
-                    "conversation_name": conversation_name,
-                    **kwargs,
-                },
+                prompt_category=(
+                    "Default"
+                    if "prompt_category" not in kwargs
+                    else kwargs["prompt_category"]
+                ),
+                **prompt_args,
             )
         # Handle commands if the prompt contains the {COMMANDS} placeholder
         # We handle command injection that DOESN'T allow command execution by using {command_list} in the prompt
         if "{COMMANDS}" in unformatted_prompt:
+            logging.info("Prompt contains {COMMANDS} placeholder.")
             await self.execution_agent(conversation_name=conversation_name)
         logging.info(f"Response: {self.response}")
         if self.response != "" and self.response != None:
+            agent_settings = self.agent.AGENT_CONFIG["settings"]
+            if "tts_provider" in agent_settings:
+                if (
+                    agent_settings["tts_provider"] != "None"
+                    and agent_settings["tts_provider"] != ""
+                ):
+                    tts_response = await self.agent.text_to_speech(text=self.response)
+                    # If tts_response is a not a url starting with http, it is a base64 encoded audio file
+                    if not str(tts_response).startswith("http"):
+                        file_type = "wav"
+                        file_name = f"{uuid.uuid4().hex}.{file_type}"
+                        audio_path = f"./WORKSPACE/{file_name}"
+                        audio_data = base64.b64decode(tts_response)
+                        with open(audio_path, "wb") as f:
+                            f.write(audio_data)
+                        global AGIXT_URI
+                        tts_response = f'<audio controls><source src="{AGIXT_URI}/outputs/{file_name}" type="audio/wav"></audio>'
+                    self.response = f"{self.response}\n\n{tts_response}"
             if disable_memory != True:
                 try:
                     await self.agent_memory.write_text_to_memory(
                         user_input=user_input,
                         text=self.response,
                         external_source="user input",
                     )
                 except:
                     pass
+            if "image_provider" in agent_settings:
+                if (
+                    agent_settings["image_provider"] != "None"
+                    and agent_settings["image_provider"] != ""
+                    and agent_settings["image_provider"] != None
+                    and agent_settings["image_provider"] != "default"
+                ):
+                    img_gen_prompt = f"Users message: {user_input} \n\n{'The user uploaded an image, one does not need generated unless the user is specifically asking.' if images else ''} **The assistant is acting as sentiment analysis expert and only responds with a concise YES or NO answer on if the user would like an image as visual or a picture generated. No other explanation is needed!**\nWould the user potentially like an image generated based on their message?\nAssistant: "
+                    logging.info(f"[IMG] Decision maker prompt: {img_gen_prompt}")
+                    create_img = await self.agent.inference(prompt=img_gen_prompt)
+                    create_img = str(create_img).lower()
+                    logging.info(f"[IMG] Decision maker response: {create_img}")
+                    if "yes" in create_img or "es," in create_img:
+                        img_prompt = f"**The assistant is acting as a Stable Diffusion Prompt Generator.**\n\nUsers message: {user_input} \nAssistant response: {self.response} \n\nImportant rules to follow:\n- Describe subjects in detail, specify image type (e.g., digital illustration), art style (e.g., steampunk), and background. Include art inspirations (e.g., Art Station, specific artists). Detail lighting, camera (type, lens, view), and render (resolution, style). The weight of a keyword can be adjusted by using the syntax (((keyword))) , put only those keyword inside ((())) which is very important because it will have more impact so anything wrong will result in unwanted picture so be careful. Realistic prompts: exclude artist, specify lens. Separate with double lines. Max 60 words, avoiding 'real' for fantastical.\n- Based on the message from the user and response of the assistant, you will need to generate one detailed stable diffusion image generation prompt based on the context of the conversation to accompany the assistant response.\n- The prompt can only be up to 60 words long, so try to be concise while using enough descriptive words to make a proper prompt.\n- Following all rules will result in a $2000 tip that you can spend on anything!\n- Must be in markdown code block to be parsed out and only provide prompt in the code block, nothing else.\nStable Diffusion Prompt Generator: "
+                        image_generation_prompt = await self.agent.inference(
+                            prompt=img_prompt
+                        )
+                        image_generation_prompt = str(image_generation_prompt)
+                        logging.info(
+                            f"[IMG] Image generation response: {image_generation_prompt}"
+                        )
+                        if "```markdown" in image_generation_prompt:
+                            image_generation_prompt = image_generation_prompt.split(
+                                "```markdown"
+                            )[1]
+                            image_generation_prompt = image_generation_prompt.split(
+                                "```"
+                            )[0]
+                        try:
+                            generated_image = await self.agent.generate_image(
+                                prompt=image_generation_prompt
+                            )
+                            self.response = f"{self.response}\n\n![Image generated by {self.agent_name}]({generated_image})"
+                        except:
+                            logging.warning(
+                                f"[IMG] Failed to generate image for prompt: {image_generation_prompt}"
+                            )
             log_interaction(
                 agent_name=self.agent_name,
                 conversation_name=conversation_name,
                 role=self.agent_name,
                 message=self.response,
                 user=self.user,
             )
         if shots > 1:
             responses = [self.response]
             for shot in range(shots - 1):
-                shot_response = self.ApiClient.prompt_agent(
+                prompt_args = {
+                    "chain_name": chain_name,
+                    "step_number": step_number,
+                    "user_input": user_input,
+                    "context_results": context_results,
+                    "conversation_name": conversation_name,
+                    "disable_memory": disable_memory,
+                    **kwargs,
+                }
+                shot_response = await self.run(
                     agent_name=self.agent_name,
                     prompt_name=prompt,
-                    prompt_args={
-                        "chain_name": chain_name,
-                        "step_number": step_number,
-                        "user_input": user_input,
-                        "context_results": context_results,
-                        "conversation_name": conversation_name,
-                        "disable_memory": disable_memory,
-                        **kwargs,
-                    },
+                    prompt_category=(
+                        "Default"
+                        if "prompt_category" not in kwargs
+                        else kwargs["prompt_category"]
+                    ),
+                    **prompt_args,
                 )
                 time.sleep(1)
                 responses.append(shot_response)
             return "\n".join(
                 [
                     f"Response {shot + 1}:\n{response}"
                     for shot, response in enumerate(responses)
                 ]
             )
         if image_response != "":
             self.response += f"\n![image]({image_response})"
         return self.response
 
     def create_command_suggestion_chain(self, agent_name, command_name, command_args):
-        chains = self.ApiClient.get_chains()
+        ch = Chain(user=self.user)
+        chains = ch.get_chains()
         chain_name = f"{agent_name} Command Suggestions"
         if chain_name in chains:
-            step = (
-                int(
-                    self.ApiClient.get_chain(chain_name=chain_name)["steps"][-1]["step"]
-                )
-                + 1
-            )
+            step = int(ch.get_chain(chain_name=chain_name)["steps"][-1]["step"]) + 1
         else:
-            self.ApiClient.add_chain(chain_name=chain_name)
+            ch.add_chain(chain_name=chain_name)
             step = 1
-        self.ApiClient.add_step(
+        ch.add_chain_step(
             chain_name=chain_name,
             agent_name=agent_name,
             step_number=step,
             prompt_type="Command",
             prompt={
                 "command_name": command_name,
                 **command_args,
@@ -682,26 +756,15 @@
                                 command_args = json.loads(
                                     '{"command_args": '
                                     + ",".join(command.split(",")[1:])
                                     + "}"
                                 )
                             except:
                                 command_args = {}
-                        if command_name not in command_list:
-                            # Ask the agent for clarification on which command should be executed.
-                            response = self.ApiClient.prompt_agent(
-                                agent_name=self.agent_name,
-                                prompt_name="Command Clarification",
-                                prompt_args={
-                                    "command_name": command_name,
-                                    "command_args": json.dumps(command_args),
-                                    "conversation_name": "AGiXT Terminal",
-                                },
-                            )
-                        else:
+                        if command_name in command_list:
                             # Check if the command is a valid command in the self.agent.available_commands list
                             try:
                                 if bool(self.agent.AUTONOMOUS_EXECUTION) == True:
                                     ext = Extensions(
                                         agent_name=self.agent_name,
                                         agent_config=self.agent.AGENT_CONFIG,
                                         conversation_name=conversation_name,
```

## Comparing `agixt-1.5.6.dist-info/LICENSE` & `agixt-1.5.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `agixt-1.5.6.dist-info/METADATA` & `agixt-1.5.7.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: agixt
-Version: 1.5.6
+Version: 1.5.7
 Summary: An Artificial Intelligence Automation Platform. AI Instruction management from various providers, has an adaptive memory, and a versatile plugin system with many commands including web browsing. Supports many AI providers and models and growing support every day.
 Author: Josh XT
 Author-email: josh@devxt.com
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: agixtsdk ==0.0.36
```

## Comparing `agixt-1.5.6.dist-info/RECORD` & `agixt-1.5.7.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-agixt/ApiClient.py,sha256=JaDmbPreojU6Yv_LWLRjoDAM5t09_RPuta9QgyNIlx8,3466
+agixt/ApiClient.py,sha256=h4-lJbztwfhH2JBLqbcMxZcbiuoW5mwXTiCk6qdr-IU,3821
 agixt/Chains.py,sha256=OA2Uug5GoGK9stv9PYCBtexQC2TkvFNXeWVwuKdxS6E,8584
 agixt/DBConnection.py,sha256=DriRjWcDF4gE0u0O4xTGZZ4fyzGUh_hpFA7w8DvtlKg,10260
 agixt/Defaults.py,sha256=aG8DOfQsDT_QKoX0q3h3e3wTXatidU3Tuz1g7QuXjlI,863
 agixt/Extensions.py,sha256=1uy2TUKMoN-vNIFTaCgNPDHs-ANPmLNwLuJO86h0gD8,9608
-agixt/Interactions.py,sha256=zay4zDYndm6UGaWlimrWVCuBtdhI79dlnSwQtnl1nGc,32804
+agixt/Interactions.py,sha256=Xi_xOE7R6vonHcyDDSdvn5ZdphppBfFDtZfADg94n2s,38231
 agixt/Memories.py,sha256=j0qC6aVGGROU4e8E9bImnIcG7ASAnLmu7V98UIcdx24,23597
 agixt/Models.py,sha256=Ol3BPZn4LF6I6McrRy0yJeg5OrZu2Oo2qjrkOfIfoHI,5228
 agixt/Providers.py,sha256=FuHJF5IxDIq0XNPnmEHKKyp1sJjkaqAQaN6xY4UIfXo,3780
 agixt/Tuning.py,sha256=4jNPRnFxGf2o1URE1XayvaKjMgSVEIhRQfNkUnIZLoo,6315
 agixt/Tunnel.py,sha256=WMCLOCzQzgUe8K_uC-UlktlUFsmSooZh4RnbdYgXOeA,626
 agixt/Websearch.py,sha256=mNrduLTy0FUiZLH7K3BvUdbXSREPHp0tD4U_Wq6f0Ts,13286
 agixt/__init__.py,sha256=w6buZkD-oYiO4B6POcfvaq2ZYK5xJPsEHhyMZ_pev_w,32
 agixt/app.py,sha256=jtVnexyZ9hbusqJXq6ydUlg_iXfjq4HXloyADR0dikU,1849
-agixt-1.5.6.dist-info/LICENSE,sha256=HKTvkW16ytKDrayEK3xZp5w6Q71SjoczlgrhsRGwYdE,1087
-agixt-1.5.6.dist-info/METADATA,sha256=YL-WX6h8-rop-pLBeyHArcXvmbfXYJxh7GdmIG5eqrY,11418
-agixt-1.5.6.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-agixt-1.5.6.dist-info/top_level.txt,sha256=xy7elM44RntvahpvIewrUnjc2fQPfpt-6xPoRfFQTzg,6
-agixt-1.5.6.dist-info/RECORD,,
+agixt-1.5.7.dist-info/LICENSE,sha256=HKTvkW16ytKDrayEK3xZp5w6Q71SjoczlgrhsRGwYdE,1087
+agixt-1.5.7.dist-info/METADATA,sha256=T-IzJO2TnftsZoPje4o625-g_vUaKyGbzzVGI_0fHoc,11418
+agixt-1.5.7.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+agixt-1.5.7.dist-info/top_level.txt,sha256=xy7elM44RntvahpvIewrUnjc2fQPfpt-6xPoRfFQTzg,6
+agixt-1.5.7.dist-info/RECORD,,
```

