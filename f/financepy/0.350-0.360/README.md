# Comparing `tmp/financepy-0.350.tar.gz` & `tmp/financepy-0.360.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "financepy-0.350.tar", last modified: Mon Feb 19 20:59:56 2024, max compression
+gzip compressed data, was "financepy-0.360.tar", last modified: Wed May  1 13:47:10 2024, max compression
```

## Comparing `financepy-0.350.tar` & `financepy-0.360.tar`

### file list

```diff
@@ -1,393 +1,393 @@
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:56.035018 financepy-0.350/
--rw-rw-rw-   0        0        0    35823 2023-11-16 17:12:54.000000 financepy-0.350/LICENSE
--rw-rw-rw-   0        0        0     8311 2024-02-19 20:59:56.034005 financepy-0.350/PKG-INFO
--rw-rw-rw-   0        0        0     7714 2024-02-19 03:11:18.000000 financepy-0.350/README.md
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.710049 financepy-0.350/financepy/
--rw-rw-rw-   0        0        0      454 2024-02-19 20:59:54.000000 financepy-0.350/financepy/__init__.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.717047 financepy-0.350/financepy/market/
--rw-rw-rw-   0        0        0        0 2023-11-16 17:12:54.000000 financepy-0.350/financepy/market/__init__.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.725709 financepy-0.350/financepy/market/curves/
--rw-rw-rw-   0        0        0      308 2023-11-16 17:12:54.000000 financepy-0.350/financepy/market/curves/__init__.py
--rw-rw-rw-   0        0        0    17268 2024-02-19 03:35:20.000000 financepy-0.350/financepy/market/curves/discount_curve.py
--rw-rw-rw-   0        0        0     5059 2023-12-11 08:19:01.000000 financepy-0.350/financepy/market/curves/discount_curve_flat.py
--rw-rw-rw-   0        0        0     6671 2023-12-09 17:10:47.000000 financepy-0.350/financepy/market/curves/discount_curve_ns.py
--rw-rw-rw-   0        0        0     7313 2023-12-03 15:24:52.000000 financepy-0.350/financepy/market/curves/discount_curve_nss.py
--rw-rw-rw-   0        0        0     6149 2023-12-02 18:59:41.000000 financepy-0.350/financepy/market/curves/discount_curve_poly.py
--rw-rw-rw-   0        0        0     5882 2023-12-02 18:59:29.000000 financepy-0.350/financepy/market/curves/discount_curve_pwf.py
--rw-rw-rw-   0        0        0     5711 2023-12-02 18:58:47.000000 financepy-0.350/financepy/market/curves/discount_curve_pwl.py
--rw-rw-rw-   0        0        0     5539 2023-12-04 09:00:36.000000 financepy-0.350/financepy/market/curves/discount_curve_zeros.py
--rw-rw-rw-   0        0        0    12536 2024-02-19 03:42:29.000000 financepy-0.350/financepy/market/curves/interpolator.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.726707 financepy-0.350/financepy/market/prices/
--rw-rw-rw-   0        0        0       25 2023-11-16 17:12:54.000000 financepy-0.350/financepy/market/prices/__init__.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.734062 financepy-0.350/financepy/market/volatility/
--rw-rw-rw-   0        0        0      172 2023-11-16 17:12:54.000000 financepy-0.350/financepy/market/volatility/__init__.py
--rw-rw-rw-   0        0        0     2741 2024-02-19 03:36:21.000000 financepy-0.350/financepy/market/volatility/equity_vol_curve.py
--rw-rw-rw-   0        0        0    29843 2024-02-19 05:17:37.000000 financepy-0.350/financepy/market/volatility/equity_vol_surface.py
--rw-rw-rw-   0        0        0    46909 2024-02-19 11:13:56.000000 financepy-0.350/financepy/market/volatility/fx_vol_surface.py
--rw-rw-rw-   0        0        0    91505 2024-02-19 11:16:14.000000 financepy-0.350/financepy/market/volatility/fx_vol_surface_plus.py
--rw-rw-rw-   0        0        0     7311 2023-12-02 17:45:00.000000 financepy-0.350/financepy/market/volatility/ibor_cap_vol_curve.py
--rw-rw-rw-   0        0        0     1489 2023-12-02 18:39:36.000000 financepy-0.350/financepy/market/volatility/ibor_cap_vol_curve_fn.py
--rw-rw-rw-   0        0        0    35135 2023-12-10 17:39:41.000000 financepy-0.350/financepy/market/volatility/swaption_vol_surface.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.766708 financepy-0.350/financepy/models/
--rw-rw-rw-   0        0        0      837 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/__init__.py
--rw-rw-rw-   0        0        0     2291 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/bachelier.py
--rw-rw-rw-   0        0        0    30744 2023-12-05 14:02:44.000000 financepy-0.350/financepy/models/bdt_tree.py
--rw-rw-rw-   0        0        0    40022 2023-12-05 14:02:49.000000 financepy-0.350/financepy/models/bk_tree.py
--rw-rw-rw-   0        0        0    17013 2023-12-05 13:18:21.000000 financepy-0.350/financepy/models/black.py
--rw-rw-rw-   0        0        0    10209 2024-02-19 04:59:17.000000 financepy-0.350/financepy/models/black_scholes.py
--rw-rw-rw-   0        0        0    17498 2024-02-19 04:57:31.000000 financepy-0.350/financepy/models/black_scholes_analytic.py
--rw-rw-rw-   0        0        0     7132 2024-02-19 04:59:10.000000 financepy-0.350/financepy/models/black_scholes_mc.py
--rw-rw-rw-   0        0        0     3137 2024-02-19 04:58:51.000000 financepy-0.350/financepy/models/black_scholes_mc_tests.py
--rw-rw-rw-   0        0        0     2876 2023-12-04 12:05:15.000000 financepy-0.350/financepy/models/black_shifted.py
--rw-rw-rw-   0        0        0        0 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/bond_analytics.py
--rw-rw-rw-   0        0        0    10140 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/cir_mc.py
--rw-rw-rw-   0        0        0     8553 2024-02-19 20:26:08.000000 financepy-0.350/financepy/models/equity_barrier_models.py
--rw-rw-rw-   0        0        0     7226 2024-02-19 04:01:25.000000 financepy-0.350/financepy/models/equity_crr_tree.py
--rw-rw-rw-   0        0        0     5724 2023-11-17 08:56:48.000000 financepy-0.350/financepy/models/equity_lsmc.py
--rw-rw-rw-   0        0        0     8217 2023-11-17 08:57:17.000000 financepy-0.350/financepy/models/finite_difference.py
--rw-rw-rw-   0        0        0     5393 2023-12-02 16:00:33.000000 financepy-0.350/financepy/models/finite_difference_PSOR.py
--rw-rw-rw-   0        0        0     1740 2023-12-02 17:32:19.000000 financepy-0.350/financepy/models/gauss_copula.py
--rw-rw-rw-   0        0        0     6389 2023-12-02 17:31:06.000000 financepy-0.350/financepy/models/gauss_copula_lhp.py
--rw-rw-rw-   0        0        0     5655 2023-12-09 17:07:47.000000 financepy-0.350/financepy/models/gauss_copula_lhplus.py
--rw-rw-rw-   0        0        0    14231 2024-02-19 19:55:02.000000 financepy-0.350/financepy/models/gauss_copula_onefactor.py
--rw-rw-rw-   0        0        0     7306 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/gbm_process_simulator.py
--rw-rw-rw-   0        0        0    14078 2023-12-02 17:45:11.000000 financepy-0.350/financepy/models/heston.py
--rw-rw-rw-   0        0        0    51072 2023-12-05 14:03:02.000000 financepy-0.350/financepy/models/hw_tree.py
--rw-rw-rw-   0        0        0    33852 2023-12-04 10:23:49.000000 financepy-0.350/financepy/models/lmm_mc.py
--rw-rw-rw-   0        0        0     4519 2023-12-09 16:53:04.000000 financepy-0.350/financepy/models/loss_dbn_builder.py
--rw-rw-rw-   0        0        0     5484 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/merton_firm.py
--rw-rw-rw-   0        0        0     6022 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/merton_firm_mkt.py
--rw-rw-rw-   0        0        0      434 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/model.py
--rw-rw-rw-   0        0        0     1980 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/option_implied_dbn.py
--rw-rw-rw-   0        0        0    14630 2023-12-10 15:44:31.000000 financepy-0.350/financepy/models/process_simulator.py
--rw-rw-rw-   0        0        0     3844 2023-12-05 14:02:52.000000 financepy-0.350/financepy/models/rates_ho_lee.py
--rw-rw-rw-   0        0        0    10630 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/sabr.py
--rw-rw-rw-   0        0        0     8447 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/sabr_shifted.py
--rw-rw-rw-   0        0        0     5318 2023-12-02 17:33:20.000000 financepy-0.350/financepy/models/sobol.py
--rw-rw-rw-   0        0        0   120492 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/sobolcoeff.npz
--rw-rw-rw-   0        0        0     1810 2023-12-02 17:33:28.000000 financepy-0.350/financepy/models/student_t_copula.py
--rw-rw-rw-   0        0        0     3400 2024-02-19 04:34:55.000000 financepy-0.350/financepy/models/vasicek_mc.py
--rw-rw-rw-   0        0        0     8196 2023-11-16 17:12:54.000000 financepy-0.350/financepy/models/volatility_fns.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.767707 financepy-0.350/financepy/products/
--rw-rw-rw-   0        0        0        0 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/__init__.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.780388 financepy-0.350/financepy/products/bonds/
--rw-rw-rw-   0        0        0      370 2024-02-19 11:45:13.000000 financepy-0.350/financepy/products/bonds/__init__.py
--rw-rw-rw-   0        0        0    41762 2024-02-19 12:38:08.000000 financepy-0.350/financepy/products/bonds/bond.py
--rw-rw-rw-   0        0        0     7345 2023-12-11 08:25:41.000000 financepy-0.350/financepy/products/bonds/bond_annuity.py
--rw-rw-rw-   0        0        0     9575 2024-02-19 03:57:18.000000 financepy-0.350/financepy/products/bonds/bond_callable.py
--rw-rw-rw-   0        0        0    26078 2024-02-19 04:01:29.000000 financepy-0.350/financepy/products/bonds/bond_convertible.py
--rw-rw-rw-   0        0        0    18777 2024-01-04 13:52:00.000000 financepy-0.350/financepy/products/bonds/bond_frn.py
--rw-rw-rw-   0        0        0     6023 2023-12-05 13:39:17.000000 financepy-0.350/financepy/products/bonds/bond_future.py
--rw-rw-rw-   0        0        0     5275 2024-02-19 04:05:52.000000 financepy-0.350/financepy/products/bonds/bond_market.py
--rw-rw-rw-   0        0        0     6241 2024-02-19 04:06:19.000000 financepy-0.350/financepy/products/bonds/bond_mortgage.py
--rw-rw-rw-   0        0        0     5586 2023-12-05 13:39:23.000000 financepy-0.350/financepy/products/bonds/bond_option.py
--rw-rw-rw-   0        0        0    11682 2024-02-19 03:53:24.000000 financepy-0.350/financepy/products/bonds/bond_portfolio.py
--rw-rw-rw-   0        0        0     6804 2024-02-19 12:30:19.000000 financepy-0.350/financepy/products/bonds/bond_yield_curve.py
--rw-rw-rw-   0        0        0    27306 2024-02-19 03:53:55.000000 financepy-0.350/financepy/products/bonds/bond_zero.py
--rw-rw-rw-   0        0        0     6986 2023-12-05 13:26:23.000000 financepy-0.350/financepy/products/bonds/bond_zero_curve.py
--rw-rw-rw-   0        0        0     5839 2024-02-19 04:09:53.000000 financepy-0.350/financepy/products/bonds/curve_fits.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.786265 financepy-0.350/financepy/products/credit/
--rw-rw-rw-   0        0        0      197 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/credit/__init__.py
--rw-rw-rw-   0        0        0    32067 2024-02-19 04:18:08.000000 financepy-0.350/financepy/products/credit/cds.py
--rw-rw-rw-   0        0        0    13140 2024-02-19 04:40:52.000000 financepy-0.350/financepy/products/credit/cds_basket.py
--rw-rw-rw-   0        0        0     8879 2024-02-19 19:04:14.000000 financepy-0.350/financepy/products/credit/cds_curve.py
--rw-rw-rw-   0        0        0    14383 2024-02-19 04:30:09.000000 financepy-0.350/financepy/products/credit/cds_index_option.py
--rw-rw-rw-   0        0        0    19923 2023-12-05 13:59:10.000000 financepy-0.350/financepy/products/credit/cds_index_portfolio.py
--rw-rw-rw-   0        0        0     6552 2023-12-05 13:37:01.000000 financepy-0.350/financepy/products/credit/cds_option.py
--rw-rw-rw-   0        0        0     8852 2024-02-19 19:30:14.000000 financepy-0.350/financepy/products/credit/cds_tranche.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.805265 financepy-0.350/financepy/products/equity/
--rw-rw-rw-   0        0        0      808 2023-12-03 16:34:34.000000 financepy-0.350/financepy/products/equity/__init__.py
--rw-rw-rw-   0        0        0     4463 2024-02-19 03:43:08.000000 financepy-0.350/financepy/products/equity/equity_american_option.py
--rw-rw-rw-   0        0        0    30414 2024-02-19 03:47:39.000000 financepy-0.350/financepy/products/equity/equity_asian_option.py
--rw-rw-rw-   0        0        0    10649 2024-02-19 20:18:19.000000 financepy-0.350/financepy/products/equity/equity_barrier_option.py
--rw-rw-rw-   0        0        0     9929 2023-12-10 15:45:13.000000 financepy-0.350/financepy/products/equity/equity_basket_option.py
--rw-rw-rw-   0        0        0     8404 2024-02-19 05:16:00.000000 financepy-0.350/financepy/products/equity/equity_binomial_tree.py
--rw-rw-rw-   0        0        0     9282 2023-12-02 17:48:13.000000 financepy-0.350/financepy/products/equity/equity_chooser_option.py
--rw-rw-rw-   0        0        0     7297 2023-12-11 08:29:10.000000 financepy-0.350/financepy/products/equity/equity_cliquet_option.py
--rw-rw-rw-   0        0        0    17985 2024-02-19 04:01:19.000000 financepy-0.350/financepy/products/equity/equity_compound_option.py
--rw-rw-rw-   0        0        0     7603 2023-12-10 16:37:52.000000 financepy-0.350/financepy/products/equity/equity_digital_option.py
--rw-rw-rw-   0        0        0    10506 2023-12-10 17:11:20.000000 financepy-0.350/financepy/products/equity/equity_fixed_lookback_option.py
--rw-rw-rw-   0        0        0     8885 2023-12-10 16:34:25.000000 financepy-0.350/financepy/products/equity/equity_float_lookback_option.py
--rw-rw-rw-   0        0        0     4764 2023-12-10 18:14:25.000000 financepy-0.350/financepy/products/equity/equity_forward.py
--rw-rw-rw-   0        0        0     9806 2023-12-02 18:36:08.000000 financepy-0.350/financepy/products/equity/equity_index_option.py
--rw-rw-rw-   0        0        0     1950 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/equity/equity_model_types.py
--rw-rw-rw-   0        0        0    19615 2023-12-10 16:39:22.000000 financepy-0.350/financepy/products/equity/equity_one_touch_option.py
--rw-rw-rw-   0        0        0     6668 2023-12-02 18:36:17.000000 financepy-0.350/financepy/products/equity/equity_option.py
--rw-rw-rw-   0        0        0    12233 2023-12-10 15:45:48.000000 financepy-0.350/financepy/products/equity/equity_rainbow_option.py
--rw-rw-rw-   0        0        0     8317 2023-12-02 18:36:27.000000 financepy-0.350/financepy/products/equity/equity_swap.py
--rw-rw-rw-   0        0        0    13612 2023-12-10 16:45:14.000000 financepy-0.350/financepy/products/equity/equity_swap_leg.py
--rw-rw-rw-   0        0        0    24582 2023-12-04 10:23:08.000000 financepy-0.350/financepy/products/equity/equity_vanilla_option.py
--rw-rw-rw-   0        0        0    10564 2023-12-10 17:58:44.000000 financepy-0.350/financepy/products/equity/equity_variance_swap.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.818610 financepy-0.350/financepy/products/fx/
--rw-rw-rw-   0        0        0      416 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/fx/__init__.py
--rw-rw-rw-   0        0        0    17185 2023-12-10 15:44:41.000000 financepy-0.350/financepy/products/fx/fx_barrier_option.py
--rw-rw-rw-   0        0        0     6095 2023-12-10 18:04:03.000000 financepy-0.350/financepy/products/fx/fx_digital_option.py
--rw-rw-rw-   0        0        0     5779 2023-12-10 18:15:08.000000 financepy-0.350/financepy/products/fx/fx_double_digital_option.py
--rw-rw-rw-   0        0        0     9224 2023-12-10 17:07:59.000000 financepy-0.350/financepy/products/fx/fx_fixed_lookback_option.py
--rw-rw-rw-   0        0        0     7774 2023-12-10 18:07:08.000000 financepy-0.350/financepy/products/fx/fx_float_lookback_option.py
--rw-rw-rw-   0        0        0     7089 2023-12-10 18:05:48.000000 financepy-0.350/financepy/products/fx/fx_forward.py
--rw-rw-rw-   0        0        0     4868 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/fx/fx_mkt_conventions.py
--rw-rw-rw-   0        0        0    19472 2023-12-09 17:18:30.000000 financepy-0.350/financepy/products/fx/fx_one_touch_option.py
--rw-rw-rw-   0        0        0     5150 2023-12-02 18:37:32.000000 financepy-0.350/financepy/products/fx/fx_option.py
--rw-rw-rw-   0        0        0    10913 2023-12-10 15:44:49.000000 financepy-0.350/financepy/products/fx/fx_rainbow_option.py
--rw-rw-rw-   0        0        0    28077 2023-12-10 17:55:45.000000 financepy-0.350/financepy/products/fx/fx_vanilla_option.py
--rw-rw-rw-   0        0        0     9963 2023-12-10 16:49:10.000000 financepy-0.350/financepy/products/fx/fx_variance_swap.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.823885 financepy-0.350/financepy/products/inflation/
--rw-rw-rw-   0        0        0     6769 2023-12-02 18:38:04.000000 financepy-0.350/financepy/products/inflation/FinInflationBond.py
--rw-rw-rw-   0        0        0     4395 2024-02-19 05:15:07.000000 financepy-0.350/financepy/products/inflation/FinInflationIndexCurve.py
--rw-rw-rw-   0        0        0     6463 2023-12-02 18:38:13.000000 financepy-0.350/financepy/products/inflation/FinInflationSwap.py
--rw-rw-rw-   0        0        0    21008 2023-12-10 16:45:18.000000 financepy-0.350/financepy/products/inflation/FinInflationSwapCurve.py
--rw-rw-rw-   0        0        0       33 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/inflation/__init__.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.841353 financepy-0.350/financepy/products/rates/
--rw-rw-rw-   0        0        0      435 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/rates/__init__.py
--rw-rw-rw-   0        0        0     9088 2023-12-10 16:46:35.000000 financepy-0.350/financepy/products/rates/bermudan_swaption.py
--rw-rw-rw-   0        0        0    11041 2023-12-10 16:46:22.000000 financepy-0.350/financepy/products/rates/callable_swap.py
--rw-rw-rw-   0        0        0    22701 2023-12-10 16:45:23.000000 financepy-0.350/financepy/products/rates/dual_curve.py
--rw-rw-rw-   0        0        0     7802 2023-12-02 18:18:40.000000 financepy-0.350/financepy/products/rates/ibor_basis_swap.py
--rw-rw-rw-   0        0        0    14975 2023-12-10 16:45:27.000000 financepy-0.350/financepy/products/rates/ibor_cap_floor.py
--rw-rw-rw-   0        0        0     1222 2023-11-16 17:12:54.000000 financepy-0.350/financepy/products/rates/ibor_conventions.py
--rw-rw-rw-   0        0        0     6503 2023-12-02 18:19:09.000000 financepy-0.350/financepy/products/rates/ibor_deposit.py
--rw-rw-rw-   0        0        0     6927 2023-12-02 18:19:57.000000 financepy-0.350/financepy/products/rates/ibor_fra.py
--rw-rw-rw-   0        0        0     5785 2023-12-02 21:17:11.000000 financepy-0.350/financepy/products/rates/ibor_future.py
--rw-rw-rw-   0        0        0    17351 2023-12-11 08:29:06.000000 financepy-0.350/financepy/products/rates/ibor_lmm_products.py
--rw-rw-rw-   0        0        0    26854 2023-12-10 16:46:18.000000 financepy-0.350/financepy/products/rates/ibor_single_curve.py
--rw-rw-rw-   0        0        0    11325 2023-12-04 11:44:57.000000 financepy-0.350/financepy/products/rates/ibor_swap.py
--rw-rw-rw-   0        0        0    17203 2023-12-10 16:46:26.000000 financepy-0.350/financepy/products/rates/ibor_swaption.py
--rw-rw-rw-   0        0        0    10026 2023-12-02 18:38:50.000000 financepy-0.350/financepy/products/rates/ois.py
--rw-rw-rw-   0        0        0     7259 2023-12-02 18:38:57.000000 financepy-0.350/financepy/products/rates/ois_basis_swap.py
--rw-rw-rw-   0        0        0    24558 2023-12-10 16:45:31.000000 financepy-0.350/financepy/products/rates/ois_curve.py
--rw-rw-rw-   0        0        0    11017 2023-12-10 16:45:35.000000 financepy-0.350/financepy/products/rates/swap_fixed_leg.py
--rw-rw-rw-   0        0        0    12269 2023-12-10 16:45:39.000000 financepy-0.350/financepy/products/rates/swap_float_leg.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.859871 financepy-0.350/financepy/utils/
--rw-rw-rw-   0        0        0      371 2023-11-16 17:12:54.000000 financepy-0.350/financepy/utils/__init__.py
--rw-rw-rw-   0        0        0     1553 2023-11-16 17:12:54.000000 financepy-0.350/financepy/utils/amount.py
--rw-rw-rw-   0        0        0    33616 2023-12-04 12:53:45.000000 financepy-0.350/financepy/utils/calendar.py
--rw-rw-rw-   0        0        0      630 2023-12-09 17:27:54.000000 financepy-0.350/financepy/utils/currency.py
--rw-rw-rw-   0        0        0    33964 2023-12-11 08:32:14.000000 financepy-0.350/financepy/utils/date.py
--rw-rw-rw-   0        0        0    10518 2023-12-09 17:28:54.000000 financepy-0.350/financepy/utils/day_count.py
--rw-rw-rw-   0        0        0      888 2023-11-16 17:12:54.000000 financepy-0.350/financepy/utils/distribution.py
--rw-rw-rw-   0        0        0     2047 2023-12-09 16:59:07.000000 financepy-0.350/financepy/utils/error.py
--rw-rw-rw-   0        0        0     1601 2023-12-09 16:59:50.000000 financepy-0.350/financepy/utils/frequency.py
--rw-rw-rw-   0        0        0     2957 2023-12-09 17:29:27.000000 financepy-0.350/financepy/utils/global_types.py
--rw-rw-rw-   0        0        0      447 2023-11-16 17:12:54.000000 financepy-0.350/financepy/utils/global_vars.py
--rw-rw-rw-   0        0        0    15551 2023-12-09 17:00:18.000000 financepy-0.350/financepy/utils/helpers.py
--rw-rw-rw-   0        0        0     2996 2023-12-09 17:01:38.000000 financepy-0.350/financepy/utils/latex.py
--rw-rw-rw-   0        0        0    21239 2023-12-09 17:04:29.000000 financepy-0.350/financepy/utils/math.py
--rw-rw-rw-   0        0        0     2288 2023-11-19 17:13:06.000000 financepy-0.350/financepy/utils/polyfit.py
--rw-rw-rw-   0        0        0    11591 2023-12-11 08:29:54.000000 financepy-0.350/financepy/utils/schedule.py
--rw-rw-rw-   0        0        0      498 2023-11-16 17:12:54.000000 financepy-0.350/financepy/utils/singleton.py
--rw-rw-rw-   0        0        0    29403 2023-12-09 17:05:56.000000 financepy-0.350/financepy/utils/solver_1d.py
--rw-rw-rw-   0        0        0    21755 2023-11-16 17:12:54.000000 financepy-0.350/financepy/utils/solver_cg.py
--rw-rw-rw-   0        0        0    13278 2023-12-04 10:59:06.000000 financepy-0.350/financepy/utils/solver_nm.py
--rw-rw-rw-   0        0        0     2758 2023-12-09 17:06:33.000000 financepy-0.350/financepy/utils/stats.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.716046 financepy-0.350/financepy.egg-info/
--rw-rw-rw-   0        0        0     8311 2024-02-19 20:59:55.000000 financepy-0.350/financepy.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    13613 2024-02-19 20:59:55.000000 financepy-0.350/financepy.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2024-02-19 20:59:55.000000 financepy-0.350/financepy.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       65 2024-02-19 20:59:55.000000 financepy-0.350/financepy.egg-info/requires.txt
--rw-rw-rw-   0        0        0       23 2024-02-19 20:59:55.000000 financepy-0.350/financepy.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2024-02-19 20:59:56.035018 financepy-0.350/setup.cfg
--rw-rw-rw-   0        0        0     2058 2023-11-16 17:12:54.000000 financepy-0.350/setup.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:55.935741 financepy-0.350/tests/
--rw-rw-rw-   0        0        0      657 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinAmount.py
--rw-rw-rw-   0        0        0    12612 2024-02-19 11:31:41.000000 financepy-0.350/tests/test_FinBond.py
--rw-rw-rw-   0        0        0     5765 2023-12-03 16:02:50.000000 financepy-0.350/tests/test_FinBondAnnuity.py
--rw-rw-rw-   0        0        0     4947 2023-12-03 16:17:14.000000 financepy-0.350/tests/test_FinBondConvertible.py
--rw-rw-rw-   0        0        0     5138 2023-12-03 16:32:45.000000 financepy-0.350/tests/test_FinBondEmbeddedOption.py
--rw-rw-rw-   0        0        0     8043 2023-12-03 15:47:17.000000 financepy-0.350/tests/test_FinBondFRN.py
--rw-rw-rw-   0        0        0     5047 2023-12-03 15:48:07.000000 financepy-0.350/tests/test_FinBondFutures.py
--rw-rw-rw-   0        0        0     1431 2023-12-03 16:19:18.000000 financepy-0.350/tests/test_FinBondMortgage.py
--rw-rw-rw-   0        0        0     5817 2023-12-05 13:26:08.000000 financepy-0.350/tests/test_FinBondOption.py
--rw-rw-rw-   0        0        0     6018 2023-12-02 17:14:01.000000 financepy-0.350/tests/test_FinBondPortfolio.py
--rw-rw-rw-   0        0        0     3422 2024-02-19 18:24:11.000000 financepy-0.350/tests/test_FinBondYieldCurve.py
--rw-rw-rw-   0        0        0     1833 2024-02-19 18:24:39.000000 financepy-0.350/tests/test_FinBondZeroCurve.py
--rw-rw-rw-   0        0        0    13833 2023-12-03 16:29:00.000000 financepy-0.350/tests/test_FinCDS.py
--rw-rw-rw-   0        0        0     4931 2023-12-03 16:29:06.000000 financepy-0.350/tests/test_FinCDSBasket.py
--rw-rw-rw-   0        0        0     2922 2023-12-03 16:12:26.000000 financepy-0.350/tests/test_FinCDSCurve.py
--rw-rw-rw-   0        0        0     2255 2023-12-03 16:31:18.000000 financepy-0.350/tests/test_FinCDSIndex.py
--rw-rw-rw-   0        0        0     4547 2023-12-03 16:30:05.000000 financepy-0.350/tests/test_FinCDSIndexAdjustHazards.py
--rw-rw-rw-   0        0        0     4542 2023-12-02 20:40:04.000000 financepy-0.350/tests/test_FinCDSIndexAdjustSpreads.py
--rw-rw-rw-   0        0        0     5057 2023-12-04 11:09:14.000000 financepy-0.350/tests/test_FinCDSIndexOption.py
--rw-rw-rw-   0        0        0     4489 2023-12-02 20:40:00.000000 financepy-0.350/tests/test_FinCDSIndexPortfolio.py
--rw-rw-rw-   0        0        0     1406 2023-12-03 16:34:20.000000 financepy-0.350/tests/test_FinCDSOption.py
--rw-rw-rw-   0        0        0     4901 2024-02-19 20:01:30.000000 financepy-0.350/tests/test_FinCDSTranche.py
--rw-rw-rw-   0        0        0     1384 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinCalendar.py
--rw-rw-rw-   0        0        0     3053 2023-12-03 16:18:54.000000 financepy-0.350/tests/test_FinDateAdjust.py
--rw-rw-rw-   0        0        0     2665 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinDayCount.py
--rw-rw-rw-   0        0        0     2438 2023-12-03 16:12:49.000000 financepy-0.350/tests/test_FinDiscountCurveFlat.py
--rw-rw-rw-   0        0        0     4748 2023-12-09 17:12:04.000000 financepy-0.350/tests/test_FinDiscountCurveNS.py
--rw-rw-rw-   0        0        0     3001 2023-12-09 17:15:34.000000 financepy-0.350/tests/test_FinDiscountCurveNSS.py
--rw-rw-rw-   0        0        0     1568 2023-12-03 16:15:27.000000 financepy-0.350/tests/test_FinDiscountCurveZeros.py
--rw-rw-rw-   0        0        0     2165 2023-12-03 16:31:23.000000 financepy-0.350/tests/test_FinEquityAmericanOption.py
--rw-rw-rw-   0        0        0     3226 2023-12-02 20:39:48.000000 financepy-0.350/tests/test_FinEquityAsianOption.py
--rw-rw-rw-   0        0        0     7255 2023-12-02 18:44:57.000000 financepy-0.350/tests/test_FinEquityBarrierOption.py
--rw-rw-rw-   0        0        0     4526 2023-12-02 18:44:52.000000 financepy-0.350/tests/test_FinEquityBasketOption.py
--rw-rw-rw-   0        0        0     3189 2023-12-02 20:39:51.000000 financepy-0.350/tests/test_FinEquityBinomialTree.py
--rw-rw-rw-   0        0        0     4805 2023-12-02 18:44:49.000000 financepy-0.350/tests/test_FinEquityChooserOption.py
--rw-rw-rw-   0        0        0     1544 2023-12-03 16:32:53.000000 financepy-0.350/tests/test_FinEquityCliquetOption.py
--rw-rw-rw-   0        0        0     6536 2023-12-02 20:39:44.000000 financepy-0.350/tests/test_FinEquityCompoundOption.py
--rw-rw-rw-   0        0        0     2161 2023-12-03 16:30:12.000000 financepy-0.350/tests/test_FinEquityDigitalOption.py
--rw-rw-rw-   0        0        0     1573 2023-12-02 20:39:37.000000 financepy-0.350/tests/test_FinEquityForward.py
--rw-rw-rw-   0        0        0     3763 2023-12-02 18:54:09.000000 financepy-0.350/tests/test_FinEquityIndexOption.py
--rw-rw-rw-   0        0        0     2225 2023-12-02 20:39:40.000000 financepy-0.350/tests/test_FinEquityLookbackOption.py
--rw-rw-rw-   0        0        0    11209 2023-12-02 20:39:33.000000 financepy-0.350/tests/test_FinEquityOneTouchOption.py
--rw-rw-rw-   0        0        0     6612 2023-12-02 20:39:30.000000 financepy-0.350/tests/test_FinEquityRainbowOption.py
--rw-rw-rw-   0        0        0     7422 2023-12-03 16:24:01.000000 financepy-0.350/tests/test_FinEquitySwap.py
--rw-rw-rw-   0        0        0     2199 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinEquityVanillaOption.py
--rw-rw-rw-   0        0        0     1756 2023-12-02 18:45:04.000000 financepy-0.350/tests/test_FinEquityVarianceSwap.py
--rw-rw-rw-   0        0        0     2805 2023-12-02 18:54:04.000000 financepy-0.350/tests/test_FinEquityVolSurface.py
--rw-rw-rw-   0        0        0     9047 2023-12-02 18:45:08.000000 financepy-0.350/tests/test_FinFXAmericanOption.py
--rw-rw-rw-   0        0        0    14288 2023-12-02 20:39:22.000000 financepy-0.350/tests/test_FinFXBarrierOption.py
--rw-rw-rw-   0        0        0     2882 2023-12-02 18:45:12.000000 financepy-0.350/tests/test_FinFXForward.py
--rw-rw-rw-   0        0        0     3278 2023-12-10 18:33:51.000000 financepy-0.350/tests/test_FinFXLookbackOption.py
--rw-rw-rw-   0        0        0     6586 2023-12-02 18:54:01.000000 financepy-0.350/tests/test_FinFXOptionSABR.py
--rw-rw-rw-   0        0        0    11992 2023-12-02 18:45:16.000000 financepy-0.350/tests/test_FinFXVanillaOption.py
--rw-rw-rw-   0        0        0     6688 2023-12-03 16:31:27.000000 financepy-0.350/tests/test_FinFXVolSurface.py
--rw-rw-rw-   0        0        0    12210 2024-02-19 02:50:00.000000 financepy-0.350/tests/test_FinFXVolSurfacePlus.py
--rw-rw-rw-   0        0        0    13059 2023-12-02 18:45:19.000000 financepy-0.350/tests/test_FinIborBermudanSwaption.py
--rw-rw-rw-   0        0        0     6906 2023-12-03 16:30:23.000000 financepy-0.350/tests/test_FinIborCapFloor.py
--rw-rw-rw-   0        0        0     2301 2023-12-03 16:33:27.000000 financepy-0.350/tests/test_FinIborCapVolCurve.py
--rw-rw-rw-   0        0        0    10159 2023-12-02 18:45:23.000000 financepy-0.350/tests/test_FinIborDualCurve.py
--rw-rw-rw-   0        0        0     1205 2023-12-03 15:29:33.000000 financepy-0.350/tests/test_FinIborFuture.py
--rw-rw-rw-   0        0        0     5686 2023-12-03 16:30:28.000000 financepy-0.350/tests/test_FinIborSingleCurve.py
--rw-rw-rw-   0        0        0     4366 2023-12-03 16:33:23.000000 financepy-0.350/tests/test_FinIborSwap.py
--rw-rw-rw-   0        0        0     8225 2023-12-02 18:45:31.000000 financepy-0.350/tests/test_FinIborSwaption.py
--rw-rw-rw-   0        0        0     4933 2023-12-02 18:53:48.000000 financepy-0.350/tests/test_FinInflationBond.py
--rw-rw-rw-   0        0        0      855 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinInflationIndexCurve.py
--rw-rw-rw-   0        0        0     6254 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinInterpolate.py
--rw-rw-rw-   0        0        0     5851 2023-12-03 16:12:52.000000 financepy-0.350/tests/test_FinInterpolatedForwards.py
--rw-rw-rw-   0        0        0     1871 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinLossDbnBuilder.py
--rw-rw-rw-   0        0        0     2056 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinMath.py
--rw-rw-rw-   0        0        0     6320 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinModelBlack.py
--rw-rw-rw-   0        0        0     6049 2023-12-02 18:45:48.000000 financepy-0.350/tests/test_FinModelBlackScholes.py
--rw-rw-rw-   0        0        0     1392 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinModelCIR.py
--rw-rw-rw-   0        0        0     2079 2023-12-03 16:30:33.000000 financepy-0.350/tests/test_FinModelHeston.py
--rw-rw-rw-   0        0        0     2904 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinModelMerton.py
--rw-rw-rw-   0        0        0     6587 2023-12-05 13:24:41.000000 financepy-0.350/tests/test_FinModelRatesBDT.py
--rw-rw-rw-   0        0        0     4102 2023-12-05 13:25:45.000000 financepy-0.350/tests/test_FinModelRatesBK.py
--rw-rw-rw-   0        0        0     2382 2023-12-05 13:25:19.000000 financepy-0.350/tests/test_FinModelRatesHW.py
--rw-rw-rw-   0        0        0     5362 2023-12-04 10:23:25.000000 financepy-0.350/tests/test_FinModelRatesLMM.py
--rw-rw-rw-   0        0        0     2722 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinModelSABR.py
--rw-rw-rw-   0        0        0     2148 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinModelShiftedSABR.py
--rw-rw-rw-   0        0        0     1714 2023-12-02 18:53:37.000000 financepy-0.350/tests/test_FinOIS.py
--rw-rw-rw-   0        0        0     5142 2023-12-03 16:31:33.000000 financepy-0.350/tests/test_FinOISCurve.py
--rw-rw-rw-   0        0        0     6979 2023-12-03 16:24:07.000000 financepy-0.350/tests/test_FinSchedule.py
--rw-rw-rw-   0        0        0      758 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinSobol.py
--rw-rw-rw-   0        0        0      985 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinStatistics.py
--rw-rw-rw-   0        0        0     5540 2023-12-02 18:46:02.000000 financepy-0.350/tests/test_FinSwapLegs.py
--rw-rw-rw-   0        0        0     1643 2023-11-16 17:12:54.000000 financepy-0.350/tests/test_FinVasicekRateModel.py
--rw-rw-rw-   0        0        0     9171 2023-12-03 16:51:53.000000 financepy-0.350/tests/test_date.py
--rw-rw-rw-   0        0        0    17681 2023-12-02 18:45:35.000000 financepy-0.350/tests/test_finite_difference.py
--rw-rw-rw-   0        0        0    12391 2023-12-02 18:53:43.000000 financepy-0.350/tests/test_finite_difference_PSOR.py
--rw-rw-rw-   0        0        0     5427 2023-12-02 18:53:30.000000 financepy-0.350/tests/test_lsmc.py
-drwxrwxrwx   0        0        0        0 2024-02-19 20:59:56.032819 financepy-0.350/tests_golden/
--rw-rw-rw-   0        0        0    18143 2024-02-19 19:58:09.000000 financepy-0.350/tests_golden/FinTestCases.py
--rw-rw-rw-   0        0        0      893 2023-12-02 15:58:32.000000 financepy-0.350/tests_golden/TestFinAmount.py
--rw-rw-rw-   0        0        0    24219 2024-02-19 12:32:04.000000 financepy-0.350/tests_golden/TestFinBond.py
--rw-rw-rw-   0        0        0     7120 2023-12-05 14:06:10.000000 financepy-0.350/tests_golden/TestFinBondAnnuity.py
--rw-rw-rw-   0        0        0     4515 2023-12-03 16:17:18.000000 financepy-0.350/tests_golden/TestFinBondConvertible.py
--rw-rw-rw-   0        0        0     6818 2023-12-02 18:53:27.000000 financepy-0.350/tests_golden/TestFinBondEmbeddedOptionBK.py
--rw-rw-rw-   0        0        0     6799 2023-12-02 18:46:21.000000 financepy-0.350/tests_golden/TestFinBondEmbeddedOptionHW.py
--rw-rw-rw-   0        0        0    13651 2023-12-02 18:46:17.000000 financepy-0.350/tests_golden/TestFinBondFRN.py
--rw-rw-rw-   0        0        0     6405 2023-12-02 18:53:22.000000 financepy-0.350/tests_golden/TestFinBondFutures.py
--rw-rw-rw-   0        0        0     2041 2023-12-03 16:19:03.000000 financepy-0.350/tests_golden/TestFinBondMortgage.py
--rw-rw-rw-   0        0        0    14505 2023-12-05 13:26:12.000000 financepy-0.350/tests_golden/TestFinBondOptionBDTModel.py
--rw-rw-rw-   0        0        0    14450 2023-12-05 13:25:53.000000 financepy-0.350/tests_golden/TestFinBondOptionBKModel.py
--rw-rw-rw-   0        0        0    18342 2023-12-05 13:25:49.000000 financepy-0.350/tests_golden/TestFinBondOptionHWModel.py
--rw-rw-rw-   0        0        0     2160 2023-12-03 15:48:11.000000 financepy-0.350/tests_golden/TestFinBondPortfolio.py
--rw-rw-rw-   0        0        0     4539 2024-02-19 12:18:16.000000 financepy-0.350/tests_golden/TestFinBondYieldCurve.py
--rw-rw-rw-   0        0        0     2852 2024-02-19 19:00:01.000000 financepy-0.350/tests_golden/TestFinBondZeroCoupon.py
--rw-rw-rw-   0        0        0     2433 2024-02-19 19:00:48.000000 financepy-0.350/tests_golden/TestFinBondZeroCurve.py
--rw-rw-rw-   0        0        0    22692 2023-12-03 06:46:29.000000 financepy-0.350/tests_golden/TestFinCDS.py
--rw-rw-rw-   0        0        0    13452 2023-12-03 06:46:34.000000 financepy-0.350/tests_golden/TestFinCDSBasket.py
--rw-rw-rw-   0        0        0     5520 2023-12-02 18:53:04.000000 financepy-0.350/tests_golden/TestFinCDSCurve.py
--rw-rw-rw-   0        0        0     5212 2023-12-02 18:48:08.000000 financepy-0.350/tests_golden/TestFinCDSIndex.py
--rw-rw-rw-   0        0        0    11115 2023-12-04 11:07:58.000000 financepy-0.350/tests_golden/TestFinCDSIndexAdjustHazards.py
--rw-rw-rw-   0        0        0    10406 2023-12-04 11:08:42.000000 financepy-0.350/tests_golden/TestFinCDSIndexAdjustSpreads.py
--rw-rw-rw-   0        0        0     8800 2023-12-04 11:11:01.000000 financepy-0.350/tests_golden/TestFinCDSIndexOption.py
--rw-rw-rw-   0        0        0     7938 2023-12-03 06:47:13.000000 financepy-0.350/tests_golden/TestFinCDSIndexPortfolio.py
--rw-rw-rw-   0        0        0    11105 2023-12-03 06:46:46.000000 financepy-0.350/tests_golden/TestFinCDSOption.py
--rw-rw-rw-   0        0        0    10645 2023-12-03 06:46:51.000000 financepy-0.350/tests_golden/TestFinCDSTranche.py
--rw-rw-rw-   0        0        0     1691 2023-12-02 21:00:03.000000 financepy-0.350/tests_golden/TestFinCalendar.py
--rw-rw-rw-   0        0        0     8569 2023-12-03 06:46:55.000000 financepy-0.350/tests_golden/TestFinDate.py
--rw-rw-rw-   0        0        0     3268 2023-12-02 18:52:53.000000 financepy-0.350/tests_golden/TestFinDateAdjust.py
--rw-rw-rw-   0        0        0     1319 2023-12-03 16:19:57.000000 financepy-0.350/tests_golden/TestFinDayCount.py
--rw-rw-rw-   0        0        0     3497 2023-12-03 16:15:57.000000 financepy-0.350/tests_golden/TestFinDiscountCurve.py
--rw-rw-rw-   0        0        0     1851 2023-12-03 16:12:30.000000 financepy-0.350/tests_golden/TestFinDiscountCurveFlat.py
--rw-rw-rw-   0        0        0     7492 2023-12-09 17:12:18.000000 financepy-0.350/tests_golden/TestFinDiscountCurveNS.py
--rw-rw-rw-   0        0        0     4423 2023-12-09 17:15:41.000000 financepy-0.350/tests_golden/TestFinDiscountCurveNSS.py
--rw-rw-rw-   0        0        0     1495 2023-12-03 16:12:57.000000 financepy-0.350/tests_golden/TestFinDiscountCurvePolynomial.py
--rw-rw-rw-   0        0        0     2837 2023-12-03 16:14:01.000000 financepy-0.350/tests_golden/TestFinDiscountCurveZeros.py
--rw-rw-rw-   0        0        0     6655 2023-12-03 16:30:38.000000 financepy-0.350/tests_golden/TestFinDiscountCurves.py
--rw-rw-rw-   0        0        0    11038 2023-12-02 18:52:26.000000 financepy-0.350/tests_golden/TestFinEquityAmericanMC.py
--rw-rw-rw-   0        0        0     7066 2023-12-03 16:30:44.000000 financepy-0.350/tests_golden/TestFinEquityAmericanOption.py
--rw-rw-rw-   0        0        0    13848 2023-12-02 18:47:38.000000 financepy-0.350/tests_golden/TestFinEquityAsianOption.py
--rw-rw-rw-   0        0        0     7002 2023-12-02 18:52:47.000000 financepy-0.350/tests_golden/TestFinEquityBarrierOption.py
--rw-rw-rw-   0        0        0     7569 2023-12-02 18:52:05.000000 financepy-0.350/tests_golden/TestFinEquityBasketOption.py
--rw-rw-rw-   0        0        0     6342 2023-12-03 16:31:38.000000 financepy-0.350/tests_golden/TestFinEquityBinomialTree.py
--rw-rw-rw-   0        0        0     5424 2023-12-02 18:47:35.000000 financepy-0.350/tests_golden/TestFinEquityChooserOption.py
--rw-rw-rw-   0        0        0     1972 2023-12-03 16:33:19.000000 financepy-0.350/tests_golden/TestFinEquityCliquetOption.py
--rw-rw-rw-   0        0        0     5937 2023-12-02 18:51:17.000000 financepy-0.350/tests_golden/TestFinEquityCompoundOption.py
--rw-rw-rw-   0        0        0     5004 2023-12-02 18:47:30.000000 financepy-0.350/tests_golden/TestFinEquityDigitalOption.py
--rw-rw-rw-   0        0        0     2094 2023-12-10 18:13:31.000000 financepy-0.350/tests_golden/TestFinEquityForward.py
--rw-rw-rw-   0        0        0    16222 2023-12-02 18:52:01.000000 financepy-0.350/tests_golden/TestFinEquityLookbackOption.py
--rw-rw-rw-   0        0        0     6136 2023-12-03 16:30:50.000000 financepy-0.350/tests_golden/TestFinEquityOneTouchOption.py
--rw-rw-rw-   0        0        0    17809 2023-12-02 18:51:57.000000 financepy-0.350/tests_golden/TestFinEquityRainbowOption.py
--rw-rw-rw-   0        0        0     7564 2023-12-02 18:47:21.000000 financepy-0.350/tests_golden/TestFinEquitySwap.py
--rw-rw-rw-   0        0        0    10636 2023-12-04 10:23:29.000000 financepy-0.350/tests_golden/TestFinEquityVanillaOption.py
--rw-rw-rw-   0        0        0     2300 2023-12-02 18:47:16.000000 financepy-0.350/tests_golden/TestFinEquityVarianceSwap.py
--rw-rw-rw-   0        0        0     3984 2023-12-10 18:00:13.000000 financepy-0.350/tests_golden/TestFinEquityVolSurface.py
--rw-rw-rw-   0        0        0     4756 2023-12-02 18:49:20.000000 financepy-0.350/tests_golden/TestFinFXAmericanOption.py
--rw-rw-rw-   0        0        0     6413 2023-12-02 18:49:25.000000 financepy-0.350/tests_golden/TestFinFXBarrierOption.py
--rw-rw-rw-   0        0        0     2618 2023-12-02 18:51:53.000000 financepy-0.350/tests_golden/TestFinFXDigitalOption.py
--rw-rw-rw-   0        0        0     1859 2023-12-03 16:33:15.000000 financepy-0.350/tests_golden/TestFinFXDoubleDigitalOption.py
--rw-rw-rw-   0        0        0     3085 2023-12-10 18:04:58.000000 financepy-0.350/tests_golden/TestFinFXForward.py
--rw-rw-rw-   0        0        0    15138 2023-12-10 18:06:17.000000 financepy-0.350/tests_golden/TestFinFXLookbackOption.py
--rw-rw-rw-   0        0        0     5920 2023-12-02 18:50:57.000000 financepy-0.350/tests_golden/TestFinFXOneTouchOption.py
--rw-rw-rw-   0        0        0     5105 2023-12-10 17:54:05.000000 financepy-0.350/tests_golden/TestFinFXOptionSABR.py
--rw-rw-rw-   0        0        0    17475 2023-12-10 17:54:17.000000 financepy-0.350/tests_golden/TestFinFXVanillaOption.py
--rw-rw-rw-   0        0        0     9758 2023-12-02 18:50:52.000000 financepy-0.350/tests_golden/TestFinFXVolSurface.py
--rw-rw-rw-   0        0        0    17959 2023-12-02 18:49:02.000000 financepy-0.350/tests_golden/TestFinFXVolSurfacePlus.py
--rw-rw-rw-   0        0        0    27974 2023-12-02 18:52:41.000000 financepy-0.350/tests_golden/TestFinIborBermudanSwaption.py
--rw-rw-rw-   0        0        0    13799 2023-12-11 08:35:09.000000 financepy-0.350/tests_golden/TestFinIborCapFloor.py
--rw-rw-rw-   0        0        0     1901 2024-02-13 17:35:23.000000 financepy-0.350/tests_golden/TestFinIborCapVolCurve.py
--rw-rw-rw-   0        0        0    24284 2023-12-02 18:48:53.000000 financepy-0.350/tests_golden/TestFinIborDualCurve.py
--rw-rw-rw-   0        0        0     1049 2023-12-02 21:00:37.000000 financepy-0.350/tests_golden/TestFinIborFuture.py
--rw-rw-rw-   0        0        0     9293 2023-12-05 13:25:23.000000 financepy-0.350/tests_golden/TestFinIborLMMProducts.py
--rw-rw-rw-   0        0        0    26387 2023-12-02 21:08:08.000000 financepy-0.350/tests_golden/TestFinIborSingleCurve.py
--rw-rw-rw-   0        0        0    13413 2023-12-03 15:49:26.000000 financepy-0.350/tests_golden/TestFinIborSwap.py
--rw-rw-rw-   0        0        0    26469 2023-12-02 18:50:46.000000 financepy-0.350/tests_golden/TestFinIborSwaption.py
--rw-rw-rw-   0        0        0    14935 2023-12-02 18:51:45.000000 financepy-0.350/tests_golden/TestFinInflationBond.py
--rw-rw-rw-   0        0        0     1429 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinInflationIndexCurve.py
--rw-rw-rw-   0        0        0     2275 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinInterpolate.py
--rw-rw-rw-   0        0        0     2203 2023-12-03 16:13:01.000000 financepy-0.350/tests_golden/TestFinInterpolatedForwards.py
--rw-rw-rw-   0        0        0     4310 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinLossDbnBuilder.py
--rw-rw-rw-   0        0        0     2868 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinMath.py
--rw-rw-rw-   0        0        0     1890 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinMathAccruedInterp.py
--rw-rw-rw-   0        0        0     3687 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinModelBlack.py
--rw-rw-rw-   0        0        0     4894 2023-12-03 16:31:49.000000 financepy-0.350/tests_golden/TestFinModelBlackScholes.py
--rw-rw-rw-   0        0        0     2588 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinModelBlack_SABR_HW.py
--rw-rw-rw-   0        0        0     2459 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinModelCIR.py
--rw-rw-rw-   0        0        0     6589 2023-12-02 18:50:42.000000 financepy-0.350/tests_golden/TestFinModelHeston.py
--rw-rw-rw-   0        0        0     3626 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinModelMerton.py
--rw-rw-rw-   0        0        0     9979 2023-12-05 13:24:45.000000 financepy-0.350/tests_golden/TestFinModelRatesBDT.py
--rw-rw-rw-   0        0        0     5151 2023-12-05 13:25:26.000000 financepy-0.350/tests_golden/TestFinModelRatesBK.py
--rw-rw-rw-   0        0        0    11368 2023-12-05 13:24:48.000000 financepy-0.350/tests_golden/TestFinModelRatesHW.py
--rw-rw-rw-   0        0        0    17737 2023-12-05 13:26:16.000000 financepy-0.350/tests_golden/TestFinModelRatesLMM.py
--rw-rw-rw-   0        0        0     3199 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinModelSABR.py
--rw-rw-rw-   0        0        0     2704 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinModelShiftedSABR.py
--rw-rw-rw-   0        0        0    12164 2023-12-04 10:23:34.000000 financepy-0.350/tests_golden/TestFinNumbaNumpySpeed.py
--rw-rw-rw-   0        0        0     2288 2023-12-02 18:51:28.000000 financepy-0.350/tests_golden/TestFinOIS.py
--rw-rw-rw-   0        0        0    19224 2023-12-02 21:08:11.000000 financepy-0.350/tests_golden/TestFinOISCurve.py
--rw-rw-rw-   0        0        0     3814 2023-12-10 17:44:59.000000 financepy-0.350/tests_golden/TestFinOptionImpliedDbn.py
--rw-rw-rw-   0        0        0     1024 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinPieceCurve.py
--rw-rw-rw-   0        0        0     6197 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinProcessSimulator.py
--rw-rw-rw-   0        0        0    16861 2023-12-10 16:46:03.000000 financepy-0.350/tests_golden/TestFinSchedule.py
--rw-rw-rw-   0        0        0     1674 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinSobol.py
--rw-rw-rw-   0        0        0     2458 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinStatistics.py
--rw-rw-rw-   0        0        0     8687 2023-12-02 18:50:01.000000 financepy-0.350/tests_golden/TestFinSwapLegs.py
--rw-rw-rw-   0        0        0     4640 2023-12-02 18:50:05.000000 financepy-0.350/tests_golden/TestFinSwaptionVolSurface.py
--rw-rw-rw-   0        0        0     1345 2023-12-02 16:04:26.000000 financepy-0.350/tests_golden/TestFinVasicekRateModel.py
--rw-rw-rw-   0        0        0     1344 2023-12-02 18:50:09.000000 financepy-0.350/tests_golden/TestFinVolatilityCurve.py
--rw-rw-rw-   0        0        0       56 2023-11-16 17:12:54.000000 financepy-0.350/tests_golden/__init__.py
--rw-rw-rw-   0        0        0     2349 2024-02-19 03:21:51.000000 financepy-0.350/tests_golden/run_all_tests.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:10.426732 financepy-0.360/
+-rw-rw-rw-   0        0        0    35823 2023-11-16 17:12:54.000000 financepy-0.360/LICENSE
+-rw-rw-rw-   0        0        0     8679 2024-05-01 13:47:10.426732 financepy-0.360/PKG-INFO
+-rw-rw-rw-   0        0        0     8082 2024-04-30 20:42:13.000000 financepy-0.360/README.md
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.191289 financepy-0.360/financepy/
+-rw-rw-rw-   0        0        0      453 2024-05-01 13:47:05.000000 financepy-0.360/financepy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.198267 financepy-0.360/financepy/market/
+-rw-rw-rw-   0        0        0        0 2023-11-16 17:12:54.000000 financepy-0.360/financepy/market/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.289028 financepy-0.360/financepy/market/curves/
+-rw-rw-rw-   0        0        0      308 2023-11-16 17:12:54.000000 financepy-0.360/financepy/market/curves/__init__.py
+-rw-rw-rw-   0        0        0    17137 2024-04-30 16:28:58.000000 financepy-0.360/financepy/market/curves/discount_curve.py
+-rw-rw-rw-   0        0        0     5101 2024-04-30 16:55:35.000000 financepy-0.360/financepy/market/curves/discount_curve_flat.py
+-rw-rw-rw-   0        0        0     6658 2024-03-09 18:49:47.000000 financepy-0.360/financepy/market/curves/discount_curve_ns.py
+-rw-rw-rw-   0        0        0     7300 2024-03-09 18:51:34.000000 financepy-0.360/financepy/market/curves/discount_curve_nss.py
+-rw-rw-rw-   0        0        0     6137 2024-03-10 17:58:07.000000 financepy-0.360/financepy/market/curves/discount_curve_poly.py
+-rw-rw-rw-   0        0        0     5869 2024-03-10 18:42:20.000000 financepy-0.360/financepy/market/curves/discount_curve_pwf.py
+-rw-rw-rw-   0        0        0     5692 2024-03-10 18:42:20.000000 financepy-0.360/financepy/market/curves/discount_curve_pwl.py
+-rw-rw-rw-   0        0        0     5515 2024-04-30 16:29:14.000000 financepy-0.360/financepy/market/curves/discount_curve_zeros.py
+-rw-rw-rw-   0        0        0    12486 2024-03-10 18:42:20.000000 financepy-0.360/financepy/market/curves/interpolator.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.296522 financepy-0.360/financepy/market/prices/
+-rw-rw-rw-   0        0        0       25 2023-11-16 17:12:54.000000 financepy-0.360/financepy/market/prices/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.375596 financepy-0.360/financepy/market/volatility/
+-rw-rw-rw-   0        0        0      172 2023-11-16 17:12:54.000000 financepy-0.360/financepy/market/volatility/__init__.py
+-rw-rw-rw-   0        0        0     2741 2024-02-22 16:57:17.000000 financepy-0.360/financepy/market/volatility/equity_vol_curve.py
+-rw-rw-rw-   0        0        0    29581 2024-05-01 08:41:46.000000 financepy-0.360/financepy/market/volatility/equity_vol_surface.py
+-rw-rw-rw-   0        0        0    46974 2024-03-12 08:38:15.000000 financepy-0.360/financepy/market/volatility/fx_vol_surface.py
+-rw-rw-rw-   0        0        0    91156 2024-03-11 19:31:55.000000 financepy-0.360/financepy/market/volatility/fx_vol_surface_plus.py
+-rw-rw-rw-   0        0        0     7359 2024-03-10 18:42:20.000000 financepy-0.360/financepy/market/volatility/ibor_cap_vol_curve.py
+-rw-rw-rw-   0        0        0     1489 2023-12-02 18:39:36.000000 financepy-0.360/financepy/market/volatility/ibor_cap_vol_curve_fn.py
+-rw-rw-rw-   0        0        0    35146 2024-05-01 08:41:53.000000 financepy-0.360/financepy/market/volatility/swaption_vol_surface.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.710811 financepy-0.360/financepy/models/
+-rw-rw-rw-   0        0        0      837 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/__init__.py
+-rw-rw-rw-   0        0        0     2286 2024-03-12 08:58:09.000000 financepy-0.360/financepy/models/bachelier.py
+-rw-rw-rw-   0        0        0    30868 2024-03-12 09:21:30.000000 financepy-0.360/financepy/models/bdt_tree.py
+-rw-rw-rw-   0        0        0    40139 2024-03-12 09:21:30.000000 financepy-0.360/financepy/models/bk_tree.py
+-rw-rw-rw-   0        0        0    17005 2024-03-12 08:58:27.000000 financepy-0.360/financepy/models/black.py
+-rw-rw-rw-   0        0        0    10150 2024-03-11 20:20:28.000000 financepy-0.360/financepy/models/black_scholes.py
+-rw-rw-rw-   0        0        0    17302 2024-03-11 20:20:43.000000 financepy-0.360/financepy/models/black_scholes_analytic.py
+-rw-rw-rw-   0        0        0     7132 2024-03-11 20:20:49.000000 financepy-0.360/financepy/models/black_scholes_mc.py
+-rw-rw-rw-   0        0        0     3135 2024-02-21 17:52:20.000000 financepy-0.360/financepy/models/black_scholes_mc_tests.py
+-rw-rw-rw-   0        0        0     2862 2024-03-11 17:53:09.000000 financepy-0.360/financepy/models/black_shifted.py
+-rw-rw-rw-   0        0        0        0 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/bond_analytics.py
+-rw-rw-rw-   0        0        0    10122 2024-03-08 19:52:25.000000 financepy-0.360/financepy/models/cir_montecarlo.py
+-rw-rw-rw-   0        0        0     8504 2024-02-22 13:26:06.000000 financepy-0.360/financepy/models/equity_barrier_models.py
+-rw-rw-rw-   0        0        0     7194 2024-02-21 18:36:37.000000 financepy-0.360/financepy/models/equity_crr_tree.py
+-rw-rw-rw-   0        0        0     5722 2024-02-21 21:35:14.000000 financepy-0.360/financepy/models/equity_lsmc.py
+-rw-rw-rw-   0        0        0     8211 2024-02-22 14:56:47.000000 financepy-0.360/financepy/models/finite_difference.py
+-rw-rw-rw-   0        0        0     5385 2024-02-22 14:57:12.000000 financepy-0.360/financepy/models/finite_difference_PSOR.py
+-rw-rw-rw-   0        0        0     1726 2024-03-11 17:34:28.000000 financepy-0.360/financepy/models/gauss_copula.py
+-rw-rw-rw-   0        0        0     6398 2024-02-19 21:25:28.000000 financepy-0.360/financepy/models/gauss_copula_lhp.py
+-rw-rw-rw-   0        0        0     5659 2024-03-09 10:19:09.000000 financepy-0.360/financepy/models/gauss_copula_lhplus.py
+-rw-rw-rw-   0        0        0    14191 2024-03-09 12:42:28.000000 financepy-0.360/financepy/models/gauss_copula_onefactor.py
+-rw-rw-rw-   0        0        0     7306 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/gbm_process_simulator.py
+-rw-rw-rw-   0        0        0    14139 2024-03-10 18:52:24.000000 financepy-0.360/financepy/models/heston.py
+-rw-rw-rw-   0        0        0    51163 2024-04-30 15:48:09.000000 financepy-0.360/financepy/models/hw_tree.py
+-rw-rw-rw-   0        0        0    33841 2024-03-08 20:04:58.000000 financepy-0.360/financepy/models/lmm_mc.py
+-rw-rw-rw-   0        0        0     4500 2024-02-22 12:00:05.000000 financepy-0.360/financepy/models/loss_dbn_builder.py
+-rw-rw-rw-   0        0        0     5516 2024-02-21 18:47:37.000000 financepy-0.360/financepy/models/merton_firm.py
+-rw-rw-rw-   0        0        0     6058 2024-02-21 19:44:37.000000 financepy-0.360/financepy/models/merton_firm_mkt.py
+-rw-rw-rw-   0        0        0      434 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/model.py
+-rw-rw-rw-   0        0        0     1980 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/option_implied_dbn.py
+-rw-rw-rw-   0        0        0    14791 2024-03-09 10:31:01.000000 financepy-0.360/financepy/models/process_simulator.py
+-rw-rw-rw-   0        0        0     3844 2023-12-05 14:02:52.000000 financepy-0.360/financepy/models/rates_ho_lee.py
+-rw-rw-rw-   0        0        0    10606 2024-03-11 18:13:19.000000 financepy-0.360/financepy/models/sabr.py
+-rw-rw-rw-   0        0        0     8430 2024-03-08 19:57:01.000000 financepy-0.360/financepy/models/sabr_shifted.py
+-rw-rw-rw-   0        0        0     5316 2024-02-22 14:57:35.000000 financepy-0.360/financepy/models/sobol.py
+-rw-rw-rw-   0        0        0   120492 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/sobolcoeff.npz
+-rw-rw-rw-   0        0        0     1811 2024-03-10 18:42:44.000000 financepy-0.360/financepy/models/student_t_copula.py
+-rw-rw-rw-   0        0        0     3603 2024-03-09 11:59:10.000000 financepy-0.360/financepy/models/vasicek_mc.py
+-rw-rw-rw-   0        0        0     8196 2023-11-16 17:12:54.000000 financepy-0.360/financepy/models/volatility_fns.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.710811 financepy-0.360/financepy/products/
+-rw-rw-rw-   0        0        0        0 2023-11-16 17:12:54.000000 financepy-0.360/financepy/products/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.852687 financepy-0.360/financepy/products/bonds/
+-rw-rw-rw-   0        0        0      370 2024-02-19 11:45:13.000000 financepy-0.360/financepy/products/bonds/__init__.py
+-rw-rw-rw-   0        0        0    41769 2024-03-12 08:38:15.000000 financepy-0.360/financepy/products/bonds/bond.py
+-rw-rw-rw-   0        0        0     7397 2024-05-01 09:23:03.000000 financepy-0.360/financepy/products/bonds/bond_annuity.py
+-rw-rw-rw-   0        0        0     9566 2024-03-12 09:23:37.000000 financepy-0.360/financepy/products/bonds/bond_callable.py
+-rw-rw-rw-   0        0        0    26246 2024-03-12 08:59:05.000000 financepy-0.360/financepy/products/bonds/bond_convertible.py
+-rw-rw-rw-   0        0        0    18716 2024-05-01 09:34:18.000000 financepy-0.360/financepy/products/bonds/bond_frn.py
+-rw-rw-rw-   0        0        0     5987 2024-03-12 08:59:32.000000 financepy-0.360/financepy/products/bonds/bond_future.py
+-rw-rw-rw-   0        0        0     5275 2024-02-19 04:05:52.000000 financepy-0.360/financepy/products/bonds/bond_market.py
+-rw-rw-rw-   0        0        0     6371 2024-03-12 08:26:00.000000 financepy-0.360/financepy/products/bonds/bond_mortgage.py
+-rw-rw-rw-   0        0        0     5559 2024-03-12 08:59:40.000000 financepy-0.360/financepy/products/bonds/bond_option.py
+-rw-rw-rw-   0        0        0    11648 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/bonds/bond_portfolio.py
+-rw-rw-rw-   0        0        0     6818 2024-04-30 18:55:35.000000 financepy-0.360/financepy/products/bonds/bond_yield_curve.py
+-rw-rw-rw-   0        0        0    27191 2024-04-30 15:44:35.000000 financepy-0.360/financepy/products/bonds/bond_zero.py
+-rw-rw-rw-   0        0        0     6973 2024-04-30 16:29:19.000000 financepy-0.360/financepy/products/bonds/bond_zero_curve.py
+-rw-rw-rw-   0        0        0     5765 2024-04-30 17:49:16.000000 financepy-0.360/financepy/products/bonds/curve_fits.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.925010 financepy-0.360/financepy/products/credit/
+-rw-rw-rw-   0        0        0      197 2023-11-16 17:12:54.000000 financepy-0.360/financepy/products/credit/__init__.py
+-rw-rw-rw-   0        0        0    31983 2024-03-11 17:28:11.000000 financepy-0.360/financepy/products/credit/cds.py
+-rw-rw-rw-   0        0        0    13107 2024-03-12 09:00:23.000000 financepy-0.360/financepy/products/credit/cds_basket.py
+-rw-rw-rw-   0        0        0     9128 2024-03-11 17:31:56.000000 financepy-0.360/financepy/products/credit/cds_curve.py
+-rw-rw-rw-   0        0        0    14534 2024-04-30 15:41:59.000000 financepy-0.360/financepy/products/credit/cds_index_option.py
+-rw-rw-rw-   0        0        0    19842 2024-04-30 15:44:40.000000 financepy-0.360/financepy/products/credit/cds_index_portfolio.py
+-rw-rw-rw-   0        0        0     6527 2024-04-30 15:41:38.000000 financepy-0.360/financepy/products/credit/cds_option.py
+-rw-rw-rw-   0        0        0     8773 2024-03-12 09:26:08.000000 financepy-0.360/financepy/products/credit/cds_tranche.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:08.107127 financepy-0.360/financepy/products/equity/
+-rw-rw-rw-   0        0        0      808 2023-12-03 16:34:34.000000 financepy-0.360/financepy/products/equity/__init__.py
+-rw-rw-rw-   0        0        0     4445 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_american_option.py
+-rw-rw-rw-   0        0        0    30309 2024-03-12 08:41:13.000000 financepy-0.360/financepy/products/equity/equity_asian_option.py
+-rw-rw-rw-   0        0        0    10623 2024-03-11 18:04:05.000000 financepy-0.360/financepy/products/equity/equity_barrier_option.py
+-rw-rw-rw-   0        0        0     9908 2024-03-11 18:16:52.000000 financepy-0.360/financepy/products/equity/equity_basket_option.py
+-rw-rw-rw-   0        0        0     8402 2024-02-21 21:55:51.000000 financepy-0.360/financepy/products/equity/equity_binomial_tree.py
+-rw-rw-rw-   0        0        0     9252 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_chooser_option.py
+-rw-rw-rw-   0        0        0     7382 2024-03-12 09:22:08.000000 financepy-0.360/financepy/products/equity/equity_cliquet_option.py
+-rw-rw-rw-   0        0        0    18015 2024-03-11 18:18:44.000000 financepy-0.360/financepy/products/equity/equity_compound_option.py
+-rw-rw-rw-   0        0        0     7580 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_digital_option.py
+-rw-rw-rw-   0        0        0    10492 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_fixed_lookback_option.py
+-rw-rw-rw-   0        0        0     8865 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_float_lookback_option.py
+-rw-rw-rw-   0        0        0     4762 2024-03-11 18:06:22.000000 financepy-0.360/financepy/products/equity/equity_forward.py
+-rw-rw-rw-   0        0        0     9782 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_index_option.py
+-rw-rw-rw-   0        0        0     1937 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_model_types.py
+-rw-rw-rw-   0        0        0    19620 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/equity/equity_one_touch_option.py
+-rw-rw-rw-   0        0        0     7392 2024-03-11 20:10:06.000000 financepy-0.360/financepy/products/equity/equity_option.py
+-rw-rw-rw-   0        0        0    12199 2024-03-11 18:20:39.000000 financepy-0.360/financepy/products/equity/equity_rainbow_option.py
+-rw-rw-rw-   0        0        0     8297 2024-04-30 16:48:20.000000 financepy-0.360/financepy/products/equity/equity_swap.py
+-rw-rw-rw-   0        0        0    13939 2024-03-12 08:50:40.000000 financepy-0.360/financepy/products/equity/equity_swap_leg.py
+-rw-rw-rw-   0        0        0    24463 2024-03-11 17:57:20.000000 financepy-0.360/financepy/products/equity/equity_vanilla_option.py
+-rw-rw-rw-   0        0        0    10539 2024-03-11 18:21:46.000000 financepy-0.360/financepy/products/equity/equity_variance_swap.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:08.235301 financepy-0.360/financepy/products/fx/
+-rw-rw-rw-   0        0        0      416 2023-11-16 17:12:54.000000 financepy-0.360/financepy/products/fx/__init__.py
+-rw-rw-rw-   0        0        0    17485 2024-03-11 18:06:45.000000 financepy-0.360/financepy/products/fx/fx_barrier_option.py
+-rw-rw-rw-   0        0        0     6065 2024-03-11 18:28:33.000000 financepy-0.360/financepy/products/fx/fx_digital_option.py
+-rw-rw-rw-   0        0        0     5759 2024-03-11 18:29:41.000000 financepy-0.360/financepy/products/fx/fx_double_digital_option.py
+-rw-rw-rw-   0        0        0     9181 2024-03-11 18:06:59.000000 financepy-0.360/financepy/products/fx/fx_fixed_lookback_option.py
+-rw-rw-rw-   0        0        0     7762 2024-03-11 18:07:20.000000 financepy-0.360/financepy/products/fx/fx_float_lookback_option.py
+-rw-rw-rw-   0        0        0     7135 2024-04-30 15:21:08.000000 financepy-0.360/financepy/products/fx/fx_forward.py
+-rw-rw-rw-   0        0        0     4873 2024-03-11 20:02:15.000000 financepy-0.360/financepy/products/fx/fx_mkt_conventions.py
+-rw-rw-rw-   0        0        0    19684 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/fx/fx_one_touch_option.py
+-rw-rw-rw-   0        0        0     5778 2024-03-10 18:04:09.000000 financepy-0.360/financepy/products/fx/fx_option.py
+-rw-rw-rw-   0        0        0    10832 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/fx/fx_rainbow_option.py
+-rw-rw-rw-   0        0        0    27910 2024-03-11 18:30:37.000000 financepy-0.360/financepy/products/fx/fx_vanilla_option.py
+-rw-rw-rw-   0        0        0    10000 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/fx/fx_variance_swap.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:08.279244 financepy-0.360/financepy/products/inflation/
+-rw-rw-rw-   0        0        0     6702 2024-03-11 17:44:12.000000 financepy-0.360/financepy/products/inflation/FinInflationBond.py
+-rw-rw-rw-   0        0        0     4364 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/inflation/FinInflationIndexCurve.py
+-rw-rw-rw-   0        0        0     6440 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/inflation/FinInflationSwap.py
+-rw-rw-rw-   0        0        0    20952 2024-04-30 16:53:51.000000 financepy-0.360/financepy/products/inflation/FinInflationSwapCurve.py
+-rw-rw-rw-   0        0        0       33 2023-11-16 17:12:54.000000 financepy-0.360/financepy/products/inflation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:08.453032 financepy-0.360/financepy/products/rates/
+-rw-rw-rw-   0        0        0      435 2023-11-16 17:12:54.000000 financepy-0.360/financepy/products/rates/__init__.py
+-rw-rw-rw-   0        0        0     9029 2024-04-30 15:44:54.000000 financepy-0.360/financepy/products/rates/bermudan_swaption.py
+-rw-rw-rw-   0        0        0    10961 2024-04-30 15:43:37.000000 financepy-0.360/financepy/products/rates/callable_swap.py
+-rw-rw-rw-   0        0        0    22630 2024-04-30 19:17:20.000000 financepy-0.360/financepy/products/rates/dual_curve.py
+-rw-rw-rw-   0        0        0     7873 2024-04-30 16:48:24.000000 financepy-0.360/financepy/products/rates/ibor_basis_swap.py
+-rw-rw-rw-   0        0        0    14863 2024-04-30 16:02:45.000000 financepy-0.360/financepy/products/rates/ibor_cap_floor.py
+-rw-rw-rw-   0        0        0     1224 2024-03-10 18:05:08.000000 financepy-0.360/financepy/products/rates/ibor_conventions.py
+-rw-rw-rw-   0        0        0     6471 2024-03-10 18:19:26.000000 financepy-0.360/financepy/products/rates/ibor_deposit.py
+-rw-rw-rw-   0        0        0     6878 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/rates/ibor_fra.py
+-rw-rw-rw-   0        0        0     5769 2024-03-10 18:45:14.000000 financepy-0.360/financepy/products/rates/ibor_future.py
+-rw-rw-rw-   0        0        0    17458 2024-04-30 15:45:05.000000 financepy-0.360/financepy/products/rates/ibor_lmm_products.py
+-rw-rw-rw-   0        0        0    26826 2024-04-30 19:16:52.000000 financepy-0.360/financepy/products/rates/ibor_single_curve.py
+-rw-rw-rw-   0        0        0    11229 2024-04-30 19:12:41.000000 financepy-0.360/financepy/products/rates/ibor_swap.py
+-rw-rw-rw-   0        0        0    17115 2024-04-30 15:43:51.000000 financepy-0.360/financepy/products/rates/ibor_swaption.py
+-rw-rw-rw-   0        0        0     9935 2024-04-30 20:32:34.000000 financepy-0.360/financepy/products/rates/ois.py
+-rw-rw-rw-   0        0        0     7383 2024-04-30 15:08:00.000000 financepy-0.360/financepy/products/rates/ois_basis_swap.py
+-rw-rw-rw-   0        0        0    24522 2024-04-30 16:48:29.000000 financepy-0.360/financepy/products/rates/ois_curve.py
+-rw-rw-rw-   0        0        0    10960 2024-04-30 15:32:03.000000 financepy-0.360/financepy/products/rates/swap_fixed_leg.py
+-rw-rw-rw-   0        0        0    12286 2024-04-30 20:32:18.000000 financepy-0.360/financepy/products/rates/swap_float_leg.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:08.650762 financepy-0.360/financepy/utils/
+-rw-rw-rw-   0        0        0      371 2023-11-16 17:12:54.000000 financepy-0.360/financepy/utils/__init__.py
+-rw-rw-rw-   0        0        0     1433 2024-04-30 18:56:43.000000 financepy-0.360/financepy/utils/amount.py
+-rw-rw-rw-   0        0        0    33569 2024-03-11 20:08:06.000000 financepy-0.360/financepy/utils/calendar.py
+-rw-rw-rw-   0        0        0      630 2023-11-16 17:12:54.000000 financepy-0.360/financepy/utils/currency.py
+-rw-rw-rw-   0        0        0    33116 2024-03-10 17:12:23.000000 financepy-0.360/financepy/utils/date.py
+-rw-rw-rw-   0        0        0    10404 2024-03-09 18:34:28.000000 financepy-0.360/financepy/utils/day_count.py
+-rw-rw-rw-   0        0        0      888 2023-11-16 17:12:54.000000 financepy-0.360/financepy/utils/distribution.py
+-rw-rw-rw-   0        0        0     2047 2024-03-09 13:01:14.000000 financepy-0.360/financepy/utils/error.py
+-rw-rw-rw-   0        0        0     1601 2023-12-09 16:59:50.000000 financepy-0.360/financepy/utils/frequency.py
+-rw-rw-rw-   0        0        0     2957 2024-02-21 19:54:38.000000 financepy-0.360/financepy/utils/global_types.py
+-rw-rw-rw-   0        0        0      448 2024-02-22 13:49:27.000000 financepy-0.360/financepy/utils/global_vars.py
+-rw-rw-rw-   0        0        0    15536 2024-03-11 17:18:37.000000 financepy-0.360/financepy/utils/helpers.py
+-rw-rw-rw-   0        0        0     3060 2024-03-11 20:05:01.000000 financepy-0.360/financepy/utils/latex.py
+-rw-rw-rw-   0        0        0    21118 2024-03-09 12:48:09.000000 financepy-0.360/financepy/utils/math.py
+-rw-rw-rw-   0        0        0     2301 2024-03-09 13:00:23.000000 financepy-0.360/financepy/utils/polyfit.py
+-rw-rw-rw-   0        0        0    11527 2024-03-09 18:20:46.000000 financepy-0.360/financepy/utils/schedule.py
+-rw-rw-rw-   0        0        0      498 2023-11-16 17:12:54.000000 financepy-0.360/financepy/utils/singleton.py
+-rw-rw-rw-   0        0        0    29416 2024-02-22 12:47:17.000000 financepy-0.360/financepy/utils/solver_1d.py
+-rw-rw-rw-   0        0        0    21755 2023-11-16 17:12:54.000000 financepy-0.360/financepy/utils/solver_cg.py
+-rw-rw-rw-   0        0        0    13278 2024-02-22 12:32:20.000000 financepy-0.360/financepy/utils/solver_nm.py
+-rw-rw-rw-   0        0        0     2756 2024-03-09 12:57:38.000000 financepy-0.360/financepy/utils/stats.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:07.197269 financepy-0.360/financepy.egg-info/
+-rw-rw-rw-   0        0        0     8679 2024-05-01 13:47:06.000000 financepy-0.360/financepy.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    13621 2024-05-01 13:47:07.000000 financepy-0.360/financepy.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-05-01 13:47:06.000000 financepy-0.360/financepy.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       65 2024-05-01 13:47:06.000000 financepy-0.360/financepy.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       23 2024-05-01 13:47:06.000000 financepy-0.360/financepy.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2024-05-01 13:47:10.426732 financepy-0.360/setup.cfg
+-rw-rw-rw-   0        0        0     2058 2023-11-16 17:12:54.000000 financepy-0.360/setup.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:09.427163 financepy-0.360/tests/
+-rw-rw-rw-   0        0        0      657 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinAmount.py
+-rw-rw-rw-   0        0        0    12608 2024-03-11 20:31:21.000000 financepy-0.360/tests/test_FinBond.py
+-rw-rw-rw-   0        0        0     5805 2024-05-01 09:27:41.000000 financepy-0.360/tests/test_FinBondAnnuity.py
+-rw-rw-rw-   0        0        0     4939 2024-02-22 17:55:59.000000 financepy-0.360/tests/test_FinBondConvertible.py
+-rw-rw-rw-   0        0        0     5110 2024-02-22 17:55:42.000000 financepy-0.360/tests/test_FinBondEmbeddedOption.py
+-rw-rw-rw-   0        0        0     8048 2024-05-01 09:32:22.000000 financepy-0.360/tests/test_FinBondFRN.py
+-rw-rw-rw-   0        0        0     5043 2024-03-10 17:33:40.000000 financepy-0.360/tests/test_FinBondFutures.py
+-rw-rw-rw-   0        0        0     1419 2024-03-10 17:34:38.000000 financepy-0.360/tests/test_FinBondMortgage.py
+-rw-rw-rw-   0        0        0     5791 2024-02-22 16:52:43.000000 financepy-0.360/tests/test_FinBondOption.py
+-rw-rw-rw-   0        0        0     5930 2024-03-11 20:35:43.000000 financepy-0.360/tests/test_FinBondPortfolio.py
+-rw-rw-rw-   0        0        0     3374 2024-05-01 08:37:29.000000 financepy-0.360/tests/test_FinBondYieldCurve.py
+-rw-rw-rw-   0        0        0     1831 2024-03-10 17:14:20.000000 financepy-0.360/tests/test_FinBondZeroCurve.py
+-rw-rw-rw-   0        0        0    13739 2024-04-30 15:48:39.000000 financepy-0.360/tests/test_FinCDS.py
+-rw-rw-rw-   0        0        0     4921 2024-02-22 17:52:55.000000 financepy-0.360/tests/test_FinCDSBasket.py
+-rw-rw-rw-   0        0        0     2916 2024-05-01 08:38:47.000000 financepy-0.360/tests/test_FinCDSCurve.py
+-rw-rw-rw-   0        0        0     2237 2024-04-30 15:49:35.000000 financepy-0.360/tests/test_FinCDSIndex.py
+-rw-rw-rw-   0        0        0     4519 2024-02-22 17:53:00.000000 financepy-0.360/tests/test_FinCDSIndexAdjustHazards.py
+-rw-rw-rw-   0        0        0     4516 2024-02-22 17:53:04.000000 financepy-0.360/tests/test_FinCDSIndexAdjustSpreads.py
+-rw-rw-rw-   0        0        0     5035 2024-04-30 15:49:04.000000 financepy-0.360/tests/test_FinCDSIndexOption.py
+-rw-rw-rw-   0        0        0     4461 2024-02-22 17:53:26.000000 financepy-0.360/tests/test_FinCDSIndexPortfolio.py
+-rw-rw-rw-   0        0        0     1398 2024-02-22 17:53:12.000000 financepy-0.360/tests/test_FinCDSOption.py
+-rw-rw-rw-   0        0        0     4895 2024-02-22 17:53:16.000000 financepy-0.360/tests/test_FinCDSTranche.py
+-rw-rw-rw-   0        0        0     1384 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinCalendar.py
+-rw-rw-rw-   0        0        0     3049 2024-03-10 17:24:14.000000 financepy-0.360/tests/test_FinDateAdjust.py
+-rw-rw-rw-   0        0        0     2665 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinDayCount.py
+-rw-rw-rw-   0        0        0     2438 2023-12-03 16:12:49.000000 financepy-0.360/tests/test_FinDiscountCurveFlat.py
+-rw-rw-rw-   0        0        0     4748 2023-12-09 17:12:04.000000 financepy-0.360/tests/test_FinDiscountCurveNS.py
+-rw-rw-rw-   0        0        0     3001 2023-12-09 17:15:34.000000 financepy-0.360/tests/test_FinDiscountCurveNSS.py
+-rw-rw-rw-   0        0        0     1568 2023-12-03 16:15:27.000000 financepy-0.360/tests/test_FinDiscountCurveZeros.py
+-rw-rw-rw-   0        0        0     2155 2024-02-22 16:52:53.000000 financepy-0.360/tests/test_FinEquityAmericanOption.py
+-rw-rw-rw-   0        0        0     3222 2024-02-22 16:56:12.000000 financepy-0.360/tests/test_FinEquityAsianOption.py
+-rw-rw-rw-   0        0        0     7255 2023-12-02 18:44:57.000000 financepy-0.360/tests/test_FinEquityBarrierOption.py
+-rw-rw-rw-   0        0        0     4526 2023-12-02 18:44:52.000000 financepy-0.360/tests/test_FinEquityBasketOption.py
+-rw-rw-rw-   0        0        0     3179 2024-02-22 16:53:03.000000 financepy-0.360/tests/test_FinEquityBinomialTree.py
+-rw-rw-rw-   0        0        0     4805 2023-12-02 18:44:49.000000 financepy-0.360/tests/test_FinEquityChooserOption.py
+-rw-rw-rw-   0        0        0     1540 2024-02-22 16:52:58.000000 financepy-0.360/tests/test_FinEquityCliquetOption.py
+-rw-rw-rw-   0        0        0     6496 2024-02-22 16:53:12.000000 financepy-0.360/tests/test_FinEquityCompoundOption.py
+-rw-rw-rw-   0        0        0     2155 2024-02-22 16:55:35.000000 financepy-0.360/tests/test_FinEquityDigitalOption.py
+-rw-rw-rw-   0        0        0     1567 2024-02-22 16:53:16.000000 financepy-0.360/tests/test_FinEquityForward.py
+-rw-rw-rw-   0        0        0     3763 2023-12-02 18:54:09.000000 financepy-0.360/tests/test_FinEquityIndexOption.py
+-rw-rw-rw-   0        0        0     2219 2024-02-22 16:54:21.000000 financepy-0.360/tests/test_FinEquityLookbackOption.py
+-rw-rw-rw-   0        0        0    11183 2024-02-22 16:53:20.000000 financepy-0.360/tests/test_FinEquityOneTouchOption.py
+-rw-rw-rw-   0        0        0     6598 2024-02-22 16:53:35.000000 financepy-0.360/tests/test_FinEquityRainbowOption.py
+-rw-rw-rw-   0        0        0     7420 2024-03-10 17:25:05.000000 financepy-0.360/tests/test_FinEquitySwap.py
+-rw-rw-rw-   0        0        0     2199 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinEquityVanillaOption.py
+-rw-rw-rw-   0        0        0     1756 2023-12-02 18:45:04.000000 financepy-0.360/tests/test_FinEquityVarianceSwap.py
+-rw-rw-rw-   0        0        0     2811 2024-05-01 08:45:39.000000 financepy-0.360/tests/test_FinEquityVolSurface.py
+-rw-rw-rw-   0        0        0     8930 2024-02-22 15:17:52.000000 financepy-0.360/tests/test_FinFXAmericanOption.py
+-rw-rw-rw-   0        0        0    13973 2024-02-22 16:53:32.000000 financepy-0.360/tests/test_FinFXBarrierOption.py
+-rw-rw-rw-   0        0        0     2868 2024-03-11 19:55:40.000000 financepy-0.360/tests/test_FinFXForward.py
+-rw-rw-rw-   0        0        0     3268 2024-02-22 16:53:38.000000 financepy-0.360/tests/test_FinFXLookbackOption.py
+-rw-rw-rw-   0        0        0     6505 2024-02-22 15:18:01.000000 financepy-0.360/tests/test_FinFXOptionSABR.py
+-rw-rw-rw-   0        0        0    11852 2024-03-11 19:55:40.000000 financepy-0.360/tests/test_FinFXVanillaOption.py
+-rw-rw-rw-   0        0        0     6636 2024-03-11 19:57:56.000000 financepy-0.360/tests/test_FinFXVolSurface.py
+-rw-rw-rw-   0        0        0    12081 2024-03-11 19:57:56.000000 financepy-0.360/tests/test_FinFXVolSurfacePlus.py
+-rw-rw-rw-   0        0        0    13020 2024-04-30 15:46:58.000000 financepy-0.360/tests/test_FinIborBermudanSwaption.py
+-rw-rw-rw-   0        0        0     6906 2023-12-03 16:30:23.000000 financepy-0.360/tests/test_FinIborCapFloor.py
+-rw-rw-rw-   0        0        0     2301 2023-12-03 16:33:27.000000 financepy-0.360/tests/test_FinIborCapVolCurve.py
+-rw-rw-rw-   0        0        0    10183 2024-03-10 17:26:20.000000 financepy-0.360/tests/test_FinIborDualCurve.py
+-rw-rw-rw-   0        0        0     1197 2024-03-10 17:26:44.000000 financepy-0.360/tests/test_FinIborFuture.py
+-rw-rw-rw-   0        0        0     5682 2024-03-10 17:27:01.000000 financepy-0.360/tests/test_FinIborSingleCurve.py
+-rw-rw-rw-   0        0        0     4351 2024-04-30 15:47:08.000000 financepy-0.360/tests/test_FinIborSwap.py
+-rw-rw-rw-   0        0        0     8225 2023-12-02 18:45:31.000000 financepy-0.360/tests/test_FinIborSwaption.py
+-rw-rw-rw-   0        0        0     4926 2024-03-11 20:35:48.000000 financepy-0.360/tests/test_FinInflationBond.py
+-rw-rw-rw-   0        0        0      855 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinInflationIndexCurve.py
+-rw-rw-rw-   0        0        0     6254 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinInterpolate.py
+-rw-rw-rw-   0        0        0     5851 2023-12-03 16:12:52.000000 financepy-0.360/tests/test_FinInterpolatedForwards.py
+-rw-rw-rw-   0        0        0     1871 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinLossDbnBuilder.py
+-rw-rw-rw-   0        0        0     2056 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinMath.py
+-rw-rw-rw-   0        0        0     6320 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinModelBlack.py
+-rw-rw-rw-   0        0        0     6049 2023-12-02 18:45:48.000000 financepy-0.360/tests/test_FinModelBlackScholes.py
+-rw-rw-rw-   0        0        0     1408 2024-02-22 18:05:21.000000 financepy-0.360/tests/test_FinModelCIR.py
+-rw-rw-rw-   0        0        0     2075 2024-02-22 16:56:42.000000 financepy-0.360/tests/test_FinModelHeston.py
+-rw-rw-rw-   0        0        0     2942 2024-02-21 18:48:02.000000 financepy-0.360/tests/test_FinModelMerton.py
+-rw-rw-rw-   0        0        0     6571 2024-03-10 17:28:04.000000 financepy-0.360/tests/test_FinModelRatesBDT.py
+-rw-rw-rw-   0        0        0     4114 2024-05-01 09:41:10.000000 financepy-0.360/tests/test_FinModelRatesBK.py
+-rw-rw-rw-   0        0        0     2376 2024-04-30 15:47:16.000000 financepy-0.360/tests/test_FinModelRatesHW.py
+-rw-rw-rw-   0        0        0     5371 2024-02-22 11:35:23.000000 financepy-0.360/tests/test_FinModelRatesLMM.py
+-rw-rw-rw-   0        0        0     2722 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinModelSABR.py
+-rw-rw-rw-   0        0        0     2148 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinModelShiftedSABR.py
+-rw-rw-rw-   0        0        0     1714 2023-12-02 18:53:37.000000 financepy-0.360/tests/test_FinOIS.py
+-rw-rw-rw-   0        0        0     5161 2024-03-10 17:30:52.000000 financepy-0.360/tests/test_FinOISCurve.py
+-rw-rw-rw-   0        0        0     6965 2024-05-01 09:36:13.000000 financepy-0.360/tests/test_FinSchedule.py
+-rw-rw-rw-   0        0        0      758 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinSobol.py
+-rw-rw-rw-   0        0        0      985 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinStatistics.py
+-rw-rw-rw-   0        0        0     5540 2023-12-02 18:46:02.000000 financepy-0.360/tests/test_FinSwapLegs.py
+-rw-rw-rw-   0        0        0     1643 2023-11-16 17:12:54.000000 financepy-0.360/tests/test_FinVasicekRateModel.py
+-rw-rw-rw-   0        0        0     9168 2024-03-10 17:39:14.000000 financepy-0.360/tests/test_date.py
+-rw-rw-rw-   0        0        0    17681 2023-12-02 18:45:35.000000 financepy-0.360/tests/test_finite_difference.py
+-rw-rw-rw-   0        0        0    12391 2023-12-02 18:53:43.000000 financepy-0.360/tests/test_finite_difference_PSOR.py
+-rw-rw-rw-   0        0        0     5427 2023-12-02 18:53:30.000000 financepy-0.360/tests/test_lsmc.py
+drwxrwxrwx   0        0        0        0 2024-05-01 13:47:10.426732 financepy-0.360/tests_golden/
+-rw-rw-rw-   0        0        0    18145 2024-04-30 16:23:22.000000 financepy-0.360/tests_golden/FinTestCases.py
+-rw-rw-rw-   0        0        0      893 2023-12-02 15:58:32.000000 financepy-0.360/tests_golden/TestFinAmount.py
+-rw-rw-rw-   0        0        0    24140 2024-04-30 19:15:19.000000 financepy-0.360/tests_golden/TestFinBond.py
+-rw-rw-rw-   0        0        0     7102 2024-03-10 18:26:51.000000 financepy-0.360/tests_golden/TestFinBondAnnuity.py
+-rw-rw-rw-   0        0        0     4507 2024-02-22 17:55:32.000000 financepy-0.360/tests_golden/TestFinBondConvertible.py
+-rw-rw-rw-   0        0        0     6818 2023-12-02 18:53:27.000000 financepy-0.360/tests_golden/TestFinBondEmbeddedOptionBK.py
+-rw-rw-rw-   0        0        0     6799 2023-12-02 18:46:21.000000 financepy-0.360/tests_golden/TestFinBondEmbeddedOptionHW.py
+-rw-rw-rw-   0        0        0    13666 2024-03-11 18:08:32.000000 financepy-0.360/tests_golden/TestFinBondFRN.py
+-rw-rw-rw-   0        0        0     6393 2024-03-09 18:29:08.000000 financepy-0.360/tests_golden/TestFinBondFutures.py
+-rw-rw-rw-   0        0        0     2027 2024-03-09 18:44:22.000000 financepy-0.360/tests_golden/TestFinBondMortgage.py
+-rw-rw-rw-   0        0        0    14479 2024-03-11 20:35:52.000000 financepy-0.360/tests_golden/TestFinBondOptionBDTModel.py
+-rw-rw-rw-   0        0        0    14444 2024-03-11 20:35:55.000000 financepy-0.360/tests_golden/TestFinBondOptionBKModel.py
+-rw-rw-rw-   0        0        0    18330 2024-03-11 20:36:04.000000 financepy-0.360/tests_golden/TestFinBondOptionHWModel.py
+-rw-rw-rw-   0        0        0     2158 2024-03-09 19:02:48.000000 financepy-0.360/tests_golden/TestFinBondPortfolio.py
+-rw-rw-rw-   0        0        0     4495 2024-03-10 18:37:52.000000 financepy-0.360/tests_golden/TestFinBondYieldCurve.py
+-rw-rw-rw-   0        0        0     2852 2024-02-19 19:00:01.000000 financepy-0.360/tests_golden/TestFinBondZeroCoupon.py
+-rw-rw-rw-   0        0        0     2431 2024-03-09 19:03:46.000000 financepy-0.360/tests_golden/TestFinBondZeroCurve.py
+-rw-rw-rw-   0        0        0    22551 2024-04-30 15:47:22.000000 financepy-0.360/tests_golden/TestFinCDS.py
+-rw-rw-rw-   0        0        0    13452 2023-12-03 06:46:34.000000 financepy-0.360/tests_golden/TestFinCDSBasket.py
+-rw-rw-rw-   0        0        0     5524 2024-04-30 15:49:39.000000 financepy-0.360/tests_golden/TestFinCDSCurve.py
+-rw-rw-rw-   0        0        0     5198 2024-04-30 15:47:30.000000 financepy-0.360/tests_golden/TestFinCDSIndex.py
+-rw-rw-rw-   0        0        0    11108 2024-04-30 15:49:09.000000 financepy-0.360/tests_golden/TestFinCDSIndexAdjustHazards.py
+-rw-rw-rw-   0        0        0    10400 2024-04-30 15:49:49.000000 financepy-0.360/tests_golden/TestFinCDSIndexAdjustSpreads.py
+-rw-rw-rw-   0        0        0     8788 2024-04-30 15:49:28.000000 financepy-0.360/tests_golden/TestFinCDSIndexOption.py
+-rw-rw-rw-   0        0        0     7942 2024-04-30 15:49:59.000000 financepy-0.360/tests_golden/TestFinCDSIndexPortfolio.py
+-rw-rw-rw-   0        0        0    11036 2024-04-30 15:47:34.000000 financepy-0.360/tests_golden/TestFinCDSOption.py
+-rw-rw-rw-   0        0        0    10641 2024-03-10 18:47:08.000000 financepy-0.360/tests_golden/TestFinCDSTranche.py
+-rw-rw-rw-   0        0        0     1689 2024-03-09 19:03:58.000000 financepy-0.360/tests_golden/TestFinCalendar.py
+-rw-rw-rw-   0        0        0     8561 2024-03-09 18:42:48.000000 financepy-0.360/tests_golden/TestFinDate.py
+-rw-rw-rw-   0        0        0     3264 2024-03-09 19:16:35.000000 financepy-0.360/tests_golden/TestFinDateAdjust.py
+-rw-rw-rw-   0        0        0     1321 2024-02-21 20:16:46.000000 financepy-0.360/tests_golden/TestFinDayCount.py
+-rw-rw-rw-   0        0        0     3497 2023-12-03 16:15:57.000000 financepy-0.360/tests_golden/TestFinDiscountCurve.py
+-rw-rw-rw-   0        0        0     1851 2023-12-03 16:12:30.000000 financepy-0.360/tests_golden/TestFinDiscountCurveFlat.py
+-rw-rw-rw-   0        0        0     7492 2023-12-09 17:12:18.000000 financepy-0.360/tests_golden/TestFinDiscountCurveNS.py
+-rw-rw-rw-   0        0        0     4423 2023-12-09 17:15:41.000000 financepy-0.360/tests_golden/TestFinDiscountCurveNSS.py
+-rw-rw-rw-   0        0        0     1495 2023-12-03 16:12:57.000000 financepy-0.360/tests_golden/TestFinDiscountCurvePolynomial.py
+-rw-rw-rw-   0        0        0     2837 2023-12-03 16:14:01.000000 financepy-0.360/tests_golden/TestFinDiscountCurveZeros.py
+-rw-rw-rw-   0        0        0     6655 2023-12-03 16:30:38.000000 financepy-0.360/tests_golden/TestFinDiscountCurves.py
+-rw-rw-rw-   0        0        0    11038 2023-12-02 18:52:09.000000 financepy-0.360/tests_golden/TestFinEquityAmericanMC.py
+-rw-rw-rw-   0        0        0     7050 2024-02-22 16:53:41.000000 financepy-0.360/tests_golden/TestFinEquityAmericanOption.py
+-rw-rw-rw-   0        0        0    13860 2024-03-12 08:41:13.000000 financepy-0.360/tests_golden/TestFinEquityAsianOption.py
+-rw-rw-rw-   0        0        0     7002 2023-12-02 18:52:47.000000 financepy-0.360/tests_golden/TestFinEquityBarrierOption.py
+-rw-rw-rw-   0        0        0     7569 2024-03-09 19:50:15.000000 financepy-0.360/tests_golden/TestFinEquityBasketOption.py
+-rw-rw-rw-   0        0        0     6330 2024-03-09 19:50:46.000000 financepy-0.360/tests_golden/TestFinEquityBinomialTree.py
+-rw-rw-rw-   0        0        0     5424 2024-03-09 19:51:33.000000 financepy-0.360/tests_golden/TestFinEquityChooserOption.py
+-rw-rw-rw-   0        0        0     1968 2024-03-09 19:52:17.000000 financepy-0.360/tests_golden/TestFinEquityCliquetOption.py
+-rw-rw-rw-   0        0        0     5937 2024-03-09 19:53:00.000000 financepy-0.360/tests_golden/TestFinEquityCompoundOption.py
+-rw-rw-rw-   0        0        0     5004 2023-12-02 18:47:30.000000 financepy-0.360/tests_golden/TestFinEquityDigitalOption.py
+-rw-rw-rw-   0        0        0     2094 2023-12-10 18:13:31.000000 financepy-0.360/tests_golden/TestFinEquityForward.py
+-rw-rw-rw-   0        0        0    16245 2024-03-12 08:15:15.000000 financepy-0.360/tests_golden/TestFinEquityLookbackOption.py
+-rw-rw-rw-   0        0        0     6126 2024-02-22 16:53:48.000000 financepy-0.360/tests_golden/TestFinEquityOneTouchOption.py
+-rw-rw-rw-   0        0        0    17811 2024-03-09 19:59:32.000000 financepy-0.360/tests_golden/TestFinEquityRainbowOption.py
+-rw-rw-rw-   0        0        0     7564 2023-12-02 18:47:21.000000 financepy-0.360/tests_golden/TestFinEquitySwap.py
+-rw-rw-rw-   0        0        0    10636 2023-12-04 10:23:29.000000 financepy-0.360/tests_golden/TestFinEquityVanillaOption.py
+-rw-rw-rw-   0        0        0     2300 2023-12-02 18:47:16.000000 financepy-0.360/tests_golden/TestFinEquityVarianceSwap.py
+-rw-rw-rw-   0        0        0     3968 2024-05-01 08:42:00.000000 financepy-0.360/tests_golden/TestFinEquityVolSurface.py
+-rw-rw-rw-   0        0        0     4709 2024-02-22 15:19:06.000000 financepy-0.360/tests_golden/TestFinFXAmericanOption.py
+-rw-rw-rw-   0        0        0     6389 2024-03-10 15:48:55.000000 financepy-0.360/tests_golden/TestFinFXBarrierOption.py
+-rw-rw-rw-   0        0        0     2598 2024-03-11 18:27:23.000000 financepy-0.360/tests_golden/TestFinFXDigitalOption.py
+-rw-rw-rw-   0        0        0     1849 2024-03-11 19:56:31.000000 financepy-0.360/tests_golden/TestFinFXDoubleDigitalOption.py
+-rw-rw-rw-   0        0        0     3069 2024-03-11 19:55:40.000000 financepy-0.360/tests_golden/TestFinFXForward.py
+-rw-rw-rw-   0        0        0    15139 2024-03-12 08:14:19.000000 financepy-0.360/tests_golden/TestFinFXLookbackOption.py
+-rw-rw-rw-   0        0        0     5942 2024-02-22 13:24:30.000000 financepy-0.360/tests_golden/TestFinFXOneTouchOption.py
+-rw-rw-rw-   0        0        0     5064 2024-02-22 15:19:07.000000 financepy-0.360/tests_golden/TestFinFXOptionSABR.py
+-rw-rw-rw-   0        0        0    17236 2024-03-11 19:56:31.000000 financepy-0.360/tests_golden/TestFinFXVanillaOption.py
+-rw-rw-rw-   0        0        0     9698 2024-03-11 19:57:56.000000 financepy-0.360/tests_golden/TestFinFXVolSurface.py
+-rw-rw-rw-   0        0        0    17815 2024-05-01 08:42:09.000000 financepy-0.360/tests_golden/TestFinFXVolSurfacePlus.py
+-rw-rw-rw-   0        0        0    27988 2024-04-30 15:47:40.000000 financepy-0.360/tests_golden/TestFinIborBermudanSwaption.py
+-rw-rw-rw-   0        0        0    13799 2024-03-10 18:48:45.000000 financepy-0.360/tests_golden/TestFinIborCapFloor.py
+-rw-rw-rw-   0        0        0     1903 2024-03-11 17:45:14.000000 financepy-0.360/tests_golden/TestFinIborCapVolCurve.py
+-rw-rw-rw-   0        0        0    24424 2024-04-30 16:37:52.000000 financepy-0.360/tests_golden/TestFinIborDualCurve.py
+-rw-rw-rw-   0        0        0     1049 2023-12-02 21:00:37.000000 financepy-0.360/tests_golden/TestFinIborFuture.py
+-rw-rw-rw-   0        0        0     9275 2024-04-30 15:49:56.000000 financepy-0.360/tests_golden/TestFinIborLMMProducts.py
+-rw-rw-rw-   0        0        0    26438 2024-04-30 16:38:34.000000 financepy-0.360/tests_golden/TestFinIborSingleCurve.py
+-rw-rw-rw-   0        0        0    13397 2024-04-30 15:47:45.000000 financepy-0.360/tests_golden/TestFinIborSwap.py
+-rw-rw-rw-   0        0        0    26422 2024-04-30 15:47:50.000000 financepy-0.360/tests_golden/TestFinIborSwaption.py
+-rw-rw-rw-   0        0        0    14925 2024-03-11 20:36:00.000000 financepy-0.360/tests_golden/TestFinInflationBond.py
+-rw-rw-rw-   0        0        0     1429 2024-03-09 20:00:48.000000 financepy-0.360/tests_golden/TestFinInflationIndexCurve.py
+-rw-rw-rw-   0        0        0     2275 2023-12-02 16:04:26.000000 financepy-0.360/tests_golden/TestFinInterpolate.py
+-rw-rw-rw-   0        0        0     2205 2024-03-09 19:55:14.000000 financepy-0.360/tests_golden/TestFinInterpolatedForwards.py
+-rw-rw-rw-   0        0        0     4310 2024-03-09 19:55:01.000000 financepy-0.360/tests_golden/TestFinLossDbnBuilder.py
+-rw-rw-rw-   0        0        0     2868 2024-03-09 19:54:48.000000 financepy-0.360/tests_golden/TestFinMath.py
+-rw-rw-rw-   0        0        0     1892 2024-03-09 19:54:35.000000 financepy-0.360/tests_golden/TestFinMathAccruedInterp.py
+-rw-rw-rw-   0        0        0     3687 2024-03-09 19:54:10.000000 financepy-0.360/tests_golden/TestFinModelBlack.py
+-rw-rw-rw-   0        0        0     4886 2024-02-22 16:53:55.000000 financepy-0.360/tests_golden/TestFinModelBlackScholes.py
+-rw-rw-rw-   0        0        0     2588 2024-03-09 19:54:24.000000 financepy-0.360/tests_golden/TestFinModelBlack_SABR_HW.py
+-rw-rw-rw-   0        0        0     2475 2024-02-21 21:48:12.000000 financepy-0.360/tests_golden/TestFinModelCIR.py
+-rw-rw-rw-   0        0        0     6591 2024-03-10 18:50:15.000000 financepy-0.360/tests_golden/TestFinModelHeston.py
+-rw-rw-rw-   0        0        0     3662 2024-02-21 18:47:31.000000 financepy-0.360/tests_golden/TestFinModelMerton.py
+-rw-rw-rw-   0        0        0     9947 2024-04-30 15:50:10.000000 financepy-0.360/tests_golden/TestFinModelRatesBDT.py
+-rw-rw-rw-   0        0        0     5138 2024-03-11 18:10:58.000000 financepy-0.360/tests_golden/TestFinModelRatesBK.py
+-rw-rw-rw-   0        0        0    11338 2024-04-30 16:23:47.000000 financepy-0.360/tests_golden/TestFinModelRatesHW.py
+-rw-rw-rw-   0        0        0    17751 2024-04-30 15:47:56.000000 financepy-0.360/tests_golden/TestFinModelRatesLMM.py
+-rw-rw-rw-   0        0        0     3199 2023-12-02 16:04:26.000000 financepy-0.360/tests_golden/TestFinModelSABR.py
+-rw-rw-rw-   0        0        0     2704 2023-12-02 16:04:26.000000 financepy-0.360/tests_golden/TestFinModelShiftedSABR.py
+-rw-rw-rw-   0        0        0    12164 2023-12-04 10:23:34.000000 financepy-0.360/tests_golden/TestFinNumbaNumpySpeed.py
+-rw-rw-rw-   0        0        0     2288 2023-12-02 18:51:28.000000 financepy-0.360/tests_golden/TestFinOIS.py
+-rw-rw-rw-   0        0        0    19435 2024-04-30 16:39:27.000000 financepy-0.360/tests_golden/TestFinOISCurve.py
+-rw-rw-rw-   0        0        0     3794 2024-03-11 19:57:56.000000 financepy-0.360/tests_golden/TestFinOptionImpliedDbn.py
+-rw-rw-rw-   0        0        0     1024 2023-12-02 16:04:26.000000 financepy-0.360/tests_golden/TestFinPieceCurve.py
+-rw-rw-rw-   0        0        0     6242 2024-02-22 13:30:27.000000 financepy-0.360/tests_golden/TestFinProcessSimulator.py
+-rw-rw-rw-   0        0        0    16831 2024-05-01 09:36:38.000000 financepy-0.360/tests_golden/TestFinSchedule.py
+-rw-rw-rw-   0        0        0     1674 2023-12-02 16:04:26.000000 financepy-0.360/tests_golden/TestFinSobol.py
+-rw-rw-rw-   0        0        0     2458 2023-12-02 16:04:26.000000 financepy-0.360/tests_golden/TestFinStatistics.py
+-rw-rw-rw-   0        0        0     8687 2023-12-02 18:50:01.000000 financepy-0.360/tests_golden/TestFinSwapLegs.py
+-rw-rw-rw-   0        0        0     4175 2024-03-09 11:26:15.000000 financepy-0.360/tests_golden/TestFinSwaptionVolSurface.py
+-rw-rw-rw-   0        0        0     1345 2024-03-09 11:57:32.000000 financepy-0.360/tests_golden/TestFinVasicekRateModel.py
+-rw-rw-rw-   0        0        0     1344 2023-12-02 18:50:09.000000 financepy-0.360/tests_golden/TestFinVolatilityCurve.py
+-rw-rw-rw-   0        0        0       56 2023-11-16 17:12:54.000000 financepy-0.360/tests_golden/__init__.py
+-rw-rw-rw-   0        0        0     2347 2024-03-10 18:33:18.000000 financepy-0.360/tests_golden/run_all_tests.py
```

### Comparing `financepy-0.350/LICENSE` & `financepy-0.360/LICENSE`

 * *Files identical despite different names*

### Comparing `financepy-0.350/PKG-INFO` & `financepy-0.360/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,31 @@
 Metadata-Version: 2.1
 Name: financepy
-Version: 0.350
+Version: 0.360
 Summary: A Finance Securities Valuation Library
 Home-page: https://github.com/domokane/FinancePy
 Author: Dominic O'Kane
 Author-email: dominic.okane@edhec.edu
 Keywords: FINANCE,OPTIONS,BONDS,VALUATION,DERIVATIVES
 Classifier: Development Status :: 2 - Pre-Alpha
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
-# Latest News and Versions
+## I'D LIKE YOUR OPINION  
+### I AM CONSIDERING SPENDING TIME THIS YEAR IMPROVING THE LIBRARY. LET ME HAVE ANY COMMENTS, REQUESTS OR ISSUES YOU MAY HAVE. JUST ENTER THEM IN THE DISCUSSION SECTION HERE OR EMAIL ME.
+
+# Latest News and Version
+19 February 2024 version 0.350 released
+- A lot of various pep8 fixes - should all be nearly done soon
+- Fixed a bug in gauss_approx_tranche_loss
+
 9 December 2023  version 0.34 released
 - A lot of various pep8 fixes - should all be nearly done soon
 - Some minor bug fixes
 
 10 November 2023  version 0.33 released
 - Tidied up key rate code
 - Fixed unit tests for pytest
```

### Comparing `financepy-0.350/README.md` & `financepy-0.360/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,15 @@
-# Latest News and Versions
+## I'D LIKE YOUR OPINION  
+### I AM CONSIDERING SPENDING TIME THIS YEAR IMPROVING THE LIBRARY. LET ME HAVE ANY COMMENTS, REQUESTS OR ISSUES YOU MAY HAVE. JUST ENTER THEM IN THE DISCUSSION SECTION HERE OR EMAIL ME.
+
+# Latest News and Version
+19 February 2024 version 0.350 released
+- A lot of various pep8 fixes - should all be nearly done soon
+- Fixed a bug in gauss_approx_tranche_loss
+
 9 December 2023  version 0.34 released
 - A lot of various pep8 fixes - should all be nearly done soon
 - Some minor bug fixes
 
 10 November 2023  version 0.33 released
 - Tidied up key rate code
 - Fixed unit tests for pytest
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve.py` & `financepy-0.360/financepy/market/curves/discount_curve.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-##############################################################################
+###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
-##############################################################################
+###############################################################################
 
 
 import numpy as np
 
 from .interpolator import Interpolator, InterpTypes, interpolate
 
 from ...utils.date import Date
 from ...utils.error import FinError
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.frequency import annual_frequency, FrequencyTypes
 from ...utils.day_count import DayCount, DayCountTypes
 from ...utils.math import test_monotonicity
 from ...utils.schedule import Schedule
 from ...utils.helpers import check_argument_types
 from ...utils.helpers import times_from_dates
 from ...utils.helpers import label_to_string
@@ -27,85 +27,81 @@
     a vector of times and discount factors and an interpolation scheme for
     interpolating between these fixed points. '''
 
     ###########################################################################
 
     def __init__(self,
                  value_dt: Date,
-                 df_dts: list,
+                 df_dates: list,
                  df_values: np.ndarray,
                  interp_type: InterpTypes = InterpTypes.FLAT_FWD_RATES):
         """ Create the discount curve from a vector of times and discount
         factors with an anchor date and specify an interpolation scheme. As we
         are explicitly linking dates and discount factors, we do not need to
         specify any compounding convention or day count calculation since
         discount factors are pure prices. We do however need to specify a
         convention for interpolating the discount factors in time."""
         check_argument_types(self.__init__, locals())
 
         # Validate curve
-        if len(df_dts) < 1:
+        if len(df_dates) < 1:
             raise FinError("Times has zero length")
 
-        if len(df_dts) != len(df_values):
+        if len(df_dates) != len(df_values):
             raise FinError("Times and Values are not the same")
 
         self._times = [0.0]
         self._dfs = [1.0]
-        self._df_dts = df_dts
+        self._df_dates = df_dates
 
-        num_points = len(df_dts)
+        num_points = len(df_dates)
 
         start_index = 0
         if num_points > 0:
-            if df_dts[0] == value_dt:
+            if df_dates[0] == value_dt:
                 self._dfs[0] = df_values[0]
                 start_index = 1
 
         for i in range(start_index, num_points):
-            t = (df_dts[i] - value_dt) / gDaysInYear
+            t = (df_dates[i] - value_dt) / gDaysInYear
             self._times.append(t)
             self._dfs.append(df_values[i])
 
         self._times = np.array(self._times)
 
         if test_monotonicity(self._times) is False:
             print(self._times)
             raise FinError("Times are not sorted in increasing order")
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
+        self.freq_type = FrequencyTypes.CONTINUOUS
+        # This needs to be thought about - I just assign an arbitrary value
+        self.dc_type = DayCountTypes.ACT_ACT_ISDA
+
         self._dfs = np.array(self._dfs)
         self._interp_type = interp_type
-        self._freq_type = FrequencyTypes.CONTINUOUS
-        # This needs to be thought about - I just assign an arbitrary value
-        self._dc_type = DayCountTypes.ACT_ACT_ISDA
         self._interpolator = Interpolator(self._interp_type)
         self._interpolator.fit(self._times, self._dfs)
 
     ###########################################################################
 
-    def value_dt(self):
-        return self._value_dt
-
-    ###########################################################################
-
     def _zero_to_df(self,
-                    value_dt: Date,  # TODO: why is value_date not used ?
+                    value_dt: Date,  # TODO: why is value_dt not used ?
                     rates: (float, np.ndarray),
                     times: (float, np.ndarray),
                     freq_type: FrequencyTypes,
                     dc_type: DayCountTypes):
         """ Convert a zero with a specified compounding frequency and day count
         convention to a discount factor for a single maturity date or a list of
         dates. The day count is used to calculate the elapsed year fraction."""
 
         if isinstance(times, float):
             times = np.array([times])
 
-        t = np.maximum(times, gSmall)
+        t = np.maximum(times, g_small)
 
         f = annual_frequency(freq_type)
 
         if freq_type == FrequencyTypes.CONTINUOUS:
             df = np.exp(-rates * t)
         elif freq_type == FrequencyTypes.SIMPLE:
             df = 1.0 / (1.0 + rates * t)
@@ -143,25 +139,25 @@
             df_list = [dfs]
         else:
             df_list = dfs
 
         if len(date_list) != len(df_list):
             raise FinError("Date list and df list do not have same length")
 
-        num_dts = len(date_list)
+        num_dates = len(date_list)
         zero_rates = []
 
         times = times_from_dates(
-            date_list, self._value_dt, dc_type)
+            date_list, self.value_dt, dc_type)
 
-        for i in range(0, num_dts):
+        for i in range(0, num_dates):
 
             df = df_list[i]
 
-            t = max(times[i], gSmall)
+            t = max(times[i], g_small)
 
             if freq_type == FrequencyTypes.CONTINUOUS:
                 r = -np.log(df) / t
             elif freq_type == FrequencyTypes.SIMPLE:
                 r = (1.0 / df - 1.0) / t
             else:
                 r = (np.power(df, -1.0 / (t * f)) - 1.0) * f
@@ -221,15 +217,15 @@
         a swap that has a price of par today. This is the same as a Libor swap
         rate except that we do not do any business day adjustments. """
 
         # Note that this function does not call the IborSwap class to
         # calculate the swap rate since that will create a circular dependency.
         # I therefore recreate the actual calculation of the swap rate here.
 
-        if effective_dt < self._value_dt:
+        if effective_dt < self.value_dt:
             raise FinError("Swap starts before the curve valuation date.")
 
         if isinstance(freq_type, FrequencyTypes) is False:
             raise FinError("Invalid Frequency type.")
 
         if isinstance(freq_type, FrequencyTypes) is False:
             raise FinError("Invalid Frequency type.")
@@ -265,15 +261,15 @@
 
             for next_dt in flow_dts[1:]:
                 df = self.df(next_dt)
                 alpha = day_counter.year_frac(prev_dt, next_dt)[0]
                 pv01 += alpha * df
                 prev_dt = next_dt
 
-            if abs(pv01) < gSmall:
+            if abs(pv01) < g_small:
                 par_rate = 0.0
             else:
                 df_start = self.df(effective_dt)
                 par_rate = (df_start - df) / pv01
 
             par_rates.append(par_rate)
 
@@ -289,21 +285,21 @@
     def df(self,
            dt: (list, Date),
            day_count=DayCountTypes.ACT_ACT_ISDA):
         ''' Function to calculate a discount factor from a date or a
         vector of dates. The day count determines how dates get converted to
         years. I allow this to default to ACT_ACT_ISDA unless specified. '''
 
-        times = times_from_dates(dt, self._value_dt, day_count)
+        times = times_from_dates(dt, self.value_dt, day_count)
         dfs = self._df(times)
 
         if isinstance(dfs, float):
             return dfs
-        else:
-            return np.array(dfs)
+
+        return np.array(dfs)
 
     ###########################################################################
 
     def _df(self,
             t: (float, np.ndarray)):
         """ Hidden function to calculate a discount factor from a time or a
         vector of times. Discourage usage in favour of passing in dates. """
@@ -392,15 +388,15 @@
         values = self._dfs.copy()
 
         n = len(self._times)
         for i in range(0, n):
             t = times[i]
             values[i] = values[i] * np.exp(-bump_size * t)
 
-        disc_curve = DiscountCurve(self._value_dt,
+        disc_curve = DiscountCurve(self.value_dt,
                                    times,
                                    values,
                                    self._interp_type)
 
         return disc_curve
 
     ###########################################################################
@@ -420,17 +416,17 @@
         elif isinstance(start_dt, list):
             start_dts = start_dt
         else:
             raise FinError("Start date and end date must be same types.")
 
         day_count = DayCount(dc_type)
 
-        num_dts = len(start_dts)
+        num_dates = len(start_dts)
         fwd_rates = []
-        for i in range(0, num_dts):
+        for i in range(0, num_dates):
             dt1 = start_dts[i]
 
             if isinstance(date_or_tenor, str):
                 dt2 = dt1.add_tenor(date_or_tenor)
             elif isinstance(date_or_tenor, Date):
                 dt2 = date_or_tenor
             elif isinstance(date_or_tenor, list):
@@ -448,18 +444,18 @@
             return np.array(fwd_rates)
 
     ###########################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        num_points = len(self._df_dts)
+        num_points = len(self._df_dates)
         s += label_to_string("DATES", "DISCOUNT FACTORS")
         for i in range(0, num_points):
-            s += label_to_string("%12s" % self._df_dts[i],
+            s += label_to_string("%12s" % self._df_dates[i],
                                  "%12.8f" % self._dfs[i])
 
         return s
 
     ###########################################################################
 
     def _print(self):
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_flat.py` & `financepy-0.360/financepy/market/curves/discount_curve_flat.py`

 * *Files 5% similar despite different names*

```diff
@@ -42,77 +42,78 @@
         As the curve is flat, no interpolation scheme is required.
         """
 
 #        super().__init__()
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
-        self._flat_rate = flat_rate
-        self._freq_type = freq_type
-        self._dc_type = dc_type
+        self.value_dt = value_dt
+        self.flat_rate = flat_rate
+        self.freq_type = freq_type
+        self.dc_type = dc_type
 
         # This is used by some inherited functions, so we choose the simplest
         self._interp_type = InterpTypes.FLAT_FWD_RATES
 
         # Need to set up a grid of times and discount factors
         years = np.linspace(0.0, 10.0, 41)
-        dts = self._value_dt.add_years(years)
+        dts = self.value_dt.add_years(years)
 
         # Set up a grid of times and discount factors for functions
         self._dfs = self.df(dts)
-        self._times = times_from_dates(dts, self._value_dt, dc_type)
+        self._times = times_from_dates(dts, self.value_dt, dc_type)
 
 ###############################################################################
 
     def bump(self,
              bump_size: float):
         """ Create a new FinDiscountCurveFlat object with the entire curve
         bumped up by the bumpsize. All other parameters are preserved."""
 
-        rate_bumped = self._flat_rate + bump_size
-        disc_curve = DiscountCurveFlat(self._value_dt,
+        rate_bumped = self.flat_rate + bump_size
+        disc_curve = DiscountCurveFlat(self.value_dt,
                                        rate_bumped,
-                                       freq_type=self._freq_type,
-                                       dc_type=self._dc_type)
+                                       freq_type=self.freq_type,
+                                       dc_type=self.dc_type)
         return disc_curve
 
 ###############################################################################
 
     def df(self,
            dts: (Date, list)):
         """ Return discount factors given a single or vector of dts. The
         discount factor depends on the rate and this in turn depends on its
         compounding frequency, and it defaults to continuous compounding. It
         also depends on the day count convention. This was set in the
         construction of the curve to be ACT_ACT_ISDA. """
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dts,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
-        dfs = self._zero_to_df(self._value_dt,
-                               self._flat_rate,
+        dfs = self._zero_to_df(self.value_dt,
+                               self.flat_rate,
                                dc_times,
-                               self._freq_type,
-                               self._dc_type)
+                               self.freq_type,
+                               self.dc_type)
 
         if isinstance(dts, Date):
             return dfs[0]
 
         return np.array(dfs)
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("FLAT RATE", (self._flat_rate))
-        s += label_to_string("FREQUENCY", (self._freq_type))
-        s += label_to_string("DAY COUNT", (self._dc_type))
+        s += label_to_string("VALUE DATE", (self.value_dt))
+        s += label_to_string("FLAT RATE", (self.flat_rate))
+        s += label_to_string("FREQUENCY", (self.freq_type))
+        s += label_to_string("DAY COUNT", (self.dc_type))
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_ns.py` & `financepy-0.360/financepy/market/curves/discount_curve_ns.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
 
 from ...utils.date import Date
 from ...utils.frequency import FrequencyTypes
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 from ...utils.error import FinError
 from ...market.curves.discount_curve import DiscountCurve
 from ...utils.helpers import check_argument_types
 from ...utils.helpers import label_to_string
 from ...utils.day_count import DayCountTypes
 from ...utils.helpers import times_from_dates
 
@@ -39,21 +39,21 @@
         defaults to continuous but which can be overridden. """
 
         check_argument_types(self.__init__, locals())
 
         if tau <= 0:
             raise FinError("Tau must be positive")
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
         self._beta_0 = beta_0
         self._beta_1 = beta_1
         self._beta_2 = beta_2
         self._tau = tau
-        self._freq_type = freq_type
-        self._dc_type = dc_type
+        self.freq_type = freq_type
+        self.dc_type = dc_type
 
     ###########################################################################
 
     def zero_rate(self,
                   dates: (list, Date),
                   freq_type: FrequencyTypes = FrequencyTypes.CONTINUOUS,
                   dc_type: DayCountTypes = DayCountTypes.ACT_360):
@@ -69,26 +69,26 @@
             raise FinError("Invalid Frequency type.")
 
         if isinstance(dc_type, DayCountTypes) is False:
             raise FinError("Invalid Day Count type.")
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         # We now get the discount factors using these times
         zero_rates = self._zero_rate(dc_times)
 
         # Now get the discount factors using curve conventions
-        dfs = self._zero_to_df(self._value_dt,
+        dfs = self._zero_to_df(self.value_dt,
                                zero_rates,
                                dc_times,
-                               self._freq_type,
-                               self._dc_type)
+                               self.freq_type,
+                               self.dc_type)
 
         # Convert these to zero rates in the required frequency and day count
         zero_rates = self._df_to_zero(dfs,
                                       dates,
                                       freq_type,
                                       dc_type)
 
@@ -97,15 +97,15 @@
     ###########################################################################
 
     def _zero_rate(self,
                    times: (float, np.ndarray)):
         """ Zero rate for Nelson-Siegel curve parametrisation. This means that
         the t vector must use the curve day count."""
 
-        t = np.maximum(times, gSmall)
+        t = np.maximum(times, g_small)
 
         theta = t / self._tau
         e = np.exp(-theta)
         zero_rate = self._beta_0
         zero_rate += self._beta_1 * (1.0 - e) / theta
         zero_rate += self._beta_2 * ((1.0 - e) / theta - e)
         return zero_rate
@@ -118,24 +118,24 @@
         discount factor depends on the rate and this in turn depends on its
         compounding frequency and it defaults to continuous compounding. It
         also depends on the day count convention. This was set in the
         construction of the curve to be ACT_ACT_ISDA. """
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         zero_rates = self._zero_rate(dc_times)
 
-        df = self._zero_to_df(self._value_dt,
+        df = self._zero_to_df(self.value_dt,
                               zero_rates,
                               dc_times,
-                              self._freq_type,
-                              self._dc_type)
+                              self.freq_type,
+                              self.dc_type)
 
         if isinstance(dates, Date):
             return df[0]
         else:
             return df
 
     ###########################################################################
@@ -144,16 +144,16 @@
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
         s += label_to_string("PARAMETER", "VALUE")
         s += label_to_string("beta_0", self._beta_0)
         s += label_to_string("beta_1", self._beta_1)
         s += label_to_string("beta_2", self._beta_2)
         s += label_to_string("TAU", self._tau)
-        s += label_to_string("FREQUENCY", (self._freq_type))
-        s += label_to_string("DAY_COUNT", (self._dc_type))
+        s += label_to_string("FREQUENCY", (self.freq_type))
+        s += label_to_string("DAY_COUNT", (self.dc_type))
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_nss.py` & `financepy-0.360/financepy/market/curves/discount_curve_nss.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
 
 from ...utils.date import Date
 from ...utils.frequency import FrequencyTypes
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 from ...utils.helpers import label_to_string
 from ...utils.error import FinError
 from ...market.curves.discount_curve import DiscountCurve
 from ...utils.helpers import check_argument_types
 from ...utils.day_count import DayCountTypes
 from ...utils.helpers import times_from_dates
 
@@ -44,23 +44,23 @@
 
         if tau_1 <= 0:
             raise FinError("Tau1 must be positive")
 
         if tau_2 <= 0:
             raise FinError("Tau2 must be positive")
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
         self._beta_0 = beta_0
         self._beta_1 = beta_1
         self._beta_2 = beta_2
         self._beta_3 = beta_3
         self._tau_1 = tau_1
         self._tau_2 = tau_2
-        self._freq_type = freq_type
-        self._dc_type = day_count_type
+        self.freq_type = freq_type
+        self.dc_type = day_count_type
 
     ###########################################################################
 
     def zero_rate(self,
                   dates: (list, Date),
                   freq_type: FrequencyTypes = FrequencyTypes.CONTINUOUS,
                   dc_type: DayCountTypes = DayCountTypes.ACT_360):
@@ -76,26 +76,26 @@
             raise FinError("Invalid Frequency type.")
 
         if isinstance(dc_type, DayCountTypes) is False:
             raise FinError("Invalid Day Count type.")
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         # We now get the discount factors using these times
         zero_rates = self._zero_rate(dc_times)
 
         # Now get the discount factors using curve conventions
-        dfs = self._zero_to_df(self._value_dt,
+        dfs = self._zero_to_df(self.value_dt,
                                zero_rates,
                                dc_times,
-                               self._freq_type,
-                               self._dc_type)
+                               self.freq_type,
+                               self.dc_type)
 
         # Convert these to zero rates in the required frequency and day count
         zero_rates = self._df_to_zero(dfs,
                                       dates,
                                       freq_type,
                                       dc_type)
 
@@ -108,15 +108,15 @@
 
     def _zero_rate(self,
                    times: (float, np.ndarray)):
         """ Calculation of zero rates given a single time or a numpy vector of
         times. This function can return a single zero rate or a vector of zero
         rates. The compounding frequency must be provided. """
 
-        t = np.maximum(times, gSmall)
+        t = np.maximum(times, g_small)
 
         theta_1 = t / self._tau_1
         theta_2 = t / self._tau_2
         e_1 = np.exp(-theta_1)
         e_2 = np.exp(-theta_2)
         zero_rate = self._beta_0
         zero_rate += self._beta_1 * (1.0 - e_1) / theta_1
@@ -132,24 +132,24 @@
         discount factor depends on the rate and this in turn depends on its
         compounding frequency and it defaults to continuous compounding. It
         also depends on the day count convention. This was set in the
         construction of the curve to be ACT_ACT_ISDA. """
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         zero_rates = self._zero_rate(dc_times)
 
-        df = self._zero_to_df(self._value_dt,
+        df = self._zero_to_df(self.value_dt,
                               zero_rates,
                               dc_times,
-                              self._freq_type,
-                              self._dc_type)
+                              self.freq_type,
+                              self.dc_type)
 
         if isinstance(dates, Date):
             return df[0]
         else:
             return df
 
     ###########################################################################
@@ -160,16 +160,16 @@
         s += label_to_string("PARAMETER", "VALUE")
         s += label_to_string("BETA0", self._beta_0)
         s += label_to_string("BETA1", self._beta_1)
         s += label_to_string("BETA2", self._beta_2)
         s += label_to_string("BETA3", self._beta_3)
         s += label_to_string("TAU1", self._tau_1)
         s += label_to_string("TAU2", self._tau_2)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY_COUNT", self._dc_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY_COUNT", self.dc_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_poly.py` & `financepy-0.360/financepy/market/curves/discount_curve_poly.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
 
 from ...utils.date import Date
 from ...utils.error import FinError
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 from ...utils.helpers import label_to_string
 from ...market.curves.discount_curve import DiscountCurve
 from ...utils.helpers import check_argument_types
 from ...utils.frequency import FrequencyTypes
 from ...utils.day_count import DayCountTypes
 from ...utils.helpers import times_from_dates
 
@@ -32,19 +32,19 @@
                  dc_type: DayCountTypes = DayCountTypes.ACT_ACT_ISDA):
         """ Create zero rate curve parametrised using a cubic curve from
         coefficients and specifying a compounding frequency type and day count
         convention. """
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
         self._coefficients = coefficients
         self._power = len(coefficients) - 1
-        self._freq_type = freq_type
-        self._dc_type = dc_type
+        self.freq_type = freq_type
+        self.dc_type = dc_type
 
     ###########################################################################
 
     def zero_rate(self,
                   dts: (list, Date),
                   freq_type: FrequencyTypes = FrequencyTypes.CONTINUOUS,
                   dc_type: DayCountTypes = DayCountTypes.ACT_360):
@@ -60,40 +60,40 @@
             raise FinError("Invalid Frequency type.")
 
         if isinstance(dc_type, DayCountTypes) is False:
             raise FinError("Invalid Day Count type.")
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(
-            dts, self._value_dt, self._dc_type)
+            dts, self.value_dt, self.dc_type)
 
         # We now get the discount factors using these times
         zero_rates = self._zero_rate(dc_times)
 
         # Now get the discount factors using curve conventions
-        dfs = self._zero_to_df(self._value_dt,
+        dfs = self._zero_to_df(self.value_dt,
                                zero_rates,
                                dc_times,
-                               self._freq_type,
-                               self._dc_type)
+                               self.freq_type,
+                               self.dc_type)
 
         # Convert these to zero rates in the required frequency and day count
         zero_rates = self._df_to_zero(dfs, dts, freq_type, dc_type)
         return zero_rates
 
     ###########################################################################
 
     def _zero_rate(self,
                    times: (float, np.ndarray)):
         """ Calculate the zero rate to maturity date but with times as inputs.
         This function is used internally and should be discouraged for external
         use. The compounding frequency defaults to that specified in the
         constructor of the curve object. Which may be annual to continuous. """
 
-        t = np.maximum(times, gSmall)
+        t = np.maximum(times, g_small)
 
         zero_rate = 0.0
         for n in range(0, len(self._coefficients)):
             zero_rate += self._coefficients[n] * np.power(t, n)
 
         return zero_rate
 
@@ -104,39 +104,39 @@
         """ Calculate the fwd rate to maturity date but with times as inputs.
         This function is used internally and should be discouraged for external
         use. The compounding frequency defaults to that specified in the
         constructor of the curve object. """
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         # We now get the discount factors using these times
         zero_rates = self._zero_rate(dc_times)
 
         # Now get the discount factors using curve conventions
-        dfs = self._zero_to_df(self._value_dt,
+        dfs = self._zero_to_df(self.value_dt,
                                zero_rates,
                                dc_times,
-                               self._freq_type,
-                               self._dc_type)
+                               self.freq_type,
+                               self.dc_type)
 
         return dfs
 
     ###########################################################################
 
     def __repr__(self):
         """ Display internal parameters of curve. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
         s += label_to_string("POWER", "COEFFICIENT")
         for i in range(0, len(self._coefficients)):
             s += label_to_string(str(i), self._coefficients[i])
-        s += label_to_string("FREQUENCY", self._freq_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
 
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_pwf.py` & `financepy-0.360/financepy/market/curves/discount_curve_pwf.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
 
 from ...utils.date import Date
 from ...utils.error import FinError
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 from ...utils.math import test_monotonicity
 from ...utils.frequency import FrequencyTypes
 from ...utils.helpers import label_to_string
 from ...utils.helpers import check_argument_types
 from ...utils.day_count import DayCountTypes
 from ...utils.helpers import times_from_dates
 from ...market.curves.discount_curve import DiscountCurve
@@ -31,59 +31,59 @@
                  freq_type: FrequencyTypes = FrequencyTypes.CONTINUOUS,
                  day_count_type: DayCountTypes = DayCountTypes.ACT_ACT_ISDA):
         """ Creates a discount curve using a vector of times and zero rates
         that assumes that the zero rates are piecewise flat. """
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
 
         if len(zero_dts) != len(zero_rates):
             raise FinError("Dates and rates vectors must have same length")
 
         if len(zero_dts) == 0:
             raise FinError("Dates vector must have length > 0")
 
         self._zero_dts = zero_dts
         self._zero_rates = np.array(zero_rates)
-        self._freq_type = freq_type
-        self._dc_type = day_count_type
+        self.freq_type = freq_type
+        self.dc_type = day_count_type
 
         dc_times = times_from_dates(zero_dts,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
-        self._times = np.array(dc_times)
+        self.times = np.array(dc_times)
 
-        if test_monotonicity(self._times) is False:
+        if test_monotonicity(self.times) is False:
             raise FinError("Times are not sorted in increasing order")
 
     ###########################################################################
 
     def _zero_rate(self,
                    times: (float, np.ndarray, list)):
         """ The piecewise flat zero rate is selected and returned. """
 
         if isinstance(times, float):
             times = np.array([times])
 
         if np.any(times < 0.0):
             raise FinError("All times must be positive")
 
-        times = np.maximum(times, gSmall)
+        times = np.maximum(times, g_small)
 
         zero_rates = []
 
         for t in times:
             l_index = 0
             found = 0
 
-            num_times = len(self._times)
+            num_times = len(self.times)
             for i in range(1, num_times):
-                if self._times[i] > t:
+                if self.times[i] > t:
                     l_index = i - 1
                     found = 1
                     break
 
             r0 = self._zero_rates[l_index]
 
             if found == 1:
@@ -126,36 +126,36 @@
         discount factor depends on the rate and this in turn depends on its
         compounding frequency and it defaults to continuous compounding. It
         also depends on the day count convention. This was set in the
         construction of the curve to be ACT_ACT_ISDA. """
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         zero_rates = self._zero_rate(dc_times)
 
-        df = self._zero_to_df(self._value_dt,
+        df = self._zero_to_df(self.value_dt,
                               zero_rates,
                               dc_times,
-                              self._freq_type,
-                              self._dc_type)
+                              self.freq_type,
+                              self.dc_type)
 
         return df
 
     ###########################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
         s += label_to_string("DATE", "ZERO RATE")
         for i in range(0, len(self._zero_dts)):
             s += label_to_string(self._zero_dts[i], self._zero_rates[i])
-        s += label_to_string("FREQUENCY", (self._freq_type))
+        s += label_to_string("FREQUENCY", (self.freq_type))
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_pwl.py` & `financepy-0.360/financepy/market/curves/discount_curve_pwl.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,34 +30,34 @@
                  zero_rates: (list, np.ndarray),
                  freq_type: FrequencyTypes = FrequencyTypes.CONTINUOUS,
                  dc_type: DayCountTypes = DayCountTypes.ACT_ACT_ISDA):
         """ Curve is defined by a vector of increasing times and zero rates."""
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
 
         if len(zero_dts) != len(zero_rates):
             raise FinError("Dates and rates vectors must have same length")
 
         if len(zero_dts) == 0:
             raise FinError("Dates vector must have length > 0")
 
         self._zero_rates = np.array(zero_rates)
         self._zero_dts = zero_dts
-        self._freq_type = freq_type
-        self._dc_type = dc_type
+        self.freq_type = freq_type
+        self.dc_type = dc_type
 
         dc_times = times_from_dates(zero_dts,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
-        self._times = np.array(dc_times)
+        self.times = np.array(dc_times)
 
-        if test_monotonicity(self._times) is False:
+        if test_monotonicity(self.times) is False:
             raise FinError("Times are not sorted in increasing order")
 
     ###########################################################################
 
     def _zero_rate(self,
                    times: (list, np.ndarray)):
         """ Calculate the piecewise linear zero rate. This is taken from the
@@ -74,24 +74,24 @@
 
         zero_rates = []
 
         for t in times:
             l_index = 0
             found = 0
 
-            num_times = len(self._times)
+            num_times = len(self.times)
             for i in range(1, num_times):
-                if self._times[i] > t:
+                if self.times[i] > t:
                     l_index = i - 1
                     found = 1
                     break
 
-            t0 = self._times[l_index]
+            t0 = self.times[l_index]
             r0 = self._zero_rates[l_index]
-            t1 = self._times[l_index + 1]
+            t1 = self.times[l_index + 1]
             r1 = self._zero_rates[l_index + 1]
 
             if found == 1:
                 zero_rate = ((t1 - t) * r0 + (t - t0) * r1) / (t1 - t0)
             else:
                 zero_rate = self._zero_rates[-1]
 
@@ -107,47 +107,47 @@
         discount factor depends on the rate and this in turn depends on its
         compounding frequency and it defaults to continuous compounding. It
         also depends on the day count convention. This was set in the
         construction of the curve to be ACT_ACT_ISDA. """
 
         # Get day count times to use with curve day count convention
         dc_times = times_from_dates(dates,
-                                    self._value_dt,
-                                    self._dc_type)
+                                    self.value_dt,
+                                    self.dc_type)
 
         zero_rates = self._zero_rate(dc_times)
 
-        df = self._zero_to_df(self._value_dt,
+        df = self._zero_to_df(self.value_dt,
                               zero_rates,
                               dc_times,
-                              self._freq_type,
-                              self._dc_type)
+                              self.freq_type,
+                              self.dc_type)
 
         return df
 
     ###########################################################################
 
     # def _df(self,
     #         t: (float, np.ndarray)):
     #     """ Returns the discount factor at time t taking into account the
     #     piecewise flat zero rate curve and the compunding frequency. """
 
-    #     r = self._zero_rate(t, self._freq_type)
-    #     df = zero_to_df(r, t, self._freq_type)
+    #     r = self._zero_rate(t, self.freq_type)
+    #     df = zero_to_df(r, t, self.freq_type)
     #     return df
 
     ###########################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
         s += label_to_string("DATE", "ZERO RATE")
         for i in range(0, len(self._zero_dts)):
             s += label_to_string(self._zero_dts[i], self._zero_rates[i])
-        s += label_to_string("FREQUENCY", self._freq_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/market/curves/discount_curve_zeros.py` & `financepy-0.360/financepy/market/curves/discount_curve_zeros.py`

 * *Files 6% similar despite different names*

```diff
@@ -58,65 +58,65 @@
         if freq_type not in FrequencyTypes:
             raise FinError("Unknown Frequency type " + str(freq_type))
 
         if dc_type not in DayCountTypes:
             raise FinError("Unknown Cap Floor DayCountRule type " +
                            str(dc_type))
 
-        self._value_dt = value_dt
-        self._freq_type = freq_type
-        self._dc_type = dc_type
-        self._interp_type = interp_type
+        self.value_dt = value_dt
+        self.freq_type = freq_type
+        self.dc_type = dc_type
 
         self._zero_rates = np.array(zero_rates)
         self._zero_dts = zero_dts
 
-        self._times = times_from_dates(
-            zero_dts, value_dt, dc_type)
+        self._times = times_from_dates(zero_dts, value_dt, dc_type)
 
         if test_monotonicity(self._times) is False:
             raise FinError("Times or dates are not sorted in increasing order")
 
-        dfs = self._zero_to_df(self._value_dt,
+        dfs = self._zero_to_df(self.value_dt,
                                self._zero_rates,
                                self._times,
-                               self._freq_type,
-                               self._dc_type)
+                               self.freq_type,
+                               self.dc_type)
 
         self._dfs = np.array(dfs)
+
+        self._interp_type = interp_type
         self._interpolator = Interpolator(self._interp_type)
         self._interpolator.fit(self._times, self._dfs)
 
 # ###############################################################################
 
 #     def bump(self, bump_size):
 #         """ Calculate the continuous forward rate at the forward date. """
 
-#         times = self._times.copy()
+#         times = self.times.copy()
 #         discount_factors = self._discount_factors.copy()
 
-#         n = len(self._times)
+#         n = len(self.times)
 #         for i in range(0, n):
 #             t = times[i]
 #             discount_factors[i] = discount_factors[i] * np.exp(-bump_size*t)
 
-#         disc_curve = FinDiscountCurve(self._value_dt, times,
+#         disc_curve = FinDiscountCurve(self.value_dt, times,
 #                                      discount_factors,
 #                                      self._interp_type)
 
 #         return disc_curve
 
 ###############################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUATION DATE", self._value_dt)
-        s += label_to_string("FREQUENCY TYPE", (self._freq_type))
-        s += label_to_string("DAY COUNT TYPE", (self._dc_type))
+        s += label_to_string("VALUATION DATE", self.value_dt)
+        s += label_to_string("FREQUENCY TYPE", (self.freq_type))
+        s += label_to_string("DAY COUNT TYPE", (self.dc_type))
         s += label_to_string("INTERP TYPE", (self._interp_type))
 
         s += label_to_string("DATES", "ZERO RATES")
         num_points = len(self._times)
         for i in range(0, num_points):
             s += label_to_string("%12s" % self._zero_dts[i],
                                  "%10.7f" % self._zero_rates[i])
```

### Comparing `financepy-0.350/financepy/market/curves/interpolator.py` & `financepy-0.360/financepy/market/curves/interpolator.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,21 +4,20 @@
 
 from enum import Enum
 from numba import njit, float64, int64
 import numpy as np
 from scipy.interpolate import PchipInterpolator
 from scipy.interpolate import CubicSpline
 from ...utils.error import FinError
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 
 ###############################################################################
 
 
 class InterpTypes(Enum):
-    ''' Types of interpolation '''
     FLAT_FWD_RATES = 1
     LINEAR_FWD_RATES = 2
     LINEAR_ZERO_RATES = 4
     FINCUBIC_ZERO_RATES = 7
     NATCUBIC_LOG_DISCOUNT = 8
     NATCUBIC_ZERO_RATES = 9
     PCHIP_ZERO_RATES = 10
@@ -196,89 +195,89 @@
 class Interpolator():
 
     def __init__(self,
                  interpolator_type: InterpTypes):
 
         self._interp_type = interpolator_type
         self._interp_fn = None
-        self._times = None
+        self.times = None
         self._dfs = None
         self._refit_curve = False
 
     ###########################################################################
 
     def fit(self,
             times: np.ndarray,
             dfs: np.ndarray):
 
-        self._times = times
+        self.times = times
         self._dfs = dfs
 
         if len(times) == 1:
             return
 
         if self._interp_type == InterpTypes.PCHIP_LOG_DISCOUNT:
 
             log_dfs = np.log(self._dfs)
-            self._interp_fn = PchipInterpolator(self._times, log_dfs)
+            self._interp_fn = PchipInterpolator(self.times, log_dfs)
 
         elif self._interp_type == InterpTypes.PCHIP_ZERO_RATES:
 
-            g_small_vector = np.ones(len(self._times)) * gSmall
-            zero_rates = -np.log(self._dfs) / (self._times + g_small_vector)
+            g_small_vector = np.ones(len(self.times)) * g_small
+            zero_rates = -np.log(self._dfs) / (self.times + g_small_vector)
 
-            if self._times[0] == 0.0:
+            if self.times[0] == 0.0:
                 zero_rates[0] = zero_rates[1]
 
-            self._interp_fn = PchipInterpolator(self._times, zero_rates)
+            self._interp_fn = PchipInterpolator(self.times, zero_rates)
 
         # if self._interp_type == InterpTypes.FINCUBIC_LOG_DISCOUNT:
 
         #     """ Second derivatives at left is zero and first derivative at
         #     right is clamped to zero. """
         #     log_dfs = np.log(self._dfs)
-        #     self._interp_fn = CubicSpline(self._times, log_dfs,
+        #     self._interp_fn = CubicSpline(self.times, log_dfs,
         #                                  bc_type=((2, 0.0), (1, 0.0)))
 
         elif self._interp_type == InterpTypes.FINCUBIC_ZERO_RATES:
 
             """ Second derivatives at left is zero and first derivative at
             right is clamped to zero. """
-            g_small_vector = np.ones(len(self._times)) * gSmall
-            zero_rates = -np.log(self._dfs) / (self._times + g_small_vector)
+            g_small_vector = np.ones(len(self.times)) * g_small
+            zero_rates = -np.log(self._dfs) / (self.times + g_small_vector)
 
-            if self._times[0] == 0.0:
+            if self.times[0] == 0.0:
                 zero_rates[0] = zero_rates[1]
 
-            self._interp_fn = CubicSpline(self._times, zero_rates,
+            self._interp_fn = CubicSpline(self.times, zero_rates,
                                           bc_type=((2, 0.0), (1, 0.0)))
 
         elif self._interp_type == InterpTypes.NATCUBIC_LOG_DISCOUNT:
 
             """ Second derivatives are clamped to zero at end points """
             log_dfs = np.log(self._dfs)
-            self._interp_fn = CubicSpline(self._times, log_dfs,
+            self._interp_fn = CubicSpline(self.times, log_dfs,
                                           bc_type='natural')
 
         elif self._interp_type == InterpTypes.NATCUBIC_ZERO_RATES:
 
             """ Second derivatives are clamped to zero at end points """
-            g_small_vector = np.ones(len(self._times)) * gSmall
-            zero_rates = -np.log(self._dfs) / (self._times + g_small_vector)
+            g_small_vector = np.ones(len(self.times)) * g_small
+            zero_rates = -np.log(self._dfs) / (self.times + g_small_vector)
 
-            if self._times[0] == 0.0:
+            if self.times[0] == 0.0:
                 zero_rates[0] = zero_rates[1]
 
-            self._interp_fn = CubicSpline(self._times, zero_rates,
+            self._interp_fn = CubicSpline(self.times, zero_rates,
                                           bc_type='natural')
 
     #        elif self._interp_type  == InterpTypes.LINEAR_LOG_DISCOUNT:
     #
     #            log_dfs = np.log(self._dfs)
-    #            self._interp_fn = interp1d(self._times, log_dfs,
+    #            self._interp_fn = interp1d(self.times, log_dfs,
     #                                      fill_value="extrapolate")
 
     ###########################################################################
 
     def interpolate(self,
                     t: float):
         """ Interpolation of discount factors at time x given discount factors
@@ -290,15 +289,15 @@
 
         if isinstance(t, (float, np.float64)):
 
             if t < 0.0:
                 print(t)
                 raise FinError("Interpolate times must all be >= 0")
 
-            if np.abs(t) < gSmall:
+            if np.abs(t) < g_small:
                 return 1.0
 
             tvec = np.array([t])
 
         elif isinstance(t, np.ndarray):
 
             if np.any(t < 0.0):
@@ -336,15 +335,15 @@
 
         #        elif self._interp_type == InterpTypes.LINEAR_LOG_DISCOUNT:
         #
         #            out = np.exp(self._interp_fn(tvec))
 
         else:
 
-            out = _vinterpolate(tvec, self._times, self._dfs,
+            out = _vinterpolate(tvec, self.times, self._dfs,
                                 self._interp_type.value)
 
         if isinstance(t, (float, np.float64)):
             return out[0]
         else:
             return out
```

### Comparing `financepy-0.350/financepy/market/volatility/equity_vol_curve.py` & `financepy-0.360/financepy/market/volatility/equity_vol_curve.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/market/volatility/equity_vol_surface.py` & `financepy-0.360/financepy/market/volatility/equity_vol_surface.py`

 * *Files 5% similar despite different names*

```diff
@@ -154,15 +154,15 @@
         return vol
     if vol_function_type_value == VolFuncTypes.SVI.value:
         vol = vol_function_svi(params, f, k, t)
         return vol
     if vol_function_type_value == VolFuncTypes.SSVI.value:
         vol = vol_function_ssvi(params, f, k, t)
         return vol
-    
+
     return 0.0
 
 ###############################################################################
 
 
 @njit(cache=True, fastmath=True)
 def _delta_fit(k, *args):
@@ -190,15 +190,15 @@
     return inv_obj_fn
 
 ###############################################################################
 # Unable to cache this function due to dynamic globals warning. Revisit.
 ###############################################################################
 
 
-#@njit(float64(float64, float64, float64, float64, int64, int64, float64,
+# @njit(float64(float64, float64, float64, float64, int64, int64, float64,
 #              float64, float64[:]), fastmath=True)
 def _solver_for_smile_strike(s, t, r, q,
                              option_type_value,
                              vol_type_value,
                              delta_target,
                              initial_guess,
                              parameters):
@@ -234,70 +234,70 @@
                  value_dt: Date,
                  stock_price: float,
                  discount_curve: DiscountCurve,
                  dividend_curve: DiscountCurve,
                  expiry_dts: (list),
                  strikes: (list, np.ndarray),
                  volatility_grid: (list, np.ndarray),
-                 volatility_function_type = VolFuncTypes.CLARK,
-                 fin_solver_type = FinSolverTypes.NELDER_MEAD):
+                 vol_func_type=VolFuncTypes.CLARK,
+                 fin_solver_type=FinSolverTypes.NELDER_MEAD):
         """ Create the EquitySurface object by passing in market vol data
         for a list of strikes and expiry dates. """
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
         self._stock_price = stock_price
 
         self._discount_curve = discount_curve
         self._dividend_curve = dividend_curve
 
-        num_expiry_dates = len(expiry_dts)
+        num_expiry_dts = len(expiry_dts)
         num_strikes = len(strikes)
         n = len(volatility_grid)
         m = len(volatility_grid[0])
 
-        if n != num_expiry_dates:
-            raise FinError("1st dim of vol grid is not num_expiry_dates")
+        if n != num_expiry_dts:
+            raise FinError("1st dim of vol grid is not num_expiry_dts")
 
         if m != num_strikes:
             raise FinError("2nd dim of the vol matrix is not num_strikes")
 
         self._strikes = strikes
         self._num_strikes = len(strikes)
 
         self._expiry_dts = expiry_dts
-        self._num_expiry_dates = len(expiry_dts)
+        self._num_expiry_dts = len(expiry_dts)
 
         self._volatility_grid = volatility_grid
-        self._volatility_function_type = volatility_function_type
+        self._vol_func_type = vol_func_type
 
         self._build_vol_surface(fin_solver_type=fin_solver_type)
 
 ###############################################################################
 
-    def vol_from_strike_dt(self, K, expiry_dt):
+    def vol_from_strike_date(self, K, expiry_dt):
         """ Interpolates the Black-Scholes volatility from the volatility
         surface given call option strike and expiry date. Linear interpolation
         is done in variance space. The smile strikes at bracketed dates are
         determined by determining the strike that reproduces the provided delta
         value. This uses the calibration delta convention, but it can be
         overriden by a provided delta convention. The resulting volatilities
         are then determined for each bracketing expiry time and linear
         interpolation is done in variance space and then converted back to a
         lognormal volatility."""
 
-        t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+        t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-        vol_type_value = self._volatility_function_type.value
+        vol_type_value = self._vol_func_type.value
 
         index0 = 0  # lower index in bracket
         index1 = 0  # upper index in bracket
 
-        num_curves = self._num_expiry_dates
+        num_curves = self._num_expiry_dts
 
         if num_curves == 1:
 
             index0 = 0
             index1 = 0
 
         # If the time is below first time then assume a flat vol
@@ -359,17 +359,17 @@
 
 ###############################################################################
 
     # def delta_to_strike(self, call_delta, expiry_dt, delta_method):
     #     """ Interpolates the strike at a delta and expiry date. Linear
     #     interpolation is used in strike."""
 
-    #     t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+    #     t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-    #     vol_type_value = self._volatility_function_type.value
+    #     vol_type_value = self._vol_func_type.value
 
     #     s = self._spot_fx_rate
 
     #     if delta_method is None:
     #         delta_method_value = self._delta_method.value
     #     else:
     #         delta_method_value = delta_method.value
@@ -407,15 +407,15 @@
     #                 break
 
     #     #######################################################################
 
     #     t0 = self._t_exp[index0]
     #     t1 = self._t_exp[index1]
 
-    #     initial_guess = self._K_ATM[index0]
+    #     initial_guess = self._k_atm[index0]
 
     #     K0 = _solver_for_smile_strike(s, t_exp, self._rd[index0], self._rf[index0],
     #                               OptionTypes.EUROPEAN_CALL.value,
     #                               vol_type_value, call_delta,
     #                               delta_method_value,
     #                               initial_guess,
     #                               self._parameters[index0],
@@ -449,35 +449,35 @@
 
     #         K = K1
 
     #     return K
 
 ###############################################################################
 
-    def vol_from_delta_dt(self, call_delta, expiry_dt, delta_method=None):
+    def vol_from_delta_date(self, call_delta, expiry_dt, delta_method=None):
         """ Interpolates the Black-Scholes volatility from the volatility
         surface given a call option delta and expiry date. Linear interpolation
         is done in variance space. The smile strikes at bracketed dates are
         determined by determining the strike that reproduces the provided delta
         value. This uses the calibration delta convention, but it can be
         overriden by a provided delta convention. The resulting volatilities
         are then determined for each bracketing expiry time and linear
         interpolation is done in variance space and then converted back to a
         lognormal volatility."""
 
-        t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+        t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-        vol_type_value = self._volatility_function_type.value
+        vol_type_value = self._vol_func_type.value
 
         s = self._stock_price
 
         index0 = 0  # lower index in bracket
         index1 = 0  # upper index in bracket
 
-        num_curves = self._num_expiry_dates
+        num_curves = self._num_expiry_dts
 
         # If there is only one time horizon then assume flat vol to this time
         if num_curves == 1:
 
             index0 = 0
             index1 = 0
 
@@ -563,62 +563,62 @@
 ###############################################################################
 
     def _build_vol_surface(self, fin_solver_type=FinSolverTypes.NELDER_MEAD):
         """ Main function to construct the vol surface. """
 
         s = self._stock_price
 
-        num_expiry_dates = self._num_expiry_dates
+        num_expiry_dts = self._num_expiry_dts
 
-        if self._volatility_function_type == VolFuncTypes.CLARK:
+        if self._vol_func_type == VolFuncTypes.CLARK:
             num_parameters = 3
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.SABR_BETA_ONE:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.SABR_BETA_ONE:
             num_parameters = 3
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.SABR_BETA_HALF:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.SABR_BETA_HALF:
             num_parameters = 3
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.BBG:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.BBG:
             num_parameters = 3
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.SABR:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.SABR:
             num_parameters = 4
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.CLARK5:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.CLARK5:
             num_parameters = 5
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.SVI:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.SVI:
             num_parameters = 5
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
-        elif self._volatility_function_type == VolFuncTypes.SSVI:
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        elif self._vol_func_type == VolFuncTypes.SSVI:
             num_parameters = 5
-            self._parameters = np.zeros([num_expiry_dates, num_parameters])
+            self._parameters = np.zeros([num_expiry_dts, num_parameters])
             self._parameters[:, 0] = 0.2  # sigma
             self._parameters[:, 1] = 0.8  # gamma
             self._parameters[:, 2] = -0.7  # rho
             self._parameters[:, 3] = 0.3
             self._parameters[:, 4] = 0.048
         else:
-            print(self._volatility_function_type)
+            print(self._vol_func_type)
             raise FinError("Unknown Model Type")
 
-        self._t_exp = np.zeros(num_expiry_dates)
+        self._t_exp = np.zeros(num_expiry_dts)
 
-        self._F0T = np.zeros(num_expiry_dates)
-        self._r = np.zeros(num_expiry_dates)
-        self._q = np.zeros(num_expiry_dates)
+        self._F0T = np.zeros(num_expiry_dts)
+        self._r = np.zeros(num_expiry_dts)
+        self._q = np.zeros(num_expiry_dts)
 
         #######################################################################
         # TODO: ADD SPOT DAYS
         #######################################################################
 
-        spot_dt = self._value_dt
+        spot_dt = self.value_dt
 
-        for i in range(0, num_expiry_dates):
+        for i in range(0, num_expiry_dts):
 
             expiry_dt = self._expiry_dts[i]
             t_exp = (expiry_dt - spot_dt) / gDaysInYear
 
             dis_df = self._discount_curve._df(t_exp)
             div_df = self._dividend_curve._df(t_exp)
             f = s * div_df / dis_df
@@ -628,21 +628,21 @@
             self._q[i] = -np.log(div_df) / t_exp
             self._F0T[i] = f
 
         #######################################################################
         # THE ACTUAL COMPUTATION LOOP STARTS HERE
         #######################################################################
 
-        vol_type_value = self._volatility_function_type.value
+        vol_type_value = self._vol_func_type.value
 
         x_inits = []
         x_init = np.zeros(num_parameters)
         x_inits.append(x_init)
 
-        for i in range(0, num_expiry_dates):
+        for i in range(0, num_expiry_dts):
 
             t = self._t_exp[i]
             r = self._r[i]
             q = self._q[i]
 
             res = _solve_to_horizon(s, t, r, q,
                                     self._strikes,
@@ -663,28 +663,28 @@
         """ Compare calibrated vol surface with market and output a report
         which sets out the quality of fit to the ATM and 10 and 25 delta market
         strangles and risk reversals. """
 
         if verbose:
 
             print("==========================================================")
-            print("VALUE DATE:", self._value_dt)
+            print("VALUE DATE:", self.value_dt)
             print("STOCK PRICE:", self._stock_price)
             print("==========================================================")
 
-        for i in range(0, self._num_expiry_dates):
+        for i in range(0, self._num_expiry_dts):
 
             expiry_dt = self._expiry_dts[i]
             print("==========================================================")
 
             for j in range(0, self._num_strikes):
 
                 strike = self._strikes[j]
 
-                fitted_vol = self.vol_from_strike_dt(strike,
+                fitted_vol = self.vol_from_strike_date(strike,
                                                      expiry_dt)
 
                 mkt_vol = self._volatility_grid[i][j]
 
                 diff = fitted_vol - mkt_vol
 
                 print("%s %12.3f %7.4f %7.4f %7.5f" %
@@ -697,15 +697,15 @@
 
     def implied_dbns(self, lowS, highS, num_intervals):
         """ Calculate the pdf for each tenor horizon. Returns a list of
         FinDistribution objects, one for each tenor horizon. """
 
         dbns = []
 
-        for iTenor in range(0, self._num_expiry_dates):
+        for iTenor in range(0, self._num_expiry_dts):
 
             f = self._F0T[iTenor]
             t = self._t_exp[iTenor]
 
             dS = (highS - lowS) / num_intervals
 
             disDF = self._discount_curve.df(t)
@@ -717,15 +717,15 @@
             Ks = []
             vols = []
 
             for iK in range(0, num_intervals):
 
                 k = lowS + iK*dS
 
-                vol = vol_function(self._volatility_function_type.value,
+                vol = vol_function(self._vol_func_type.value,
                                    self._parameters[iTenor],
                                    f, k, t)
 
                 Ks.append(k)
                 vols.append(vol)
 
             Ks = np.array(Ks)
@@ -740,59 +740,59 @@
 
 ###############################################################################
 
     def plot_vol_curves(self):
         """ Generates a plot of each of the vol discount implied by the market
         and fitted. """
 
-        lowK = self._strikes[0] * 0.9
-        highK = self._strikes[-1] * 1.1
+        low_k = self._strikes[0] * 0.9
+        high_k = self._strikes[-1] * 1.1
 
-        for tenor_index in range(0, self._num_expiry_dates):
+        for tenor_index in range(0, self._num_expiry_dts):
 
             expiry_dt = self._expiry_dts[tenor_index]
             plt.figure()
 
             ks = []
             fitted_vols = []
 
             num_intervals = 30
-            K = lowK
-            dK = (highK - lowK)/num_intervals
+            K = low_k
+            dK = (high_k - low_k)/num_intervals
 
             for _ in range(0, num_intervals):
 
                 ks.append(K)
-                fitted_vol = self.vol_from_strike_dt(K, expiry_dt) * 100.
+                fitted_vol = self.vol_from_strike_date(K, expiry_dt) * 100.
                 fitted_vols.append(fitted_vol)
                 K = K + dK
 
             label_str = "FITTED AT " + str(self._expiry_dts[tenor_index])
             plt.plot(ks, fitted_vols, label=label_str)
 
             label_str = "MARKET AT " + str(self._expiry_dts[tenor_index])
             mkt_vols = self._volatility_grid[tenor_index] * 100.0
             plt.plot(self._strikes, mkt_vols, 'o', label=label_str)
 
             plt.xlabel("Strike")
             plt.ylabel("Volatility")
 
-            title = str(self._volatility_function_type)
+            title = str(self._vol_func_type)
             plt.title(title)
             plt.legend()
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUE DATE", self._value_dt)
+        s += label_to_string("VALUE DATE", self.value_dt)
         s += label_to_string("STOCK PRICE", self._stock_price)
-        s += label_to_string("VOL FUNCTION", self._volatility_function_type)
+        s += label_to_string("VOL FUNCTION", self._vol_func_type)
 
-        for i in range(0, self._num_expiry_dates):
+        for i in range(0, self._num_expiry_dts):
             s += label_to_string("EXPIRY DATE", self._expiry_dts[i])
 
         for i in range(0, self._num_strikes):
             s += label_to_string("STRIKE", self._strikes[i])
 
         s += label_to_string("EQUITY VOL GRID", self._volatility_grid)
```

### Comparing `financepy-0.350/financepy/market/volatility/fx_vol_surface.py` & `financepy-0.360/financepy/market/volatility/fx_vol_surface.py`

 * *Files 10% similar despite different names*

```diff
@@ -39,28 +39,28 @@
 ###############################################################################
 # TODO: Speed up search for strike by providing derivative function to go with
 #       delta fit.
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
-def g(K, *args):
+def g(k, *args):
     """ This is the objective function used in the determination of the FX
     option implied strike which is computed in the class below. """
 
     s = args[0]
     t = args[1]
     r_d = args[2]
     r_f = args[3]
     volatility = args[4]
     delta_method_value = args[5]
     option_type_value = args[6]
     delta_target = args[7]
 
-    delta_out = fast_delta(s, t, K, r_d, r_f,
+    delta_out = fast_delta(s, t, k, r_d, r_f,
                            volatility,
                            delta_method_value,
                            option_type_value)
 
     obj_fn = delta_target - delta_out
     return obj_fn
 
@@ -74,67 +74,67 @@
     been best fitted using the parametric volatility curve represented by cvec
     """
 
     s = args[0]
     t = args[1]
     r_d = args[2]
     r_f = args[3]
-    K_ATM = args[4]
+    k_atm = args[4]
     atm_vol = args[5]
     k_25d_c_ms = args[6]
     k_25d_p_ms = args[7]
     v_25d_ms_target = args[8]
     delta_method_value = args[9]
     target_rr_vol = args[10]
     vol_type_value = args[11]
 
     f = s * np.exp((r_d-r_f)*t)
     # We first need to solve for the strikes at the 25 delta points using the
     # new volatility curve
 
     # Match the at-the-money option volatility
-    atm_curve_vol = vol_function(vol_type_value, params, f, K_ATM, t)
+    atm_curve_vol = vol_function(vol_type_value, params, f, k_atm, t)
     term1 = (atm_vol - atm_curve_vol)**2
 
     ###########################################################################
     # Match the market strangle value but this has to be at the MS strikes
     ###########################################################################
 
     sigma_k_25d_c_ms = vol_function(vol_type_value, params, f, k_25d_c_ms, t)
 
-    V_25D_C_MS = bs_value(s, t, k_25d_c_ms, r_d, r_f, sigma_k_25d_c_ms,
+    V_25d_C_MS = bs_value(s, t, k_25d_c_ms, r_d, r_f, sigma_k_25d_c_ms,
                           OptionTypes.EUROPEAN_CALL.value)
 
     sigma_k_25d_p_ms = vol_function(vol_type_value, params, f, k_25d_p_ms, t)
 
-    V_25D_P_MS = bs_value(s, t, k_25d_p_ms, r_d, r_f, sigma_k_25d_p_ms,
+    V_25d_P_MS = bs_value(s, t, k_25d_p_ms, r_d, r_f, sigma_k_25d_p_ms,
                           OptionTypes.EUROPEAN_PUT.value)
 
-    v_25d_ms = V_25D_C_MS + V_25D_P_MS
+    v_25d_ms = V_25d_C_MS + V_25d_P_MS
     term2 = (v_25d_ms - v_25d_ms_target)**2
 
     ###########################################################################
     # Match the risk reversal volatility
     ###########################################################################
 
-    K_25D_C = solver_for_smile_strike_fast(s, t, r_d, r_f,
+    K_25d_C = solver_for_smile_strike_fast(s, t, r_d, r_f,
                                            OptionTypes.EUROPEAN_CALL.value,
                                            vol_type_value, +0.2500,
                                            delta_method_value, k_25d_c_ms,
                                            params)
 
-    sigma_k_25d_c = vol_function(vol_type_value, params, f, K_25D_C, t)
+    sigma_k_25d_c = vol_function(vol_type_value, params, f, K_25d_C, t)
 
-    K_25D_P = solver_for_smile_strike_fast(s, t, r_d, r_f,
+    K_25d_P = solver_for_smile_strike_fast(s, t, r_d, r_f,
                                            OptionTypes.EUROPEAN_PUT.value,
                                            vol_type_value, -0.2500,
                                            delta_method_value, k_25d_p_ms,
                                            params)
 
-    sigma_k_25d_p = vol_function(vol_type_value, params, f, K_25D_P, t)
+    sigma_k_25d_p = vol_function(vol_type_value, params, f, K_25d_P, t)
 
     sigma_25d_rr = (sigma_k_25d_c - sigma_k_25d_p)
     term3 = (sigma_25d_rr - target_rr_vol)**2
 
     # sum up the errors
     err = term1 + term2 + term3
 
@@ -143,15 +143,15 @@
 ###############################################################################
 # This function cannot be jitted until the scipy minimisation has been replaced
 # with a jittable function
 
 
 def solve_to_horizon_fast(s, t,
                           rd, rf,
-                          K_ATM, atm_vol,
+                          k_atm, atm_vol,
                           ms_25d_vol, rr_25d_vol,
                           delta_method_value, vol_type_value,
                           xopt):
 
     c0 = xopt
 
     # Determine the price of a market strangle from market strangle
@@ -168,50 +168,50 @@
     k_25d_p_ms = solve_for_strike(s, t, rd, rf,
                                   OptionTypes.EUROPEAN_PUT.value,
                                   -0.2500,
                                   delta_method_value,
                                   vol_25d_ms)
 
     # USE MARKET STRANGLE VOL TO DETERMINE PRICE OF A MARKET STRANGLE
-    V_25D_C_MS = bs_value(s, t, k_25d_c_ms, rd, rf, vol_25d_ms,
+    V_25d_C_MS = bs_value(s, t, k_25d_c_ms, rd, rf, vol_25d_ms,
                           OptionTypes.EUROPEAN_CALL.value)
 
-    V_25D_P_MS = bs_value(s, t, k_25d_p_ms, rd, rf, vol_25d_ms,
+    V_25d_P_MS = bs_value(s, t, k_25d_p_ms, rd, rf, vol_25d_ms,
                           OptionTypes.EUROPEAN_PUT.value)
 
     # Market price of strangle in the domestic currency
-    v_25d_ms = V_25D_C_MS + V_25D_P_MS
+    v_25d_ms = V_25d_C_MS + V_25d_P_MS
 
     # Determine parameters of vol surface using minimisation
     tol = 1e-8
 
     fargs = (s, t, rd, rf,
-             K_ATM, atm_vol,
+             k_atm, atm_vol,
              k_25d_c_ms, k_25d_p_ms,
              v_25d_ms,
              delta_method_value, rr_25d_vol, vol_type_value)
 
     opt = minimize(obj_fast, c0, fargs, method="CG", tol=tol)
     xopt = opt.x
 
     params = np.array(xopt)
 
-    K_25D_C = solver_for_smile_strike_fast(s, t, rd, rf,
+    K_25d_C = solver_for_smile_strike_fast(s, t, rd, rf,
                                            OptionTypes.EUROPEAN_CALL.value,
                                            vol_type_value, +0.2500,
                                            delta_method_value, k_25d_c_ms,
                                            params)
 
-    K_25D_P = solver_for_smile_strike_fast(s, t, rd, rf,
+    K_25d_P = solver_for_smile_strike_fast(s, t, rd, rf,
                                            OptionTypes.EUROPEAN_PUT.value,
                                            vol_type_value, -0.2500,
                                            delta_method_value, k_25d_p_ms,
                                            params)
 
-    ret = (params, k_25d_c_ms, k_25d_p_ms, K_25D_C, K_25D_P)
+    ret = (params, k_25d_c_ms, k_25d_p_ms, K_25d_C, K_25d_P)
     return ret
 
 ###############################################################################
 
 
 @njit(float64(int64, float64[:], float64, float64, float64),
       cache=True, fastmath=True)
@@ -300,15 +300,15 @@
 ###############################################################################
 # Unable to cache function
 
 
 @njit(float64(float64, float64, float64, float64, int64, float64,
               int64, float64), fastmath=True)
 def solve_for_strike(spot_fx_rate,
-                     tdel, rd, rf,
+                     t_del, rd, rf,
                      option_type_value,
                      delta_target,
                      delta_method_value,
                      volatility):
     """ This function determines the implied strike of an FX option
     given a delta and the other option details. It uses a one-dimensional
     Newton root search algorithm to determine the strike that matches an
@@ -322,59 +322,59 @@
     # inverse value of delta, this may not, on a round trip using N(x), give
     # back the value x as it is calculated to a different number of decimal
     # places. It should however agree to 6-7 decimal places. Which is OK.
     # =========================================================================
 
     if delta_method_value == FinFXDeltaMethod.SPOT_DELTA.value:
 
-        dom_df = np.exp(-rd*tdel)
-        for_df = np.exp(-rf*tdel)
+        dom_df = np.exp(-rd*t_del)
+        for_df = np.exp(-rf*t_del)
 
         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
             phi = +1.0
         else:
             phi = -1.0
 
         F0T = spot_fx_rate * for_df / dom_df
-        vsqrtt = volatility * np.sqrt(tdel)
+        vsqrtt = volatility * np.sqrt(t_del)
         arg = delta_target*phi/for_df  # CHECK THIS !!!
         norm_inv_delta = norminvcdf(arg)
         K = F0T * np.exp(-vsqrtt * (phi*norm_inv_delta - vsqrtt/2.0))
         return K
 
     elif delta_method_value == FinFXDeltaMethod.FORWARD_DELTA.value:
 
-        dom_df = np.exp(-rd*tdel)
-        for_df = np.exp(-rf*tdel)
+        dom_df = np.exp(-rd*t_del)
+        for_df = np.exp(-rf*t_del)
 
         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
             phi = +1.0
         else:
             phi = -1.0
 
         F0T = spot_fx_rate * for_df / dom_df
-        vsqrtt = volatility * np.sqrt(tdel)
+        vsqrtt = volatility * np.sqrt(t_del)
         arg = delta_target*phi   # CHECK THIS!!!!!!!!
         norm_inv_delta = norminvcdf(arg)
         K = F0T * np.exp(-vsqrtt * (phi*norm_inv_delta - vsqrtt/2.0))
         return K
 
     elif delta_method_value == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ.value:
 
-        argtuple = (spot_fx_rate, tdel, rd, rf, volatility,
+        argtuple = (spot_fx_rate, t_del, rd, rf, volatility,
                     delta_method_value, option_type_value, delta_target)
 
         K = newton_secant(g, x0=spot_fx_rate, args=argtuple,
                           tol=1e-7, maxiter=50)
 
         return K
 
     elif delta_method_value == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ.value:
 
-        argtuple = (spot_fx_rate, tdel, rd, rf, volatility,
+        argtuple = (spot_fx_rate, t_del, rd, rf, volatility,
                     delta_method_value, option_type_value, delta_target)
 
         K = newton_secant(g, x0=spot_fx_rate, args=argtuple,
                           tol=1e-7, maxiter=50)
 
         return K
 
@@ -393,142 +393,154 @@
     function ranging from polynomial in delta to a limited version of SABR. """
 
     def __init__(self,
                  value_dt: Date,
                  spot_fx_rate: float,
                  currency_pair: str,
                  notional_currency: str,
-                 dom_discount_curve: DiscountCurve,
-                 for_discount_curve: DiscountCurve,
+                 domestic_curve: DiscountCurve,
+                 foreign_curve: DiscountCurve,
                  tenors: (list),
                  atm_vols: (list, np.ndarray),
-                 ms25DeltaVols: (list, np.ndarray),
-                 rr25DeltaVols: (list, np.ndarray),
-                 atmMethod: FinFXATMMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL,
+                 ms25deltaVols: (list, np.ndarray),
+                 rr25deltaVols: (list, np.ndarray),
+                 atm_method: FinFXATMMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL,
                  delta_method: FinFXDeltaMethod = FinFXDeltaMethod.SPOT_DELTA,
-                 volatility_function_type: VolFuncTypes = VolFuncTypes.CLARK):
+                 vol_func_type: VolFuncTypes = VolFuncTypes.CLARK):
         """ Create the FinFXVolSurface object by passing in market vol data
         for ATM and 25 Delta Market Strangles and Risk Reversals. """
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
-        self._spot_fx_rate = spot_fx_rate
-        self._currency_pair = currency_pair
+        self.value_dt = value_dt
+        self.spot_fx_rate = spot_fx_rate
+        self.currency_pair = currency_pair
 
         if len(currency_pair) != 6:
             raise FinError("Currency pair must be 6 characters.")
 
-        self._forName = self._currency_pair[0:3]
-        self._domName = self._currency_pair[3:6]
+        self.for_name = self.currency_pair[0:3]
+        self.dom_name = self.currency_pair[3:6]
 
-        self._notional_currency = notional_currency
-        self._dom_discount_curve = dom_discount_curve
-        self._for_discount_curve = for_discount_curve
-        self._num_vol_curves = len(tenors)
+        self.notional_currency = notional_currency
+        self.domestic_curve = domestic_curve
+        self.foreign_curve = foreign_curve
+        self.num_vol_curves = len(tenors)
 
-        if len(atm_vols) != self._num_vol_curves:
+        if len(atm_vols) != self.num_vol_curves:
             raise FinError("Number ATM vols must equal number of tenors")
 
-        if len(atm_vols) != self._num_vol_curves:
+        if len(atm_vols) != self.num_vol_curves:
             raise FinError("Number ATM vols must equal number of tenors")
 
-        if len(ms25DeltaVols) != self._num_vol_curves:
-            raise FinError("Number MS25D vols must equal number of tenors")
+        if len(ms25deltaVols) != self.num_vol_curves:
+            raise FinError("Number MS25d vols must equal number of tenors")
 
-        if len(rr25DeltaVols) != self._num_vol_curves:
-            raise FinError("Number RR25D vols must equal number of tenors")
+        if len(rr25deltaVols) != self.num_vol_curves:
+            raise FinError("Number RR25d vols must equal number of tenors")
 
-        self._tenors = tenors
-        self._atm_vols = np.array(atm_vols)/100.0
-        self._ms25DeltaVols = np.array(ms25DeltaVols)/100.0
-        self._rr25DeltaVols = np.array(rr25DeltaVols)/100.0
-
-        self._atmMethod = atmMethod
-        self._delta_method = delta_method
-
-        if self._delta_method == FinFXDeltaMethod.SPOT_DELTA:
-            self._delta_method_string = "pips_spot_delta"
-        elif self._delta_method == FinFXDeltaMethod.FORWARD_DELTA:
-            self._delta_method_string = "pips_fwd_delta"
-        elif self._delta_method == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ:
-            self._delta_method_string = "pct_spot_delta_prem_adj"
-        elif self._delta_method == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ:
-            self._delta_method_string = "pct_fwd_delta_prem_adj"
+        self.tenors = tenors
+        self.atm_vols = np.array(atm_vols)/100.0
+        self.ms25deltaVols = np.array(ms25deltaVols)/100.0
+        self.rr25deltaVols = np.array(rr25deltaVols)/100.0
+
+        self.atm_method = atm_method
+        self.delta_method = delta_method
+
+        if self.delta_method == FinFXDeltaMethod.SPOT_DELTA:
+            self.delta_method_string = "pips_spot_delta"
+        elif self.delta_method == FinFXDeltaMethod.FORWARD_DELTA:
+            self.delta_method_string = "pips_fwd_delta"
+        elif self.delta_method == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ:
+            self.delta_method_string = "pct_spot_delta_prem_adj"
+        elif self.delta_method == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ:
+            self.delta_method_string = "pct_fwd_delta_prem_adj"
         else:
             raise FinError("Unknown Delta Type")
 
-        self._vol_func_type = volatility_function_type
-        self._tenor_index = 0
+        self.vol_func_type = vol_func_type
+        self.tenor_index = 0
 
-        self._expiry_dts = []
-        for i in range(0, self._num_vol_curves):
+        self.k_25d_c = None
+        self.k_25d_p = None
+        self.k_25d_c_ms = None
+        self.k_25d_p_ms = None
+        self.v_25d_ms = None
+        self.t_exp = None
+        self.k_atm = None
+        self.rd = None
+        self.rf = None
+        self.fwd = None
+        self.parameters = None
+
+        self.expiry_dts = []
+        for i in range(0, self.num_vol_curves):
             expiry_dt = value_dt.add_tenor(tenors[i])
-            self._expiry_dts.append(expiry_dt)
+            self.expiry_dts.append(expiry_dt)
 
         self.build_vol_surface()
 
 ###############################################################################
 
     def volatility(self, K, expiry_dt):
         """ Interpolate the Black-Scholes volatility from the volatility
         surface given the option strike and expiry date. Linear interpolation
         is done in variance x time. """
 
-        vol_type_value = self._vol_func_type.value
+        vol_type_value = self.vol_func_type.value
 
         index0 = 0
         index1 = 0
 
-        t = (expiry_dt - self._value_dt) / gDaysInYear
+        t = (expiry_dt - self.value_dt) / gDaysInYear
 
-        num_curves = self._num_vol_curves
+        num_curves = self.num_vol_curves
 
         if num_curves == 1:
 
             # The volatility term structure is flat if there is only one expiry
-            fwd = self._F0T[0]
-            t_exp = self._t_exp[0]
-            vol = vol_function(vol_type_value, self._parameters[0],
+            fwd = self.fwd[0]
+            t_exp = self.t_exp[0]
+            vol = vol_function(vol_type_value, self.parameters[0],
                                fwd, K, t_exp)
             return vol
 
         # If the time is below first time then assume a flat vol
-        if t <= self._t_exp[0]:
+        if t <= self.t_exp[0]:
 
-            fwd = self._F0T[0]
-            t_exp = self._t_exp[0]
-            vol = vol_function(vol_type_value, self._parameters[0],
+            fwd = self.fwd[0]
+            t_exp = self.t_exp[0]
+            vol = vol_function(vol_type_value, self.parameters[0],
                                fwd, K, t_exp)
             return vol
 
         # If the time is beyond the last time then extrapolate with a flat vol
-        if t > self._t_exp[-1]:
+        if t > self.t_exp[-1]:
 
-            fwd = self._F0T[-1]
-            t_exp = self._t_exp[-1]
-            vol = vol_function(vol_type_value, self._parameters[-1],
+            fwd = self.fwd[-1]
+            t_exp = self.t_exp[-1]
+            vol = vol_function(vol_type_value, self.parameters[-1],
                                fwd, K, t_exp)
             return vol
 
         for i in range(1, num_curves):
 
-            if t <= self._t_exp[i] and t > self._t_exp[i-1]:
+            if t <= self.t_exp[i] and t > self.t_exp[i-1]:
                 index0 = i-1
                 index1 = i
                 break
 
-        fwd0 = self._F0T[index0]
-        t0 = self._t_exp[index0]
-        vol0 = vol_function(vol_type_value, self._parameters[index0],
+        fwd0 = self.fwd[index0]
+        t0 = self.t_exp[index0]
+        vol0 = vol_function(vol_type_value, self.parameters[index0],
                             fwd0, K, t0)
 
-        fwd1 = self._F0T[index1]
-        t1 = self._t_exp[index1]
-        vol1 = vol_function(vol_type_value, self._parameters[index1],
+        fwd1 = self.fwd[index1]
+        t1 = self.t_exp[index1]
+        vol1 = vol_function(vol_type_value, self.parameters[index1],
                             fwd1, K, t1)
 
         vart0 = vol0*vol0*t0
         vart1 = vol1*vol1*t1
         vart = ((t-t0) * vart1 + (t1-t) * vart0) / (t1 - t0)
 
         if vart < 0.0:
@@ -537,631 +549,640 @@
         volt = np.sqrt(vart/t)
         return volt
 
 ###############################################################################
 
     def build_vol_surface(self):
 
-        s = self._spot_fx_rate
-        num_vol_curves = self._num_vol_curves
+        s = self.spot_fx_rate
+        num_vol_curves = self.num_vol_curves
 
-        if self._vol_func_type == VolFuncTypes.CLARK:
+        if self.vol_func_type == VolFuncTypes.CLARK:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.SABR:
+        elif self.vol_func_type == VolFuncTypes.SABR:
             num_parameters = 4
-        elif self._vol_func_type == VolFuncTypes.SABR_BETA_ONE:
+        elif self.vol_func_type == VolFuncTypes.SABR_BETA_ONE:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.SABR_BETA_HALF:
+        elif self.vol_func_type == VolFuncTypes.SABR_BETA_HALF:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.BBG:
+        elif self.vol_func_type == VolFuncTypes.BBG:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.CLARK5:
+        elif self.vol_func_type == VolFuncTypes.CLARK5:
             num_parameters = 5
         else:
-            print(self._vol_func_type)
+            print(self.vol_func_type)
             raise FinError("Unknown Model Type")
 
-        self._parameters = np.zeros([num_vol_curves, num_parameters])
+        self.parameters = np.zeros([num_vol_curves, num_parameters])
 
-        self._F0T = np.zeros(num_vol_curves)
-        self._rd = np.zeros(num_vol_curves)
-        self._rf = np.zeros(num_vol_curves)
-        self._K_ATM = np.zeros(num_vol_curves)
-        self._deltaATM = np.zeros(num_vol_curves)
-
-        self._k_25d_c = np.zeros(num_vol_curves)
-        self._k_25d_p = np.zeros(num_vol_curves)
-        self._k_25d_c_ms = np.zeros(num_vol_curves)
-        self._k_25d_p_ms = np.zeros(num_vol_curves)
-        self._v_25d_ms = np.zeros(num_vol_curves)
-        self._t_exp = np.zeros(num_vol_curves)
+        self.fwd = np.zeros(num_vol_curves)
+        self.rd = np.zeros(num_vol_curves)
+        self.rf = np.zeros(num_vol_curves)
+        self.k_atm = np.zeros(num_vol_curves)
+        self.delta_atm = np.zeros(num_vol_curves)
+
+        self.k_25d_c = np.zeros(num_vol_curves)
+        self.k_25d_p = np.zeros(num_vol_curves)
+        self.k_25d_c_ms = np.zeros(num_vol_curves)
+        self.k_25d_p_ms = np.zeros(num_vol_curves)
+        self.v_25d_ms = np.zeros(num_vol_curves)
+        self.t_exp = np.zeros(num_vol_curves)
 
         #######################################################################
         # TODO: ADD SPOT DAYS
         #######################################################################
-        spot_dt = self._value_dt
+        spot_dt = self.value_dt
 
         for i in range(0, num_vol_curves):
 
-            expiry_dt = self._expiry_dts[i]
+            expiry_dt = self.expiry_dts[i]
             t_exp = (expiry_dt - spot_dt) / gDaysInYear
 
-            dom_df = self._dom_discount_curve._df(t_exp)
-            for_df = self._for_discount_curve._df(t_exp)
+            dom_df = self.domestic_curve._df(t_exp)
+            for_df = self.foreign_curve._df(t_exp)
             f = s * for_df/dom_df
 
-            self._t_exp[i] = t_exp
-            self._rd[i] = -np.log(dom_df) / t_exp
-            self._rf[i] = -np.log(for_df) / t_exp
-            self._F0T[i] = f
+            self.t_exp[i] = t_exp
+            self.rd[i] = -np.log(dom_df) / t_exp
+            self.rf[i] = -np.log(for_df) / t_exp
+            self.fwd[i] = f
 
-            atm_vol = self._atm_vols[i]
+            atm_vol = self.atm_vols[i]
 
             # This follows exposition in Clarke Page 52
-            if self._atmMethod == FinFXATMMethod.SPOT:
-                self._K_ATM[i] = s
-            elif self._atmMethod == FinFXATMMethod.FWD:
-                self._K_ATM[i] = f
-            elif self._atmMethod == FinFXATMMethod.FWD_DELTA_NEUTRAL:
-                self._K_ATM[i] = f * np.exp(atm_vol*atm_vol*t_exp/2.0)
-            elif self._atmMethod == FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ:
-                self._K_ATM[i] = f * np.exp(-atm_vol*atm_vol*t_exp/2.0)
+            if self.atm_method == FinFXATMMethod.SPOT:
+                self.k_atm[i] = s
+            elif self.atm_method == FinFXATMMethod.FWD:
+                self.k_atm[i] = f
+            elif self.atm_method == FinFXATMMethod.FWD_DELTA_NEUTRAL:
+                self.k_atm[i] = f * np.exp(atm_vol*atm_vol*t_exp/2.0)
+            elif self.atm_method == FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ:
+                self.k_atm[i] = f * np.exp(-atm_vol*atm_vol*t_exp/2.0)
             else:
                 raise FinError("Unknown Delta Type")
 
         #######################################################################
         # THE ACTUAL COMPUTATION LOOP STARTS HERE
         #######################################################################
 
         x_inits = []
         for i in range(0, num_vol_curves):
 
-            atm_vol = self._atm_vols[i]
-            ms25 = self._ms25DeltaVols[i]
-            rr25 = self._rr25DeltaVols[i]
+            atm_vol = self.atm_vols[i]
+            ms25 = self.ms25deltaVols[i]
+            rr25 = self.rr25deltaVols[i]
             s25 = atm_vol + ms25 + rr25/2.0
             s50 = atm_vol
             s75 = atm_vol + ms25 - rr25/2.0
 
-            if self._vol_func_type == VolFuncTypes.CLARK:
+            if self.vol_func_type == VolFuncTypes.CLARK:
 
-                # Fit to 25D
+                # Fit to 25d
                 c0 = np.log(atm_vol)
                 c1 = 2.0 * np.log(s75/s25)
                 c2 = 8.0 * np.log(s25*s75/atm_vol/atm_vol)
                 x_init = [c0, c1, c2]
 
-            elif self._vol_func_type == VolFuncTypes.SABR:
+            elif self.vol_func_type == VolFuncTypes.SABR:
                 # SABR parameters are alpha, nu, rho
                 # SABR parameters are alpha, nu, rho
                 alpha = 0.174
                 beta = 1.0
                 rho = -0.112
                 nu = 0.817
 
                 x_init = [alpha, beta, rho, nu]
 
-            elif self._vol_func_type == VolFuncTypes.SABR_BETA_ONE:
+            elif self.vol_func_type == VolFuncTypes.SABR_BETA_ONE:
                 # SABR parameters are alpha, nu, rho
                 alpha = 0.174
                 rho = -0.112
                 nu = 0.817
                 x_init = [alpha, nu, rho]
 
-            elif self._vol_func_type == VolFuncTypes.SABR_BETA_HALF:
+            elif self.vol_func_type == VolFuncTypes.SABR_BETA_HALF:
                 # SABR parameters are alpha, nu, rho
                 alpha = 0.174
                 rho = -0.112
                 nu = 0.817
                 x_init = [alpha, rho, nu]
 
-            elif self._vol_func_type == VolFuncTypes.BBG:
+            elif self.vol_func_type == VolFuncTypes.BBG:
 
-                # BBG Params if we fit to 25D
+                # BBG Params if we fit to 25d
                 a = 8.0*s75-16.0*s50+8.0*s25
                 b = -6.0*s75+16.0*s50-10.0*s25
                 c = s75-3.0*s50+3.0*s25
 
                 x_init = [a, b, c]
 
-            elif self._vol_func_type == VolFuncTypes.CLARK5:
+            elif self.vol_func_type == VolFuncTypes.CLARK5:
 
-                # Fit to 25D
+                # Fit to 25d
                 c0 = np.log(atm_vol)
                 c1 = 2.0 * np.log(s75/s25)
                 c2 = 8.0 * np.log(s25*s75/atm_vol/atm_vol)
                 x_init = [c0, c1, c2, 0.0, 0.0]
 
             else:
                 raise FinError("Unknown Model Type")
 
             x_inits.append(x_init)
 
-        delta_method_value = self._delta_method.value
-        vol_type_value = self._vol_func_type.value
+        delta_method_value = self.delta_method.value
+        vol_type_value = self.vol_func_type.value
 
         for i in range(0, num_vol_curves):
 
-            t = self._t_exp[i]
-            r_d = self._rd[i]
-            r_f = self._rf[i]
-            K_ATM = self._K_ATM[i]
-            atm_vol = self._atm_vols[i]
-            ms_25d_vol = self._ms25DeltaVols[i]
-            rr_25d_vol = self._rr25DeltaVols[i]
+            t = self.t_exp[i]
+            r_d = self.rd[i]
+            r_f = self.rf[i]
+            k_atm = self.k_atm[i]
+            atm_vol = self.atm_vols[i]
+            ms_25d_vol = self.ms25deltaVols[i]
+            rr_25d_vol = self.rr25deltaVols[i]
 
-#            print(t, rd, rf, K_ATM, atm_vol, ms_25d_vol, rr_25d_vol)
+#            print(t, rd, rf, k_atm, atm_vol, ms_25d_vol, rr_25d_vol)
 
-            res = solve_to_horizon_fast(s, t, r_d, r_f, K_ATM,
+            res = solve_to_horizon_fast(s, t, r_d, r_f, k_atm,
                                         atm_vol, ms_25d_vol, rr_25d_vol,
                                         delta_method_value, vol_type_value,
                                         x_inits[i])
 
-            (self._parameters[i, :],
-             self._k_25d_c_ms[i], self._k_25d_p_ms[i],
-             self._k_25d_c[i], self._k_25d_p[i]) = res
+            (self.parameters[i, :],
+             self.k_25d_c_ms[i], self.k_25d_p_ms[i],
+             self.k_25d_c[i], self.k_25d_p[i]) = res
 
 ###############################################################################
 
     def solver_for_smile_strike(self,
                                 option_type_value,
                                 delta_target,
                                 tenor_index,
                                 initialValue):
         """ Solve for the strike that sets the delta of the option equal to the
         target value of delta allowing the volatility to be a function of the
         strike. """
 
-        s0 = self._spot_fx_rate
-        tdel = self._t_exp[tenor_index]
-        r_d = self._rd[tenor_index]
-        r_f = self._rf[tenor_index]
+        s0 = self.spot_fx_rate
+        t_del = self.t_exp[tenor_index]
+        r_d = self.rd[tenor_index]
+        r_f = self.rf[tenor_index]
 
         inverse_delta_target = norminvcdf(np.abs(delta_target))
-        argtuple = (self, s0, tdel, r_d, r_f, option_type_value,
-                    inverse_delta_target, tenor_index)
-
-        vol_type_value = self._vol_func_type.value
-
-        argtuple = (vol_type_value, s0, tdel, r_d, r_f, option_type_value,
-                    self._delta_method.value,
-                    inverse_delta_target, self._parameters[tenor_index])
 
-        K = newton_secant(delta_fit, x0=initialValue, args=argtuple,
+        argtuple = (self, s0, t_del, r_d, r_f, 
+                    option_type_value,
+                    inverse_delta_target, 
+                    tenor_index)
+
+        vol_type_value = self.vol_func_type.value
+
+        argtuple = (vol_type_value, 
+                    s0, t_del, r_d, r_f, 
+                    option_type_value,
+                    self.delta_method.value,
+                    inverse_delta_target, 
+                    self.parameters[tenor_index])
+
+        K = newton_secant(delta_fit, 
+                          x0=initialValue, 
+                          args=argtuple,
                           tol=1e-5, maxiter=50)
 
         return K
 
 ###############################################################################
 
     def check_calibration(self, verbose: bool, tol: float = 1e-6):
 
         if verbose:
 
             print("==========================================================")
-            print("VALUE DATE:", self._value_dt)
-            print("SPOT FX RATE:", self._spot_fx_rate)
-            print("ATM METHOD:", self._atmMethod)
-            print("DELTA METHOD:", self._delta_method)
+            print("VALUE DATE:", self.value_dt)
+            print("SPOT FX RATE:", self.spot_fx_rate)
+            print("ATM METHOD:", self.atm_method)
+            print("DELTA METHOD:", self.delta_method)
             print("==========================================================")
 
         K_dummy = 999
 
-        for i in range(0, self._num_vol_curves):
+        for i in range(0, self.num_vol_curves):
 
-            expiry_dt = self._expiry_dts[i]
+            expiry_dt = self.expiry_dts[i]
 
             if verbose:
-                print("TENOR:", self._tenors[i])
+                print("TENOR:", self.tenors[i])
                 print("EXPIRY DATE:", expiry_dt)
-                print("IN ATM VOL: %9.6f %%" % (100.0*self._atm_vols[i]))
-                print("IN MKT STRANGLE 25D VOL: %9.6f %%" %
-                      (100.0*self._ms25DeltaVols[i]))
-                print("IN RSK REVERSAL 25D VOL: %9.6f %%" %
-                      (100.0*self._rr25DeltaVols[i]))
+                print("IN ATM VOL: %9.6f %%" % (100.0*self.atm_vols[i]))
+                print("IN MKT STRANGLE 25d VOL: %9.6f %%" %
+                      (100.0*self.ms25deltaVols[i]))
+                print("IN RSK REVERSAL 25d VOL: %9.6f %%" %
+                      (100.0*self.rr25deltaVols[i]))
 
             call = FXVanillaOption(expiry_dt,
                                    K_dummy,
-                                   self._currency_pair,
+                                   self.currency_pair,
                                    OptionTypes.EUROPEAN_CALL,
                                    1.0,
-                                   self._notional_currency, )
+                                   self.notional_currency, )
 
             put = FXVanillaOption(expiry_dt,
                                   K_dummy,
-                                  self._currency_pair,
+                                  self.currency_pair,
                                   OptionTypes.EUROPEAN_PUT,
                                   1.0,
-                                  self._notional_currency)
+                                  self.notional_currency)
 
             ###################################################################
             # AT THE MONEY
             ###################################################################
 
             if verbose:
                 print("======================================================")
-                print("T_(YEARS): ", self._t_exp[i])
-                print("CNT_CPD_RD:%9.6f %%" % (self._rd[i]*100))
-                print("CNT_CPD_RF:%9.6f %%" % (self._rf[i]*100))
-                print("FWD_RATE:  %9.6f" % (self._F0T[i]))
-
-            sigma_ATM_out = vol_function(self._vol_func_type.value,
-                                         self._parameters[i],
-                                         self._F0T[i],
-                                         self._K_ATM[i],
-                                         self._t_exp[i])
+                print("T_(YEARS): ", self.t_exp[i])
+                print("CNT_CPD_RD:%9.6f %%" % (self.rd[i]*100))
+                print("CNT_CPD_RF:%9.6f %%" % (self.rf[i]*100))
+                print("FWD_RATE:  %9.6f" % (self.fwd[i]))
+
+            sigma_atm_out = vol_function(self.vol_func_type.value,
+                                         self.parameters[i],
+                                         self.fwd[i],
+                                         self.k_atm[i],
+                                         self.t_exp[i])
 
             if verbose:
                 print("======================================================")
-                print("VOL FUNCTION", self._vol_func_type)
-                print("VOL_PARAMETERS:", self._parameters[i])
+                print("VOL FUNCTION", self.vol_func_type)
+                print("VOL_PARAMETERS:", self.parameters[i])
                 print("======================================================")
-                print("OUT_K_ATM:  %9.6f" % (self._K_ATM[i]))
+                print("OUT_K_ATM:  %9.6f" % (self.k_atm[i]))
                 print("OUT_ATM_VOL: %9.6f %%"
-                      % (100.0*sigma_ATM_out))
+                      % (100.0*sigma_atm_out))
 
-            diff = sigma_ATM_out - self._atm_vols[i]
+            diff = sigma_atm_out - self.atm_vols[i]
 
             if np.abs(diff) > tol:
+
                 print("FAILED FIT TO ATM VOL IN: %9.6f  OUT: %9.6f  DIFF: %9.6f" %
-                      (self._atm_vols[i]*100.0, sigma_ATM_out*100.0,
+                      (self.atm_vols[i]*100.0, sigma_atm_out*100.0,
                        diff * 100.0))
 
-            call._strike_fx_rate = self._K_ATM[i]
-            put._strike_fx_rate = self._K_ATM[i]
+            call.strike_fx_rate = self.k_atm[i]
+            put.strike_fx_rate = self.k_atm[i]
 
-            model = BlackScholes(sigma_ATM_out)
+            model = BlackScholes(sigma_atm_out)
 
-            delta_call = call.delta(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
-                                    model)[self._delta_method_string]
-
-            delta_put = put.delta(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
-                                  model)[self._delta_method_string]
+            delta_call = call.delta(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
+                                    model)[self.delta_method_string]
+
+            delta_put = put.delta(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
+                                  model)[self.delta_method_string]
 
             if verbose:
                 print("CALL_DELTA: % 9.6f  PUT_DELTA: % 9.6f  NET_DELTA: % 9.6f"
                       % (delta_call, delta_put, delta_call + delta_put))
 
             ###################################################################
             # NOW WE ASSIGN THE SAME VOLATILITY TO THE MS STRIKES
             # THESE STRIKES ARE DETERMINED BY SETTING DELTA TO 0.25/-0.25
             ###################################################################
 
-            msVol = self._atm_vols[i] + self._ms25DeltaVols[i]
+            ms_vol = self.atm_vols[i] + self.ms25deltaVols[i]
 
             if verbose:
 
                 print("======================================================")
                 print("MKT STRANGLE VOL IN: %9.6f %%"
-                      % (100.0*self._ms25DeltaVols[i]))
+                      % (100.0*self.ms25deltaVols[i]))
 
-            call._strike_fx_rate = self._k_25d_c_ms[i]
-            put._strike_fx_rate = self._k_25d_p_ms[i]
+            call.strike_fx_rate = self.k_25d_c_ms[i]
+            put.strike_fx_rate = self.k_25d_p_ms[i]
 
-            model = BlackScholes(msVol)
+            model = BlackScholes(ms_vol)
 
-            delta_call = call.delta(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
-                                    model)[self._delta_method_string]
-
-            delta_put = put.delta(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
-                                  model)[self._delta_method_string]
+            delta_call = call.delta(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
+                                    model)[self.delta_method_string]
+
+            delta_put = put.delta(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
+                                  model)[self.delta_method_string]
 
             if verbose:
-                print("k_25d_c_ms: %9.6f  ATM + MSVOL: %9.6f %%   DELTA: %9.6f"
-                      % (self._k_25d_c_ms[i], 100.0*msVol, delta_call))
+                print("k_25d_c_ms: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
+                      % (self.k_25d_c_ms[i], 100.0*ms_vol, delta_call))
 
-                print("k_25d_p_ms: %9.6f  ATM + MSVOL: %9.6f %%   DELTA: %9.6f"
-                      % (self._k_25d_p_ms[i], 100.0*msVol, delta_put))
+                print("k_25d_p_ms: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
+                      % (self.k_25d_p_ms[i], 100.0*ms_vol, delta_put))
 
-            call_value = call.value(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
+            call_value = call.value(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
                                     model)['v']
 
-            put_value = put.value(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
+            put_value = put.value(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
                                   model)['v']
 
-            mktStrangleValue = call_value + put_value
+            mkt_strangle_value = call_value + put_value
 
             if verbose:
                 print("CALL_VALUE: %9.6f  PUT_VALUE: %9.6f  MS_VALUE: % 9.6f"
-                      % (call_value, put_value, mktStrangleValue))
+                      % (call_value, put_value, mkt_strangle_value))
 
             ###################################################################
             # NOW WE ASSIGN A DIFFERENT VOLATILITY TO THE MS STRIKES
             # THE DELTAS WILL NO LONGER EQUAL 0.25, -0.25
             ###################################################################
 
             # CALL
-            sigma_k_25d_c_ms = vol_function(self._vol_func_type.value,
-                                            self._parameters[i],
-                                            self._F0T[i],
-                                            self._k_25d_c_ms[i],
-                                            self._t_exp[i])
+            sigma_k_25d_c_ms = vol_function(self.vol_func_type.value,
+                                            self.parameters[i],
+                                            self.fwd[i],
+                                            self.k_25d_c_ms[i],
+                                            self.t_exp[i])
 
             model = BlackScholes(sigma_k_25d_c_ms)
-            call_value = call.value(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
+            call_value = call.value(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
                                     model)['v']
 
             # THIS IS NOT GOING TO BE 0.25 AS WE HAVE USED A DIFFERENT SKEW VOL
-            delta_call = call.delta(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
-                                    model)[self._delta_method_string]
+            delta_call = call.delta(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
+                                    model)[self.delta_method_string]
 
             # PUT
-            sigma_k_25d_p_ms = vol_function(self._vol_func_type.value,
-                                            self._parameters[i],
-                                            self._F0T[i],
-                                            self._k_25d_p_ms[i],
-                                            self._t_exp[i])
+            sigma_k_25d_p_ms = vol_function(self.vol_func_type.value,
+                                            self.parameters[i],
+                                            self.fwd[i],
+                                            self.k_25d_p_ms[i],
+                                            self.t_exp[i])
 
             model = BlackScholes(sigma_k_25d_p_ms)
-            put_value = put.value(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
+            put_value = put.value(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
                                   model)['v']
 
             # THIS IS NOT GOING TO BE -0.25 AS WE HAVE USED A DIFFERENT SKEW VOL
-            delta_put = put.delta(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
-                                  model)[self._delta_method_string]
+            delta_put = put.delta(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
+                                  model)[self.delta_method_string]
 
-            mktStrangleValueSkew = call_value + put_value
+            mkt_strangle_value_skew = call_value + put_value
 
             if verbose:
                 print("k_25d_c_ms: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
-                      % (self._k_25d_c_ms[i], 100.0*sigma_k_25d_c_ms, delta_call))
+                      % (self.k_25d_c_ms[i], 100.0*sigma_k_25d_c_ms, delta_call))
 
                 print("k_25d_p_ms: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
-                      % (self._k_25d_p_ms[i], 100.0*sigma_k_25d_p_ms, delta_put))
+                      % (self.k_25d_p_ms[i], 100.0*sigma_k_25d_p_ms, delta_put))
 
                 print("CALL_VALUE: %9.6f  PUT_VALUE: %9.6f  MS_SKEW_VALUE: % 9.6f"
-                      % (call_value, put_value, mktStrangleValueSkew))
+                      % (call_value, put_value, mkt_strangle_value_skew))
 
-            diff = mktStrangleValue - mktStrangleValueSkew
+            diff = mkt_strangle_value - mkt_strangle_value_skew
             if np.abs(diff) > tol:
-                print("FAILED FIT TO 25D MS VAL: %9.6f  OUT: %9.6f  DIFF: % 9.6f" %
-                      (mktStrangleValue, mktStrangleValueSkew, diff))
+                print("FAILED FIT TO 25d MS VAL: %9.6f  OUT: %9.6f  DIFF: % 9.6f" %
+                      (mkt_strangle_value, mkt_strangle_value_skew, diff))
 
             ###################################################################
             # NOW WE SHIFT STRIKES SO THAT DELTAS NOW EQUAL 0.25, -0.25
             ###################################################################
 
-            call._strike_fx_rate = self._k_25d_c[i]
-            put._strike_fx_rate = self._k_25d_p[i]
+            call.strike_fx_rate = self.k_25d_c[i]
+            put.strike_fx_rate = self.k_25d_p[i]
 
-            sigma_k_25d_c = vol_function(self._vol_func_type.value,
-                                         self._parameters[i],
-                                         self._F0T[i],
-                                         self._k_25d_c[i],
-                                         self._t_exp[i])
+            sigma_k_25d_c = vol_function(self.vol_func_type.value,
+                                         self.parameters[i],
+                                         self.fwd[i],
+                                         self.k_25d_c[i],
+                                         self.t_exp[i])
 
             model = BlackScholes(sigma_k_25d_c)
 
             # THIS DELTA SHOULD BE +0.25
-            delta_call = call.delta(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
-                                    model)[self._delta_method_string]
-
-            sigma_k_25d_p = vol_function(self._vol_func_type.value,
-                                         self._parameters[i],
-                                         self._F0T[i],
-                                         self._k_25d_p[i],
-                                         self._t_exp[i])
+            delta_call = call.delta(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
+                                    model)[self.delta_method_string]
+
+            sigma_k_25d_p = vol_function(self.vol_func_type.value,
+                                         self.parameters[i],
+                                         self.fwd[i],
+                                         self.k_25d_p[i],
+                                         self.t_exp[i])
 
             model = BlackScholes(sigma_k_25d_p)
 
             # THIS DELTA SHOULD BE -0.25
-            delta_put = put.delta(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
-                                  model)[self._delta_method_string]
+            delta_put = put.delta(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
+                                  model)[self.delta_method_string]
 
             if verbose:
-                print("K_25D_C: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
-                      % (self._k_25d_c[i], 100.0*sigma_k_25d_c, delta_call))
+                print("K_25d_C: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
+                      % (self.k_25d_c[i], 100.0*sigma_k_25d_c, delta_call))
 
-                print("K_25D_P: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
-                      % (self._k_25d_p[i], 100.0*sigma_k_25d_p, delta_put))
+                print("K_25d_P: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
+                      % (self.k_25d_p[i], 100.0*sigma_k_25d_p, delta_put))
 
             sigma_RR = sigma_k_25d_c - sigma_k_25d_p
 
             if verbose:
                 print("==========================================================")
                 print("RR = VOL_K_25_C - VOL_K_25_P => RR_IN: %9.6f %% RR_OUT: %9.6f %%"
-                      % (100.0 * self._rr25DeltaVols[i], 100.0*sigma_RR))
+                      % (100.0 * self.rr25deltaVols[i], 100.0*sigma_RR))
                 print("==========================================================")
 
-            diff = sigma_RR - self._rr25DeltaVols[i]
+            diff = sigma_RR - self.rr25deltaVols[i]
 
             if np.abs(diff) > tol:
-                print("FAILED FIT TO 25D RRV IN: % 9.6f  OUT: % 9.6f  DIFF: % 9.6f" %
-                      (self._rr25DeltaVols[i]*100.0,
+                print("FAILED FIT TO 25d RRV IN: % 9.6f  OUT: % 9.6f  DIFF: % 9.6f" %
+                      (self.rr25deltaVols[i]*100.0,
                        sigma_RR*100.0,
                        diff*100.0))
 
 ###############################################################################
 
     def implied_dbns(self, low_fx, high_fx, num_intervals):
         """ Calculate the pdf for each tenor horizon. Returns a list of
         FinDistribution objects, one for each tenor horizon. """
 
         dbns = []
 
-        for i_tenor in range(0, len(self._tenors)):
+        for i_tenor in range(0, len(self.tenors)):
 
-            f = self._F0T[i_tenor]
-            t_exp = self._t_exp[i_tenor]
+            f = self.fwd[i_tenor]
+            t_exp = self.t_exp[i_tenor]
 
             dFX = (high_fx - low_fx) / num_intervals
 
-            dom_df = self._dom_discount_curve.df(t_exp)
-            for_df = self._for_discount_curve.df(t_exp)
+            dom_df = self.domestic_curve.df(t_exp)
+            for_df = self.foreign_curve.df(t_exp)
 
             r_d = -np.log(dom_df) / t_exp
             r_f = -np.log(for_df) / t_exp
 
             Ks = []
             vols = []
 
             for iK in range(0, num_intervals):
 
                 k = low_fx + iK*dFX
 
-                vol = vol_function(self._vol_func_type.value,
-                                   self._parameters[i_tenor],
+                vol = vol_function(self.vol_func_type.value,
+                                   self.parameters[i_tenor],
                                    f, k, t_exp)
 
                 Ks.append(k)
                 vols.append(vol)
 
             Ks = np.array(Ks)
             vols = np.array(vols)
 
-            density = option_implied_dbn(self._spot_fx_rate, t_exp,
+            density = option_implied_dbn(self.spot_fx_rate, t_exp,
                                          r_d, r_f, Ks, vols)
 
             dbn = FinDistribution(Ks, density)
             dbns.append(dbn)
 
         return dbns
 
 ###############################################################################
 
     def plot_vol_curves(self):
 
         plt.figure()
 
-        vol_type_val = self._vol_func_type.value
+        vol_type_val = self.vol_func_type.value
 
-        for tenor_index in range(0, self._num_vol_curves):
+        for tenor_index in range(0, self.num_vol_curves):
 
-            atm_vol = self._atm_vols[tenor_index]*100
-            msVol = self._ms25DeltaVols[tenor_index]*100
-            rrVol = self._rr25DeltaVols[tenor_index]*100
+            atm_vol = self.atm_vols[tenor_index]*100
+            ms_vol = self.ms25deltaVols[tenor_index]*100
+            rr_vol = self.rr25deltaVols[tenor_index]*100
 
-            lowK = self._k_25d_p[tenor_index] * 0.75
-            highK = self._k_25d_c[tenor_index] * 1.25
+            low_k = self.k_25d_p[tenor_index] * 0.75
+            high_k = self.k_25d_c[tenor_index] * 1.25
 
             strikes = []
             vols = []
             num_intervals = 30
-            K = lowK
-            dK = (highK - lowK)/num_intervals
-            params = self._parameters[tenor_index]
-            t = self._t_exp[tenor_index]
-            f = self._F0T[tenor_index]
+            k = low_k
+            dk = (high_k - low_k)/num_intervals
+            params = self.parameters[tenor_index]
+            t = self.t_exp[tenor_index]
+            f = self.fwd[tenor_index]
 
             for _ in range(0, num_intervals):
                 sigma = vol_function(vol_type_val, params, f, K, t) * 100.0
                 strikes.append(K)
                 vols.append(sigma)
-                K = K + dK
+                k = k + dk
 
-            label_str = self._tenors[tenor_index]
+            label_str = self.tenors[tenor_index]
             label_str += " ATM: " + str(atm_vol)[0:6]
-            label_str += " MS: " + str(msVol)[0:6]
-            label_str += " RR: " + str(rrVol)[0:6]
+            label_str += " MS: " + str(ms_vol)[0:6]
+            label_str += " RR: " + str(rr_vol)[0:6]
 
             plt.plot(strikes, vols, label=label_str)
             plt.xlabel("Strike")
             plt.ylabel("Volatility")
 
-            title = "25D FIT:" + self._currency_pair + \
-                " " + str(self._vol_func_type)
+            title = "25d FIT:" + self.currency_pair + \
+                " " + str(self.vol_func_type)
 
             key_strikes = []
-            key_strikes.append(self._K_ATM[tenor_index])
+            key_strikes.append(self.k_atm[tenor_index])
 
             key_vols = []
             for K in key_strikes:
                 sigma = vol_function(vol_type_val, params, f, K, t) * 100.0
                 key_vols.append(sigma)
 
             plt.plot(key_strikes, key_vols, 'ko', markersize=4)
 
             key_strikes = []
-            key_strikes.append(self._k_25d_p[tenor_index])
-            key_strikes.append(self._k_25d_p_ms[tenor_index])
-            key_strikes.append(self._k_25d_c[tenor_index])
-            key_strikes.append(self._k_25d_c_ms[tenor_index])
+            key_strikes.append(self.k_25d_p[tenor_index])
+            key_strikes.append(self.k_25d_p_ms[tenor_index])
+            key_strikes.append(self.k_25d_c[tenor_index])
+            key_strikes.append(self.k_25d_c_ms[tenor_index])
 
             key_vols = []
 
-            for K in key_strikes:
-                sigma = vol_function(vol_type_val, params, f, K, t) * 100.0
+            for k in key_strikes:
+                sigma = vol_function(vol_type_val, params, f, k, t) * 100.0
                 key_vols.append(sigma)
 
             plt.plot(key_strikes, key_vols, 'bo', markersize=4)
 
         plt.title(title)
 #        plt.legend(loc="lower left", bbox_to_anchor=(1,0))
 
 ###############################################################################
 
     def __repr__(self):
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUE DATE", self._value_dt)
-        s += label_to_string("FX RATE", self._spot_fx_rate)
-        s += label_to_string("CCY PAIR", self._currency_pair)
-        s += label_to_string("NOTIONAL CCY", self._notional_currency)
-        s += label_to_string("NUM TENORS", self._num_vol_curves)
-        s += label_to_string("ATM METHOD", self._atmMethod)
-        s += label_to_string("DELTA METHOD", self._delta_method)
-        s += label_to_string("VOL FUNCTION", self._vol_func_type)
+        s = label_to_string("OBJECT TYPE", type(self)._name__)
+        s += label_to_string("VALUE DATE", self.value_dt)
+        s += label_to_string("FX RATE", self.spot_fx_rate)
+        s += label_to_string("CCY PAIR", self.currency_pair)
+        s += label_to_string("NOTIONAL CCY", self.notional_currency)
+        s += label_to_string("NUM TENORS", self.num_vol_curves)
+        s += label_to_string("ATM METHOD", self.atm_method)
+        s += label_to_string("DELTA METHOD", self.delta_method)
+        s += label_to_string("VOL FUNCTION", self.vol_func_type)
 
-        for i in range(0, self._num_vol_curves):
+        for i in range(0, self.num_vol_curves):
 
             s += "\n"
 
-            s += label_to_string("TENOR", self._tenors[i])
-            s += label_to_string("EXPIRY DATE", self._expiry_dts[i])
-            s += label_to_string("TIME (YRS)", self._t_exp[i])
-            s += label_to_string("FWD FX", self._F0T[i])
-
-            s += label_to_string("ATM VOLS", self._atm_vols[i]*100.0)
-            s += label_to_string("MS VOLS", self._ms25DeltaVols[i]*100.0)
-            s += label_to_string("RR VOLS", self._rr25DeltaVols[i]*100.0)
-
-            s += label_to_string("ATM Strike", self._K_ATM[i])
-            s += label_to_string("ATM Delta", self._deltaATM[i])
-
-            s += label_to_string("K_ATM", self._K_ATM[i])
-            s += label_to_string("MS 25D Call Strike", self._k_25d_c_ms[i])
-            s += label_to_string("MS 25D Put Strike", self._k_25d_p_ms[i])
-            s += label_to_string("SKEW 25D CALL STRIKE", self._k_25d_c[i])
-            s += label_to_string("SKEW 25D PUT STRIKE", self._k_25d_p[i])
-            s += label_to_string("PARAMS", self._parameters[i])
+            s += label_to_string("TENOR", self.tenors[i])
+            s += label_to_string("EXPIRY DATE", self.expiry_dts[i])
+            s += label_to_string("TIME (YRS)", self.t_exp[i])
+            s += label_to_string("FWD FX", self.fwd[i])
+
+            s += label_to_string("ATM VOLS", self.atm_vols[i]*100.0)
+            s += label_to_string("MS VOLS", self.ms25deltaVols[i]*100.0)
+            s += label_to_string("RR VOLS", self.rr25deltaVols[i]*100.0)
+
+            s += label_to_string("ATM Strike", self.k_atm[i])
+            s += label_to_string("ATM Delta", self.delta_atm[i])
+
+            s += label_to_string("k_atm", self.k_atm[i])
+            s += label_to_string("MS 25d Call Strike", self.k_25d_c_ms[i])
+            s += label_to_string("MS 25d Put Strike", self.k_25d_p_ms[i])
+            s += label_to_string("SKEW 25d CALL STRIKE", self.k_25d_c[i])
+            s += label_to_string("SKEW 25d PUT STRIKE", self.k_25d_p[i])
+            s += label_to_string("PARAMS", self.parameters[i])
 
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Print a list of the unadjusted coupon payment dates used in
```

### Comparing `financepy-0.350/financepy/market/volatility/fx_vol_surface_plus.py` & `financepy-0.360/financepy/market/volatility/fx_vol_surface_plus.py`

 * *Files 20% similar despite different names*

```diff
@@ -118,26 +118,26 @@
     params and specified by the vol_type_value
     """
 
     s = args[0]
     t = args[1]
     r_d = args[2]
     r_f = args[3]
-    K_ATM = args[4]
+    k_atm = args[4]
     atm_vol = args[5]
 
-    K_25D_C_MS = args[6]
-    K_25D_P_MS = args[7]
-    V_25D_MS_target = args[8]
-    target25DRRVol = args[9]
-
-    K_10D_C_MS = args[10]
-    K_10D_P_MS = args[11]
-    V_10D_MS_target = args[12]
-    target10DRRVol = args[13]
+    k_25d_c_ms = args[6]
+    k_25d_p_ms = args[7]
+    v_25d_ms_target = args[8]
+    target_25d_rr_vol = args[9]
+
+    k_10d_c_ms = args[10]
+    k_10d_p_ms = args[11]
+    v_10d_ms_target = args[12]
+    target_10d_rr_vol = args[13]
 
     delta_method_value = args[14]
     vol_type_value = args[15]
     alpha = args[16]
 
     strikes_null = np.zeros(1)
     gaps_null = np.zeros(1)
@@ -145,146 +145,146 @@
     f = s * np.exp((r_d-r_f)*t)
     # We first need to solve for the strikes at the 25 delta points using the
     # new volatility curve
 
     # Match the at-the-money option volatility
     atm_curve_vol = vol_function(vol_type_value, params,
                                  strikes_null, gaps_null,
-                                 f, K_ATM, t)
+                                 f, k_atm, t)
 
     term_atm = (atm_vol - atm_curve_vol)**2
 
     ###########################################################################
-    # Match the market strangle value but this has to be at the MS 25D strikes
+    # Match the market strangle value but this has to be at the MS 25d strikes
     ###########################################################################
 
-    if target25DRRVol > -999.0:
+    if target_25d_rr_vol > -999.0:
 
-        sigma_K_25D_C_MS = vol_function(vol_type_value, params,
+        sigma_k_25d_c_ms = vol_function(vol_type_value, params,
                                         strikes_null, gaps_null,
-                                        f, K_25D_C_MS, t)
+                                        f, k_25d_c_ms, t)
 
-        V_25D_C_MS = bs_value(s, t, K_25D_C_MS, r_d, r_f, sigma_K_25D_C_MS,
+        v_25d_c_ms = bs_value(s, t, k_25d_c_ms, r_d, r_f, sigma_k_25d_c_ms,
                               OptionTypes.EUROPEAN_CALL.value)
 
-        sigma_K_25D_P_MS = vol_function(vol_type_value, params,
+        sigma_k_25d_p_ms = vol_function(vol_type_value, params,
                                         strikes_null, gaps_null,
-                                        f, K_25D_P_MS, t)
+                                        f, k_25d_p_ms, t)
 
-        V_25D_P_MS = bs_value(s, t, K_25D_P_MS, r_d, r_f, sigma_K_25D_P_MS,
+        v_25d_p_ms = bs_value(s, t, k_25d_p_ms, r_d, r_f, sigma_k_25d_p_ms,
                               OptionTypes.EUROPEAN_PUT.value)
 
-        V_25D_MS = V_25D_C_MS + V_25D_P_MS
-        term_25D_1 = (V_25D_MS - V_25D_MS_target)**2
+        v_25d_ms = v_25d_c_ms + v_25d_p_ms
+        term_25d_1 = (v_25d_ms - v_25d_ms_target)**2
 
     else:
 
-        term_25D_1 = 0.0
+        term_25d_1 = 0.0
 
     ###########################################################################
     # Match the risk reversal volatility
     ###########################################################################
 
-    if target25DRRVol > -999.0:
+    if target_25d_rr_vol > -999.0:
 
-        K_25D_C = _solver_for_smile_strike(s, t, r_d, r_f,
+        k_25d_c = _solver_for_smile_strike(s, t, r_d, r_f,
                                            OptionTypes.EUROPEAN_CALL.value,
                                            vol_type_value, +0.2500,
-                                           delta_method_value, K_25D_C_MS,
+                                           delta_method_value, k_25d_c_ms,
                                            params, strikes_null, gaps_null)
 
-        sigma_K_25D_C = vol_function(vol_type_value, params,
+        sigma_k_25d_c = vol_function(vol_type_value, params,
                                      strikes_null, gaps_null,
-                                     f, K_25D_C, t)
+                                     f, k_25d_c, t)
 
-        K_25D_P = _solver_for_smile_strike(s, t, r_d, r_f,
+        k_25d_p = _solver_for_smile_strike(s, t, r_d, r_f,
                                            OptionTypes.EUROPEAN_PUT.value,
                                            vol_type_value, -0.2500,
-                                           delta_method_value, K_25D_P_MS,
+                                           delta_method_value, k_25d_p_ms,
                                            params, strikes_null, gaps_null)
 
-        sigma_K_25D_P = vol_function(vol_type_value, params,
+        sigma_k_25d_p = vol_function(vol_type_value, params,
                                      strikes_null, gaps_null,
-                                     f, K_25D_P, t)
+                                     f, k_25d_p, t)
 
-        sigma_25D_RR = (sigma_K_25D_C - sigma_K_25D_P)
-        term_25D_2 = (sigma_25D_RR - target25DRRVol)**2
+        sigma_25d_RR = (sigma_k_25d_c - sigma_k_25d_p)
+        term_25d_2 = (sigma_25d_RR - target_25d_rr_vol)**2
 
     else:
 
-        term_25D_2 = 0.0
+        term_25d_2 = 0.0
 
     ###########################################################################
-    # Match the market strangle value but this has to be at the MS 10D strikes
+    # Match the market strangle value but this has to be at the MS 10d strikes
     ###########################################################################
 
-    if target10DRRVol > -999.0:
+    if target_10d_rr_vol > -999.0:
 
-        sigma_K_10D_C_MS = vol_function(vol_type_value, params,
+        sigma_k_10d_c_ms = vol_function(vol_type_value, params,
                                         strikes_null, gaps_null,
-                                        f, K_10D_C_MS, t)
+                                        f, k_10d_c_ms, t)
 
-        V_10D_C_MS = bs_value(s, t, K_10D_C_MS, r_d, r_f, sigma_K_10D_C_MS,
+        v_10d_c_ms = bs_value(s, t, k_10d_c_ms, r_d, r_f, sigma_k_10d_c_ms,
                               OptionTypes.EUROPEAN_CALL.value)
 
-        sigma_K_10D_P_MS = vol_function(vol_type_value, params,
+        sigma_k_10d_p_ms = vol_function(vol_type_value, params,
                                         strikes_null, gaps_null,
-                                        f, K_10D_P_MS, t)
+                                        f, k_10d_p_ms, t)
 
-        V_10D_P_MS = bs_value(s, t, K_10D_P_MS, r_d, r_f, sigma_K_10D_P_MS,
+        v_10d_p_ms = bs_value(s, t, k_10d_p_ms, r_d, r_f, sigma_k_10d_p_ms,
                               OptionTypes.EUROPEAN_PUT.value)
 
-        V_10D_MS = V_10D_C_MS + V_10D_P_MS
-        term10D_1 = (V_10D_MS - V_10D_MS_target)**2
+        v_10d_ms = v_10d_c_ms + v_10d_p_ms
+        term10d_1 = (v_10d_ms - v_10d_ms_target)**2
 
     else:
 
-        term10D_1 = 0.0
+        term10d_1 = 0.0
 
     ###########################################################################
     # Match the risk reversal volatility
     ###########################################################################
 
-    if target10DRRVol > -999.0:
+    if target_10d_rr_vol > -999.0:
 
-        K_10D_C = _solver_for_smile_strike(s, t, r_d, r_f,
+        k_10d_c = _solver_for_smile_strike(s, t, r_d, r_f,
                                            OptionTypes.EUROPEAN_CALL.value,
                                            vol_type_value, +0.1000,
-                                           delta_method_value, K_10D_C_MS,
+                                           delta_method_value, k_10d_c_ms,
                                            params, strikes_null, gaps_null)
 
-        sigma_K_10D_C = vol_function(vol_type_value, params,
+        sigma_k_10d_c = vol_function(vol_type_value, params,
                                      strikes_null, gaps_null,
-                                     f, K_10D_C, t)
+                                     f, k_10d_c, t)
 
-        K_10D_P = _solver_for_smile_strike(s, t, r_d, r_f,
+        k_10d_p = _solver_for_smile_strike(s, t, r_d, r_f,
                                            OptionTypes.EUROPEAN_PUT.value,
                                            vol_type_value, -0.1000,
-                                           delta_method_value, K_10D_P_MS,
+                                           delta_method_value, k_10d_p_ms,
                                            params, strikes_null, gaps_null)
 
-        sigma_K_10D_P = vol_function(vol_type_value, params,
+        sigma_k_10d_p = vol_function(vol_type_value, params,
                                      strikes_null, gaps_null,
-                                     f, K_10D_P, t)
+                                     f, k_10d_p, t)
 
-        sigma_10D_RR = (sigma_K_10D_C - sigma_K_10D_P)
-        term10D_2 = (sigma_10D_RR - target10DRRVol)**2
+        sigma_10d_RR = (sigma_k_10d_c - sigma_k_10d_p)
+        term10d_2 = (sigma_10d_RR - target_10d_rr_vol)**2
 
     else:
 
-        term10D_2 = 0.0
+        term10d_2 = 0.0
 
     ###########################################################################
-    # Alpha interpolates between fitting only ATM and 25D when alpha = 0.0 and
-    # fitting only ATM and 10D when alpha = 1.0. Equal when alpha = 0.50.
+    # Alpha interpolates between fitting only ATM and 25d when alpha = 0.0 and
+    # fitting only ATM and 10d when alpha = 1.0. Equal when alpha = 0.50.
     ###########################################################################
 
     tot = term_atm
-    tot = tot + (1.0 - alpha) * (term_25D_1 + term_25D_2)
-    tot = tot + alpha * (term10D_1 + term10D_2)
+    tot = tot + (1.0 - alpha) * (term_25d_1 + term_25d_2)
+    tot = tot + alpha * (term10d_1 + term10d_2)
     return tot
 
 ###############################################################################
 # Do not cache this function as it leads to complaints
 ###############################################################################
 
 # THIS FUNCTION IS NOT USED CURRENTLY
@@ -297,369 +297,369 @@
     params and specified by the vol_type_value
     """
 
     s = args[0]
     t = args[1]
     r_d = args[2]
     r_f = args[3]
-    K_ATM = args[4]
+    k_atm = args[4]
     atm_vol = args[5]
 
-    K_25D_C_MS = args[6]
-    K_25D_P_MS = args[7]
-    V_25D_MS_target = args[8]
-    target25DRRVol = args[9]
-
-    K_10D_C_MS = args[10]
-    K_10D_P_MS = args[11]
-    V_10D_MS_target = args[12]
-    target10DRRVol = args[13]
+    k_25d_c_ms = args[6]
+    k_25d_p_ms = args[7]
+    v_25d_ms_target = args[8]
+    target_25d_rr_vol = args[9]
+
+    k_10d_c_ms = args[10]
+    k_10d_p_ms = args[11]
+    v_10d_ms_target = args[12]
+    target_10d_rr_vol = args[13]
 
     delta_method_value = args[14]
     vol_type_value = args[15]
     params = args[16]
 
-    strikes = [K_10D_P_MS, K_25D_P_MS, K_ATM, K_25D_C_MS, K_10D_C_MS]
+    strikes = [k_10d_p_ms, k_25d_p_ms, k_atm, k_25d_c_ms, k_10d_c_ms]
     strikes = np.array(strikes)
 
     f = s * np.exp((r_d-r_f)*t)
     # We first need to solve for the strikes at the 25 delta points using the
     # new volatility curve
 
     # Match the at-the-money option volatility
     atm_curve_vol = vol_function(vol_type_value, params, strikes, gaps,
-                                 f, K_ATM, t)
+                                 f, k_atm, t)
 
     print("atm_curve_vol", atm_curve_vol)
 
     term_atm = (atm_vol - atm_curve_vol)**2
 
     ###########################################################################
-    # Match the market strangle value but this has to be at the MS 25D strikes
+    # Match the market strangle value but this has to be at the MS 25d strikes
     ###########################################################################
 
-    sigma_K_25D_C_MS = vol_function(vol_type_value, params, strikes, gaps,
-                                    f, K_25D_C_MS, t)
+    sigma_k_25d_c_ms = vol_function(vol_type_value, params, strikes, gaps,
+                                    f, k_25d_c_ms, t)
 
-    print("sigma_K_25D_C_MS", sigma_K_25D_C_MS)
+    print("sigma_k_25d_c_ms", sigma_k_25d_c_ms)
 
-    V_25D_C_MS = bs_value(s, t, K_25D_C_MS, r_d, r_f, sigma_K_25D_C_MS,
+    v_25d_c_ms = bs_value(s, t, k_25d_c_ms, r_d, r_f, sigma_k_25d_c_ms,
                           OptionTypes.EUROPEAN_CALL.value)
 
-    sigma_K_25D_P_MS = vol_function(vol_type_value, params, strikes, gaps,
-                                    f, K_25D_P_MS, t)
+    sigma_k_25d_p_ms = vol_function(vol_type_value, params, strikes, gaps,
+                                    f, k_25d_p_ms, t)
 
-    print("sigma_K_25D_P_MS", sigma_K_25D_P_MS)
+    print("sigma_k_25d_p_ms", sigma_k_25d_p_ms)
 
-    V_25D_P_MS = bs_value(s, t, K_25D_P_MS, r_d, r_f, sigma_K_25D_P_MS,
+    v_25d_p_ms = bs_value(s, t, k_25d_p_ms, r_d, r_f, sigma_k_25d_p_ms,
                           OptionTypes.EUROPEAN_PUT.value)
 
-    V_25D_MS = V_25D_C_MS + V_25D_P_MS
-    term_25D_1 = (V_25D_MS - V_25D_MS_target)**2
+    v_25d_ms = v_25d_c_ms + v_25d_p_ms
+    term_25d_1 = (v_25d_ms - v_25d_ms_target)**2
 
     ###########################################################################
     # Match the risk reversal volatility
     ###########################################################################
 
-    K_25D_C = _solver_for_smile_strike(s, t, r_d, r_f,
+    k_25d_c = _solver_for_smile_strike(s, t, r_d, r_f,
                                        OptionTypes.EUROPEAN_CALL.value,
                                        vol_type_value, +0.2500,
-                                       delta_method_value, K_25D_C_MS,
+                                       delta_method_value, k_25d_c_ms,
                                        params, strikes, gaps)
 
-    sigma_K_25D_C = vol_function(vol_type_value, params, strikes, gaps,
-                                 f, K_25D_C, t)
+    sigma_k_25d_c = vol_function(vol_type_value, params, strikes, gaps,
+                                 f, k_25d_c, t)
 
-    print("sigma_K_25D_C", sigma_K_25D_C)
+    print("sigma_k_25d_c", sigma_k_25d_c)
 
-    K_25D_P = _solver_for_smile_strike(s, t, r_d, r_f,
+    k_25d_p = _solver_for_smile_strike(s, t, r_d, r_f,
                                        OptionTypes.EUROPEAN_PUT.value,
                                        vol_type_value, -0.2500,
-                                       delta_method_value, K_25D_P_MS,
+                                       delta_method_value, k_25d_p_ms,
                                        params, strikes, gaps)
 
-    sigma_K_25D_P = vol_function(vol_type_value, params, strikes, gaps,
-                                 f, K_25D_P, t)
+    sigma_k_25d_p = vol_function(vol_type_value, params, strikes, gaps,
+                                 f, k_25d_p, t)
 
-    print("sigma_K_25D_P", sigma_K_25D_P)
+    print("sigma_k_25d_p", sigma_k_25d_p)
 
-    sigma_25D_RR = (sigma_K_25D_C - sigma_K_25D_P)
-    term_25D_2 = (sigma_25D_RR - target25DRRVol)**2
+    sigma_25d_RR = (sigma_k_25d_c - sigma_k_25d_p)
+    term_25d_2 = (sigma_25d_RR - target_25d_rr_vol)**2
 
     ###########################################################################
-    # Match the market strangle value but this has to be at the MS 10D strikes
+    # Match the market strangle value but this has to be at the MS 10d strikes
     ###########################################################################
 
-    sigma_K_10D_C_MS = vol_function(vol_type_value, params, strikes, gaps,
-                                    f, K_10D_C_MS, t)
+    sigma_k_10d_c_ms = vol_function(vol_type_value, params, strikes, gaps,
+                                    f, k_10d_c_ms, t)
 
-    print("sigma_K_10D_C_MS", sigma_K_10D_C_MS)
+    print("sigma_k_10d_c_ms", sigma_k_10d_c_ms)
 
-    V_10D_C_MS = bs_value(s, t, K_10D_C_MS, r_d, r_f, sigma_K_10D_C_MS,
+    v_10d_c_ms = bs_value(s, t, k_10d_c_ms, r_d, r_f, sigma_k_10d_c_ms,
                           OptionTypes.EUROPEAN_CALL.value)
 
-    sigma_K_10D_P_MS = vol_function(vol_type_value, params, strikes, gaps,
-                                    f, K_10D_P_MS, t)
+    sigma_k_10d_p_ms = vol_function(vol_type_value, params, strikes, gaps,
+                                    f, k_10d_p_ms, t)
 
-    print("sigma_K_10D_P_MS", sigma_K_10D_P_MS)
+    print("sigma_k_10d_p_ms", sigma_k_10d_p_ms)
 
-    V_10D_P_MS = bs_value(s, t, K_10D_P_MS, r_d, r_f, sigma_K_10D_P_MS,
+    v_10d_p_ms = bs_value(s, t, k_10d_p_ms, r_d, r_f, sigma_k_10d_p_ms,
                           OptionTypes.EUROPEAN_PUT.value)
 
-    V_10D_MS = V_10D_C_MS + V_10D_P_MS
-    term10D_1 = (V_10D_MS - V_10D_MS_target)**2
+    v_10d_ms = v_10d_c_ms + v_10d_p_ms
+    term10d_1 = (v_10d_ms - v_10d_ms_target)**2
 
     ###########################################################################
     # Match the risk reversal volatility
     ###########################################################################
 
-    K_10D_C = _solver_for_smile_strike(s, t, r_d, r_f,
+    k_10d_c = _solver_for_smile_strike(s, t, r_d, r_f,
                                        OptionTypes.EUROPEAN_CALL.value,
                                        vol_type_value, +0.1000,
-                                       delta_method_value, K_10D_C_MS,
+                                       delta_method_value, k_10d_c_ms,
                                        params, strikes, gaps)
 
-    sigma_K_10D_C = vol_function(vol_type_value, params, strikes, gaps,
-                                 f, K_10D_C, t)
+    sigma_k_10d_c = vol_function(vol_type_value, params, strikes, gaps,
+                                 f, k_10d_c, t)
 
-    print("SIGMA_K_10D_C", sigma_K_10D_C)
+    print("SIGMA_k_10d_c", sigma_k_10d_c)
 
-    print("INIT K_10D_P_MS", K_10D_P_MS)
+    print("INIT k_10d_p_ms", k_10d_p_ms)
 
-    K_10D_P = _solver_for_smile_strike(s, t, r_d, r_f,
+    k_10d_p = _solver_for_smile_strike(s, t, r_d, r_f,
                                        OptionTypes.EUROPEAN_PUT.value,
                                        vol_type_value, -0.1000,
-                                       delta_method_value, K_10D_P_MS,
+                                       delta_method_value, k_10d_p_ms,
                                        params, strikes, gaps)
 
-    print("K_10D_P", K_10D_P)
-    sigma_K_10D_P = vol_function(vol_type_value, params, strikes, gaps,
-                                 f, K_10D_P, t)
+    print("k_10d_p", k_10d_p)
+    sigma_k_10d_p = vol_function(vol_type_value, params, strikes, gaps,
+                                 f, k_10d_p, t)
 
-    print("SIGMA_K_10D_P", sigma_K_10D_P)
+    print("SIGMA_k_10d_p", sigma_k_10d_p)
 
-    sigma_10D_RR = (sigma_K_10D_C - sigma_K_10D_P)
-    term10D_2 = (sigma_10D_RR - target10DRRVol)**2
+    sigma_10d_RR = (sigma_k_10d_c - sigma_k_10d_p)
+    term10d_2 = (sigma_10d_RR - target_10d_rr_vol)**2
 
     ###########################################################################
-    # Alpha interpolates between fitting only ATM and 25D when alpha = 0.0 and
-    # fitting only ATM and 10D when alpha = 1.0. Equal when alpha = 0.50.
+    # Alpha interpolates between fitting only ATM and 25d when alpha = 0.0 and
+    # fitting only ATM and 10d when alpha = 1.0. Equal when alpha = 0.50.
     ###########################################################################
 
     tot = term_atm
-    tot = tot + (term_25D_1 + term_25D_2)
-    tot = tot + (term10D_1 + term10D_2)
+    tot = tot + (term_25d_1 + term_25d_2)
+    tot = tot + (term10d_1 + term10d_2)
     return tot
 
 ###############################################################################
 
 
 def _solve_to_horizon(s, t, rd, rf,
-                      K_ATM, atm_vol,
+                      k_atm, atm_vol,
                       ms_25d_vol, rr_25d_vol,
                       ms_10d_vol, rr_10d_vol,
                       delta_method_value, vol_type_value,
                       alpha,
                       x_inits,
                       ginits,
-                      finSolverType,
+                      fin_solver_type,
                       tol):
 
     ###########################################################################
     # Determine the price of a market strangle from market strangle
     # Need to price a call and put that agree with market strangle
     ###########################################################################
 
-    use10D = True
-    use25D = True
+    use10d = True
+    use25d = True
 
     if ms_25d_vol == -999.0:
-        use25D = False
+        use25d = False
 
     if ms_10d_vol == -999.0:
-        use10D = False
+        use10d = False
 
-    if use25D is True:
+    if use25d is True:
 
-        vol_25D_MS = atm_vol + ms_25d_vol
+        vol_25d_ms = atm_vol + ms_25d_vol
 
-        K_25D_C_MS = solve_for_strike(s, t, rd, rf,
+        k_25d_c_ms = solve_for_strike(s, t, rd, rf,
                                       OptionTypes.EUROPEAN_CALL.value,
                                       +0.2500,
                                       delta_method_value,
-                                      vol_25D_MS)
+                                      vol_25d_ms)
 
-        K_25D_P_MS = solve_for_strike(s, t, rd, rf,
+        k_25d_p_ms = solve_for_strike(s, t, rd, rf,
                                       OptionTypes.EUROPEAN_PUT.value,
                                       -0.2500,
                                       delta_method_value,
-                                      vol_25D_MS)
+                                      vol_25d_ms)
 
         # USE MARKET STRANGLE VOL TO DETERMINE PRICE OF A MARKET STRANGLE
-        V_25D_C_MS = bs_value(s, t, K_25D_C_MS, rd, rf, vol_25D_MS,
+        v_25d_c_ms = bs_value(s, t, k_25d_c_ms, rd, rf, vol_25d_ms,
                               OptionTypes.EUROPEAN_CALL.value)
 
-        V_25D_P_MS = bs_value(s, t, K_25D_P_MS, rd, rf, vol_25D_MS,
+        v_25d_p_ms = bs_value(s, t, k_25d_p_ms, rd, rf, vol_25d_ms,
                               OptionTypes.EUROPEAN_PUT.value)
 
         # Market price of strangle in the domestic currency
-        V_25D_MS = V_25D_C_MS + V_25D_P_MS
+        v_25d_ms = v_25d_c_ms + v_25d_p_ms
 
     else:
 
-        vol_25D_MS = -999.0
-        K_25D_C_MS = 0.0
-        K_25D_P_MS = 0.0
-        V_25D_C_MS = 0.0
-        V_25D_P_MS = 0.0
-        V_25D_MS = 0.0
+        vol_25d_ms = -999.0
+        k_25d_c_ms = 0.0
+        k_25d_p_ms = 0.0
+        v_25d_c_ms = 0.0
+        v_25d_p_ms = 0.0
+        v_25d_ms = 0.0
 
     ###########################################################################
 
-    if use10D is True:
+    if use10d is True:
 
-        vol_10D_MS = atm_vol + ms_10d_vol
+        vol_10d_ms = atm_vol + ms_10d_vol
 
-        K_10D_C_MS = solve_for_strike(s, t, rd, rf,
+        k_10d_c_ms = solve_for_strike(s, t, rd, rf,
                                       OptionTypes.EUROPEAN_CALL.value,
                                       +0.1000,
                                       delta_method_value,
-                                      vol_10D_MS)
+                                      vol_10d_ms)
 
-        K_10D_P_MS = solve_for_strike(s, t, rd, rf,
+        k_10d_p_ms = solve_for_strike(s, t, rd, rf,
                                       OptionTypes.EUROPEAN_PUT.value,
                                       -0.1000,
                                       delta_method_value,
-                                      vol_10D_MS)
+                                      vol_10d_ms)
 
         # USE MARKET STRANGLE VOL TO DETERMINE PRICE OF A MARKET STRANGLE
-        V_10D_C_MS = bs_value(s, t, K_10D_C_MS, rd, rf, vol_10D_MS,
+        v_10d_c_ms = bs_value(s, t, k_10d_c_ms, rd, rf, vol_10d_ms,
                               OptionTypes.EUROPEAN_CALL.value)
 
-        V_10D_P_MS = bs_value(s, t, K_10D_P_MS, rd, rf, vol_10D_MS,
+        v_10d_p_ms = bs_value(s, t, k_10d_p_ms, rd, rf, vol_10d_ms,
                               OptionTypes.EUROPEAN_PUT.value)
 
         # Market price of strangle in the domestic currency
-        V_10D_MS = V_10D_C_MS + V_10D_P_MS
+        v_10d_ms = v_10d_c_ms + v_10d_p_ms
 
     else:
 
-        vol_10D_MS = -999.0
-        K_10D_C_MS = 0.0
-        K_10D_P_MS = 0.0
-        V_10D_C_MS = 0.0
-        V_10D_P_MS = 0.0
-        V_10D_MS = 0.0
+        vol_10d_ms = -999.0
+        k_10d_c_ms = 0.0
+        k_10d_p_ms = 0.0
+        v_10d_c_ms = 0.0
+        v_10d_p_ms = 0.0
+        v_10d_ms = 0.0
 
     ###########################################################################
     # Determine parameters of vol surface using minimisation
     ###########################################################################
 
     # tol = 1e-8
 
     args = (s, t, rd, rf,
-            K_ATM, atm_vol,
-            K_25D_C_MS, K_25D_P_MS, V_25D_MS, rr_25d_vol,
-            K_10D_C_MS, K_10D_P_MS, V_10D_MS, rr_10d_vol,
+            k_atm, atm_vol,
+            k_25d_c_ms, k_25d_p_ms, v_25d_ms, rr_25d_vol,
+            k_10d_c_ms, k_10d_p_ms, v_10d_ms, rr_10d_vol,
             delta_method_value, vol_type_value, alpha)
 
     # Nelder-Mead (both SciPy & Numba) is quicker, but occasionally fails
     # to converge, so for those cases try again with CG
     # Numba version is quicker, but can be slightly away from CG output
     try:
-        if finSolverType == FinSolverTypes.NELDER_MEAD_NUMBA:
+        if fin_solver_type == FinSolverTypes.NELDER_MEAD_NUMBA:
             xopt = nelder_mead(_obj, np.array(x_inits),
                                bounds=np.array(
                                    [[], []]).T, args=args, tol_f=tol,
                                tol_x=tol, max_iter=1000)
-        elif finSolverType == FinSolverTypes.NELDER_MEAD:
+        elif fin_solver_type == FinSolverTypes.NELDER_MEAD:
             opt = minimize(_obj, x_inits, args, method="Nelder-Mead", tol=tol)
             xopt = opt.x
-        elif finSolverType == FinSolverTypes.CONJUGATE_GRADIENT:
+        elif fin_solver_type == FinSolverTypes.CONJUGATE_GRADIENT:
             opt = minimize(_obj, x_inits, args, method="CG", tol=tol)
             xopt = opt.x
     except Exception:
         # If convergence fails try again with CG if necessary
-        if finSolverType != FinSolverTypes.CONJUGATE_GRADIENT:
+        if fin_solver_type != FinSolverTypes.CONJUGATE_GRADIENT:
             print('Failed to converge, will try CG')
             opt = minimize(_obj, x_inits, args, method="CG", tol=tol)
 
             xopt = opt.x
 
     params = np.array(xopt)
 
-    strikes = [K_10D_P_MS, K_25D_P_MS, K_ATM, K_10D_C_MS, K_25D_C_MS]
+    strikes = [k_10d_p_ms, k_25d_p_ms, k_atm, k_10d_c_ms, k_25d_c_ms]
     strikes = np.array(strikes)
     gaps = np.zeros(5)
 
     ###########################################################################
     # Determine parameters of vol surface using minimisation
     ###########################################################################
 
     if 1 == 0:
 
         tol = 1e-12
 
         args = (s, t, rd, rf,
-                K_ATM, atm_vol,
-                K_25D_C_MS, K_25D_P_MS, V_25D_MS, rr_25d_vol,
-                K_10D_C_MS, K_10D_P_MS, V_10D_MS, rr_10d_vol,
+                k_atm, atm_vol,
+                k_25d_c_ms, k_25d_p_ms, v_25d_ms, rr_25d_vol,
+                k_10d_c_ms, k_10d_p_ms, v_10d_ms, rr_10d_vol,
                 delta_method_value, vol_type_value, params)
 
         opt = minimize(_obj_gap, ginits, args, method="Nelder-Mead", tol=tol)
         xopt = opt.x
         gaps = np.array(xopt)
 
         print("SOLVED")
 
 # Removed this as it causes discontinuity
 #    f = s * np.exp((rd-rf)*t)
 #    interpATMVol = vol_function(vol_type_value, params,
-#                                   strikes, gaps, f, K_ATM, t)
+#                                   strikes, gaps, f, k_atm, t)
 
 #    diff = atm_vol - interpATMVol
 #    gaps[2] = diff
 
     ###########################################################################
 
-    if use25D is False:
-        K_25D_C_MS = K_ATM
-        K_25D_P_MS = K_ATM
+    if use25d is False:
+        k_25d_c_ms = k_atm
+        k_25d_p_ms = k_atm
 
-    K_25D_C = _solver_for_smile_strike(s, t, rd, rf,
+    k_25d_c = _solver_for_smile_strike(s, t, rd, rf,
                                        OptionTypes.EUROPEAN_CALL.value,
                                        vol_type_value, +0.2500,
-                                       delta_method_value, K_25D_C_MS,
+                                       delta_method_value, k_25d_c_ms,
                                        params, strikes, gaps)
 
-    K_25D_P = _solver_for_smile_strike(s, t, rd, rf,
+    k_25d_p = _solver_for_smile_strike(s, t, rd, rf,
                                        OptionTypes.EUROPEAN_PUT.value,
                                        vol_type_value, -0.2500,
-                                       delta_method_value, K_25D_P_MS,
+                                       delta_method_value, k_25d_p_ms,
                                        params, strikes, gaps)
 
-    if use10D is False:
-        K_10D_C_MS = K_ATM
-        K_10D_P_MS = K_ATM
+    if use10d is False:
+        k_10d_c_ms = k_atm
+        k_10d_p_ms = k_atm
 
-    K_10D_C = _solver_for_smile_strike(s, t, rd, rf,
+    k_10d_c = _solver_for_smile_strike(s, t, rd, rf,
                                        OptionTypes.EUROPEAN_CALL.value,
                                        vol_type_value, +0.1000,
-                                       delta_method_value, K_10D_C_MS,
+                                       delta_method_value, k_10d_c_ms,
                                        params, strikes, gaps)
 
-    K_10D_P = _solver_for_smile_strike(s, t, rd, rf,
+    k_10d_p = _solver_for_smile_strike(s, t, rd, rf,
                                        OptionTypes.EUROPEAN_PUT.value,
                                        vol_type_value, -0.1000,
-                                       delta_method_value, K_10D_P_MS,
+                                       delta_method_value, k_10d_p_ms,
                                        params, strikes, gaps)
 
     return (params, strikes, gaps,
-            K_25D_C_MS, K_25D_P_MS, K_25D_C, K_25D_P,
-            K_10D_C_MS, K_10D_P_MS, K_10D_C, K_10D_P)
+            k_25d_c_ms, k_25d_p_ms, k_25d_c, k_25d_p,
+            k_10d_c_ms, k_10d_p_ms, k_10d_c, k_10d_p)
 
 ###############################################################################
 
 
 @njit(float64(int64, float64[:], float64[:], float64[:],
               float64, float64, float64), cache=True, fastmath=True)
 def vol_function(vol_function_type_value, params, strikes, gaps, f, k, t):
@@ -767,15 +767,15 @@
 # Unable to cache function and if I remove njit it complains about pickle
 ###############################################################################
 
 
 @njit(float64(float64, float64, float64, float64, int64, float64,
               int64, float64), fastmath=True)
 def solve_for_strike(spot_fx_rate,
-                     tdel, rd, rf,
+                     t_del, rd, rf,
                      option_type_value,
                      delta_target,
                      delta_method_value,
                      volatility):
     """ This function determines the implied strike of an FX option
     given a delta and the other option details. It uses a one-dimensional
     Newton root search algorithm to determine the strike that matches an
@@ -789,59 +789,59 @@
     # inverse value of delta, this may not, on a round trip using N(x), give
     # back the value x as it is calculated to a different number of decimal
     # places. It should however agree to 6-7 decimal places. Which is OK.
     # =========================================================================
 
     if delta_method_value == FinFXDeltaMethod.SPOT_DELTA.value:
 
-        dom_df = np.exp(-rd*tdel)
-        for_df = np.exp(-rf*tdel)
+        dom_df = np.exp(-rd*t_del)
+        for_df = np.exp(-rf*t_del)
 
         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
             phi = +1.0
         else:
             phi = -1.0
 
         F0T = spot_fx_rate * for_df / dom_df
-        vsqrtt = volatility * np.sqrt(tdel)
+        vsqrtt = volatility * np.sqrt(t_del)
         arg = delta_target*phi/for_df  # CHECK THIS !!!
         norminvdelta = norminvcdf(arg)
         K = F0T * np.exp(-vsqrtt * (phi * norminvdelta - vsqrtt/2.0))
         return K
 
     elif delta_method_value == FinFXDeltaMethod.FORWARD_DELTA.value:
 
-        dom_df = np.exp(-rd*tdel)
-        for_df = np.exp(-rf*tdel)
+        dom_df = np.exp(-rd*t_del)
+        for_df = np.exp(-rf*t_del)
 
         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
             phi = +1.0
         else:
             phi = -1.0
 
         F0T = spot_fx_rate * for_df / dom_df
-        vsqrtt = volatility * np.sqrt(tdel)
+        vsqrtt = volatility * np.sqrt(t_del)
         arg = delta_target*phi
         norminvdelta = norminvcdf(arg)
         K = F0T * np.exp(-vsqrtt * (phi * norminvdelta - vsqrtt/2.0))
         return K
 
     elif delta_method_value == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ.value:
 
-        argtuple = (spot_fx_rate, tdel, rd, rf, volatility,
+        argtuple = (spot_fx_rate, t_del, rd, rf, volatility,
                     delta_method_value, option_type_value, delta_target)
 
         K = newton_secant(_g, x0=spot_fx_rate, args=argtuple,
                           tol=1e-7, maxiter=50)
 
         return K
 
     elif delta_method_value == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ.value:
 
-        argtuple = (spot_fx_rate, tdel, rd, rf, volatility,
+        argtuple = (spot_fx_rate, t_del, rd, rf, volatility,
                     delta_method_value, option_type_value, delta_target)
 
         K = newton_secant(_g, x0=spot_fx_rate, args=argtuple,
                           tol=1e-7, maxiter=50)
 
         return K
 
@@ -854,224 +854,224 @@
 
 class FXVolSurfacePlus():
     """ Class to perform a calibration of a chosen parametrised surface to the
     prices of FX options at different strikes and expiry tenors. The
     calibration inputs are the ATM and 25 and 10 Delta volatilities in terms of
     the market strangle amd risk reversals. There is a choice of volatility
     function from cubic in delta to full SABR. Check out VolFuncTypes.
-    Parameter alpha [0,1] is used to interpolate between fitting only 25D when
-    alpha=0 to fitting only 10D when alpha=1.0. Alpha=0.5 assigns equal weights
+    Parameter alpha [0,1] is used to interpolate between fitting only 25d when
+    alpha=0 to fitting only 10d when alpha=1.0. Alpha=0.5 assigns equal weights
     A vol function with more parameters will give a better fit. Of course. But
     it might also overfit. Visualising the volatility curve is useful. Also,
     there is no guarantee that the implied pdf will be positive."""
 
     def __init__(self,
                  value_dt: Date,
                  spot_fx_rate: float,
                  currency_pair: str,
                  notional_currency: str,
-                 dom_discount_curve: DiscountCurve,
-                 for_discount_curve: DiscountCurve,
+                 domestic_curve: DiscountCurve,
+                 foreign_curve: DiscountCurve,
                  tenors: (list),
                  atm_vols: (list, np.ndarray),
-                 ms25DeltaVols: (list, np.ndarray),
-                 rr25DeltaVols: (list, np.ndarray),
-                 ms10DeltaVols: (list, np.ndarray),
-                 rr10DeltaVols: (list, np.ndarray),
+                 ms_25_delta_vols: (list, np.ndarray),
+                 rr_25_delta_vols: (list, np.ndarray),
+                 ms_10_delta_vols: (list, np.ndarray),
+                 rr_10_delta_vols: (list, np.ndarray),
                  alpha: float,
-                 atmMethod: FinFXATMMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL,
+                 atm_method: FinFXATMMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL,
                  delta_method: FinFXDeltaMethod = FinFXDeltaMethod.SPOT_DELTA,
-                 volatility_function_type: VolFuncTypes = VolFuncTypes.CLARK,
-                 finSolverType: FinSolverTypes = FinSolverTypes.NELDER_MEAD,
+                 vol_func_type: VolFuncTypes = VolFuncTypes.CLARK,
+                 fin_solver_type: FinSolverTypes = FinSolverTypes.NELDER_MEAD,
                  tol: float = 1e-8):
         """ Create the FinFXVolSurfacePlus object by passing in market vol data
         for ATM, 25 Delta and 10 Delta strikes. The alpha weight shifts the
-        fitting between 25D and 10D. Alpha = 0.0 is 100% 25D while alpha = 1.0
-        is 100% 10D. An alpha of 0.50 is equally weighted. """
+        fitting between 25d and 10d. Alpha = 0.0 is 100% 25d while alpha = 1.0
+        is 100% 10d. An alpha of 0.50 is equally weighted. """
 
         # I want to allow Nones for some of the market inputs
-        if ms10DeltaVols is None:
-            ms10DeltaVols = []
+        if ms_10_delta_vols is None:
+            ms_10_delta_vols = []
 
-        if rr10DeltaVols is None:
-            rr10DeltaVols = []
+        if rr_10_delta_vols is None:
+            rr_10_delta_vols = []
 
-        if ms25DeltaVols is None:
-            ms25DeltaVols = []
+        if ms_25_delta_vols is None:
+            ms_25_delta_vols = []
 
-        if rr25DeltaVols is None:
-            rr25DeltaVols = []
+        if rr_25_delta_vols is None:
+            rr_25_delta_vols = []
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
-        self._spot_fx_rate = spot_fx_rate
-        self._currency_pair = currency_pair
+        self.value_dt = value_dt
+        self.spot_fx_rate = spot_fx_rate
+        self.currency_pair = currency_pair
 
         if len(currency_pair) != 6:
             raise FinError("Currency pair must be 6 characters.")
 
-        self._forName = self._currency_pair[0:3]
-        self._domName = self._currency_pair[3:6]
+        self.for_name = self.currency_pair[0:3]
+        self.dom_name = self.currency_pair[3:6]
 
-        self._notional_currency = notional_currency
-        self._dom_discount_curve = dom_discount_curve
-        self._for_discount_curve = for_discount_curve
-        self._num_vol_curves = len(tenors)
-        self._tenors = tenors
+        self.notional_currency = notional_currency
+        self.domestic_curve = domestic_curve
+        self.foreign_curve = foreign_curve
+        self.num_vol_curves = len(tenors)
+        self.tenors = tenors
 
-        if len(atm_vols) != self._num_vol_curves:
+        if len(atm_vols) != self.num_vol_curves:
             raise FinError("Number ATM vols must equal number of tenors")
 
-        self._atm_vols = np.array(atm_vols)/100.0
+        self.atm_vols = np.array(atm_vols)/100.0
 
-        self._usems_25d_vol = True
-        self._userr_25d_vol = True
-        self._usems_10d_vol = True
-        self._userr_10d_vol = True
+        self.use_ms_25d_vol = True
+        self.use_rr_25d_vol = True
+        self.use_ms_10d_vol = True
+        self.use_rr_10d_vol = True
 
         # Some of these can be missing which is signified by length zero
-        n = len(ms25DeltaVols)
+        n = len(ms_25_delta_vols)
 
-        if n != self._num_vol_curves and n != 0:
-            raise FinError("Number MS25D vols must equal number of tenors")
+        if n != self.num_vol_curves and n != 0:
+            raise FinError("Number MS25d vols must equal number of tenors")
 
         if n == 0:
-            self._usems_25d_vol = False
+            self.use_ms_25d_vol = False
 
-        n = len(rr25DeltaVols)
+        n = len(rr_25_delta_vols)
 
-        if n != self._num_vol_curves and n != 0:
-            raise FinError("Number RR25D vols must equal number of tenors")
+        if n != self.num_vol_curves and n != 0:
+            raise FinError("Number RR25d vols must equal number of tenors")
 
         if n == 0:
-            self._userr_25d_vol = False
+            self.use_rr_25d_vol = False
 
-        n = len(ms10DeltaVols)
+        n = len(ms_10_delta_vols)
 
-        if n != self._num_vol_curves and n != 0:
-            raise FinError("Number MS10D vols must equal number of tenors")
+        if n != self.num_vol_curves and n != 0:
+            raise FinError("Number MS10d vols must equal number of tenors")
 
         if n == 0:
-            self._usems_10d_vol = False
+            self.use_ms_10d_vol = False
 
-        n = len(rr10DeltaVols)
+        n = len(rr_10_delta_vols)
 
-        if n != self._num_vol_curves and n != 0:
-            raise FinError("Number RR10D vols must equal number of tenors")
+        if n != self.num_vol_curves and n != 0:
+            raise FinError("Number RR10d vols must equal number of tenors")
 
         if n == 0:
-            self._userr_10d_vol = False
+            self.use_rr_10d_vol = False
 
-        if self._usems_10d_vol != self._userr_10d_vol:
-            raise FinError("You must provide both 10D RR + 10D MS or neither")
+        if self.use_ms_10d_vol != self.use_rr_10d_vol:
+            raise FinError("You must provide both 10d RR + 10d MS or neither")
 
-        if self._usems_25d_vol != self._userr_25d_vol:
-            raise FinError("You must provide both 25D RR + 25D MS or neither")
+        if self.use_ms_25d_vol != self.use_rr_25d_vol:
+            raise FinError("You must provide both 25d RR + 25d MS or neither")
 
-        if self._usems_10d_vol is False and self._usems_25d_vol is False:
+        if self.use_ms_10d_vol is False and self.use_ms_25d_vol is False:
             raise FinError(
-                "No MS and RR. You must provide 10D or 25D MS + RR.")
+                "No MS and RR. You must provide 10d or 25d MS + RR.")
 
-        self._ms25DeltaVols = np.array(ms25DeltaVols)/100.0
-        self._rr25DeltaVols = np.array(rr25DeltaVols)/100.0
-        self._ms10DeltaVols = np.array(ms10DeltaVols)/100.0
-        self._rr10DeltaVols = np.array(rr10DeltaVols)/100.0
+        self.ms_25_delta_vols = np.array(ms_25_delta_vols)/100.0
+        self.rr_25_delta_vols = np.array(rr_25_delta_vols)/100.0
+        self.ms_10_delta_vols = np.array(ms_10_delta_vols)/100.0
+        self.rr_10_delta_vols = np.array(rr_10_delta_vols)/100.0
 
         if alpha < 0.0 or alpha > 1.0:
             raise FinError("Alpha must be between 0.0 and 1.0")
 
-        self._alpha = alpha
+        self.alpha = alpha
 
-        self._atmMethod = atmMethod
-        self._delta_method = delta_method
+        self.atm_method = atm_method
+        self.delta_method = delta_method
 
-        if self._delta_method == FinFXDeltaMethod.SPOT_DELTA:
-            self._delta_method_string = "pips_spot_delta"
-        elif self._delta_method == FinFXDeltaMethod.FORWARD_DELTA:
-            self._delta_method_string = "pips_fwd_delta"
-        elif self._delta_method == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ:
-            self._delta_method_string = "pct_spot_delta_prem_adj"
-        elif self._delta_method == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ:
-            self._delta_method_string = "pct_fwd_delta_prem_adj"
+        if self.delta_method == FinFXDeltaMethod.SPOT_DELTA:
+            self.delta_method_string = "pips_spot_delta"
+        elif self.delta_method == FinFXDeltaMethod.FORWARD_DELTA:
+            self.delta_method_string = "pips_fwd_delta"
+        elif self.delta_method == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ:
+            self.delta_method_string = "pct_spot_delta_prem_adj"
+        elif self.delta_method == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ:
+            self.delta_method_string = "pct_fwd_delta_prem_adj"
         else:
             raise FinError("Unknown Delta Type")
 
-        self._vol_func_type = volatility_function_type
-        self._tenor_index = 0
+        self.vol_func_type = vol_func_type
+        self.tenor_index = 0
 
-        self._expiry_dts = []
-        for i in range(0, self._num_vol_curves):
+        self.expiry_dts = []
+        for i in range(0, self.num_vol_curves):
             expiry_dt = value_dt.add_tenor(tenors[i])
-            self._expiry_dts.append(expiry_dt)
+            self.expiry_dts.append(expiry_dt)
 
-        self._build_vol_surface(finSolverType=finSolverType, tol=tol)
+        self._build_vol_surface(fin_solver_type=fin_solver_type, tol=tol)
 
 ###############################################################################
 
-    def vol_from_strike_dt(self, K, expiry_dt):
+    def vol_from_strike_date(self, K, expiry_dt):
         """ Interpolates the Black-Scholes volatility from the volatility
         surface given call option strike and expiry date. Linear interpolation
         is done in variance space. The smile strikes at bracketed dates are
         determined by determining the strike that reproduces the provided delta
         value. This uses the calibration delta convention, but it can be
         overriden by a provided delta convention. The resulting volatilities
         are then determined for each bracketing expiry time and linear
         interpolation is done in variance space and then converted back to a
         lognormal volatility."""
 
-        t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+        t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-        vol_type_value = self._vol_func_type.value
+        vol_type_value = self.vol_func_type.value
 
         index0 = 0  # lower index in bracket
         index1 = 0  # upper index in bracket
 
-        num_curves = self._num_vol_curves
+        num_curves = self.num_vol_curves
 
         if num_curves == 1:
 
             index0 = 0
             index1 = 0
 
         # If the time is below first time then assume a flat vol
-        elif t_exp <= self._t_exp[0]:
+        elif t_exp <= self.t_exp[0]:
 
             index0 = 0
             index1 = 0
 
         # If the time is beyond the last time then extrapolate with a flat vol
-        elif t_exp >= self._t_exp[-1]:
+        elif t_exp >= self.t_exp[-1]:
 
-            index0 = len(self._t_exp) - 1
-            index1 = len(self._t_exp) - 1
+            index0 = len(self.t_exp) - 1
+            index1 = len(self.t_exp) - 1
 
         else:  # Otherwise we look for bracketing times and interpolate
 
             for i in range(1, num_curves):
 
-                if t_exp <= self._t_exp[i] and t_exp > self._t_exp[i-1]:
+                if t_exp <= self.t_exp[i] and t_exp > self.t_exp[i-1]:
                     index0 = i-1
                     index1 = i
                     break
 
-        fwd0 = self._F0T[index0]
-        fwd1 = self._F0T[index1]
+        fwd0 = self.fwd[index0]
+        fwd1 = self.fwd[index1]
 
-        t0 = self._t_exp[index0]
-        t1 = self._t_exp[index1]
+        t0 = self.t_exp[index0]
+        t1 = self.t_exp[index1]
 
-        vol0 = vol_function(vol_type_value, self._parameters[index0],
-                            self._strikes[index0], self._gaps[index0],
+        vol0 = vol_function(vol_type_value, self.parameters[index0],
+                            self.strikes[index0], self.gaps[index0],
                             fwd0, K, t0)
 
         if index1 != index0:
 
-            vol1 = vol_function(vol_type_value, self._parameters[index1],
-                                self._strikes[index1], self._gaps[index1],
+            vol1 = vol_function(vol_type_value, self.parameters[index1],
+                                self.strikes[index1], self.gaps[index1],
                                 fwd1, K, t1)
 
         else:
 
             vol1 = vol0
 
         # In the expiry time dimension, both volatilities are interpolated
@@ -1094,88 +1094,88 @@
 
 ###############################################################################
 
     def delta_to_strike(self, call_delta, expiry_dt, delta_method):
         """ Interpolates the strike at a delta and expiry date. Linear
         time to expiry interpolation is used in strike."""
 
-        t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+        t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-        vol_type_value = self._vol_func_type.value
+        vol_type_value = self.vol_func_type.value
 
-        s = self._spot_fx_rate
+        s = self.spot_fx_rate
 
         if delta_method is None:
-            delta_method_value = self._delta_method.value
+            delta_method_value = self.delta_method.value
         else:
             delta_method_value = delta_method.value
 
         index0 = 0  # lower index in bracket
         index1 = 0  # upper index in bracket
 
-        num_curves = self._num_vol_curves
+        num_curves = self.num_vol_curves
 
         # If there is only one time horizon then assume flat vol to this time
         if num_curves == 1:
 
             index0 = 0
             index1 = 0
 
         # If the time is below first time then assume a flat vol
-        elif t_exp <= self._t_exp[0]:
+        elif t_exp <= self.t_exp[0]:
 
             index0 = 0
             index1 = 0
 
         # If the time is beyond the last time then extrapolate with a flat vol
-        elif t_exp > self._t_exp[-1]:
+        elif t_exp > self.t_exp[-1]:
 
-            index0 = len(self._t_exp) - 1
-            index1 = len(self._t_exp) - 1
+            index0 = len(self.t_exp) - 1
+            index1 = len(self.t_exp) - 1
 
         else:  # Otherwise we look for bracketing times and interpolate
 
             for i in range(1, num_curves):
 
-                if t_exp <= self._t_exp[i] and t_exp > self._t_exp[i-1]:
+                if t_exp <= self.t_exp[i] and t_exp > self.t_exp[i-1]:
                     index0 = i-1
                     index1 = i
                     break
 
         #######################################################################
 
-        t0 = self._t_exp[index0]
-        t1 = self._t_exp[index1]
+        t0 = self.t_exp[index0]
+        t1 = self.t_exp[index1]
 
-        initial_guess = self._K_ATM[index0]
+        initial_guess = self.k_atm[index0]
 
         K0 = _solver_for_smile_strike(s, t_exp,
-                                      self._rd[index0],
-                                      self._rf[index0],
+                                      self.rd[index0],
+                                      self.rf[index0],
                                       OptionTypes.EUROPEAN_CALL.value,
                                       vol_type_value,
                                       call_delta,
                                       delta_method_value,
                                       initial_guess,
-                                      self._parameters[index0],
-                                      self._strikes[index0],
-                                      self._gaps[index0])
+                                      self.parameters[index0],
+                                      self.strikes[index0],
+                                      self.gaps[index0])
 
         if index1 != index0:
 
             K1 = _solver_for_smile_strike(s, t_exp,
-                                          self._rd[index1],
-                                          self._rf[index1],
+                                          self.rd[index1],
+                                          self.rf[index1],
                                           OptionTypes.EUROPEAN_CALL.value,
                                           vol_type_value, call_delta,
                                           delta_method_value,
                                           initial_guess,
-                                          self._parameters[index1],
-                                          self._strikes[index1],
-                                          self._gaps[index1])
+                                          self.parameters[index1],
+                                          self.strikes[index1],
+                                          self.gaps[index1])
         else:
 
             K1 = K0
 
         # In the expiry time dimension, both volatilities are interpolated
         # at the same strikes but different deltas.
 
@@ -1187,108 +1187,108 @@
 
             K = K1
 
         return K
 
 ###############################################################################
 
-    def vol_from_delta_dt(self, call_delta,
-                            expiry_dt,
-                            delta_method=None):
+    def vol_from_delta_date(self, call_delta,
+                          expiry_dt,
+                          delta_method=None):
         """ Interpolates the Black-Scholes volatility from the volatility
         surface given a call option delta and expiry date. Linear interpolation
         is done in variance space. The smile strikes at bracketed dates are
         determined by determining the strike that reproduces the provided delta
         value. This uses the calibration delta convention, but it can be
         overriden by a provided delta convention. The resulting volatilities
         are then determined for each bracketing expiry time and linear
         interpolation is done in variance space and then converted back to a
         lognormal volatility."""
 
-        t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+        t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-        vol_type_value = self._vol_func_type.value
+        vol_type_value = self.vol_func_type.value
 
-        s = self._spot_fx_rate
+        s = self.spot_fx_rate
 
         if delta_method is None:
-            delta_method_value = self._delta_method.value
+            delta_method_value = self.delta_method.value
         else:
             delta_method_value = delta_method.value
 
         index0 = 0  # lower index in bracket
         index1 = 0  # upper index in bracket
 
-        num_curves = self._num_vol_curves
+        num_curves = self.num_vol_curves
 
         # If there is only one time horizon then assume flat vol to this time
         if num_curves == 1:
 
             index0 = 0
             index1 = 0
 
         # If the time is below first time then assume a flat vol
-        elif t_exp <= self._t_exp[0]:
+        elif t_exp <= self.t_exp[0]:
 
             index0 = 0
             index1 = 0
 
         # If the time is beyond the last time then extrapolate with a flat vol
-        elif t_exp > self._t_exp[-1]:
+        elif t_exp > self.t_exp[-1]:
 
-            index0 = len(self._t_exp) - 1
-            index1 = len(self._t_exp) - 1
+            index0 = len(self.t_exp) - 1
+            index1 = len(self.t_exp) - 1
 
         else:  # Otherwise we look for bracketing times and interpolate
 
             for i in range(1, num_curves):
 
-                if t_exp <= self._t_exp[i] and t_exp > self._t_exp[i-1]:
+                if t_exp <= self.t_exp[i] and t_exp > self.t_exp[i-1]:
                     index0 = i-1
                     index1 = i
                     break
 
-        fwd0 = self._F0T[index0]
-        fwd1 = self._F0T[index1]
+        fwd0 = self.fwd[index0]
+        fwd1 = self.fwd[index1]
 
-        t0 = self._t_exp[index0]
-        t1 = self._t_exp[index1]
+        t0 = self.t_exp[index0]
+        t1 = self.t_exp[index1]
 
-        initial_guess = self._K_ATM[index0]
+        initial_guess = self.k_atm[index0]
 
         K0 = _solver_for_smile_strike(s, t_exp,
-                                      self._rd[index0],
-                                      self._rf[index0],
+                                      self.rd[index0],
+                                      self.rf[index0],
                                       OptionTypes.EUROPEAN_CALL.value,
                                       vol_type_value, call_delta,
                                       delta_method_value,
                                       initial_guess,
-                                      self._parameters[index0],
-                                      self._strikes[index0],
-                                      self._gaps[index0])
+                                      self.parameters[index0],
+                                      self.strikes[index0],
+                                      self.gaps[index0])
 
-        vol0 = vol_function(vol_type_value, self._parameters[index0],
-                            self._strikes[index0], self._gaps[index0],
+        vol0 = vol_function(vol_type_value, self.parameters[index0],
+                            self.strikes[index0], self.gaps[index0],
                             fwd0, K0, t0)
 
         if index1 != index0:
 
             K1 = _solver_for_smile_strike(s, t_exp,
-                                          self._rd[index1],
-                                          self._rf[index1],
+                                          self.rd[index1],
+                                          self.rf[index1],
                                           OptionTypes.EUROPEAN_CALL.value,
                                           vol_type_value, call_delta,
                                           delta_method_value,
                                           initial_guess,
-                                          self._parameters[index1],
-                                          self._strikes[index1],
-                                          self._gaps[index1])
+                                          self.parameters[index1],
+                                          self.strikes[index1],
+                                          self.gaps[index1])
 
-            vol1 = vol_function(vol_type_value, self._parameters[index1],
-                                self._strikes[index1], self._gaps[index1],
+            vol1 = vol_function(vol_type_value, self.parameters[index1],
+                                self.strikes[index1], self.gaps[index1],
                                 fwd1, K1, t1)
         else:
             vol1 = vol0
 
         # In the expiry time dimension, both volatilities are interpolated
         # at the same strikes but different deltas.
         vart0 = vol0*vol0*t0
@@ -1310,795 +1310,800 @@
             volt = vol0
             kt = K0
 
         return volt, kt
 
 ###############################################################################
 
-    def _build_vol_surface(self, finSolverType=FinSolverTypes.NELDER_MEAD,
+    def _build_vol_surface(self, fin_solver_type=FinSolverTypes.NELDER_MEAD,
                            tol=1e-8):
         """ Main function to construct the vol surface. """
 
-        s = self._spot_fx_rate
-        num_vol_curves = self._num_vol_curves
+        s = self.spot_fx_rate
+        num_vol_curves = self.num_vol_curves
 
-        if self._vol_func_type == VolFuncTypes.CLARK:
+        if self.vol_func_type == VolFuncTypes.CLARK:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.SABR:
+        elif self.vol_func_type == VolFuncTypes.SABR:
             num_parameters = 4
-        elif self._vol_func_type == VolFuncTypes.SABR_BETA_ONE:
+        elif self.vol_func_type == VolFuncTypes.SABR_BETA_ONE:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.SABR_BETA_HALF:
+        elif self.vol_func_type == VolFuncTypes.SABR_BETA_HALF:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.BBG:
+        elif self.vol_func_type == VolFuncTypes.BBG:
             num_parameters = 3
-        elif self._vol_func_type == VolFuncTypes.CLARK5:
+        elif self.vol_func_type == VolFuncTypes.CLARK5:
             num_parameters = 5
         else:
-            print(self._vol_func_type)
+            print(self.vol_func_type)
             raise FinError("Unknown Model Type")
 
-        self._parameters = np.zeros([num_vol_curves, num_parameters])
+        self.parameters = np.zeros([num_vol_curves, num_parameters])
 
         num_strikes = 5
-        self._strikes = np.zeros([num_vol_curves, num_strikes])
-        self._gaps = np.zeros([num_vol_curves, num_strikes])
+        self.strikes = np.zeros([num_vol_curves, num_strikes])
+        self.gaps = np.zeros([num_vol_curves, num_strikes])
 
-        self._t_exp = np.zeros(num_vol_curves)
+        self.t_exp = np.zeros(num_vol_curves)
 
-        self._F0T = np.zeros(num_vol_curves)
-        self._rd = np.zeros(num_vol_curves)
-        self._rf = np.zeros(num_vol_curves)
-        self._K_ATM = np.zeros(num_vol_curves)
-        self._deltaATM = np.zeros(num_vol_curves)
-
-        self._K_25D_C = np.zeros(num_vol_curves)
-        self._K_25D_P = np.zeros(num_vol_curves)
-        self._K_25D_C_MS = np.zeros(num_vol_curves)
-        self._K_25D_P_MS = np.zeros(num_vol_curves)
-        self._V_25D_MS = np.zeros(num_vol_curves)
-
-        self._K_10D_C = np.zeros(num_vol_curves)
-        self._K_10D_P = np.zeros(num_vol_curves)
-        self._K_10D_C_MS = np.zeros(num_vol_curves)
-        self._K_10D_P_MS = np.zeros(num_vol_curves)
-        self._V_10D_MS = np.zeros(num_vol_curves)
+        self.fwd = np.zeros(num_vol_curves)
+        self.rd = np.zeros(num_vol_curves)
+        self.rf = np.zeros(num_vol_curves)
+        self.k_atm = np.zeros(num_vol_curves)
+        self.deltaATM = np.zeros(num_vol_curves)
+
+        self.k_25d_c = np.zeros(num_vol_curves)
+        self.k_25d_p = np.zeros(num_vol_curves)
+        self.k_25d_c_ms = np.zeros(num_vol_curves)
+        self.k_25d_p_ms = np.zeros(num_vol_curves)
+        self.v_25d_ms = np.zeros(num_vol_curves)
+
+        self.k_10d_c = np.zeros(num_vol_curves)
+        self.k_10d_p = np.zeros(num_vol_curves)
+        self.k_10d_c_ms = np.zeros(num_vol_curves)
+        self.k_10d_p_ms = np.zeros(num_vol_curves)
+        self.v_10d_ms = np.zeros(num_vol_curves)
 
         #######################################################################
         # TODO: ADD SPOT DAYS
         #######################################################################
 
-        spot_dt = self._value_dt
+        spot_dt = self.value_dt
 
         for i in range(0, num_vol_curves):
 
-            expiry_dt = self._expiry_dts[i]
+            expiry_dt = self.expiry_dts[i]
             t_exp = (expiry_dt - spot_dt) / gDaysInYear
 
-            dom_df = self._dom_discount_curve.df(expiry_dt)
-            for_df = self._for_discount_curve.df(expiry_dt)
+            dom_df = self.domestic_curve.df(expiry_dt)
+            for_df = self.foreign_curve.df(expiry_dt)
             f = s * for_df / dom_df
 
-            self._t_exp[i] = t_exp
-            self._rd[i] = -np.log(dom_df) / t_exp
-            self._rf[i] = -np.log(for_df) / t_exp
-            self._F0T[i] = f
+            self.t_exp[i] = t_exp
+            self.rd[i] = -np.log(dom_df) / t_exp
+            self.rf[i] = -np.log(for_df) / t_exp
+            self.fwd[i] = f
 
-            atm_vol = self._atm_vols[i]
+            atm_vol = self.atm_vols[i]
 
             # This follows exposition in Clarke Page 52
-            if self._atmMethod == FinFXATMMethod.SPOT:
-                self._K_ATM[i] = s
-            elif self._atmMethod == FinFXATMMethod.FWD:
-                self._K_ATM[i] = f
-            elif self._atmMethod == FinFXATMMethod.FWD_DELTA_NEUTRAL:
-                self._K_ATM[i] = f * np.exp(atm_vol*atm_vol*t_exp/2.0)
-            elif self._atmMethod == FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ:
-                self._K_ATM[i] = f * np.exp(-atm_vol*atm_vol*t_exp/2.0)
+            if self.atm_method == FinFXATMMethod.SPOT:
+                self.k_atm[i] = s
+            elif self.atm_method == FinFXATMMethod.FWD:
+                self.k_atm[i] = f
+            elif self.atm_method == FinFXATMMethod.FWD_DELTA_NEUTRAL:
+                self.k_atm[i] = f * np.exp(atm_vol*atm_vol*t_exp/2.0)
+            elif self.atm_method == FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ:
+                self.k_atm[i] = f * np.exp(-atm_vol*atm_vol*t_exp/2.0)
             else:
                 raise FinError("Unknown Delta Type")
 
         #######################################################################
         # THE ACTUAL COMPUTATION LOOP STARTS HERE
         #######################################################################
 
         ginit = np.array([0.0, 0.0, 0.0, 0.0, 0.0])
 
         x_inits = []
         ginits = []
+
         for i in range(0, num_vol_curves):
 
-            atm_vol = self._atm_vols[i]
+            atm_vol = self.atm_vols[i]
 
-            if self._usems_25d_vol > 0:
-                ms25 = self._ms25DeltaVols[i]
+            if self.use_ms_25d_vol > 0:
+                
+                if len(self.ms_25_delta_vols) == 0:
+                    x = 1
+                    
+                ms25 = self.ms_25_delta_vols[i]
             else:
                 ms25 = 0.0
 
-            if self._userr_25d_vol > 0:
-                rr25 = self._rr25DeltaVols[i]
+            if self.use_rr_25d_vol > 0:
+                rr25 = self.rr_25_delta_vols[i]
             else:
                 rr25 = 0.0
 
-            if self._usems_10d_vol > 0:
-                ms10 = self._ms10DeltaVols[i]
+            if self.use_ms_10d_vol > 0:
+                ms10 = self.ms_10_delta_vols[i]
             else:
                 ms10 = 0.0
 
-            if self._userr_10d_vol > 0:
-                rr10 = self._rr10DeltaVols[i]
+            if self.use_rr_10d_vol > 0:
+                rr10 = self.rr_10_delta_vols[i]
             else:
                 rr10 = 0.0
 
             # https://quantpie.co.uk/fx/fx_rr_str.php
-            s25 = atm_vol + ms25 + rr25/2.0  # 25D Call
+            s25 = atm_vol + ms25 + rr25/2.0  # 25d Call
             s50 = atm_vol                   # ATM
-            s75 = atm_vol + ms25 - rr25/2.0  # 25D Put (75D Call)
+            s75 = atm_vol + ms25 - rr25/2.0  # 25d Put (75D Call)
 
-            s10 = atm_vol + ms10 + rr10/2.0  # 10D Call
+            s10 = atm_vol + ms10 + rr10/2.0  # 10d Call
             s50 = atm_vol                   # ATM
-            s90 = atm_vol + ms10 - rr10/2.0  # 10D Put (90D Call)
+            s90 = atm_vol + ms10 - rr10/2.0  # 10d Put (90D Call)
 
-            if self._vol_func_type == VolFuncTypes.CLARK:
+            if self.vol_func_type == VolFuncTypes.CLARK:
 
-                # Our preference is to fit to the 10D wings first
-                if self._usems_10d_vol is False:
-                    # Fit to 25D
+                # Our preference is to fit to the 10d wings first
+                if self.use_ms_10d_vol is False:
+                    # Fit to 25d
                     c0 = np.log(atm_vol)
                     c1 = 2.0 * np.log(s75/s25)
                     c2 = 8.0 * np.log(s25*s75/atm_vol/atm_vol)
                     x_init = [c0, c1, c2]
                 else:
-                    # Fit to 10D
+                    # Fit to 10d
                     c0 = np.log(atm_vol)
                     c1 = np.log(s90/s10) / 0.80
                     c2 = np.log(s10*s90/atm_vol/atm_vol) / 0.32
                     x_init = [c0, c1, c2]
 
-            elif self._vol_func_type == VolFuncTypes.SABR:
+            elif self.vol_func_type == VolFuncTypes.SABR:
                 # SABR parameters are alpha, nu, rho
                 # SABR parameters are alpha, nu, rho
                 alpha = 0.174
                 beta = 1.0
                 rho = -0.112
                 nu = 0.817
 
                 x_init = [alpha, beta, rho, nu]
 
-            elif self._vol_func_type == VolFuncTypes.SABR_BETA_ONE:
+            elif self.vol_func_type == VolFuncTypes.SABR_BETA_ONE:
                 # SABR parameters are alpha, nu, rho
                 alpha = 0.174
                 beta = 1.0  # FIXED
                 rho = -0.112
                 nu = 0.817
 
                 x_init = [alpha, rho, nu]
 
-            elif self._vol_func_type == VolFuncTypes.SABR_BETA_HALF:
+            elif self.vol_func_type == VolFuncTypes.SABR_BETA_HALF:
                 # SABR parameters are alpha, nu, rho
                 alpha = 0.174
                 beta = 0.50  # FIXED
                 rho = -0.112
                 nu = 0.817
 
                 x_init = [alpha, rho, nu]
 
-            elif self._vol_func_type == VolFuncTypes.BBG:
+            elif self.vol_func_type == VolFuncTypes.BBG:
 
-                # Our preference is to fit to the 10D wings first
-                if self._usems_10d_vol is False:
-                    # BBG Params if we fit to 25D
+                # Our preference is to fit to the 10d wings first
+                if self.use_ms_10d_vol is False:
+                    # BBG Params if we fit to 25d
                     a = 8.0*s75-16.0*s50+8.0*s25
                     b = -6.0*s75+16.0*s50-10.0*s25
                     c = s75-3.0*s50+3.0*s25
                 else:
-                    # BBG Params if we fit to 10D
+                    # BBG Params if we fit to 10d
                     a = (25.0*s90 - 50.0*s50 + 25.0*s10) / 8.0
                     b = (-15.0*s90 + 50.0*s50 - 35.0*s10) / 8.0
                     c = (5.0*s90 - 18.0*s50 + 45.0*s10) / 32.0
 
                 x_init = [a, b, c]
 
-            elif self._vol_func_type == VolFuncTypes.CLARK5:
+            elif self.vol_func_type == VolFuncTypes.CLARK5:
 
-                # Our preference is to fit to the 10D wings first
-                if self._usems_10d_vol is False:
-                    # Fit to 25D
+                # Our preference is to fit to the 10d wings first
+                if self.use_ms_10d_vol is False:
+                    # Fit to 25d
                     c0 = np.log(atm_vol)
                     c1 = 2.0 * np.log(s75/s25)
                     c2 = 8.0 * np.log(s25*s75/atm_vol/atm_vol)
                     x_init = [c0, c1, c2, 0.0, 0.0]
                 else:
-                    # Fit to 10D
+                    # Fit to 10d
                     c0 = np.log(atm_vol)
                     c1 = np.log(s90/s10) / 0.80
                     c2 = np.log(s10*s90/atm_vol/atm_vol) / 0.32
                     x_init = [c0, c1, c2, 0.0, 0.0]
 
             else:
                 raise FinError("Unknown Model Type")
 
             x_inits.append(x_init)
             ginits.append(ginit)
 
-        delta_method_value = self._delta_method.value
-        vol_type_value = self._vol_func_type.value
+        delta_method_value = self.delta_method.value
+        vol_type_value = self.vol_func_type.value
 
         for i in range(0, num_vol_curves):
 
-            t = self._t_exp[i]
-            r_d = self._rd[i]
-            r_f = self._rf[i]
-            K_ATM = self._K_ATM[i]
-            atm_vol = self._atm_vols[i]
+            t = self.t_exp[i]
+            r_d = self.rd[i]
+            r_f = self.rf[i]
+            k_atm = self.k_atm[i]
+            atm_vol = self.atm_vols[i]
 
             # If the data has not been provided, pass a dummy value
             # as I don't want more arguments and Numpy needs floats
-            if self._usems_25d_vol:
-                ms_25d_vol = self._ms25DeltaVols[i]
-                rr_25d_vol = self._rr25DeltaVols[i]
+            if self.use_ms_25d_vol:
+                ms_25d_vol = self.ms_25_delta_vols[i]
+                rr_25d_vol = self.rr_25_delta_vols[i]
             else:
                 ms_25d_vol = -999.0
                 rr_25d_vol = -999.0
 
-            if self._usems_10d_vol:
-                ms_10d_vol = self._ms10DeltaVols[i]
-                rr_10d_vol = self._rr10DeltaVols[i]
+            if self.use_ms_10d_vol:
+                ms_10d_vol = self.ms_10_delta_vols[i]
+                rr_10d_vol = self.rr_10_delta_vols[i]
             else:
                 ms_10d_vol = -999.0
                 rr_10d_vol = -999.0
 
             res = _solve_to_horizon(s, t, r_d, r_f,
-                                    K_ATM, atm_vol,
+                                    k_atm, atm_vol,
                                     ms_25d_vol, rr_25d_vol,
                                     ms_10d_vol, rr_10d_vol,
                                     delta_method_value, vol_type_value,
-                                    self._alpha,
+                                    self.alpha,
                                     x_inits[i],
                                     ginits[i],
-                                    finSolverType,
+                                    fin_solver_type,
                                     tol)
 
-            (self._parameters[i, :], self._strikes[i, :], self._gaps[i:],
-             self._K_25D_C_MS[i], self._K_25D_P_MS[i],
-             self._K_25D_C[i], self._K_25D_P[i],
-             self._K_10D_C_MS[i], self._K_10D_P_MS[i],
-             self._K_10D_C[i], self._K_10D_P[i]
+            (self.parameters[i, :], self.strikes[i, :], self.gaps[i:],
+             self.k_25d_c_ms[i], self.k_25d_p_ms[i],
+             self.k_25d_c[i], self.k_25d_p[i],
+             self.k_10d_c_ms[i], self.k_10d_p_ms[i],
+             self.k_10d_c[i], self.k_10d_p[i]
              ) = res
 
 ###############################################################################
 
     def check_calibration(self, verbose: bool, tol: float = 1e-6):
         """ Compare calibrated vol surface with market and output a report
         which sets out the quality of fit to the ATM and 10 and 25 delta market
         strangles and risk reversals. """
 
         if verbose:
 
             print("==========================================================")
-            print("VALUE DATE:", self._value_dt)
-            print("SPOT FX RATE:", self._spot_fx_rate)
-            print("ALPHA WEIGHT:", self._alpha)
-            print("ATM METHOD:", self._atmMethod)
-            print("DELTA METHOD:", self._delta_method)
+            print("VALUE DATE:", self.value_dt)
+            print("SPOT FX RATE:", self.spot_fx_rate)
+            print("ALPHA WEIGHT:", self.alpha)
+            print("ATM METHOD:", self.atm_method)
+            print("DELTA METHOD:", self.delta_method)
             print("==========================================================")
 
-        K_dummy = 999
+        k_dummy = 999
 
-        for i in range(0, self._num_vol_curves):
+        for i in range(0, self.num_vol_curves):
 
-            expiry_dt = self._expiry_dts[i]
+            expiry_dt = self.expiry_dts[i]
 
             if verbose:
-                print("TENOR:", self._tenors[i])
+                print("TENOR:", self.tenors[i])
                 print("EXPIRY DATE:", expiry_dt)
                 print("IN ATM VOL: %9.6f %%" %
-                      (100.0*self._atm_vols[i]))
+                      (100.0*self.atm_vols[i]))
 
-                if self._usems_25d_vol:
-                    print("IN MKT STRANGLE 25D VOL: %9.6f %%" %
-                          (100.0*self._ms25DeltaVols[i]))
-                    print("IN RSK REVERSAL 25D VOL: %9.6f %%" %
-                          (100.0*self._rr25DeltaVols[i]))
-
-                if self._usems_10d_vol:
-                    print("IN MKT STRANGLE 10D VOL: %9.6f %%" %
-                          (100.0*self._ms10DeltaVols[i]))
-                    print("IN RSK REVERSAL 10D VOL: %9.6f %%" %
-                          (100.0*self._rr10DeltaVols[i]))
+                if self.use_ms_25d_vol:
+                    print("IN MKT STRANGLE 25d VOL: %9.6f %%" %
+                          (100.0*self.ms_25_delta_vols[i]))
+                    print("IN RSK REVERSAL 25d VOL: %9.6f %%" %
+                          (100.0*self.rr_25_delta_vols[i]))
+
+                if self.use_ms_10d_vol:
+                    print("IN MKT STRANGLE 10d VOL: %9.6f %%" %
+                          (100.0*self.ms_10_delta_vols[i]))
+                    print("IN RSK REVERSAL 10d VOL: %9.6f %%" %
+                          (100.0*self.rr_10_delta_vols[i]))
 
             call = FXVanillaOption(expiry_dt,
-                                   K_dummy,
-                                   self._currency_pair,
+                                   k_dummy,
+                                   self.currency_pair,
                                    OptionTypes.EUROPEAN_CALL,
                                    1.0,
-                                   self._notional_currency, )
+                                   self.notional_currency, )
 
             put = FXVanillaOption(expiry_dt,
-                                  K_dummy,
-                                  self._currency_pair,
+                                  k_dummy,
+                                  self.currency_pair,
                                   OptionTypes.EUROPEAN_PUT,
                                   1.0,
-                                  self._notional_currency)
+                                  self.notional_currency)
 
             ###################################################################
             # AT THE MONEY
             ###################################################################
 
             if verbose:
                 print("======================================================")
-                print("T_(YEARS): ", self._t_exp[i])
-                print("CNT_CPD_RD:%9.6f %%" % (self._rd[i]*100))
-                print("CNT_CPD_RF:%9.6f %%" % (self._rf[i]*100))
-                print("FWD_RATE:  %9.6f" % (self._F0T[i]))
-
-            sigma_ATM_out = vol_function(self._vol_func_type.value,
-                                         self._parameters[i],
-                                         self._strikes[i],
-                                         self._gaps[i],
-                                         self._F0T[i],
-                                         self._K_ATM[i],
-                                         self._t_exp[i])
+                print("T_(YEARS): ", self.t_exp[i])
+                print("CNT_cPD_RD:%9.6f %%" % (self.rd[i]*100))
+                print("CNT_cPD_RF:%9.6f %%" % (self.rf[i]*100))
+                print("FWD_RATE:  %9.6f" % (self.fwd[i]))
+
+            sigma_ATM_out = vol_function(self.vol_func_type.value,
+                                         self.parameters[i],
+                                         self.strikes[i],
+                                         self.gaps[i],
+                                         self.fwd[i],
+                                         self.k_atm[i],
+                                         self.t_exp[i])
 
             if verbose:
                 print("======================================================")
-                print("VOL FUNCTION", self._vol_func_type)
-                print("VOL_PARAMETERS:", self._parameters[i])
+                print("VOL FUNCTION", self.vol_func_type)
+                print("VOL_pARAMETERS:", self.parameters[i])
                 print("======================================================")
-                print("OUT_K_ATM:  %9.6f" % (self._K_ATM[i]))
+                print("OUT_k_atm:  %9.6f" % (self.k_atm[i]))
                 print("OUT_ATM_VOL: %9.6f %%"
                       % (100.0*sigma_ATM_out))
 
-            diff = sigma_ATM_out - self._atm_vols[i]
+            diff = sigma_ATM_out - self.atm_vols[i]
 
             if np.abs(diff) > tol:
                 print("FAILED FIT TO ATM VOL IN: %9.6f  OUT: %9.6f  DIFF: %9.6f" %
-                      (self._atm_vols[i]*100.0, sigma_ATM_out*100.0,
+                      (self.atm_vols[i]*100.0, sigma_ATM_out*100.0,
                        diff * 100.0))
 
-            call._strike_fx_rate = self._K_ATM[i]
-            put._strike_fx_rate = self._K_ATM[i]
+            call.strike_fx_rate = self.k_atm[i]
+            put.strike_fx_rate = self.k_atm[i]
 
             model = BlackScholes(sigma_ATM_out)
 
-            delta_call = call.delta(self._value_dt,
-                                    self._spot_fx_rate,
-                                    self._dom_discount_curve,
-                                    self._for_discount_curve,
-                                    model)[self._delta_method_string]
-
-            delta_put = put.delta(self._value_dt,
-                                  self._spot_fx_rate,
-                                  self._dom_discount_curve,
-                                  self._for_discount_curve,
-                                  model)[self._delta_method_string]
+            delta_call = call.delta(self.value_dt,
+                                    self.spot_fx_rate,
+                                    self.domestic_curve,
+                                    self.foreign_curve,
+                                    model)[self.delta_method_string]
+
+            delta_put = put.delta(self.value_dt,
+                                  self.spot_fx_rate,
+                                  self.domestic_curve,
+                                  self.foreign_curve,
+                                  model)[self.delta_method_string]
 
             if verbose:
                 print("CALL_DELTA: % 9.6f  PUT_DELTA: % 9.6f  NET_DELTA: % 9.6f"
                       % (delta_call, delta_put, delta_call + delta_put))
 
             ###################################################################
             # NOW WE ASSIGN THE SAME VOLATILITY TO THE MS STRIKES
             # THESE STRIKES ARE DETERMINED BY SETTING DELTA TO 0.25/-0.25
             ###################################################################
 
-            if self._usems_25d_vol is True:
+            if self.use_ms_25d_vol is True:
 
-                ms_vol = self._atm_vols[i] + self._ms25DeltaVols[i]
+                ms_vol = self.atm_vols[i] + self.ms_25_delta_vols[i]
 
                 if verbose:
 
                     print("==================================================")
-                    print("MKT STRANGLE 25D VOL IN: %9.6f %%"
-                          % (100.0*self._ms25DeltaVols[i]))
+                    print("MKT STRANGLE 25d VOL IN: %9.6f %%"
+                          % (100.0*self.ms_25_delta_vols[i]))
 
-                call._strike_fx_rate = self._K_25D_C_MS[i]
-                put._strike_fx_rate = self._K_25D_P_MS[i]
+                call.strike_fx_rate = self.k_25d_c_ms[i]
+                put.strike_fx_rate = self.k_25d_p_ms[i]
 
                 model = BlackScholes(ms_vol)
 
-                delta_call = call.delta(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
-                                        model)[self._delta_method_string]
-
-                delta_put = put.delta(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
-                                      model)[self._delta_method_string]
+                delta_call = call.delta(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
+                                        model)[self.delta_method_string]
+
+                delta_put = put.delta(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
+                                      model)[self.delta_method_string]
 
                 if verbose:
-                    print("K_25D_C_MS: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_25D_C_MS[i], 100.0*ms_vol, delta_call))
+                    print("k_25d_c_ms: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_25d_c_ms[i], 100.0*ms_vol, delta_call))
 
-                    print("K_25D_P_MS: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_25D_P_MS[i], 100.0*ms_vol, delta_put))
+                    print("k_25d_p_ms: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_25d_p_ms[i], 100.0*ms_vol, delta_put))
 
-                call_value = call.value(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
+                call_value = call.value(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
                                         model)['v']
 
-                put_value = put.value(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
+                put_value = put.value(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
                                       model)['v']
 
-                mktStrangleValue = call_value + put_value
+                mkt_strangle_value = call_value + put_value
 
                 if verbose:
                     print("CALL_VALUE: %9.6f  PUT_VALUE: %9.6f  MS_VALUE: % 9.6f"
-                          % (call_value, put_value, mktStrangleValue))
+                          % (call_value, put_value, mkt_strangle_value))
 
                 ###############################################################
                 # NOW WE ASSIGN A DIFFERENT VOLATILITY TO THE MS STRIKES
                 # THE DELTAS WILL NO LONGER EQUAL 0.25, -0.25
                 ###############################################################
 
                 # CALL
-                sigma_K_25D_C_MS = vol_function(self._vol_func_type.value,
-                                                self._parameters[i],
-                                                self._strikes[i],
-                                                self._gaps[i],
-                                                self._F0T[i],
-                                                self._K_25D_C_MS[i],
-                                                self._t_exp[i])
-
-                model = BlackScholes(sigma_K_25D_C_MS)
-                call_value = call.value(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
+                sigma_k_25d_c_ms = vol_function(self.vol_func_type.value,
+                                                self.parameters[i],
+                                                self.strikes[i],
+                                                self.gaps[i],
+                                                self.fwd[i],
+                                                self.k_25d_c_ms[i],
+                                                self.t_exp[i])
+
+                model = BlackScholes(sigma_k_25d_c_ms)
+                call_value = call.value(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
                                         model)['v']
 
                 # THIS IS NOT GOING TO BE 0.25 AS WE USED A DIFFERENT SKEW VOL
-                delta_call = call.delta(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
-                                        model)[self._delta_method_string]
+                delta_call = call.delta(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
+                                        model)[self.delta_method_string]
 
                 # PUT
-                sigma_K_25D_P_MS = vol_function(self._vol_func_type.value,
-                                                self._parameters[i],
-                                                self._strikes[i],
-                                                self._gaps[i],
-                                                self._F0T[i],
-                                                self._K_25D_P_MS[i],
-                                                self._t_exp[i])
-
-                model = BlackScholes(sigma_K_25D_P_MS)
-                put_value = put.value(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
+                sigma_k_25d_p_ms = vol_function(self.vol_func_type.value,
+                                                self.parameters[i],
+                                                self.strikes[i],
+                                                self.gaps[i],
+                                                self.fwd[i],
+                                                self.k_25d_p_ms[i],
+                                                self.t_exp[i])
+
+                model = BlackScholes(sigma_k_25d_p_ms)
+                put_value = put.value(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
                                       model)['v']
 
                 # THIS IS NOT GOING TO BE -0.25 AS WE USED A DIFFERENT SKEW VOL
-                delta_put = put.delta(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
-                                      model)[self._delta_method_string]
+                delta_put = put.delta(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
+                                      model)[self.delta_method_string]
 
-                mktStrangleValueSkew = call_value + put_value
+                mkt_strangle_value_skew = call_value + put_value
 
                 if verbose:
-                    print("K_25D_C_MS: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_25D_C_MS[i], 100.0*sigma_K_25D_C_MS, delta_call))
+                    print("k_25d_c_ms: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_25d_c_ms[i], 100.0*sigma_k_25d_c_ms, delta_call))
 
-                    print("K_25D_P_MS: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_25D_P_MS[i], 100.0*sigma_K_25D_P_MS, delta_put))
+                    print("k_25d_p_ms: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_25d_p_ms[i], 100.0*sigma_k_25d_p_ms, delta_put))
 
                     print("CALL_VALUE: %9.6f  PUT_VALUE: %9.6f  MS_SKEW_VALUE: % 9.6f"
-                          % (call_value, put_value, mktStrangleValueSkew))
+                          % (call_value, put_value, mkt_strangle_value_skew))
 
-                diff = mktStrangleValue - mktStrangleValueSkew
+                diff = mkt_strangle_value - mkt_strangle_value_skew
                 if np.abs(diff) > tol:
-                    print("FAILED FIT TO 25D MS VAL: %9.6f  OUT: %9.6f  DIFF: % 9.6f" %
-                          (mktStrangleValue, mktStrangleValueSkew, diff))
+                    print("FAILED FIT TO 25d MS VAL: %9.6f  OUT: %9.6f  DIFF: % 9.6f" %
+                          (mkt_strangle_value, mkt_strangle_value_skew, diff))
 
                 ###############################################################
                 # NOW WE SHIFT STRIKES SO THAT DELTAS NOW EQUAL 0.25, -0.25
                 ###############################################################
 
-                call._strike_fx_rate = self._K_25D_C[i]
-                put._strike_fx_rate = self._K_25D_P[i]
+                call.strike_fx_rate = self.k_25d_c[i]
+                put.strike_fx_rate = self.k_25d_p[i]
 
-                sigma_K_25D_C = vol_function(self._vol_func_type.value,
-                                             self._parameters[i],
-                                             self._strikes[i],
-                                             self._gaps[i],
-                                             self._F0T[i],
-                                             self._K_25D_C[i],
-                                             self._t_exp[i])
+                sigma_k_25d_c = vol_function(self.vol_func_type.value,
+                                             self.parameters[i],
+                                             self.strikes[i],
+                                             self.gaps[i],
+                                             self.fwd[i],
+                                             self.k_25d_c[i],
+                                             self.t_exp[i])
 
-                model = BlackScholes(sigma_K_25D_C)
+                model = BlackScholes(sigma_k_25d_c)
 
                 # THIS DELTA SHOULD BE +0.25
-                delta_call = call.delta(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
-                                        model)[self._delta_method_string]
-
-                sigma_K_25D_P = vol_function(self._vol_func_type.value,
-                                             self._parameters[i],
-                                             self._strikes[i],
-                                             self._gaps[i],
-                                             self._F0T[i],
-                                             self._K_25D_P[i],
-                                             self._t_exp[i])
+                delta_call = call.delta(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
+                                        model)[self.delta_method_string]
+
+                sigma_k_25d_p = vol_function(self.vol_func_type.value,
+                                             self.parameters[i],
+                                             self.strikes[i],
+                                             self.gaps[i],
+                                             self.fwd[i],
+                                             self.k_25d_p[i],
+                                             self.t_exp[i])
 
-                model = BlackScholes(sigma_K_25D_P)
+                model = BlackScholes(sigma_k_25d_p)
 
                 # THIS DELTA SHOULD BE -0.25
-                delta_put = put.delta(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
-                                      model)[self._delta_method_string]
+                delta_put = put.delta(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
+                                      model)[self.delta_method_string]
 
                 if verbose:
-                    print("K_25D_C: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
-                          % (self._K_25D_C[i], 100.0*sigma_K_25D_C, delta_call))
+                    print("k_25d_c: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
+                          % (self.k_25d_c[i], 100.0*sigma_k_25d_c, delta_call))
 
-                    print("K_25D_P: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
-                          % (self._K_25D_P[i], 100.0*sigma_K_25D_P, delta_put))
+                    print("k_25d_p: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
+                          % (self.k_25d_p[i], 100.0*sigma_k_25d_p, delta_put))
 
-                sigma_RR = sigma_K_25D_C - sigma_K_25D_P
+                sigma_RR = sigma_k_25d_c - sigma_k_25d_p
 
                 if verbose:
                     print("==========================================================")
-                    print("RR = VOL_K_25_C - VOL_K_25_P => RR_IN: %9.6f %% RR_OUT: %9.6f %%"
-                          % (100.0 * self._rr25DeltaVols[i], 100.0*sigma_RR))
+                    print("RR = VOL_k_25_c - VOL_k_25_p => RR_IN: %9.6f %% RR_OUT: %9.6f %%"
+                          % (100.0 * self.rr_25_delta_vols[i], 100.0*sigma_RR))
                     print("==========================================================")
 
-                diff = sigma_RR - self._rr25DeltaVols[i]
+                diff = sigma_RR - self.rr_25_delta_vols[i]
 
                 if np.abs(diff) > tol:
-                    print("FAILED FIT TO 25D RRV IN: % 9.6f  OUT: % 9.6f  DIFF: % 9.6f" %
-                          (self._rr25DeltaVols[i]*100.0,
+                    print("FAILED FIT TO 25d RRV IN: % 9.6f  OUT: % 9.6f  DIFF: % 9.6f" %
+                          (self.rr_25_delta_vols[i]*100.0,
                            sigma_RR*100.0,
                            diff*100.0))
 
             ###################################################################
             # NOW WE ASSIGN THE SAME VOLATILITY TO THE MS STRIKES
             # THESE STRIKES ARE DETERMINED BY SETTING DELTA TO 0.10/-0.10
             ###################################################################
 
-            if self._usems_10d_vol:
+            if self.use_ms_10d_vol:
 
-                ms_vol = self._atm_vols[i] + self._ms10DeltaVols[i]
+                ms_vol = self.atm_vols[i] + self.ms_10_delta_vols[i]
 
                 if verbose:
 
                     print("==========================================================")
-                    print("MKT STRANGLE 10D VOL IN: %9.6f %%"
-                          % (100.0*self._ms10DeltaVols[i]))
+                    print("MKT STRANGLE 10d VOL IN: %9.6f %%"
+                          % (100.0*self.ms_10_delta_vols[i]))
 
-                call._strike_fx_rate = self._K_10D_C_MS[i]
-                put._strike_fx_rate = self._K_10D_P_MS[i]
+                call.strike_fx_rate = self.k_10d_c_ms[i]
+                put.strike_fx_rate = self.k_10d_p_ms[i]
 
                 model = BlackScholes(ms_vol)
 
-                delta_call = call.delta(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
-                                        model)[self._delta_method_string]
-
-                delta_put = put.delta(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
-                                      model)[self._delta_method_string]
+                delta_call = call.delta(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
+                                        model)[self.delta_method_string]
+
+                delta_put = put.delta(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
+                                      model)[self.delta_method_string]
 
                 if verbose:
-                    print("K_10D_C_MS: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_10D_C_MS[i], 100.0*ms_vol, delta_call))
+                    print("k_10d_c_ms: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_10d_c_ms[i], 100.0*ms_vol, delta_call))
 
-                    print("K_10D_P_MS: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_10D_P_MS[i], 100.0*ms_vol, delta_put))
+                    print("k_10d_p_ms: %9.6f  ATM + ms_vol: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_10d_p_ms[i], 100.0*ms_vol, delta_put))
 
-                call_value = call.value(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
+                call_value = call.value(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
                                         model)['v']
 
-                put_value = put.value(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
+                put_value = put.value(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
                                       model)['v']
 
-                mktStrangleValue = call_value + put_value
+                mkt_strangle_value = call_value + put_value
 
                 if verbose:
                     print("CALL_VALUE: %9.6f  PUT_VALUE: %9.6f  MS_VALUE: % 9.6f"
-                          % (call_value, put_value, mktStrangleValue))
+                          % (call_value, put_value, mkt_strangle_value))
 
                 ###############################################################
                 # NOW WE ASSIGN A DIFFERENT VOLATILITY TO THE MS STRIKES
                 # THE DELTAS WILL NO LONGER EQUAL 0.25, -0.25
                 ###############################################################
 
                 # CALL
-                sigma_K_10D_C_MS = vol_function(self._vol_func_type.value,
-                                                self._parameters[i],
-                                                self._strikes[i],
-                                                self._gaps[i],
-                                                self._F0T[i],
-                                                self._K_10D_C_MS[i],
-                                                self._t_exp[i])
-
-                model = BlackScholes(sigma_K_10D_C_MS)
-                call_value = call.value(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
+                sigma_k_10d_c_ms = vol_function(self.vol_func_type.value,
+                                                self.parameters[i],
+                                                self.strikes[i],
+                                                self.gaps[i],
+                                                self.fwd[i],
+                                                self.k_10d_c_ms[i],
+                                                self.t_exp[i])
+
+                model = BlackScholes(sigma_k_10d_c_ms)
+                call_value = call.value(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
                                         model)['v']
 
                 # THIS IS NOT GOING TO BE 0.10 AS WE HAVE USED A DIFFERENT SKEW VOL
-                delta_call = call.delta(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
-                                        model)[self._delta_method_string]
+                delta_call = call.delta(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
+                                        model)[self.delta_method_string]
 
                 # PUT
-                sigma_K_10D_P_MS = vol_function(self._vol_func_type.value,
-                                                self._parameters[i],
-                                                self._strikes[i],
-                                                self._gaps[i],
-                                                self._F0T[i],
-                                                self._K_10D_P_MS[i],
-                                                self._t_exp[i])
-
-                model = BlackScholes(sigma_K_10D_P_MS)
-                put_value = put.value(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
+                sigma_k_10d_p_ms = vol_function(self.vol_func_type.value,
+                                                self.parameters[i],
+                                                self.strikes[i],
+                                                self.gaps[i],
+                                                self.fwd[i],
+                                                self.k_10d_p_ms[i],
+                                                self.t_exp[i])
+
+                model = BlackScholes(sigma_k_10d_p_ms)
+                put_value = put.value(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
                                       model)['v']
 
                 # THIS IS NOT GOING TO BE -0.10 AS WE HAVE USED A DIFFERENT SKEW VOL
-                delta_put = put.delta(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
-                                      model)[self._delta_method_string]
+                delta_put = put.delta(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
+                                      model)[self.delta_method_string]
 
-                mktStrangleValueSkew = call_value + put_value
+                mkt_strangle_value_skew = call_value + put_value
 
                 if verbose:
-                    print("K_10D_C_MS: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_10D_C_MS[i], 100.0*sigma_K_10D_C_MS, delta_call))
+                    print("k_10d_c_ms: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_10d_c_ms[i], 100.0*sigma_k_10d_c_ms, delta_call))
 
-                    print("K_10D_P_MS: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
-                          % (self._K_10D_P_MS[i], 100.0*sigma_K_10D_P_MS, delta_put))
+                    print("k_10d_p_ms: %9.6f  SURFACE_VOL: %9.6f %%   DELTA: %9.6f"
+                          % (self.k_10d_p_ms[i], 100.0*sigma_k_10d_p_ms, delta_put))
 
                     print("CALL_VALUE: %9.6f  PUT_VALUE: %9.6f  MS_SKEW_VALUE: % 9.6f"
-                          % (call_value, put_value, mktStrangleValueSkew))
+                          % (call_value, put_value, mkt_strangle_value_skew))
 
-                diff = mktStrangleValue - mktStrangleValueSkew
+                diff = mkt_strangle_value - mkt_strangle_value_skew
                 if np.abs(diff) > tol:
-                    print("FAILED FIT TO 10D MS VAL: %9.6f  OUT: %9.6f  DIFF: % 9.6f" %
-                          (mktStrangleValue, mktStrangleValueSkew, diff))
+                    print("FAILED FIT TO 10d MS VAL: %9.6f  OUT: %9.6f  DIFF: % 9.6f" %
+                          (mkt_strangle_value, mkt_strangle_value_skew, diff))
 
                 ###############################################################
                 # NOW WE SHIFT STRIKES SO THAT DELTAS NOW EQUAL 0.10, -0.10
                 ###############################################################
 
-                call._strike_fx_rate = self._K_10D_C[i]
-                put._strike_fx_rate = self._K_10D_P[i]
+                call.strike_fx_rate = self.k_10d_c[i]
+                put.strike_fx_rate = self.k_10d_p[i]
 
-                sigma_K_10D_C = vol_function(self._vol_func_type.value,
-                                             self._parameters[i],
-                                             self._strikes[i],
-                                             self._gaps[i],
-                                             self._F0T[i],
-                                             self._K_10D_C[i],
-                                             self._t_exp[i])
+                sigma_k_10d_c = vol_function(self.vol_func_type.value,
+                                             self.parameters[i],
+                                             self.strikes[i],
+                                             self.gaps[i],
+                                             self.fwd[i],
+                                             self.k_10d_c[i],
+                                             self.t_exp[i])
 
-                model = BlackScholes(sigma_K_10D_C)
+                model = BlackScholes(sigma_k_10d_c)
 
                 # THIS DELTA SHOULD BE +0.25
-                delta_call = call.delta(self._value_dt,
-                                        self._spot_fx_rate,
-                                        self._dom_discount_curve,
-                                        self._for_discount_curve,
-                                        model)[self._delta_method_string]
-
-                sigma_K_10D_P = vol_function(self._vol_func_type.value,
-                                             self._parameters[i],
-                                             self._strikes[i],
-                                             self._gaps[i],
-                                             self._F0T[i],
-                                             self._K_10D_P[i],
-                                             self._t_exp[i])
+                delta_call = call.delta(self.value_dt,
+                                        self.spot_fx_rate,
+                                        self.domestic_curve,
+                                        self.foreign_curve,
+                                        model)[self.delta_method_string]
+
+                sigma_k_10d_p = vol_function(self.vol_func_type.value,
+                                             self.parameters[i],
+                                             self.strikes[i],
+                                             self.gaps[i],
+                                             self.fwd[i],
+                                             self.k_10d_p[i],
+                                             self.t_exp[i])
 
-                model = BlackScholes(sigma_K_10D_P)
+                model = BlackScholes(sigma_k_10d_p)
 
                 # THIS DELTA SHOULD BE -0.25
-                delta_put = put.delta(self._value_dt,
-                                      self._spot_fx_rate,
-                                      self._dom_discount_curve,
-                                      self._for_discount_curve,
-                                      model)[self._delta_method_string]
+                delta_put = put.delta(self.value_dt,
+                                      self.spot_fx_rate,
+                                      self.domestic_curve,
+                                      self.foreign_curve,
+                                      model)[self.delta_method_string]
 
                 if verbose:
-                    print("K_10D_C: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
-                          % (self._K_10D_C[i], 100.0*sigma_K_10D_C, delta_call))
+                    print("k_10d_c: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
+                          % (self.k_10d_c[i], 100.0*sigma_k_10d_c, delta_call))
 
-                    print("K_10D_P: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
-                          % (self._K_10D_P[i], 100.0*sigma_K_10D_P, delta_put))
+                    print("k_10d_p: %9.7f  VOL: %9.6f  DELTA: % 9.6f"
+                          % (self.k_10d_p[i], 100.0*sigma_k_10d_p, delta_put))
 
-                sigma_RR = sigma_K_10D_C - sigma_K_10D_P
+                sigma_RR = sigma_k_10d_c - sigma_k_10d_p
 
                 if verbose:
                     print("==========================================================")
-                    print("RR = VOL_K_10D_C - VOL_K_10D_P => RR_IN: %9.6f %% RR_OUT: %9.6f %%"
-                          % (100.0 * self._rr10DeltaVols[i], 100.0*sigma_RR))
+                    print("RR = VOL_k_10d_c - VOL_k_10d_p => RR_IN: %9.6f %% RR_OUT: %9.6f %%"
+                          % (100.0 * self.rr_10_delta_vols[i], 100.0*sigma_RR))
                     print("==========================================================")
 
-                diff = sigma_RR - self._rr10DeltaVols[i]
+                diff = sigma_RR - self.rr_10_delta_vols[i]
 
                 if np.abs(diff) > tol:
-                    print("FAILED FIT TO 10D RRV IN: % 9.6f  OUT: % 9.6f  DIFF: % 9.6f" %
-                          (self._rr10DeltaVols[i]*100.0,
+                    print("FAILED FIT TO 10d RRV IN: % 9.6f  OUT: % 9.6f  DIFF: % 9.6f" %
+                          (self.rr_10_delta_vols[i]*100.0,
                            sigma_RR*100.0,
                            diff*100.0))
 
 ###############################################################################
 
     def implied_dbns(self, lowFX, highFX, num_intervals):
         """ Calculate the pdf for each tenor horizon. Returns a list of
         FinDistribution objects, one for each tenor horizon. """
 
         dbns = []
 
-        for iTenor in range(0, len(self._tenors)):
+        for iTenor in range(0, len(self.tenors)):
 
-            f = self._F0T[iTenor]
-            t = self._t_exp[iTenor]
+            f = self.fwd[iTenor]
+            t = self.t_exp[iTenor]
 
             dFX = (highFX - lowFX) / num_intervals
 
-            dom_df = self._dom_discount_curve.df(t)
-            for_df = self._for_discount_curve.df(t)
+            dom_df = self.domestic_curve.df(t)
+            for_df = self.foreign_curve.df(t)
 
             r_d = -np.log(dom_df) / t
             r_f = -np.log(for_df) / t
 
             Ks = []
             vols = []
 
             for iK in range(0, num_intervals):
 
                 k = lowFX + iK*dFX
 
-                vol = vol_function(self._vol_func_type.value,
-                                   self._parameters[iTenor],
-                                   self._strikes[iTenor],
-                                   self._gaps[iTenor],
+                vol = vol_function(self.vol_func_type.value,
+                                   self.parameters[iTenor],
+                                   self.strikes[iTenor],
+                                   self.gaps[iTenor],
                                    f, k, t)
 
                 Ks.append(k)
                 vols.append(vol)
 
             Ks = np.array(Ks)
             vols = np.array(vols)
 
-            density = option_implied_dbn(self._spot_fx_rate, t,
+            density = option_implied_dbn(self.spot_fx_rate, t,
                                          r_d, r_f, Ks, vols)
 
             dbn = FinDistribution(Ks, density)
             dbns.append(dbn)
 
         return dbns
 
@@ -2106,152 +2111,152 @@
 
     def plot_vol_curves(self):
         """ Generates a plot of each of the vol discount implied by the market
         and fitted. """
 
         plt.figure()
 
-        volTypeVal = self._vol_func_type.value
+        vol_type_val = self.vol_func_type.value
 
-        for tenor_index in range(0, self._num_vol_curves):
+        for tenor_index in range(0, self.num_vol_curves):
 
-            atm_vol = self._atm_vols[tenor_index]*100
-            ms_vol25 = self._ms25DeltaVols[tenor_index]*100
-            rrVol25 = self._rr25DeltaVols[tenor_index]*100
-            ms_vol10 = self._ms10DeltaVols[tenor_index]*100
-            rrVol10 = self._rr10DeltaVols[tenor_index]*100
-            strikes = self._strikes[tenor_index]
+            atm_vol = self.atm_vols[tenor_index]*100
+            ms_vol25 = self.ms_25_delta_vols[tenor_index]*100
+            rrVol25 = self.rr_25_delta_vols[tenor_index]*100
+            ms_vol10 = self.ms_10_delta_vols[tenor_index]*100
+            rrVol10 = self.rr_10_delta_vols[tenor_index]*100
+            strikes = self.strikes[tenor_index]
 
-            gaps = self._gaps[tenor_index]
+            gaps = self.gaps[tenor_index]
 
-            lowK = self._K_10D_P[tenor_index] * 0.90
-            highK = self._K_10D_C_MS[tenor_index] * 1.10
+            low_K = self.k_10d_p[tenor_index] * 0.90
+            high_k = self.k_10d_c_ms[tenor_index] * 1.10
 
             ks = []
             vols = []
             num_intervals = 30
-            K = lowK
-            dK = (highK - lowK)/num_intervals
-            params = self._parameters[tenor_index]
-            t = self._t_exp[tenor_index]
-            f = self._F0T[tenor_index]
+            K = low_K
+            dK = (high_k - low_K)/num_intervals
+            params = self.parameters[tenor_index]
+            t = self.t_exp[tenor_index]
+            f = self.fwd[tenor_index]
 
             for i in range(0, num_intervals):
 
-                sigma = vol_function(volTypeVal, params, strikes, gaps,
+                sigma = vol_function(vol_type_val, params, strikes, gaps,
                                      f, K, t) * 100.0
                 ks.append(K)
                 vols.append(sigma)
                 K = K + dK
 
-            label_str = self._tenors[tenor_index]
+            label_str = self.tenors[tenor_index]
             label_str += " ATM: " + str(atm_vol)[0:6]
             label_str += " MS25: " + str(ms_vol25)[0:6]
             label_str += " RR25: " + str(rrVol25)[0:6]
             label_str += " MS10: " + str(ms_vol10)[0:6]
             label_str += " RR10: " + str(rrVol10)[0:6]
 
             plt.plot(ks, vols, label=label_str)
             plt.xlabel("Strike")
             plt.ylabel("Volatility")
 
-            title = "JNT FIT:" + self._currency_pair + " " +\
-                    str(self._vol_func_type)
+            title = "JNT FIT:" + self.currency_pair + " " +\
+                    str(self.vol_func_type)
 
             key_strikes = []
-            key_strikes.append(self._K_ATM[tenor_index])
+            key_strikes.append(self.k_atm[tenor_index])
 
             key_vols = []
             for K in key_strikes:
 
-                sigma = vol_function(volTypeVal, params,
+                sigma = vol_function(vol_type_val, params,
                                      strikes, gaps,
                                      f, K, t) * 100.0
 
                 key_vols.append(sigma)
 
             plt.plot(key_strikes, key_vols, 'ko', markersize=4)
 
             key_strikes = []
-            key_strikes.append(self._K_25D_P[tenor_index])
-            key_strikes.append(self._K_25D_P_MS[tenor_index])
-            key_strikes.append(self._K_25D_C[tenor_index])
-            key_strikes.append(self._K_25D_C_MS[tenor_index])
+            key_strikes.append(self.k_25d_p[tenor_index])
+            key_strikes.append(self.k_25d_p_ms[tenor_index])
+            key_strikes.append(self.k_25d_c[tenor_index])
+            key_strikes.append(self.k_25d_c_ms[tenor_index])
 
             key_vols = []
             for K in key_strikes:
 
-                sigma = vol_function(volTypeVal, params,
+                sigma = vol_function(vol_type_val, params,
                                      strikes, gaps,
                                      f, K, t) * 100.0
 
                 key_vols.append(sigma)
 
             plt.plot(key_strikes, key_vols, 'bo', markersize=4)
 
             key_strikes = []
-            key_strikes.append(self._K_10D_P[tenor_index])
-            key_strikes.append(self._K_10D_P_MS[tenor_index])
-            key_strikes.append(self._K_10D_C[tenor_index])
-            key_strikes.append(self._K_10D_C_MS[tenor_index])
+            key_strikes.append(self.k_10d_p[tenor_index])
+            key_strikes.append(self.k_10d_p_ms[tenor_index])
+            key_strikes.append(self.k_10d_c[tenor_index])
+            key_strikes.append(self.k_10d_c_ms[tenor_index])
 
             key_vols = []
             for K in key_strikes:
-                sigma = vol_function(volTypeVal, params,
+                sigma = vol_function(vol_type_val, params,
                                      strikes, gaps,
                                      f, K, t) * 100.0
                 key_vols.append(sigma)
 
             plt.plot(key_strikes, key_vols, 'ro', markersize=4)
 
         plt.title(title)
         plt.legend(loc="lower left", bbox_to_anchor=(1, 0))
 
 ###############################################################################
 
     def __repr__(self):
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUE DATE", self._value_dt)
-        s += label_to_string("FX RATE", self._spot_fx_rate)
-        s += label_to_string("CCY PAIR", self._currency_pair)
-        s += label_to_string("NOTIONAL CCY", self._notional_currency)
-        s += label_to_string("NUM TENORS", self._num_vol_curves)
-        s += label_to_string("ATM METHOD", self._atmMethod)
-        s += label_to_string("DELTA METHOD", self._delta_method)
-        s += label_to_string("ALPHA WEIGHT", self._alpha)
-        s += label_to_string("VOL FUNCTION", self._vol_func_type)
+        s = label_to_string("OBJECT TYPE", type(self)._name__)
+        s += label_to_string("VALUE DATE", self.value_dt)
+        s += label_to_string("FX RATE", self.spot_fx_rate)
+        s += label_to_string("CCY PAIR", self.currency_pair)
+        s += label_to_string("NOTIONAL CCY", self.notional_currency)
+        s += label_to_string("NUM TENORS", self.num_vol_curves)
+        s += label_to_string("ATM METHOD", self.atm_method)
+        s += label_to_string("DELTA METHOD", self.delta_method)
+        s += label_to_string("ALPHA WEIGHT", self.alpha)
+        s += label_to_string("VOL FUNCTION", self.vol_func_type)
 
-        for i in range(0, self._num_vol_curves):
+        for i in range(0, self.num_vol_curves):
 
             s += "\n"
 
-            s += label_to_string("TENOR", self._tenors[i])
-            s += label_to_string("EXPIRY DATE", self._expiry_dts[i])
-            s += label_to_string("TIME (YRS)", self._t_exp[i])
-            s += label_to_string("FWD FX", self._F0T[i])
-
-            s += label_to_string("ATM VOLS", self._atm_vols[i]*100.0)
-            s += label_to_string("MS VOLS", self._ms25DeltaVols[i]*100.)
-            s += label_to_string("RR VOLS", self._rr25DeltaVols[i]*100.)
-
-            s += label_to_string("ATM Strike", self._K_ATM[i])
-            s += label_to_string("ATM Delta", self._deltaATM[i])
-
-            s += label_to_string("K_ATM", self._K_ATM[i])
-
-            s += label_to_string("MS 25D Call Strike", self._K_25D_C_MS[i])
-            s += label_to_string("MS 25D Put Strike", self._K_25D_P_MS[i])
-            s += label_to_string("SKEW 25D CALL STRIKE", self._K_25D_C[i])
-            s += label_to_string("SKEW 25D PUT STRIKE", self._K_25D_P[i])
-            s += label_to_string("PARAMS", self._parameters[i])
-
-            s += label_to_string("MS 10D Call Strike", self._K_10D_C_MS[i])
-            s += label_to_string("MS 10D Put Strike", self._K_10D_P_MS[i])
-            s += label_to_string("SKEW 10D CALL STRIKE", self._K_10D_C[i])
-            s += label_to_string("SKEW 10D PUT STRIKE", self._K_10D_P[i])
+            s += label_to_string("TENOR", self.tenors[i])
+            s += label_to_string("EXPIRY DATE", self.expiry_dts[i])
+            s += label_to_string("TIME (YRS)", self.t_exp[i])
+            s += label_to_string("FWD FX", self.fwd[i])
+
+            s += label_to_string("ATM VOLS", self.atm_vols[i]*100.0)
+            s += label_to_string("MS VOLS", self.ms_25_delta_vols[i]*100.)
+            s += label_to_string("RR VOLS", self.rr_25_delta_vols[i]*100.)
+
+            s += label_to_string("ATM Strike", self.k_atm[i])
+            s += label_to_string("ATM Delta", self.deltaATM[i])
+
+            s += label_to_string("k_atm", self.k_atm[i])
+
+            s += label_to_string("MS 25d Call Strike", self.k_25d_c_ms[i])
+            s += label_to_string("MS 25d Put Strike", self.k_25d_p_ms[i])
+            s += label_to_string("SKEW 25d CALL STRIKE", self.k_25d_c[i])
+            s += label_to_string("SKEW 25d PUT STRIKE", self.k_25d_p[i])
+            s += label_to_string("PARAMS", self.parameters[i])
+
+            s += label_to_string("MS 10d Call Strike", self.k_10d_c_ms[i])
+            s += label_to_string("MS 10d Put Strike", self.k_10d_p_ms[i])
+            s += label_to_string("SKEW 10d CALL STRIKE", self.k_10d_c[i])
+            s += label_to_string("SKEW 10d PUT STRIKE", self.k_10d_p[i])
 
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Print a list of the unadjusted coupon payment dates used in
```

### Comparing `financepy-0.350/financepy/market/volatility/ibor_cap_vol_curve.py` & `financepy-0.360/financepy/market/volatility/ibor_cap_vol_curve.py`

 * *Files 11% similar despite different names*

```diff
@@ -53,14 +53,15 @@
         self._curve_dt = curve_dt
 
         if cap_sigmas[0] != 0.0:
             raise FinError("Curve date cap floor volatility must equal zero")
 
         self._cap_sigmas = np.array(cap_sigmas)
         self._caplet_gammas = []
+        self._caplet_vols = []
 
         # Basic validation of dates
         prev_dt = self._curve_dt
         for dt in cap_maturity_dts[1:]:
             if dt < prev_dt:
                 raise FinError("CapFloorLet Dates not in increasing order")
 
@@ -81,74 +82,74 @@
 ###############################################################################
 
     def generate_caplet_vols(self):
         """ Bootstrap caplet volatilities from cap volatilities using similar
         notation to Hull's book (page 32.11). The first volatility in the
         vector of caplet vols is zero. """
 
-        self._times = []
+        self.times = []
         self._taus = []
 
         day_counter = DayCount(self._dc_type)
         prev_dt = self._curve_dt
-        numCaps = len(self._cap_maturity_dts)
+        num_caps = len(self._cap_maturity_dts)
 
         for dt in self._cap_maturity_dts:
             t = (dt - self._curve_dt) / gDaysInYear
-            self._times.append(t)
+            self.times.append(t)
             tau = day_counter.year_frac(prev_dt, dt)[0]
             self._taus.append(tau)
             prev_dt = dt
 
-        fwd_rateVol = self._cap_sigmas[0]
-        self._caplet_gammas = np.zeros(numCaps)
+        fwd_rate_vol = self._cap_sigmas[0]
+        self._caplet_gammas = np.zeros(num_caps)
         self._caplet_gammas[0] = 0.0
-        cumIbor2Tau = (fwd_rateVol**2) * self._taus[0]
+        cum_ibor2_tau = (fwd_rate_vol**2) * self._taus[0]
 
-        sumTau = 0.0
+        sum_tau = 0.0
         for i in range(1, len(self._cap_maturity_dts)):
-            t = self._times[i]
+            t = self.times[i]
             tau = self._taus[i]
-            sumTau += tau
-            volCap = self._cap_sigmas[i]
-            volIbor2 = ((volCap**2) * sumTau - cumIbor2Tau) / tau
+            sum_tau += tau
+            vol_cap = self._cap_sigmas[i]
+            vol_ibor2 = ((vol_cap**2) * sum_tau - cum_ibor2_tau) / tau
 
-            if volIbor2 < 0.0:
+            if vol_ibor2 < 0.0:
                 raise FinError("Error due to negative caplet variance.")
 
-            volIbor = np.sqrt(volIbor2)
-            self._caplet_gammas[i] = volIbor
-            cumIbor2Tau += volIbor2 * self._taus[i]
+            vol_ibor = np.sqrt(vol_ibor2)
+            self._caplet_gammas[i] = vol_ibor
+            cum_ibor2_tau += vol_ibor2 * self._taus[i]
 
 ###############################################################################
 
     def caplet_vol(self, dt):
         """ Return the forward rate caplet/floorlet volatility for a specific
         forward caplet expiry date. The period of the volatility is the
         the intercaplet spacing period used when creating the class object.
         The volatility interpolation is piecewise flat. """
 
         if isinstance(dt, Date):
             t = (dt - self._curve_dt) / gDaysInYear
         else:
             t = dt
 
-        if t <= self._times[1]:
+        if t <= self.times[1]:
             return self._caplet_gammas[1]
 
         if 1 == 0:
-            print(self._times)
+            print(self.times)
             print(self._caplet_gammas)
             print(t)
 
-        num_vols = len(self._times)
+        num_vols = len(self.times)
         vol = self._caplet_gammas[1]
 
         for i in range(1, num_vols):
-            if self._times[i] >= t:
+            if self.times[i] >= t:
                 vol = self._caplet_gammas[i]
                 return vol
 
         return self._caplet_gammas[-1]
 
 ###############################################################################
 
@@ -158,41 +159,41 @@
         is piecewise flat. """
 
         if isinstance(dt, Date):
             t = (dt - self._curve_dt) / gDaysInYear
         else:
             t = dt
 
-        num_vols = len(self._times)
+        num_vols = len(self.times)
         vol = self._cap_sigmas[0]
 
         if 1 == 0:
-            print(self._times)
+            print(self.times)
             print(self._caplet_gammas)
             print(t)
 
         for i in range(1, num_vols):
-            if self._times[i] >= t:
+            if self.times[i] >= t:
                 vol = self._cap_sigmas[i]
                 return vol
 
         return self._cap_sigmas[-1]
 
 ###############################################################################
 
     def __repr__(self):
         """ Output the contents of the FinCapVolCurve class object. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        num_times = len(self._times)
+        num_times = len(self.times)
         s += " TIME     TAU    CAP VOL    CAPLET VOL"
         for i in range(0, num_times):
-            t = self._times[i]
+            t = self.times[i]
             tau = self._taus[i]
-            volCap = self._cap_sigmas[i]
-            fwdIborVol = self._capletVols[i]
+            vol_cap = self._cap_sigmas[i]
+            fwd_ibor_vol = self._caplet_vols[i]
             s += label_to_string("%7.4f  %6.4f  %9.4f  %9.4f"
-                                 % (t, tau, volCap*100.0, fwdIborVol*100.0))
+                                 % (t, tau, vol_cap*100.0, fwd_ibor_vol*100.0))
 
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/market/volatility/ibor_cap_vol_curve_fn.py` & `financepy-0.360/financepy/market/volatility/ibor_cap_vol_curve_fn.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/market/volatility/swaption_vol_surface.py` & `financepy-0.360/financepy/market/volatility/swaption_vol_surface.py`

 * *Files 4% similar despite different names*

```diff
@@ -103,76 +103,76 @@
     params and specified by the vol_type_value at a single time slice only.
     """
 
     t = args[0]
     f = args[1]
     strikes_grid = args[2]
     index = args[3]
-    volatility_grid = args[4]
+    vol_grid = args[4]
     vol_type_value = args[5]
 
     tot = 0.0
 
-    num_strikes = len(volatility_grid)
+    num_strikes = len(vol_grid)
 
     for i in range(0, num_strikes):
 
         k = strikes_grid[i][index]
         fitted_vol = vol_function(vol_type_value, params, f, k, t)
-        mkt_vol = volatility_grid[i][index]
+        mkt_vol = vol_grid[i][index]
         diff = fitted_vol - mkt_vol
         tot += diff**2
 
     return tot
 
 ###############################################################################
 # Do not cache this function as it leads to complaints
 ###############################################################################
 
 
 def _solve_to_horizon(t, f,
                       strikes_grid,
                       time_index,
-                      volatility_grid,
+                      vol_grid,
                       vol_type_value,
                       x_inits,
-                      finSolverType):
+                      fin_solver_type):
 
     ###########################################################################
     # Determine parameters of vol surface using minimisation
     ###########################################################################
 
     tol = 1e-6
 
-    args = (t, f, strikes_grid, time_index, volatility_grid, vol_type_value)
+    args = (t, f, strikes_grid, time_index, vol_grid, vol_type_value)
 
     # Nelder-Mead (both SciPy amd Numba) is quicker, but occasionally fails
     # to converge, so for those cases try again with CG
     # Numba version is quicker, but can be slightly away from CG output
     try:
-        if finSolverType == FinSolverTypes.NELDER_MEAD_NUMBA:
+        if fin_solver_type == FinSolverTypes.NELDER_MEAD_NUMBA:
             xopt = nelder_mead(_obj, np.array(x_inits),
                                bounds=np.array([[], []]).T,
                                args=args, tol_f=tol,
                                tol_x=tol, max_iter=1000)
-        elif finSolverType == FinSolverTypes.NELDER_MEAD:
+        elif fin_solver_type == FinSolverTypes.NELDER_MEAD:
             opt = minimize(_obj, x_inits, args, method="Nelder-Mead", tol=tol)
             xopt = opt.x
-        elif finSolverType == FinSolverTypes.CONJUGATE_GRADIENT:
+        elif fin_solver_type == FinSolverTypes.CONJUGATE_GRADIENT:
             opt = minimize(_obj, x_inits, args, method="CG", tol=tol)
             xopt = opt.x
     except Exception:
         # If convergence fails try again with CG if necessary
-        if finSolverType != FinSolverTypes.CONJUGATE_GRADIENT:
+        if fin_solver_type != FinSolverTypes.CONJUGATE_GRADIENT:
             print('Failed to converge, will try CG')
             opt = minimize(_obj, x_inits, args, method="CG", tol=tol)
             xopt = opt.x
 
-    print("t: %9.5f alpha:%9.5f beta: %9.5f rho: %9.5f nu: %9.5f" %
-          (t, xopt[0], 0.5, xopt[1], xopt[2]))
+    # print("t: %9.5f alpha:%9.5f beta: %9.5f rho: %9.5f nu: %9.5f" %
+    #      (t, xopt[0], 0.5, xopt[1], xopt[2]))
 
     params = np.array(xopt)
     return params
 
 ###############################################################################
 
 
@@ -277,15 +277,15 @@
 # Unable to cache function and if I remove njit it complains about pickle
 ###############################################################################
 
 
 # @njit(float64(float64, float64, float64, float64, int64, float64,
 #               int64, float64), fastmath=True)
 # def solve_for_strike(spot_fx_rate,
-#                    tdel, rd, rf,
+#                    t_del, rd, rf,
 #                    option_type_value,
 #                    delta_target,
 #                    delta_method_value,
 #                    volatility):
 #     """ This function determines the implied strike of an FX option
 #     given a delta and the other option details. It uses a one-dimensional
 #     Newton root search algorithm to determine the strike that matches an
@@ -299,59 +299,59 @@
 #     # inverse value of delta, this may not, on a round trip using N(x), give
 #     # back the value x as it is calculated to a different number of decimal
 #     # places. It should however agree to 6-7 decimal places. Which is OK.
 #     # =========================================================================
 
 #     if delta_method_value == FinFXDeltaMethod.SPOT_DELTA.value:
 
-#         dom_df = np.exp(-rd*tdel)
-#         for_df = np.exp(-rf*tdel)
+#         dom_df = np.exp(-rd*t_del)
+#         for_df = np.exp(-rf*t_del)
 
 #         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
 #             phi = +1.0
 #         else:
 #             phi = -1.0
 
 #         F0T = spot_fx_rate * for_df / dom_df
-#         vsqrtt = volatility * np.sqrt(tdel)
+#         vsqrtt = volatility * np.sqrt(t_del)
 #         arg = delta_target*phi/for_df  # CHECK THIS !!!
 #         norm_inv_delta = norminvcdf(arg)
 #         K = F0T * np.exp(-vsqrtt * (phi * norm_inv_delta - vsqrtt/2.0))
 #         return K
 
 #     elif delta_method_value == FinFXDeltaMethod.FORWARD_DELTA.value:
 
-#         dom_df = np.exp(-rd*tdel)
-#         for_df = np.exp(-rf*tdel)
+#         dom_df = np.exp(-rd*t_del)
+#         for_df = np.exp(-rf*t_del)
 
 #         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
 #             phi = +1.0
 #         else:
 #             phi = -1.0
 
 #         F0T = spot_fx_rate * for_df / dom_df
-#         vsqrtt = volatility * np.sqrt(tdel)
+#         vsqrtt = volatility * np.sqrt(t_del)
 #         arg = delta_target*phi
 #         norm_inv_delta = norminvcdf(arg)
 #         K = F0T * np.exp(-vsqrtt * (phi * norm_inv_delta - vsqrtt/2.0))
 #         return K
 
 #     elif delta_method_value == FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ.value:
 
-#         argtuple = (spot_fx_rate, tdel, rd, rf, volatility,
+#         argtuple = (spot_fx_rate, t_del, rd, rf, volatility,
 #                     delta_method_value, option_type_value, delta_target)
 
 #         K = newton_secant(_g, x0=spot_fx_rate, args=argtuple,
 #                           tol=1e-7, maxiter=50)
 
 #         return K
 
 #     elif delta_method_value == FinFXDeltaMethod.FORWARD_DELTA_PREM_ADJ.value:
 
-#         argtuple = (spot_fx_rate, tdel, rd, rf, volatility,
+#         argtuple = (spot_fx_rate, t_del, rd, rf, volatility,
 #                     delta_method_value, option_type_value, delta_target)
 
 #         K = newton_secant(_g, x0=spot_fx_rate, args=argtuple,
 #                           tol=1e-7, maxiter=50)
 
 #         return K
 
@@ -370,75 +370,83 @@
     Also, there is no guarantee that the implied pdf will be positive."""
 
     def __init__(self,
                  value_dt: Date,
                  expiry_dts: (list),
                  fwd_swap_rates: (list, np.ndarray),
                  strike_grid: (np.ndarray),
-                 volatility_grid: (np.ndarray),
-                 volatility_function_type: VolFuncTypes = VolFuncTypes.SABR,
-                 finSolverType: FinSolverTypes = FinSolverTypes.NELDER_MEAD):
+                 vol_grid: (np.ndarray),
+                 vol_func_type: VolFuncTypes = VolFuncTypes.SABR,
+                 fin_solver_type: FinSolverTypes = FinSolverTypes.NELDER_MEAD):
         """ Create the FinSwaptionVolSurface object by passing in market vol
         data for a list of strikes and expiry dates. """
 
         check_argument_types(self.__init__, locals())
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
 
         if len(strike_grid.shape) != 2:
             raise FinError("Strike grid must be a 2D grid of values")
 
-        if len(volatility_grid.shape) != 2:
+        if len(vol_grid.shape) != 2:
             raise FinError("Volatility grid must be a 2D grid of values")
 
-        if len(strike_grid) != len(volatility_grid):
+        if len(strike_grid) != len(vol_grid):
             raise FinError(
                 "Strike grid and volatility grid must have same size")
 
-        if len(strike_grid[0]) != len(volatility_grid[0]):
+        if len(strike_grid[0]) != len(vol_grid[0]):
             raise FinError(
                 "Strike grid and volatility grid must have same size")
 
-        if len(expiry_dts) != len(volatility_grid[0]):
+        if len(expiry_dts) != len(vol_grid[0]):
             raise FinError("Expiry dates not same size as volatility grid")
 
-        self._numExpiryDates = len(volatility_grid[0])
-        self._num_strikes = len(volatility_grid)
+        self._num_expiry_dts = len(vol_grid[0])
+        self._num_strikes = len(vol_grid)
 
         self._strike_grid = strike_grid
-        self._volatility_grid = volatility_grid
+        self._vol_grid = vol_grid
 
         self._expiry_dts = expiry_dts
-        self._volatility_function_type = volatility_function_type
+        self._vol_func_type = vol_func_type
 
         self._fwd_swap_rates = fwd_swap_rates
 
-        self._build_vol_surface(finSolverType=finSolverType)
+        self._build_vol_surface(fin_solver_type=fin_solver_type)
+
+#        self._F0T = []
+#        self._stock_price = None
+#        self._atm_method = None
+#        self._atm_vols = []
+#        self._delta_method = None
+#        self._strikes = []
+#        self._vol_grid = []
 
 ###############################################################################
 
     def vol_from_strike_dt(self, K, expiry_dt):
         """ Interpolates the Black-Scholes volatility from the volatility
         surface given call option strike and expiry date. Linear interpolation
         is done in variance space. The smile strikes at bracketed dates are
         determined by determining the strike that reproduces the provided delta
         value. This uses the calibration delta convention, but it can be
         overriden by a provided delta convention. The resulting volatilities
         are then determined for each bracketing expiry time and linear
         interpolation is done in variance space and then converted back to a
         lognormal volatility."""
 
-        t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+        t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-        vol_type_value = self._volatility_function_type.value
+        vol_type_value = self._vol_func_type.value
 
         index0 = 0  # lower index in bracket
         index1 = 0  # upper index in bracket
 
-        num_curves = self._numExpiryDates
+        num_curves = self._num_expiry_dts
 
         if num_curves == 1:
 
             index0 = 0
             index1 = 0
 
         # If the time is below first time then assume a flat vol
@@ -502,17 +510,17 @@
 
 ###############################################################################
 
     # def delta_to_strike(self, call_delta, expiry_dt, delta_method):
     #     """ Interpolates the strike at a delta and expiry date. Linear
     #     interpolation is used in strike."""
 
-    #     t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+    #     t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-    #     vol_type_value = self._volatility_function_type.value
+    #     vol_type_value = self._vol_func_type.value
 
     #     s = self._spot_fx_rate
 
     #     if delta_method is None:
     #         delta_method_value = self._delta_method.value
     #     else:
     #         delta_method_value = delta_method.value
@@ -550,15 +558,15 @@
     #                 break
 
     #     #######################################################################
 
     #     t0 = self._t_exp[index0]
     #     t1 = self._t_exp[index1]
 
-    #     initial_guess = self._K_ATM[index0]
+    #     initial_guess = self._k_atm[index0]
 
     #     K0 = _solver_for_smile_strike(s, t_exp, self._rd[index0], self._rf[index0],
     #                               OptionTypes.EUROPEAN_CALL.value,
     #                               vol_type_value, call_delta,
     #                               delta_method_value,
     #                               initial_guess,
     #                               self._parameters[index0],
@@ -592,29 +600,29 @@
 
     #         K = K1
 
     #     return K
 
 ###############################################################################
 
-    # def vol_from_delta_dt(self, call_delta, expiry_dt,
+    # def vol_from_delta_date(self, call_delta, expiry_dt,
     #                                delta_method = None):
     #     """ Interpolates the Black-Scholes volatility from the volatility
     #     surface given a call option delta and expiry date. Linear interpolation
     #     is done in variance space. The smile strikes at bracketed dates are
     #     determined by determining the strike that reproduces the provided delta
     #     value. This uses the calibration delta convention, but it can be
     #     overriden by a provided delta convention. The resulting volatilities
     #     are then determined for each bracketing expiry time and linear
     #     interpolation is done in variance space and then converted back to a
     #     lognormal volatility."""
 
-    #     t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+    #     t_exp = (expiry_dt - self.value_dt) / gDaysInYear
 
-    #     vol_type_value = self._volatility_function_type.value
+    #     vol_type_value = self._vol_func_type.value
 
     #     s = self._spot_fx_rate
 
     #     if delta_method is None:
     #         delta_method_value = self._delta_method.value
     #     else:
     #         delta_method_value = delta_method.value
@@ -653,15 +661,15 @@
 
     #     fwd0 = self._F0T[index0]
     #     fwd1 = self._F0T[index1]
 
     #     t0 = self._t_exp[index0]
     #     t1 = self._t_exp[index1]
 
-    #     initial_guess = self._K_ATM[index0]
+    #     initial_guess = self._k_atm[index0]
 
     #     K0 = _solver_for_smile_strike(s, t_exp, self._rd[index0], self._rf[index0],
     #                               OptionTypes.EUROPEAN_CALL.value,
     #                               vol_type_value, call_delta,
     #                               delta_method_value,
     #                               initial_guess,
     #                               self._parameters[index0],
@@ -711,107 +719,107 @@
     #         volt = vol0
     #         kt = K0
 
     #     return volt, kt
 
 ###############################################################################
 
-    def _build_vol_surface(self, finSolverType=FinSolverTypes.NELDER_MEAD):
+    def _build_vol_surface(self, fin_solver_type=FinSolverTypes.NELDER_MEAD):
         """ Main function to construct the vol surface. """
 
-        if self._volatility_function_type == VolFuncTypes.CLARK:
+        if self._vol_func_type == VolFuncTypes.CLARK:
             num_parameters = 3
-        elif self._volatility_function_type == VolFuncTypes.SABR_BETA_ONE:
+        elif self._vol_func_type == VolFuncTypes.SABR_BETA_ONE:
             num_parameters = 3
-        elif self._volatility_function_type == VolFuncTypes.SABR_BETA_HALF:
+        elif self._vol_func_type == VolFuncTypes.SABR_BETA_HALF:
             num_parameters = 3
-        elif self._volatility_function_type == VolFuncTypes.BBG:
+        elif self._vol_func_type == VolFuncTypes.BBG:
             num_parameters = 3
-        elif self._volatility_function_type == VolFuncTypes.SABR:
+        elif self._vol_func_type == VolFuncTypes.SABR:
             num_parameters = 4
-        elif self._volatility_function_type == VolFuncTypes.CLARK5:
+        elif self._vol_func_type == VolFuncTypes.CLARK5:
             num_parameters = 5
-        elif self._volatility_function_type == VolFuncTypes.SVI:
+        elif self._vol_func_type == VolFuncTypes.SVI:
             num_parameters = 5
-        elif self._volatility_function_type == VolFuncTypes.SSVI:
+        elif self._vol_func_type == VolFuncTypes.SSVI:
             num_parameters = 5
         else:
-            print(self._volatility_function_type)
+            print(self._vol_func_type)
             raise FinError("Unknown Model Type")
 
-        numExpiryDates = self._numExpiryDates
+        num_expiry_dts = self._num_expiry_dts
 
-        self._parameters = np.zeros([numExpiryDates, num_parameters])
-        self._t_exp = np.zeros(numExpiryDates)
+        self._parameters = np.zeros([num_expiry_dts, num_parameters])
+        self._t_exp = np.zeros(num_expiry_dts)
 
         #######################################################################
         # TODO: ADD SPOT DAYS
         #######################################################################
 
-        for i in range(0, numExpiryDates):
+        for i in range(0, num_expiry_dts):
 
             expiry_dt = self._expiry_dts[i]
-            t_exp = (expiry_dt - self._value_dt) / gDaysInYear
+            t_exp = (expiry_dt - self.value_dt) / gDaysInYear
             self._t_exp[i] = t_exp
 
         #######################################################################
         # THE ACTUAL COMPUTATION LOOP STARTS HERE
         #######################################################################
 
-        vol_type_value = self._volatility_function_type.value
+        vol_type_value = self._vol_func_type.value
 
         x_inits = []
         x_init = np.zeros(num_parameters)
         x_inits.append(x_init)
 
-        for i in range(0, numExpiryDates):
+        for i in range(0, num_expiry_dts):
 
             t = self._t_exp[i]
             f = self._fwd_swap_rates[i]
 
             res = _solve_to_horizon(t, f,
                                     self._strike_grid,
                                     i,
-                                    self._volatility_grid,
+                                    self._vol_grid,
                                     vol_type_value,
                                     x_inits[i],
-                                    finSolverType)
+                                    fin_solver_type)
 
             self._parameters[i, :] = res
 
             x_init = res
             x_inits.append(x_init)
 
 ###############################################################################
 
     def check_calibration(self, verbose: bool, tol: float = 1e-6):
         """ Compare calibrated vol surface with market and output a report
         which sets out the quality of fit to the ATM and 10 and 25 delta market
         strangles and risk reversals. """
 
+        if self._vol_grid == []:
+            raise FinError("Error: Vol Grid is empty")
+
         if verbose:
 
             print("==========================================================")
-            print("VALUE DATE:", self._value_dt)
+            print("VALUE DATE:", self.value_dt)
             print("STOCK PRICE:", self._stock_price)
             print("==========================================================")
 
-        for i in range(0, self._numExpiryDates):
+        for i in range(0, self._num_expiry_dts):
 
             expiry_dt = self._expiry_dts[i]
             print("==========================================================")
 
             for j in range(0, self._num_strikes):
 
                 strike = self._strike_grid[j][i]
-
                 fitted_vol = self.vol_from_strike_dt(strike, expiry_dt)
-
-                mkt_vol = self._volatility_grid[j][i]
-
+                mkt_vol = self._vol_grid[j][i]
                 diff = fitted_vol - mkt_vol
 
                 print("%s %12.3f %7.4f %7.4f %7.5f" %
                       (expiry_dt,
                        strike,
                        fitted_vol*100.0,
                        mkt_vol*100,
@@ -823,15 +831,15 @@
 
     # def implied_dbns(self, lowS, highS, num_intervals):
     #     """ Calculate the pdf for each tenor horizon. Returns a list of
     #     FinDistribution objects, one for each tenor horizon. """
 
     #     dbns = []
 
-    #     for iTenor in range(0, self._numExpiryDates):
+    #     for iTenor in range(0, self._num_expiry_dts):
 
     #         f = self._fwd_swap_rates[iTenor]
     #         t = self._t_exp[iTenor]
 
     #         dS = (highS - lowS)/ num_intervals
 
     #         dis_df = self._discount_curve.df(t)
@@ -843,15 +851,15 @@
     #         Ks = []
     #         vols = []
 
     #         for iK in range(0, num_intervals):
 
     #             k = lowS + iK*dS
 
-    #             vol = vol_function(self._volatility_function_type.value,
+    #             vol = vol_function(self._vol_func_type.value,
     #                               self._parameters[iTenor],
     #                               f, k, t)
 
     #             Ks.append(k)
     #             vols.append(vol)
 
     #         Ks = np.array(Ks)
@@ -866,78 +874,77 @@
 
 ###############################################################################
 
     def plot_vol_curves(self):
         """ Generates a plot of each of the vol discount implied by the market
         and fitted. """
 
-        for tenor_index in range(0, self._numExpiryDates):
+        for tenor_index in range(0, self._num_expiry_dts):
 
-            lowK = self._strike_grid[0][tenor_index] * 0.9
-            highK = self._strike_grid[-1][tenor_index] * 1.1
+            low_k = self._strike_grid[0][tenor_index] * 0.9
+            high_k = self._strike_grid[-1][tenor_index] * 1.1
 
             expiry_dt = self._expiry_dts[tenor_index]
             plt.figure()
 
             ks = []
 
             num_intervals = 30
-            K = lowK
-            dK = (highK - lowK)/num_intervals
+            K = low_k
+            dK = (high_k - low_k)/num_intervals
 
             fitted_vols = []
 
             for i in range(0, num_intervals):
 
                 ks.append(K)
                 fitted_vol = self.vol_from_strike_dt(K, expiry_dt) * 100.0
                 fitted_vols.append(fitted_vol)
                 K = K + dK
 
             label_str = "FITTED AT " + str(self._expiry_dts[tenor_index])
             plt.plot(ks, fitted_vols, label=label_str)
 
             label_str = "MARKET AT " + str(self._expiry_dts[tenor_index])
-            mkt_vols = self._volatility_grid[:, tenor_index] * 100.0
+            mkt_vols = self._vol_grid[:, tenor_index] * 100.0
             plt.plot(self._strike_grid[:, tenor_index],
                      mkt_vols, 'o', label=label_str)
 
             plt.xlabel("Strike")
             plt.ylabel("Volatility")
 
-            title = str(self._volatility_function_type)
+            title = str(self._vol_func_type)
             plt.title(title)
             plt.legend()
 
 ###############################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUE DATE", self._value_dt)
+        s += label_to_string("VALUE DATE", self.value_dt)
         s += label_to_string("STOCK PRICE", self._stock_price)
-        s += label_to_string("ATM METHOD", self._atmMethod)
+        s += label_to_string("ATM METHOD", self._atm_method)
         s += label_to_string("DELTA METHOD", self._delta_method)
-        s += label_to_string("VOL FUNCTION", self._volatility_function_type)
+        s += label_to_string("VOL FUNCTION", self._vol_func_type)
 
-        for i in range(0, self._numExpiryDates):
+        for i in range(0, self._num_expiry_dts):
 
             s += "\n"
 
             s += label_to_string("EXPIRY DATE", self._expiry_dts[i])
             s += label_to_string("TIME (YRS)", self._t_exp[i])
             s += label_to_string("FWD FX", self._F0T[i])
-
             s += label_to_string("ATM VOLS", self._atm_vols[i]*100.0)
 
             for j in range(0, self._num_strikes):
 
                 expiry_dt = self._expiry_dts[i]
                 k = self._strikes[j]
-                vol = self._volGrid[i][j]
+                vol = self._vol_grid[i][j]
                 print(expiry_dt, k, vol)
 
         return s
 
 ###############################################################################
 
     def _print(self):
```

### Comparing `financepy-0.350/financepy/models/__init__.py` & `financepy-0.360/financepy/models/__init__.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/models/bachelier.py` & `financepy-0.360/financepy/models/bachelier.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,46 +13,46 @@
 ###############################################################################
 # NOTE: Need to convert option types to use enums.
 # NOTE: Perhaps just turn this into a function rather than a class.
 ###############################################################################
 
 
 class Bachelier():
-    """ Bachelier's Model which prices call and put options in the forward
-    measure assuming the underlying rate follows a normal process. """
+    """Bachelier's Model which prices call and put options in the forward
+    measure assuming the underlying rate follows a normal process.
+    """
 
     def __init__(self, volatility):
-        """ Create FinModel black using parameters. """
-        self._volatility = volatility
+        """Create FinModel black using parameters."""
+        self.volatility = volatility
 
 ###############################################################################
 
     def value(self,
               forward_rate,   # Forward rate F
               strike_rate,    # Strike Rate K
               time_to_expiry,  # Time to Expiry (years)
               df,            # Discount Factor to expiry date
               call_or_put):    # Call or put
-        """ Price a call or put option using Bachelier's model. """
-
+        """Price a call or put option using Bachelier's model."""
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
         root_t = np.sqrt(t)
-        v = self._volatility
+        v = self.volatility
         d = (f-k) / (v * root_t)
 
         if call_or_put == OptionTypes.EUROPEAN_CALL:
             return df * ((f - k) * norm.cdf(d) + v * root_t * norm.pdf(d))
         elif call_or_put == OptionTypes.EUROPEAN_PUT:
             return df * ((k - f) * norm.cdf(-d) + v * root_t * norm.pdf(d))
         else:
             raise FinError("Option type must be a European Call(C) or Put(P)")
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VOLATILITY", self._volatility)
+        s += label_to_string("VOLATILITY", self.volatility)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/bdt_tree.py` & `financepy-0.360/financepy/models/bdt_tree.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 from numba import njit, float64, int64
 
 from ..utils.error import FinError
 from ..utils.math import accrued_interpolator
 from ..market.curves.interpolator import InterpTypes, _uinterpolate
 from ..utils.helpers import label_to_string
 from ..utils.global_types import FinExerciseTypes
-from ..utils.global_vars import gSmall
+from ..utils.global_vars import g_small
 
 INTERP_TYPE = InterpTypes.FLAT_FWD_RATES.value
 
 ###############################################################################
 # ISSUE: PUT CALL PARITY IS NOT EXACTLY OBSERVED FOR BERMUDAN SWAPTIONS WHEN
 #       VOL IS TURNED UP. SMALL EFFECT. $3 OUT OF $1m.
 ###############################################################################
@@ -33,15 +33,14 @@
 
 ###############################################################################
 
 
 @njit(float64(float64, int64, float64[:, :], float64[:, :],
               float64, float64, float64), fastmath=True, cache=True)
 def f(x0, m, q_matrix, rt, df_end, dt, sigma):
-
     # x is the middle value on the short-rate on the tree
     midm = int(m/2)
     rt[m, midm] = x0
 
     for i in range(midm, 0, -1):
         rt[m, i-1] = rt[m, i] * np.exp(-2.0 * sigma * np.sqrt(dt))
 
@@ -60,15 +59,14 @@
 
 ###############################################################################
 
 
 @njit(float64(float64, int64, float64[:, :], float64[:, :], float64, float64,
               float64), fastmath=True, cache=True)
 def search_root(x0, m, q_matrix, rt, df_end, dt, sigma):
-
     #    print("Searching for root", x0)
     max_iter = 10
     max_error = 1e-8
 
     x1 = x0 * 1.0001
     f0 = f(x0, m, q_matrix, rt, df_end, dt, sigma)
     f1 = f(x1, m, q_matrix, rt, df_end, dt, sigma)
@@ -100,19 +98,18 @@
                                 cpn_times,
                                 cpn_flows,
                                 exercise_type_int,
                                 _df_times,
                                 _df_values,
                                 _tree_times,
                                 _Q, _rt, _dt):
-    """ Option to enter into a swap that can be exercised on coupon payment
+    """Option to enter into a swap that can be exercised on coupon payment
     dates after the start of the exercise period. Due to non-analytical bond
     price we need to extend tree out to bond maturity and take into account
-    cash flows through time. """
-
+    cash flows through time."""
     pu = 0.50
     pd = 0.50
 
     ###########################################################################
 
     num_time_steps, num_nodes = _Q.shape
     expiry_step = int(t_exp/_dt + 0.50)
@@ -122,18 +119,18 @@
 
     fixed_leg_flows = np.zeros(num_time_steps)
     float_leg_values = np.zeros(num_time_steps)
     num_cpns = len(cpn_times)
 
     # Tree flows go all the way out to the swap maturity date
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        n = int(tcpn/_dt + 0.50)
+        t_cpn = cpn_times[i]
+        n = int(t_cpn/_dt + 0.50)
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, INTERP_TYPE)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, INTERP_TYPE)
         df_tree = _uinterpolate(ttree, _df_times, _df_values, INTERP_TYPE)
         fixed_leg_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
         float_leg_values[n] = strike_price  # * df_flow / df_tree
 
     ###########################################################################
     # Mapped times stores the mapped times and flows and is used to calculate
     # accrued interest in a consistent manner as using actual flows will
@@ -141,18 +138,18 @@
     ###########################################################################
 
     mapped_times = np.array([0.0])
     mapped_amounts = np.array([0.0])
 
     for n in range(1, len(_tree_times)):
 
-        accdAtExpiry = 0.0
+        accd_at_expiry = 0.0
         if _tree_times[n-1] < t_exp and _tree_times[n] >= t_exp:
             mapped_times = np.append(mapped_times, t_exp)
-            mapped_amounts = np.append(mapped_amounts, accdAtExpiry)
+            mapped_amounts = np.append(mapped_amounts, accd_at_expiry)
 
         if fixed_leg_flows[n] > 0.0:
             mapped_times = np.append(mapped_times, _tree_times[n])
             mapped_amounts = np.append(mapped_amounts, fixed_leg_flows[n])
 
     ###########################################################################
 
@@ -160,15 +157,15 @@
     for m in range(0, maturity_step+1):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, mapped_times, mapped_amounts)
         accrued[m] *= face_amount
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if fixed_leg_flows[m] > gSmall:
+        if fixed_leg_flows[m] > g_small:
             accrued[m] = fixed_leg_flows[m] * face_amount
 
     #######################################################################
 
     # The value of the swap at each time and node. Principal is exchanged.
     fixed_leg_values = np.zeros(shape=(num_time_steps, num_nodes))
     # The value of the option to enter into a payer swap
@@ -223,15 +220,15 @@
             rec_exercise = max(fixed_leg_value - float_leg_value, 0.0)
 
             if m == expiry_step:
 
                 pay_values[m, k] = max(pay_exercise, hold_pay)
                 rec_values[m, k] = max(rec_exercise, hold_rec)
 
-            elif exercise_type_int == 2 and flow > gSmall and m > expiry_step:
+            elif exercise_type_int == 2 and flow > g_small and m > expiry_step:
 
                 pay_values[m, k] = max(pay_exercise, hold_pay)
                 rec_values[m, k] = max(rec_exercise, hold_rec)
 
             elif exercise_type_int == 3 and m > expiry_step:
 
                 raise FinError("American optionality not completed.")
@@ -280,38 +277,38 @@
 
     tree_flows = np.zeros(num_time_steps)
     num_cpns = len(cpn_times)
 
     # Tree flows go all the way out to the bond maturity date
     # Do not include first coupon as it is the previous coupon and is negative
     for i in range(1, num_cpns):
-        tcpn = cpn_times[i]
+        t_cpn = cpn_times[i]
 
-        if tcpn < 0.0:
+        if t_cpn < 0.0:
             print(cpn_times)
             raise FinError("Coupon times must be positive.")
 
-        n = int(tcpn/_dt + 0.50)
+        n = int(t_cpn/_dt + 0.50)
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, INTERP_TYPE)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, INTERP_TYPE)
         df_tree = _uinterpolate(ttree, _df_times, _df_values, INTERP_TYPE)
         tree_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
 
     ###########################################################################
     # mapped_times = np.zeros(0)   # CHANGE
     # mapped_amounts = np.zeros(0)  # CHANGE
     # for n in range(0, len(_tree_times)):
-    #     if treeFlows[n] > 0.0:
+    #     if tree_flows[n] > 0.0:
     #         mapped_times = np.append(mapped_times, _tree_times[n])
-    #         mapped_amounts = np.append(mapped_amounts, treeFlows[n])
+    #         mapped_amounts = np.append(mapped_amounts, tree_flows[n])
     # if DEBUG:
     #     print("MAPPED TIMES", mapped_times)
     #     print("MAPPED AMOUNTS", mapped_amounts)
     #
-    #    if mapped_times[0] > gSmall:
+    #    if mapped_times[0] > g_small:
     #        raise FinError("Mapped times [0] must be <= 0 for first coupon > 0")
     #
     ###########################################################################
 
     if DEBUG:
         print(_tree_times)
         print(tree_flows)
@@ -320,15 +317,15 @@
     for m in range(0, maturity_step+1):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, cpn_times, cpn_flows)
         accrued[m] *= face_amount
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if tree_flows[m] > gSmall:
+        if tree_flows[m] > g_small:
             accrued[m] = tree_flows[m] * face_amount
 
     if DEBUG:
         for i in range(0, expiry_step+1):
             print(i, tree_flows[i], accrued[i])
 
     ###########################################################################
@@ -364,15 +361,16 @@
 
             bond_values[m, k] = v
             bond_values[m, k] += flow
             dirty_price = bond_values[m, k]
             clean_price = dirty_price - accrued[m]
 
         if DEBUG:
-            print(m, _tree_times[m], accrued[m], dirty_price, clean_price, 0, 0)
+            print(m, _tree_times[m], accrued[m],
+                  dirty_price, clean_price, 0, 0)
 
     # Now step back to today from the expiry date considering early exercise
     for m in range(expiry_step, -1, -1):
         nm = m
         flow = tree_flows[m] * face_amount
 
         for k in range(0, nm+1):
@@ -403,26 +401,26 @@
             put_option_values[m, k] = vput
 
             dirty_price = bond_values[m, k]
             clean_price = dirty_price - accrued[m]
             call_exercise = max(clean_price - strike_price, 0.0)
             put_exercise = max(strike_price - clean_price, 0.0)
 
-            holdCall = call_option_values[m, k]
-            holdPut = put_option_values[m, k]
+            hold_call = call_option_values[m, k]
+            hold_put = put_option_values[m, k]
 
             if m == expiry_step:
 
-                call_option_values[m, k] = max(call_exercise, holdCall)
-                put_option_values[m, k] = max(put_exercise, holdPut)
+                call_option_values[m, k] = max(call_exercise, hold_call)
+                put_option_values[m, k] = max(put_exercise, hold_put)
 
             elif exercise_type_int == 3 and m < expiry_step:
 
-                call_option_values[m, k] = max(call_exercise, holdCall)
-                put_option_values[m, k] = max(put_exercise, holdPut)
+                call_option_values[m, k] = max(call_exercise, hold_call)
+                put_option_values[m, k] = max(put_exercise, hold_put)
 
         if DEBUG:
             print(m, _tree_times[m], accrued[m], dirty_price, clean_price,
                   call_exercise, put_exercise)
 
     return call_option_values[0, 0], put_option_values[0, 0]
 
@@ -454,18 +452,18 @@
     # Map coupons onto tree while preserving their present value
     ###########################################################################
 
     tree_flows = np.zeros(num_time_steps)
 
     num_cpns = len(cpn_times)
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        n = int(tcpn/_dt + 0.50)
+        t_cpn = cpn_times[i]
+        n = int(t_cpn/_dt + 0.50)
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, INTERP_TYPE)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, INTERP_TYPE)
         df_tree = _uinterpolate(ttree, _df_times, _df_values, INTERP_TYPE)
         tree_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
 
     #######################################################################
     # Mapped times stores the mapped times and flows and is used to calculate
     # accrued interest in a consistent manner as using actual flows will
     # result in some convergence noise issues as it is inconsistent
@@ -510,15 +508,15 @@
         n = int(put_time/dt + 0.50)
         tree_put_value[n] = put_prices[i]
 
     ###########################################################################
     # Value the bond by backward induction starting at bond maturity
     ###########################################################################
 
-    callPutBondValues = np.zeros(shape=(num_time_steps, num_nodes))
+    call_put_bond_values = np.zeros(shape=(num_time_steps, num_nodes))
     bond_values = np.zeros(shape=(num_time_steps, num_nodes))
 
     DEBUG = False
     if DEBUG:
         df = 1.0
         px = 0.0
         for i in range(0, maturity_step+1):
@@ -538,15 +536,15 @@
     vput = tree_put_value[m]
     vhold = (1.0 + tree_flows[m]) * face_amount
     vclean = vhold - accrued[m]
     value = min(max(vclean, vput), vcall) + accrued[m]
 
     for k in range(0, nm+1):
         bond_values[m, k] = (1.0 + tree_flows[m]) * face_amount
-        callPutBondValues[m, k] = value
+        call_put_bond_values[m, k] = value
 
     for m in range(maturity_step-1, -1, -1):
         nm = m
         flow = tree_flows[m] * face_amount
         vcall = tree_call_value[m]
         vput = tree_put_value[m]
 
@@ -558,24 +556,24 @@
             vu = bond_values[m+1, k+1]
             vd = bond_values[m+1, k]
             v = (pu*vu + pd*vd) * df
 
             bond_values[m, k] = v
             bond_values[m, k] += flow
 
-            vu = callPutBondValues[m+1, k+1]
-            vd = callPutBondValues[m+1, k]
+            vu = call_put_bond_values[m+1, k+1]
+            vd = call_put_bond_values[m+1, k]
 
             vhold = (pu*vu + pd*vd) * df
             # Need to make add on coupons paid if we hold
             vhold = vhold + flow
             value = min(max(vhold - accrued[m], vput), vcall) + accrued[m]
-            callPutBondValues[m, k] = value
+            call_put_bond_values[m, k] = value
 
-    return {'bondwithoption': callPutBondValues[0, 0],
+    return {'bondwithoption': call_put_bond_values[0, 0],
             'bondpure': bond_values[0, 0]}
 
 ###############################################################################
 ###############################################################################
 
 
 @njit(cache=True, fastmath=True)
@@ -654,57 +652,63 @@
         """ Constructs the Black-Derman-Toy rate model in the case when the
         volatility is assumed to be constant. The short rate process simplifies
         and is given by d(log(r)) = theta(t) * dt + sigma * dW. Althopugh """
 
         if sigma < 0.0:
             raise FinError("Negative volatility not allowed.")
 
-        self._sigma = sigma
+        self.sigma = sigma
 
         if num_time_steps < 3:
             raise FinError("Drift fitting requires at least 3 time steps.")
 
-        self._num_time_steps = num_time_steps
+        self.num_time_steps = num_time_steps
+
+        self.Q = None
+        self.rt = None
+        self.tree_times = None
+        self.df_times = None
+        self.dfs = None
+        self.pu = 0.50
+        self.pd = 0.50
+        self.discount_curve = None
+        self.dt = None
 
-        self._Q = None
-        self._rt = None
-        self._tree_times = None
-        self._pu = 0.50
-        self._pd = 0.50
-        self._discount_curve = None
 
 ###############################################################################
 
-    def build_tree(self, treeMat, df_times, df_values):
+
+    def build_tree(self, tree_mat, df_times, df_values):
 
         if isinstance(df_times, np.ndarray) is False:
             raise FinError("DF TIMES must be a numpy vector")
 
         if isinstance(df_values, np.ndarray) is False:
             raise FinError("DF VALUES must be a numpy vector")
 
         interp = InterpTypes.FLAT_FWD_RATES.value
 
-        treeMaturity = treeMat * (self._num_time_steps+1)/self._num_time_steps
-        tree_times = np.linspace(0.0, treeMaturity, self._num_time_steps + 2)
-        self._tree_times = tree_times
+        tree_maturity = tree_mat * \
+            (self.num_time_steps+1)/self.num_time_steps
+        tree_times = np.linspace(0.0, tree_maturity, self.num_time_steps + 2)
+        self.tree_times = tree_times
 
-        dfTree = np.zeros(shape=(self._num_time_steps+2))
-        dfTree[0] = 1.0
+        df_tree = np.zeros(shape=(self.num_time_steps+2))
+        df_tree[0] = 1.0
 
-        for i in range(1, self._num_time_steps+2):
+        for i in range(1, self.num_time_steps+2):
             t = tree_times[i]
-            dfTree[i] = _uinterpolate(t, df_times, df_values, interp)
+            df_tree[i] = _uinterpolate(t, df_times, df_values, interp)
 
-        self._df_times = df_times
-        self._dfs = df_values
+        self.df_times = df_times
+        self.dfs = df_values
 
-        self._Q, self._rt, self._dt \
-            = build_tree_fast(self._sigma,
-                              tree_times, self._num_time_steps, dfTree)
+        self.Q, self.rt, self.dt \
+            = build_tree_fast(self.sigma,
+                              tree_times, self.num_time_steps, df_tree)
 
         return
 
 ###############################################################################
 
     def bond_option(self, t_exp, strike_price, face_amount,
                     cpn_times, cpn_flows, exercise_type):
@@ -724,18 +728,18 @@
         #######################################################################
 
         call_value, put_value \
             = american_bond_option_tree_fast(t_exp, t_mat,
                                              strike_price, face_amount,
                                              cpn_times, cpn_flows,
                                              exercise_typeInt,
-                                             self._df_times, self._dfs,
-                                             self._tree_times, self._Q,
-                                             self._rt,
-                                             self._dt)
+                                             self.df_times, self.dfs,
+                                             self.tree_times, self.Q,
+                                             self.rt,
+                                             self.dt)
 
         return {'call': call_value, 'put': put_value}
 
 ###############################################################################
 
     def bermudan_swaption(self, t_exp, t_mat, strike, face_amount,
                           cpn_times, cpn_flows, exercise_type):
@@ -751,25 +755,25 @@
             raise FinError("Option expiry after bond matures.")
 
         if t_exp < 0.0:
             raise FinError("Option expiry time negative.")
 
         #######################################################################
 
-        payValue, recValue \
+        pay_value, rec_value \
             = bermudan_swaption_tree_fast(t_exp, t_mat,
                                           strike, face_amount,
                                           cpn_times, cpn_flows,
                                           exercise_type_int,
-                                          self._df_times, self._dfs,
-                                          self._tree_times, self._Q,
-                                          self._rt,
-                                          self._dt)
+                                          self.df_times, self.dfs,
+                                          self.tree_times, self.Q,
+                                          self.rt,
+                                          self.dt)
 
-        return {'pay': payValue, 'rec': recValue}
+        return {'pay': pay_value, 'rec': rec_value}
 
 ###############################################################################
 
     def callable_puttable_bond_tree(self,
                                     cpn_times, cpn_flows,
                                     call_times, call_prices,
                                     put_times, put_prices,
@@ -783,27 +787,27 @@
 
         call_prices = np.array(call_prices)
         put_prices = np.array(put_prices)
 
         v = callable_puttable_bond_tree_fast(cpn_times, cpn_flows,
                                              call_times, call_prices,
                                              put_times, put_prices, face_amount,
-                                             self._sigma,
-                                             self._Q,
-                                             self._rt, self._dt,
-                                             self._tree_times,
-                                             self._df_times, self._dfs)
+                                             self.sigma,
+                                             self.Q,
+                                             self.rt, self.dt,
+                                             self.tree_times,
+                                             self.df_times, self.dfs)
 
         return {'bondwithoption': v['bondwithoption'],
                 'bondpure': v['bondpure']}
 
 ###############################################################################
 
     def __repr__(self):
         """ Return string with class details. """
 
         s = "Black-Derman-Toy Model\n"
-        s += label_to_string("Sigma", self._sigma)
-        s += label_to_string("num_time_steps", self._num_time_steps)
+        s += label_to_string("Sigma", self.sigma)
+        s += label_to_string("num_time_steps", self.num_time_steps)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/bk_tree.py` & `financepy-0.360/financepy/models/bk_tree.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-##############################################################################
+###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
-##############################################################################
+###############################################################################
 
 import numpy as np
 from numba import njit, float64, int64
 from math import ceil
 
 from ..utils.error import FinError
 from ..utils.math import accrued_interpolator
 from ..market.curves.interpolator import InterpTypes, _uinterpolate
 from ..utils.helpers import label_to_string
 from ..utils.global_types import FinExerciseTypes
-from ..utils.global_vars import gSmall
+from ..utils.global_vars import g_small
 
 interp = InterpTypes.FLAT_FWD_RATES.value
 
 ###############################################################################
 # TODO : Calculate accrued in bond option according to accrual convention
 # TODO : Convergence is unstable - investigate how to improve it
 # TODO : Write a fallback for gradient based alpha using bisection
@@ -24,113 +24,109 @@
 
 # (c) Dominic O'Kane - December-2019
 # Fergal O'Kane - search root function - 16-12-2019
 
 ###############################################################################
 
 
-def option_exercise_types_to_int(optionExerciseType):
-
-    if optionExerciseType == FinExerciseTypes.EUROPEAN:
+def option_exercise_types_to_int(option_exercise_type):
+    if option_exercise_type == FinExerciseTypes.EUROPEAN:
         return 1
-    if optionExerciseType == FinExerciseTypes.BERMUDAN:
+    if option_exercise_type == FinExerciseTypes.BERMUDAN:
         return 2
-    if optionExerciseType == FinExerciseTypes.AMERICAN:
+    if option_exercise_type == FinExerciseTypes.AMERICAN:
         return 3
     else:
         raise FinError("Unknown option exercise type.")
 
 ###############################################################################
 
 
 @njit(float64(float64, int64, float64[:], float64, float64, float64, int64),
       fastmath=True, cache=True)
-def f(alpha, nm, Q, P, dX, dt, N):
-
+def f(alpha, nm, Q, P, dx, dt, N):
     sum_qz = 0.0
     for j in range(-nm, nm+1):
-        x = alpha + j*dX
+        x = alpha + j*dx
         rdt = np.exp(x)*dt
         sum_qz += Q[j+N] * np.exp(-rdt)
 
     obj_fn = sum_qz - P
     return obj_fn
 
 ###############################################################################
 
 
 @njit(float64(float64, int64, float64[:], float64, float64, float64, int64),
       fastmath=True, cache=True)
-def fprime(alpha, nm, Q, P, dX, dt, N):
-
+def fprime(alpha, nm, Q, P, dx, dt, N):
     sum_q_zd_z = 0.0
     for j in range(-nm, nm+1):
-        x = alpha + j*dX
+        x = alpha + j*dx
         rdt = np.exp(x)*dt
         sum_q_zd_z += Q[j+N] * np.exp(-rdt) * np.exp(x)
 
     deriv = -sum_q_zd_z*dt
     return deriv
 
 ###############################################################################
 # This is the secant method which is not used as I computed the derivative of
 # objective function with respect to the drift term
 ###############################################################################
 
 
 @njit(float64(float64, int64, float64[:], float64, float64, float64, int64),
       fastmath=True, cache=True)
-def search_root(x0, nm, Q, P, dX, dt, N):
-
+def search_root(x0, nm, Q, P, dx, dt, N):
     #    print("Searching for root", x0)
     max_iter = 50
     max_error = 1e-8
 
     x1 = x0 * 1.0001
-    f0 = f(x0, nm, Q, P, dX, dt, N)
-    f1 = f(x1, nm, Q, P, dX, dt, N)
+    f0 = f(x0, nm, Q, P, dx, dt, N)
+    f1 = f(x1, nm, Q, P, dx, dt, N)
 
     for _ in range(0, max_iter):
 
         df = f1 - f0
 
         if df == 0.0:
             raise FinError("Search for alpha fails due to zero derivative")
 
         x = x1 - f1 * (x1 - x0) / df
         x0, f0 = x1, f1
         x1 = x
-        f1 = f(x1, nm, Q, P, dX, dt, N)
+        f1 = f(x1, nm, Q, P, dx, dt, N)
 
         if abs(f1) <= max_error:
             return x1
 
     raise FinError("Search root deriv FAILED to find alpha.")
 
 ###############################################################################
 # This is Newton Raphson which is faster than the secant measure as it has the
 # analytical derivative  that is easy to calculate.
 ###############################################################################
 
 
 @njit(float64(float64, int64, float64[:], float64, float64, float64, int64),
       fastmath=True, cache=True)
-def search_root_deriv(x0, nm, Q, P, dX, dt, N):
+def search_root_deriv(x0, nm, Q, P, dx, dt, N):
 
     max_iter = 50
     max_error = 1e-8
 
     for _ in range(0, max_iter):
 
-        fval = f(x0, nm, Q, P, dX, dt, N)
+        fval = f(x0, nm, Q, P, dx, dt, N)
 
         if abs(fval) <= max_error:
             return x0
 
-        fderiv = fprime(x0, nm, Q, P, dX, dt, N)
+        fderiv = fprime(x0, nm, Q, P, dx, dt, N)
 
         if abs(fderiv) == 0.0:
             print(x0, fval, fderiv)
             raise FinError("Function derivative is zero.")
 
         step = fval/fderiv
         x0 = x0 - step
@@ -168,18 +164,18 @@
     fixed_leg_flows = np.zeros(num_time_steps)
     # Initialise it with ones CHANGE
     float_leg_values = np.ones(num_time_steps)
     num_cpns = len(cpn_times)
 
     # swap fixed leg flows go all the way out to the swap maturity date
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        n = int(tcpn/_dt + 0.50)
+        t_cpn = cpn_times[i]
+        n = int(t_cpn/_dt + 0.50)
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, interp)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, interp)
         df_tree = _uinterpolate(ttree, _df_times, _df_values, interp)
         fixed_leg_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
         float_leg_values[n] = strike_price  # * df_flow / df_tree
 
     ############################## REMOVE START ###############################
 
     if 1 == 0:
@@ -195,20 +191,20 @@
         df_tree = _uinterpolate(t_exp, _df_times, _df_values, interp)
         floatpv = df_tree
         swaptionpv = (fixed_pv/df_tree - 1.0) * df_tree
         print("PV:", fixed_pv, floatpv, swaptionpv)
 
         fixed_pv = 0.0
         for n in range(0, num_cpns):
-            tcpn = cpn_times[n]
-            df = _uinterpolate(tcpn, _df_times, _df_values, interp)
+            t_cpn = cpn_times[n]
+            df = _uinterpolate(t_cpn, _df_times, _df_values, interp)
             flow = cpn_flows[n]
             pv_flow = flow * df
             fixed_pv += pv_flow
-            print("++", n, tcpn, df, flow, fixed_pv)
+            print("++", n, t_cpn, df, flow, fixed_pv)
         fixed_pv += df
         df_tree = _uinterpolate(t_exp, _df_times, _df_values, interp)
         floatpv = df_tree
         swaptionpv = (fixed_pv/df_tree - 1.0) * df_tree
         print("PV:", fixed_pv, floatpv, swaptionpv)
 
     ########################### REMOVE END ####################################
@@ -219,18 +215,18 @@
     # result in some convergence noise issues as it is inconsistent
     ###########################################################################
 
     mapped_times = np.array([0.0])
     mapped_amounts = np.array([0.0])
     for n in range(1, len(_tree_times)):
 
-        accdAtExpiry = 0.0
+        accd_at_expiry = 0.0
         if _tree_times[n-1] < t_exp and _tree_times[n] >= t_exp:
             mapped_times = np.append(mapped_times, t_exp)
-            mapped_amounts = np.append(mapped_amounts, accdAtExpiry)
+            mapped_amounts = np.append(mapped_amounts, accd_at_expiry)
 
         if fixed_leg_flows[n] > 0.0:
             mapped_times = np.append(mapped_times, _tree_times[n])
             mapped_amounts = np.append(mapped_amounts, fixed_leg_flows[n])
 
     ###########################################################################
 
@@ -238,15 +234,15 @@
     for m in range(0, maturity_step+1):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, mapped_times, mapped_amounts)
         accrued[m] *= face_amount
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if fixed_leg_flows[m] > gSmall:
+        if fixed_leg_flows[m] > g_small:
             accrued[m] = fixed_leg_flows[m] * face_amount
 
     #######################################################################
 
     # The value of the swap at each time and node. Principal is exchanged.
     fixed_leg_values = np.zeros(shape=(num_time_steps, num_nodes))
     # The value of the option to enter into a payer swap
@@ -344,15 +340,15 @@
             rec_exercise = max(fixed_leg_value - float_leg_value, 0.0)
 
             if m == expiry_step:
 
                 pay_values[m, kN] = max(pay_exercise, hold_pay)
                 rec_values[m, kN] = max(rec_exercise, hold_rec)
 
-            elif exercise_type_int == 2 and flow > gSmall and m > expiry_step:
+            elif exercise_type_int == 2 and flow > g_small and m > expiry_step:
 
                 pay_values[m, kN] = max(pay_exercise, hold_pay)
                 rec_values[m, kN] = max(rec_exercise, hold_rec)
 
             elif exercise_type_int == 3 and m > expiry_step:
 
                 raise FinError("American optionality not allowed.")
@@ -394,22 +390,22 @@
 
     tree_flows = np.zeros(num_time_steps)
     num_cpns = len(cpn_times)
 
     # Tree flows go all the way out to the bond maturity date
     # Do not include first coupon as it is the previous coupon and is negative
     for i in range(1, num_cpns):
-        tcpn = cpn_times[i]
+        t_cpn = cpn_times[i]
 
-        if tcpn < 0.0:
+        if t_cpn < 0.0:
             raise FinError("Coupon times must be positive.")
 
-        n = int(tcpn/_dt + 0.50)
+        n = int(t_cpn/_dt + 0.50)
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, interp)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, interp)
         df_tree = _uinterpolate(ttree, _df_times, _df_values, interp)
         tree_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
 
     ###########################################################################
     #
     # mapped_times = np.zeros(0)
     # mapped_amounts = np.zeros(0)
@@ -423,15 +419,15 @@
     for m in range(0, maturity_step+1):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, cpn_times, cpn_flows)
         accrued[m] *= face_amount
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if tree_flows[m] > gSmall:
+        if tree_flows[m] > g_small:
             accrued[m] = tree_flows[m] * face_amount
 
     if DEBUG:
         for i in range(0, expiry_step+1):
             print(i, tree_flows[i], accrued[i])
 
     #######################################################################
@@ -483,15 +479,16 @@
                 vd = bond_values[m+1, kN-1]
                 v = (pu*vu + pm*vm + pd*vd) * df
                 bond_values[m, kN] = v
 
             bond_values[m, kN] += flow
 
         if DEBUG:
-            print(m, _tree_times[m], accrued[m], dirty_price, clean_price, 0, 0)
+            print(m, _tree_times[m], accrued[m],
+                  dirty_price, clean_price, 0, 0)
 
     # Now consider exercise of the option on and before the expiry date
     for m in range(expiry_step, -1, -1):
         nm = min(m, j_max)
         flow = tree_flows[m] * face_amount
 
         for k in range(-nm, nm+1):
@@ -565,26 +562,26 @@
             put_option_values[m, kN] = vput
 
             dirty_price = bond_values[m, kN]
             clean_price = dirty_price - accrued[m]
             call_exercise = max(clean_price - strike_price, 0.0)
             put_exercise = max(strike_price - clean_price, 0.0)
 
-            holdCall = call_option_values[m, kN]
-            holdPut = put_option_values[m, kN]
+            hold_call = call_option_values[m, kN]
+            hold_put = put_option_values[m, kN]
 
             if m == expiry_step:
 
-                call_option_values[m, kN] = max(call_exercise, holdCall)
-                put_option_values[m, kN] = max(put_exercise, holdPut)
+                call_option_values[m, kN] = max(call_exercise, hold_call)
+                put_option_values[m, kN] = max(put_exercise, hold_put)
 
             elif exercise_type_int == 3 and m < expiry_step:  # AMERICAN
 
-                call_option_values[m, kN] = max(call_exercise, holdCall)
-                put_option_values[m, kN] = max(put_exercise, holdPut)
+                call_option_values[m, kN] = max(call_exercise, hold_call)
+                put_option_values[m, kN] = max(put_exercise, hold_put)
 
         if DEBUG:
             print(m, _tree_times[m], accrued[m], dirty_price, clean_price,
                   call_exercise, put_exercise)
 
     return call_option_values[0, j_max], put_option_values[0, j_max]
 
@@ -614,18 +611,18 @@
     # Map coupons onto tree while preserving their present value
     ###########################################################################
 
     tree_flows = np.zeros(num_time_steps)
 
     num_cpns = len(cpn_times)
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        n = int(tcpn/_dt + 0.50)
+        t_cpn = cpn_times[i]
+        n = int(t_cpn/_dt + 0.50)
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, interp)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, interp)
         df_tree = _uinterpolate(ttree, _df_times, _df_values, interp)
         tree_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
 
     #######################################################################
     # Mapped times stores the mapped times and flows and is used to calculate
     # accrued interest in a consistent manner as using actual flows will
     # result in some convergence noise issues as it is inconsistent
@@ -670,15 +667,15 @@
         n = int(put_time/dt + 0.50)
         tree_put_value[n] = put_prices[i]
 
     ###########################################################################
     # Value the bond by backward induction starting at bond maturity
     ###########################################################################
 
-    callPutBondValues = np.zeros(shape=(num_time_steps, num_nodes))
+    call_put_bond_values = np.zeros(shape=(num_time_steps, num_nodes))
     bond_values = np.zeros(shape=(num_time_steps, num_nodes))
 
     DEBUG = False
     if DEBUG:
         df = 1.0
         px = 0.0
         for i in range(0, maturity_step+1):
@@ -699,15 +696,15 @@
     vhold = (1.0 + tree_flows[m]) * face_amount
     vclean = vhold - accrued[m]
     value = min(max(vclean, vput), vcall) + accrued[m]
 
     for k in range(-nm, nm+1):
         kN = k + j_max
         bond_values[m, kN] = (1.0 + tree_flows[m]) * face_amount
-        callPutBondValues[m, kN] = value
+        call_put_bond_values[m, kN] = value
 
     for m in range(maturity_step-1, -1, -1):
         nm = min(m, j_max)
         flow = tree_flows[m] * face_amount
         vcall = tree_call_value[m]
         vput = tree_put_value[m]
 
@@ -733,44 +730,44 @@
                 vd = bond_values[m+1, kN-1]
 
             v = (pu*vu + pm*vm + pd*vd) * df
             bond_values[m, kN] = v
             bond_values[m, kN] += flow
 
             if k == j_max:
-                vu = callPutBondValues[m+1, kN]
-                vm = callPutBondValues[m+1, kN-1]
-                vd = callPutBondValues[m+1, kN-2]
+                vu = call_put_bond_values[m+1, kN]
+                vm = call_put_bond_values[m+1, kN-1]
+                vd = call_put_bond_values[m+1, kN-2]
             elif k == -j_max:
-                vu = callPutBondValues[m+1, kN+2]
-                vm = callPutBondValues[m+1, kN+1]
-                vd = callPutBondValues[m+1, kN]
+                vu = call_put_bond_values[m+1, kN+2]
+                vm = call_put_bond_values[m+1, kN+1]
+                vd = call_put_bond_values[m+1, kN]
             else:
-                vu = callPutBondValues[m+1, kN+1]
-                vm = callPutBondValues[m+1, kN]
-                vd = callPutBondValues[m+1, kN-1]
+                vu = call_put_bond_values[m+1, kN+1]
+                vm = call_put_bond_values[m+1, kN]
+                vd = call_put_bond_values[m+1, kN-1]
 
             vhold = (pu*vu + pm*vm + pd*vd) * df
             # Need to make add on coupons paid if we hold
             vhold = vhold + flow
             value = min(max(vhold - accrued[m], vput), vcall) + accrued[m]
-            callPutBondValues[m, kN] = value
+            call_put_bond_values[m, kN] = value
 
-    return {'bondwithoption': callPutBondValues[0, j_max],
+    return {'bondwithoption': call_put_bond_values[0, j_max],
             'bondpure': bond_values[0, j_max]}
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def build_tree_fast(a, sigma, tree_times, num_time_steps, discount_factors):
     """ Calibrate the tree to a term structure of interest rates. """
 
-    treeMaturity = tree_times[-1]
-    dt = treeMaturity / (num_time_steps+1)
+    tree_maturity = tree_times[-1]
+    dt = tree_maturity / (num_time_steps+1)
     dX = sigma * np.sqrt(3.0 * dt)
     j_max = ceil(0.1835/(a * dt))
 
     if j_max > 1000:
         raise FinError("j_max > 1000. Increase a or dt.")
 
     pu = np.zeros(shape=(2*j_max+1))
@@ -878,59 +875,62 @@
 
         if a < 0.0:
             raise FinError("Mean reversion speed parameter should be >= 0.")
 
         if a < 1e-10:
             a = 1e-10
 
-        self._a = a
-        self._sigma = sigma
+        self.a = a
+        self.sigma = sigma
 
         if num_time_steps < 3:
             raise FinError("Drift fitting requires at least 3 time steps")
 
-        self._num_time_steps = num_time_steps
+        self.num_time_steps = num_time_steps
 
-        self._Q = None
-        self._rt = None
-        self._tree_times = None
-        self._pu = None
-        self._pm = None
-        self._pd = None
-        self._discount_curve = None
+        self.Q = None
+        self.rt = None
+        self.tree_times = None
+        self.pu = None
+        self.pm = None
+        self.pd = None
+        self.discount_curve = None
+        self.df_times = None
+        self.dfs = None
+        self.dt = None
 
 ###############################################################################
 
     def build_tree(self, t_mat, df_times, df_values):
 
         if isinstance(df_times, np.ndarray) is False:
             raise FinError("DF TIMES must be a numpy vector")
 
         if isinstance(df_values, np.ndarray) is False:
             raise FinError("DF VALUES must be a numpy vector")
 
         interp = InterpTypes.FLAT_FWD_RATES.value
 
-        treeMaturity = t_mat * (self._num_time_steps+1)/self._num_time_steps
-        tree_times = np.linspace(0.0, treeMaturity, self._num_time_steps + 2)
-        self._tree_times = tree_times
+        tree_maturity = t_mat * (self.num_time_steps+1)/self.num_time_steps
+        tree_times = np.linspace(0.0, tree_maturity, self.num_time_steps + 2)
+        self.tree_times = tree_times
 
-        dfTree = np.zeros(shape=(self._num_time_steps+2))
-        dfTree[0] = 1.0
+        df_tree = np.zeros(shape=(self.num_time_steps+2))
+        df_tree[0] = 1.0
 
-        for i in range(1, self._num_time_steps+2):
+        for i in range(1, self.num_time_steps+2):
             t = tree_times[i]
-            dfTree[i] = _uinterpolate(t, df_times, df_values, interp)
+            df_tree[i] = _uinterpolate(t, df_times, df_values, interp)
 
-        self._df_times = df_times
-        self._dfs = df_values
+        self.df_times = df_times
+        self.dfs = df_values
 
-        self._Q, self._pu, self._pm, self._pd, self._rt, self._dt \
-            = build_tree_fast(self._a, self._sigma,
-                              tree_times, self._num_time_steps, dfTree)
+        self.Q, self.pu, self.pm, self.pd, self.rt, self.dt \
+            = build_tree_fast(self.a, self.sigma,
+                              tree_times, self.num_time_steps, df_tree)
 
         return
 
 ###############################################################################
 
     def bond_option(self, t_exp, strike_price, face_amount,
                     cpn_times, cpn_flows, exercise_type):
@@ -950,19 +950,19 @@
         #######################################################################
 
         call_value, put_value \
             = american_bond_option_tree_fast(t_exp, t_mat,
                                              strike_price, face_amount,
                                              cpn_times, cpn_flows,
                                              exercise_type_int,
-                                             self._df_times, self._dfs,
-                                             self._tree_times, self._Q,
-                                             self._pu, self._pm, self._pd,
-                                             self._rt,
-                                             self._dt, self._a)
+                                             self.df_times, self.dfs,
+                                             self.tree_times, self.Q,
+                                             self.pu, self.pm, self.pd,
+                                             self.rt,
+                                             self.dt, self.a)
 
         return {'call': call_value, 'put': put_value}
 
 ###############################################################################
 
     def bermudan_swaption(self, t_exp, t_mat, strike_price, face_amount,
                           cpn_times, cpn_flows, exercise_type):
@@ -978,26 +978,26 @@
             raise FinError("Option expiry after bond matures.")
 
         if t_exp < 0.0:
             raise FinError("Option expiry time negative.")
 
         #######################################################################
 
-        payValue, recValue \
+        pay_value, rec_value \
             = bermudan_swaption_tree_fast(t_exp, t_mat,
                                           strike_price, face_amount,
                                           cpn_times, cpn_flows,
                                           exercise_type_int,
-                                          self._df_times, self._dfs,
-                                          self._tree_times, self._Q,
-                                          self._pu, self._pm, self._pd,
-                                          self._rt,
-                                          self._dt, self._a)
+                                          self.df_times, self.dfs,
+                                          self.tree_times, self.Q,
+                                          self.pu, self.pm, self.pd,
+                                          self.rt,
+                                          self.dt, self.a)
 
-        return {'pay': payValue, 'rec': recValue}
+        return {'pay': pay_value, 'rec': rec_value}
 
 ###############################################################################
 
     def callable_puttable_bond_tree(self,
                                     cpn_times, cpn_flows,
                                     call_times, call_prices,
                                     put_times, put_prices,
@@ -1011,29 +1011,29 @@
 
         call_prices = np.array(call_prices)
         put_prices = np.array(put_prices)
 
         v = callable_puttable_bond_tree_fast(cpn_times, cpn_flows,
                                              call_times, call_prices,
                                              put_times, put_prices, face,
-                                             self._sigma, self._a,
-                                             self._Q,
-                                             self._pu, self._pm, self._pd,
-                                             self._rt, self._dt,
-                                             self._tree_times,
-                                             self._df_times, self._dfs)
+                                             self.sigma, self.a,
+                                             self.Q,
+                                             self.pu, self.pm, self.pd,
+                                             self.rt, self.dt,
+                                             self.tree_times,
+                                             self.df_times, self.dfs)
 
         return {'bondwithoption': v['bondwithoption'],
                 'bondpure': v['bondpure']}
 
 ###############################################################################
 
     def __repr__(self):
         """ Return string with class details. """
 
         s = "Black-Karasinski Model\n"
-        s += label_to_string("Sigma", self._sigma)
-        s += label_to_string("a", self._a)
-        s += label_to_string("num_time_steps", self._num_time_steps)
+        s += label_to_string("Sigma", self.sigma)
+        s += label_to_string("a", self.a)
+        s += label_to_string("num_time_steps", self.num_time_steps)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/black.py` & `financepy-0.360/financepy/models/black.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # TODO Fix this
 from enum import Enum
 
 import numpy as np
 from numba import njit, float64
 
 from ..utils.math import n_vect, n_prime_vect
-from ..utils.global_vars import gSmall
+from ..utils.global_vars import g_small
 from ..utils.helpers import label_to_string
 from ..utils.global_types import OptionTypes
 from ..utils.error import FinError
 from ..utils.solver_1d import bisection, newton
 from ..models.equity_crr_tree import crr_tree_val_avg
 ###############################################################################
 # TODO: Use Numba ?
@@ -29,20 +29,20 @@
 class Black():
     """ Black's Model which prices call and put options in the forward
     measure according to the Black-Scholes equation. """
 
     def __init__(self, volatility, implementation_type=BlackTypes.ANALYTICAL,
                  num_steps=0):
         """ Create FinModel black using parameters. """
-        self._volatility = volatility
-        self._implementation_type = implementation_type
-        self._num_steps = num_steps
-        self._seed = 0
-        self._param1 = 0
-        self._param2 = 0
+        self.volatility = volatility
+        self.implementation_type = implementation_type
+        self.num_steps = num_steps
+        self.seed = 0
+        self.param1 = 0
+        self.param2 = 0
 
 ###############################################################################
 
     def value(self,
               forward_rate,   # Forward rate F
               strike_rate,    # Strike Rate K
               time_to_expiry,  # Time to Expiry (years)
@@ -50,63 +50,63 @@
               option_type):    # Call or put
         """ Price a derivative using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        v = self._volatility
+        v = self.volatility
         r = -np.log(df)/t
         if option_type in (OptionTypes.EUROPEAN_CALL,
                            OptionTypes.EUROPEAN_PUT):
-            if self._implementation_type == BlackTypes.ANALYTICAL:
+            if self.implementation_type == BlackTypes.ANALYTICAL:
                 value = black_value(f, t, k, r, v, option_type)
             else:
                 raise FinError("Implementation not available for this product")
 
         elif option_type in (OptionTypes.AMERICAN_CALL,
                              OptionTypes.AMERICAN_PUT):
 
             results = crr_tree_val_avg(f, 0.0, 0.0, v,
-                                       self._num_steps, t,
+                                       self.num_steps, t,
                                        option_type.value, k)
             value = results['value']
         else:
             raise FinError(
                 "Option type must be a European/American Call or Put")
         return value
 
 ###############################################################################
 
     def delta(self,
-              forward_rate,   # Forward rate F
-              strike_rate,    # Strike Rate K
+              forward_rate,   # Forward rate
+              strike_rate,    # Strike Rate
               time_to_expiry,  # Time to Expiry (years)
-              df,  # RFR to expiry date
+              df,  # Discount factor to expiry date
               option_type):    # Call or put
         """ Calculate delta using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        v = self._volatility
+        v = self.volatility
         r = -np.log(df)/t
 
         if option_type in (OptionTypes.EUROPEAN_CALL,
                            OptionTypes.EUROPEAN_PUT):
-            if self._implementation_type == BlackTypes.ANALYTICAL:
+            if self.implementation_type == BlackTypes.ANALYTICAL:
                 return black_delta(f, t, k, r, v, option_type)
             else:
                 raise FinError("Implementation not available for this product")
         elif option_type in (OptionTypes.AMERICAN_CALL,
                              OptionTypes.AMERICAN_PUT):
-            if self._implementation_type == BlackTypes.CRR_TREE:
+            if self.implementation_type == BlackTypes.CRR_TREE:
                 results = crr_tree_val_avg(
-                    f, 0.0, 0.0, v, self._num_steps, t, option_type.value, k)
+                    f, 0.0, 0.0, v, self.num_steps, t, option_type.value, k)
                 return results['delta']
             else:
                 raise FinError("Implementation not available for this product")
         else:
             raise FinError(
                 "Option type must be a European/American Call or Put")
 
@@ -120,28 +120,28 @@
               option_type):    # Call or put
         """ Calculate gamma using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        v = self._volatility
+        v = self.volatility
         r = -np.log(df)/t
 
         if option_type in (OptionTypes.EUROPEAN_CALL,
                            OptionTypes.EUROPEAN_PUT):
-            if self._implementation_type == BlackTypes.ANALYTICAL:
+            if self.implementation_type == BlackTypes.ANALYTICAL:
                 return black_gamma(f, t, k, r, v, option_type)
             else:
                 raise FinError("Implementation not available for this product")
         elif option_type in (OptionTypes.AMERICAN_CALL,
                              OptionTypes.AMERICAN_PUT):
-            if self._implementation_type == BlackTypes.CRR_TREE:
+            if self.implementation_type == BlackTypes.CRR_TREE:
                 results = crr_tree_val_avg(
-                    f, 0.0, 0.0, v, self._num_steps, t, option_type.value, k)
+                    f, 0.0, 0.0, v, self.num_steps, t, option_type.value, k)
                 return results['gamma']
             else:
                 raise FinError("Implementation not available for this product")
         else:
             raise FinError(
                 "Option type must be a European/American Call or Put")
 ###############################################################################
@@ -154,28 +154,28 @@
               option_type):    # Call or put
         """ Calculate theta using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        v = self._volatility
+        v = self.volatility
         r = -np.log(df)/t
 
         if option_type in (OptionTypes.EUROPEAN_CALL,
                            OptionTypes.EUROPEAN_PUT):
-            if self._implementation_type == BlackTypes.ANALYTICAL:
+            if self.implementation_type == BlackTypes.ANALYTICAL:
                 theta = black_theta(f, t, k, r, v, option_type)
             else:
                 raise FinError("Implementation not available for this product")
         elif option_type in (OptionTypes.AMERICAN_CALL,
                              OptionTypes.AMERICAN_PUT):
-            if self._implementation_type == BlackTypes.CRR_TREE:
+            if self.implementation_type == BlackTypes.CRR_TREE:
                 results = crr_tree_val_avg(
-                    f, 0.0, 0.0, v, self._num_steps, t, option_type.value, k)
+                    f, 0.0, 0.0, v, self.num_steps, t, option_type.value, k)
                 return results['theta']
             else:
                 raise FinError("Implementation not available for this product")
         else:
             raise FinError(
                 "Option type must be a European/American Call or Put")
         return theta
@@ -190,31 +190,31 @@
              option_type):    # Call or put
         """ Calculate vega using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        v = self._volatility
+        v = self.volatility
         r = -np.log(df)/t
 
         if option_type in (OptionTypes.EUROPEAN_CALL,
                            OptionTypes.EUROPEAN_PUT):
-            if self._implementation_type == BlackTypes.ANALYTICAL:
+            if self.implementation_type == BlackTypes.ANALYTICAL:
                 vega = black_vega(f, t, k, r, v, option_type)
             else:
                 raise FinError("Implementation not available for this product")
         elif option_type in (OptionTypes.AMERICAN_CALL,
                              OptionTypes.AMERICAN_PUT):
-            if self._implementation_type == BlackTypes.CRR_TREE:
+            if self.implementation_type == BlackTypes.CRR_TREE:
                 bump_size = 0.01
                 results = crr_tree_val_avg(
-                    f, 0.0, 0.0, v, self._num_steps, t, option_type.value, k)
+                    f, 0.0, 0.0, v, self.num_steps, t, option_type.value, k)
                 results_volshift = crr_tree_val_avg(
-                    f, 0.0, 0.0, v+bump_size, self._num_steps, t,
+                    f, 0.0, 0.0, v+bump_size, self.num_steps, t,
                     option_type.value, k)
                 vega = (results_volshift['value'] -
                         results['value']) / bump_size
                 return vega
             else:
                 raise FinError("Implementation not available for this product")
         else:
@@ -222,17 +222,17 @@
                 "Option type must be a European/American Call or Put")
         return vega
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VOLATILITY", self._volatility)
-        s += label_to_string("IMPLEMENTATION", self._implementation)
-        s += label_to_string("NUMSTEPS", self._num_steps)
+        s += label_to_string("VOLATILITY", self.volatility)
+        s += label_to_string("IMPLEMENTATION", self.implementation_type)
+        s += label_to_string("NUMSTEPS", self.num_steps)
         return s
 
 ###############################################################################
 
 
 def black_value(fwd, t, k, r, v, option_type):
     """ Price a derivative using Black model. """
@@ -287,27 +287,27 @@
         raise FinError("Option type must be a European Call or Put")
 
 
 @njit(float64[:](float64, float64, float64, float64), fastmath=True,
       cache=True)
 def calculate_d1_d2(f, t, k, v):
 
-    t = np.maximum(t, gSmall)
-    vol = np.maximum(v, gSmall)
-    k = np.maximum(k, gSmall)
-    sqrtT = np.sqrt(t)
+    t = np.maximum(t, g_small)
+    vol = np.maximum(v, g_small)
+    k = np.maximum(k, g_small)
+    sqrt_t = np.sqrt(t)
 
     if f <= 0.0:
         raise FinError("Forward is zero.")
 
     if k <= 0.0:
         raise FinError("Strike is zero.")
 
-    d1 = (np.log(f/k) + vol * vol * t / 2.0) / (vol * sqrtT)
-    d2 = d1 - vol * sqrtT
+    d1 = (np.log(f/k) + vol * vol * t / 2.0) / (vol * sqrt_t)
+    d2 = d1 - vol * sqrt_t
 
     return np.array([d1, d2])
 
 ###############################################################################
 
 
 def implied_volatility(fwd, t, r, k, price, option_type, debug_print=True):
@@ -360,15 +360,15 @@
         if european_option_type == OptionTypes.EUROPEAN_CALL:
             price = european_price
         elif european_option_type == OptionTypes.EUROPEAN_PUT:
             price = european_price + np.exp(-r*t) * (fwd - k)
         else:
             raise FinError("Option type must be a European Call or Put")
         sigma_guess = price / (0.398 * np.sqrt(t) * fwd * np.exp(-r*t))
-        if t < gSmall:  # avoid zero division
+        if t < g_small:  # avoid zero division
             sigma_guess = 0.0
         return sigma_guess
 
     # Set objective function, its first derivative, and initial point of implied volatility
     # A simple approximation is used to estimate implied volatility
     # ,which is used as the input of calibration.
     if option_type in (OptionTypes.EUROPEAN_CALL, OptionTypes.EUROPEAN_PUT):
```

### Comparing `financepy-0.350/financepy/models/black_scholes.py` & `financepy-0.360/financepy/products/rates/swap_fixed_leg.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,256 +1,295 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
-# TODO Fix this
+from ...utils.error import FinError
+from ...utils.date import Date
+from ...utils.math import ONE_MILLION
+from ...utils.day_count import DayCount, DayCountTypes
+from ...utils.frequency import FrequencyTypes
+from ...utils.calendar import CalendarTypes,  DateGenRuleTypes
+from ...utils.calendar import Calendar, BusDayAdjustTypes
+from ...utils.schedule import Schedule
+from ...utils.helpers import format_table, label_to_string, check_argument_types
+from ...utils.global_types import SwapTypes
+from ...market.curves.discount_curve import DiscountCurve
+
+##########################################################################
+
+
+class SwapFixedLeg:
+    """ Class for managing the fixed leg of a swap. A fixed leg is a leg with
+    a sequence of flows calculated according to an ISDA schedule and with a
+    coupon that is fixed over the life of the swap. """
 
-import numpy as np
+    def __init__(self,
+                 effective_dt: Date,  # Date interest starts to accrue
+                 end_dt: (Date, str),  # Date contract ends
+                 leg_type: SwapTypes,
+                 coupon: (float),
+                 freq_type: FrequencyTypes,
+                 dc_type: DayCountTypes,
+                 notional: float = ONE_MILLION,
+                 principal: float = 0.0,
+                 payment_lag: int = 0,
+                 cal_type: CalendarTypes = CalendarTypes.WEEKEND,
+                 bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
+                 dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD,
+                 end_of_month: bool = False):
+        """ Create the fixed leg of a swap contract giving the contract start
+        date, its maturity, fixed coupon, fixed leg frequency, fixed leg day
+        count convention and notional.  """
 
-from ..utils.global_types import OptionTypes
-from ..utils.error import FinError
+        check_argument_types(self.__init__, locals())
 
-from ..utils.helpers import check_argument_types
+        if type(end_dt) == Date:
+            self.termination_dt = end_dt
+        else:
+            self.termination_dt = effective_dt.add_tenor(end_dt)
 
-from .model import Model
-from .equity_crr_tree import crr_tree_val_avg
-from .equity_lsmc import equity_lsmc, FIT_TYPES
+        calendar = Calendar(cal_type)
 
-from .black_scholes_analytic import (
-    bs_value,
-    baw_value,
-    bjerksund_stensland_value
-)
-from .finite_difference import black_scholes_fd
-from .finite_difference_PSOR import black_scholes_fd_PSOR
+        self.maturity_dt = calendar.adjust(self.termination_dt,
+                                           bd_type)
 
+        if effective_dt > self.maturity_dt:
+            raise FinError("Effective date after maturity date")
+
+        self.effective_dt = effective_dt
+        self.end_dt = end_dt
+        self.leg_type = leg_type
+        self.freq_type = freq_type
+        self.payment_lag = payment_lag
+        self.notional = notional
+        self.principal = principal
+        self.cpn = coupon
+
+        self.dc_type = dc_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+        self.end_of_month = end_of_month
+
+        self.start_accrued_dts = []
+        self.end_accrued_dts = []
+        self.payment_dts = []
+        self.payments = []
+        self.year_fracs = []
+        self.accrued_days = []
+        self.rates = []
 
-from enum import Enum
+        self.generate_payments()
 
+###############################################################################
 
-class BlackScholesTypes(Enum):
-    DEFAULT = 0
-    ANALYTICAL = 1
-    CRR_TREE = 2
-    BARONE_ADESI = 3
-    LSMC = 4
-    Bjerksund_Stensland = 5
-    FINITE_DIFFERENCE = 6
-    PSOR = 7
+    def generate_payments(self):
+        ''' These are generated immediately as they are for the entire
+        life of the swap. Given a valuation date we can determine
+        which cash flows are in the future and value the swap
+        The schedule allows for a specified lag in the payment date
+        Nothing is paid on the swap effective date and so the first payment
+        date is the first actual payment date. '''
+
+        schedule = Schedule(self.effective_dt,
+                            self.termination_dt,
+                            self.freq_type,
+                            self.cal_type,
+                            self.bd_type,
+                            self.dg_type,
+                            end_of_month=self.end_of_month)
+
+        schedule_dts = schedule.adjusted_dts
+
+        if len(schedule_dts) < 2:
+            raise FinError("Schedule has none or only one date")
+
+        self.start_accrued_dts = []
+        self.end_accrued_dts = []
+        self.payment_dts = []
+        self.payments = []
+        self.year_fracs = []
+        self.accrued_days = []
+        self.rates = []
+
+        prev_dt = schedule_dts[0]
+
+        day_counter = DayCount(self.dc_type)
+        calendar = Calendar(self.cal_type)
 
-###############################################################################
+        for next_dt in schedule_dts[1:]:
 
+            self.start_accrued_dts.append(prev_dt)
+            self.end_accrued_dts.append(next_dt)
 
-class BlackScholes(Model):
+            if self.payment_lag == 0:
+                payment_dt = next_dt
+            else:
+                payment_dt = calendar.add_business_days(next_dt,
+                                                        self.payment_lag)
 
-    ###########################################################################
+            self.payment_dts.append(payment_dt)
 
-    def __init__(self,
-                 volatility: (float, np.ndarray),
-                 bs_type: BlackScholesTypes = BlackScholesTypes.DEFAULT,
-                 num_steps_per_year=52,
-                 num_paths=10000,
-                 seed=42,
-                 use_sobol=False,
-                 params=None):
+            (year_frac, num, den) = day_counter.year_frac(prev_dt,
+                                                          next_dt)
 
-        check_argument_types(self.__init__, locals())
+            self.rates.append(self.cpn)
 
-        self._volatility = volatility
-        self._bs_type = bs_type
-        self._num_steps_per_year = num_steps_per_year
-        self._num_paths = num_paths
-        self._seed = seed
-        self._use_sobol = use_sobol
-        self._params = params if params else {}
+            payment = year_frac * self.notional * self.cpn
 
-    ###########################################################################
+            self.payments.append(payment)
+            self.year_fracs.append(year_frac)
+            self.accrued_days.append(num)
+
+            prev_dt = next_dt
+
+###############################################################################
 
     def value(self,
-              spot_price: float,
-              time_to_expiry: float,
-              strike_price: float,
-              risk_free_rate: float,
-              dividend_rate: float,
-              option_type: OptionTypes):
-
-        if option_type == OptionTypes.EUROPEAN_CALL \
-                or option_type == OptionTypes.EUROPEAN_PUT:
-
-            if self._bs_type is BlackScholesTypes.DEFAULT:
-                self._bs_type = BlackScholesTypes.ANALYTICAL
-
-            if self._bs_type == BlackScholesTypes.ANALYTICAL:
-
-                v = bs_value(spot_price,
-                             time_to_expiry,
-                             strike_price,
-                             risk_free_rate,
-                             dividend_rate,
-                             self._volatility,
-                             option_type.value)
-
-                return v
-
-            elif self._bs_type == BlackScholesTypes.CRR_TREE:
-
-                v = crr_tree_val_avg(spot_price,
-                                     risk_free_rate,
-                                     dividend_rate,
-                                     self._volatility,
-                                     self._num_steps_per_year,
-                                     time_to_expiry,
-                                     option_type.value,
-                                     strike_price)['value']
-
-                return v
-
-            elif self._bs_type == BlackScholesTypes.FINITE_DIFFERENCE:
-
-                v = black_scholes_fd(spot_price=spot_price,
-                                     time_to_expiry=time_to_expiry,
-                                     strike_price=strike_price,
-                                     risk_free_rate=risk_free_rate,
-                                     dividend_yield=dividend_rate,
-                                     volatility=self._volatility,
-                                     option_type=option_type.value,
-                                     **self._params)
-
-                return v
-
-            elif self._bs_type == BlackScholesTypes.PSOR:
-
-                v = black_scholes_fd_PSOR(spot_price=spot_price,
-                                          time_to_expiry=time_to_expiry,
-                                          strike_price=strike_price,
-                                          risk_free_rate=risk_free_rate,
-                                          dividend_yield=dividend_rate,
-                                          volatility=self._volatility,
-                                          option_type=option_type.value,
-                                          **self._params)
-
-                return v
-
-            elif self._bs_type == BlackScholesTypes.LSMC:
-
-                print("LSMC Model", self)
-                poly_degree = self._poly_degree
-                fit_type = self._fit_type
-
-                v = equity_lsmc(spot_price=spot_price,
-                                risk_free_rate=risk_free_rate,
-                                dividend_yield=dividend_rate,
-                                sigma=self._volatility,
-                                num_steps_per_year=self._num_steps_per_year,
-                                num_paths=self._num_paths,
-                                time_to_expiry=time_to_expiry,
-                                option_type_value=option_type.value,
-                                strike_price=strike_price,
-                                poly_degree=poly_degree,
-                                fit_type=fit_type,
-                                use_sobol=self._use_sobol,
-                                seed=self._seed)
+              value_dt: Date,
+              discount_curve: DiscountCurve):
 
-                return v
+        self.payment_dfs = []
+        self.payment_pvs = []
+        self.cumulative_pvs = []
 
-            else:
+        notional = self.notional
+        df_value = discount_curve.df(value_dt)
+        leg_pv = 0.0
+        num_payments = len(self.payment_dts)
+
+        df_payment = 0.0
 
-                raise FinError("Implementation not available for this product")
+        for i_pmnt in range(0, num_payments):
 
-        elif option_type == OptionTypes.AMERICAN_CALL \
-                or option_type == OptionTypes.AMERICAN_PUT:
+            payment_dt = self.payment_dts[i_pmnt]
+            pmnt_amount = self.payments[i_pmnt]
 
-            if self._bs_type is BlackScholesTypes.DEFAULT:
-                self._bs_type = BlackScholesTypes.CRR_TREE
+            if payment_dt > value_dt:
 
-            if self._bs_type == BlackScholesTypes.BARONE_ADESI:
-
-                if option_type == OptionTypes.AMERICAN_CALL:
-                    phi = +1
-                elif option_type == OptionTypes.AMERICAN_PUT:
-                    phi = -1
-
-                v = baw_value(spot_price,
-                              time_to_expiry,
-                              strike_price,
-                              risk_free_rate,
-                              dividend_rate,
-                              self._volatility,
-                              phi)
-
-                return v
-
-            elif self._bs_type == BlackScholesTypes.CRR_TREE:
-
-                v = crr_tree_val_avg(spot_price,
-                                     risk_free_rate,
-                                     dividend_rate,
-                                     self._volatility,
-                                     self._num_steps_per_year,
-                                     time_to_expiry,
-                                     option_type.value,
-                                     strike_price)['value']
-
-                return v
-
-            elif self._bs_type == BlackScholesTypes.LSMC:
-
-                poly_degree = 3
-                fit_type = FIT_TYPES.HERMITE_E
-
-                v = equity_lsmc(spot_price=spot_price,
-                                risk_free_rate=risk_free_rate,
-                                dividend_yield=dividend_rate,
-                                sigma=self._volatility,
-                                num_paths=self._num_paths,
-                                num_steps_per_year=self._num_steps_per_year,
-                                time_to_expiry=time_to_expiry,
-                                option_type_value=option_type.value,
-                                strike_price=strike_price,
-                                poly_degree=poly_degree,
-                                fit_type_value=fit_type.value,
-                                use_sobol=self._use_sobol,
-                                seed=self._seed)
-
-                return v
-            elif self._bs_type == BlackScholesTypes.Bjerksund_Stensland:
-                v = bjerksund_stensland_value(spot_price,
-                                              time_to_expiry,
-                                              strike_price,
-                                              risk_free_rate,
-                                              dividend_rate,
-                                              self._volatility,
-                                              option_type.value)
-                return v
-
-            elif self._bs_type == BlackScholesTypes.FINITE_DIFFERENCE:
-                v = black_scholes_fd(spot_price=spot_price,
-                                     time_to_expiry=time_to_expiry,
-                                     strike_price=strike_price,
-                                     risk_free_rate=risk_free_rate,
-                                     dividend_yield=dividend_rate,
-                                     volatility=self._volatility,
-                                     option_type=option_type.value,
-                                     **self._params)
-                return v
-
-            elif self._bs_type == BlackScholesTypes.PSOR:
-                v = black_scholes_fd_PSOR(spot_price=spot_price,
-                                          time_to_expiry=time_to_expiry,
-                                          strike_price=strike_price,
-                                          risk_free_rate=risk_free_rate,
-                                          dividend_yield=dividend_rate,
-                                          volatility=self._volatility,
-                                          option_type=option_type.value,
-                                          **self._params
-                                          )
-                return v
+                df_payment = discount_curve.df(payment_dt) / df_value
+                payment_pv = pmnt_amount * df_payment
+                leg_pv += payment_pv
+
+                self.payment_dfs.append(df_payment)
+                self.payment_pvs.append(pmnt_amount*df_payment)
+                self.cumulative_pvs.append(leg_pv)
 
             else:
 
-                raise FinError("Implementation not available for this product")
+                self.payment_dfs.append(0.0)
+                self.payment_pvs.append(0.0)
+                self.cumulative_pvs.append(0.0)
+
+        if payment_dt > value_dt:
+            payment_pv = self.principal * df_payment * notional
+            self.payment_pvs[-1] += payment_pv
+            leg_pv += payment_pv
+            self.cumulative_pvs[-1] = leg_pv
+
+        if self.leg_type == SwapTypes.PAY:
+            leg_pv = leg_pv * (-1.0)
+
+        return leg_pv
+
+##########################################################################
+
+    def print_payments(self):
+        """ Prints the fixed leg dates, accrual factors, discount factors,
+        cash amounts, their present value and their cumulative PV using the
+        last valuation performed. """
+
+        print("START DATE:", self.effective_dt)
+        print("MATURITY DATE:", self.maturity_dt)
+        print("COUPON (%):", self.cpn * 100)
+        print("FREQUENCY:", str(self.freq_type))
+        print("DAY COUNT:", str(self.dc_type))
+
+        if len(self.payments) == 0:
+            print("Payments not calculated.")
+            return
+
+        header = ["PAY_NUM", "PAY_dt", "ACCR_START", "ACCR_END",
+                  "DAYS", "YEARFRAC", "RATE", "PMNT"]
+
+        rows = []
+        num_flows = len(self.payment_dts)
+        for i_flow in range(0, num_flows):
+            rows.append([
+                i_flow + 1,
+                self.payment_dts[i_flow],
+                self.start_accrued_dts[i_flow],
+                self.end_accrued_dts[i_flow],
+                self.accrued_days[i_flow],
+                round(self.year_fracs[i_flow], 4),
+                round(self.rates[i_flow] * 100.0, 4),
+                round(self.payments[i_flow], 2),
+            ])
+
+        table = format_table(header, rows)
+        print("\nPAYMENTS SCHEDULE:")
+        print(table)
 
-        else:
+###############################################################################
+
+    def print_valuation(self):
+        """ Prints the fixed leg dates, accrual factors, discount factors,
+        cash amounts, their present value and their cumulative PV using the
+        last valuation performed. """
+
+        print("START DATE:", self.effective_dt)
+        print("MATURITY DATE:", self.maturity_dt)
+        print("COUPON (%):", self.cpn * 100)
+        print("FREQUENCY:", str(self.freq_type))
+        print("DAY COUNT:", str(self.dc_type))
+
+        if len(self.payments) == 0:
+            print("Payments not calculated.")
+            return
+
+        header = ["PAY_NUM", "PAY_dt", "NOTIONAL",
+                  "RATE", "PMNT", "DF", "PV", "CUM_PV"]
+
+        rows = []
+        num_flows = len(self.payment_dts)
+        for i_flow in range(0, num_flows):
+            rows.append([
+                i_flow + 1,
+                self.payment_dts[i_flow],
+                round(self.notional, 0),
+                round(self.rates[i_flow] * 100.0, 4),
+                round(self.payments[i_flow], 2),
+                round(self.payment_dfs[i_flow], 4),
+                round(self.payment_pvs[i_flow], 2),
+                round(self.cumulative_pvs[i_flow], 2),
+            ])
+
+        table = format_table(header, rows)
+        print("\nPAYMENTS VALUATION:")
+        print(table)
+
+##########################################################################
+
+    def __repr__(self):
+        s = label_to_string("OBJECT TYPE", type(self).__name__)
+        s += label_to_string("START DATE", self.effective_dt)
+        s += label_to_string("TERMINATION DATE", self.termination_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("PRINCIPAL", self.principal)
+        s += label_to_string("LEG TYPE", self.leg_type)
+        s += label_to_string("COUPON", self.cpn)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT", self.dc_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUS DAY ADJUST", self.bd_type)
+        s += label_to_string("DATE GEN TYPE", self.dg_type)
+        return s
+
+###############################################################################
 
-            raise FinError("Should not be here")
+    def _print(self):
+        """ Print a list of the unadjusted coupon payment dates used in
+        analytic calculations for the bond. """
+        print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/black_scholes_analytic.py` & `financepy-0.360/financepy/models/black_scholes_analytic.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,39 +2,39 @@
 # Copyright (C) 2020 Dominic O'Kane, G Poorna Prudhvi
 ##############################################################################
 
 import numpy as np
 from numba import float64, int64, vectorize, njit
 
 from ..utils.global_types import OptionTypes
-from ..utils.global_vars import gSmall
+from ..utils.global_vars import g_small
 from ..utils.math import N, n_vect, n_prime_vect
 from ..utils.error import FinError
 from ..utils.solver_1d import bisection, newton, newton_secant
 
 ###############################################################################
 # Analytical Black Scholes model implementation and approximations
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64, float64, float64,
                     int64)], fastmath=True, cache=True)
 def bs_value(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
+    """Price a derivative using Black-Scholes model."""
 
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         phi = 1.0
     elif option_type_value == OptionTypes.EUROPEAN_PUT.value:
         phi = -1.0
     else:
         raise FinError("Unknown option type value")
 
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     v_sqrt_t = v * np.sqrt(t)
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     d2 = d1 - v_sqrt_t
 
@@ -43,65 +43,62 @@
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, float64, int64)], fastmath=True, cache=True)
 def bs_delta(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
-
+    """Price a derivative using Black-Scholes model."""
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         phi = +1.0
     elif option_type_value == OptionTypes.EUROPEAN_PUT.value:
         phi = -1.0
     else:
-        raise FinError("Unknown option type value")
-        return 0.0
+        raise FinError("Error: Unknown option type value")
 
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     v_sqrt_t = v * np.sqrt(t)
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     delta = phi * np.exp(-q*t) * n_vect(phi * d1)
     return delta
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, float64, int64)], fastmath=True, cache=True)
 def bs_gamma(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
+    """Price a derivative using Black-Scholes model."""
 
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     v_sqrt_t = v * np.sqrt(t)
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     gamma = np.exp(-q*t) * n_prime_vect(d1) / s / v_sqrt_t
     return gamma
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, float64, int64)], fastmath=True, cache=True)
 def bs_vega(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
-
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    """Price a derivative using Black-Scholes model."""
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     sqrt_t = np.sqrt(t)
     v_sqrt_t = v * sqrt_t
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     vega = ss * sqrt_t * n_prime_vect(d1)
@@ -109,24 +106,24 @@
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, float64, int64)], fastmath=True, cache=True)
 def bs_theta(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
+    """Price a derivative using Black-Scholes model."""
 
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         phi = 1.0
     elif option_type_value == OptionTypes.EUROPEAN_PUT.value:
         phi = -1.0
 
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     sqrt_t = np.sqrt(t)
     v_sqrt_t = v * sqrt_t
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     d2 = d1 - v_sqrt_t
@@ -137,24 +134,24 @@
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, float64, int64)], fastmath=True, cache=True)
 def bs_rho(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
+    """Price a derivative using Black-Scholes model."""
 
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         phi = 1.0
     elif option_type_value == OptionTypes.EUROPEAN_PUT.value:
         phi = -1.0
 
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     sqrt_t = np.sqrt(t)
     v_sqrt_t = v * sqrt_t
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     d2 = d1 - v_sqrt_t
@@ -163,19 +160,19 @@
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, float64, int64)], fastmath=True, cache=True)
 def bs_vanna(s, t, k, r, q, v, option_type_value):
-    """ Price a derivative using Black-Scholes model. """
+    """Price a derivative using Black-Scholes model."""
 
-    k = np.maximum(k, gSmall)
-    t = np.maximum(t, gSmall)
-    v = np.maximum(v, gSmall)
+    k = np.maximum(k, g_small)
+    t = np.maximum(t, g_small)
+    v = np.maximum(v, g_small)
 
     sqrt_t = np.sqrt(t)
     v_sqrt_t = v * sqrt_t
     ss = s * np.exp(-q*t)
     kk = k * np.exp(-r*t)
     d1 = np.log(ss/kk) / v_sqrt_t + v_sqrt_t / 2.0
     d2 = d1 - v_sqrt_t
@@ -192,16 +189,16 @@
     t = args[1]
     k = args[2]
     r = args[3]
     q = args[4]
     price = args[5]
     option_type_value = int(args[6])
 
-    bsPrice = bs_value(s, t, k, r, q, sigma, option_type_value)
-    obj = bsPrice - price
+    bs_price = bs_value(s, t, k, r, q, sigma, option_type_value)
+    obj = bs_price - price
     return obj
 
 ##############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def _fvega(sigma, args):
@@ -217,76 +214,76 @@
 
 ###############################################################################
 
 
 @vectorize([float64(float64, float64, float64, float64,
                     float64, int64)], fastmath=True, cache=True)
 def bs_intrinsic(s, t, k, r, q, option_type_value):
-    """ Calculate the Black-Scholes implied volatility of a European
-    vanilla option using Newton with a fallback to bisection. """
+    """Calculate the Black-Scholes implied volatility of a European
+     vanilla option using Newton with a fallback to bisection."""
 
     fwd = s * np.exp((r-q)*t)
 
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         intrinsic_value = np.exp(-r*t) * max(fwd - k, 0.0)
     else:
         intrinsic_value = np.exp(-r*t) * max(k - fwd, 0.0)
 
     return intrinsic_value
 
 ###############################################################################
 
 
-# @vectorize([float64(float64, float64, float64, float64, float64, float64,
-#                    int64)], fastmath=True, cache=True,  forceobj=True)
+@vectorize([float64(float64, float64, float64, float64, float64, float64,
+                    int64)], fastmath=True, cache=True,  forceobj=True)
 def bs_implied_volatility(s, t, k, r, q, price, option_type_value):
-    """ Calculate the Black-Scholes implied volatility of a European
-    vanilla option using Newton with a fallback to bisection. """
+    """Calculate the Black-Scholes implied volatility of a European
+     vanilla option using Newton with a fallback to bisection."""
 
     fwd = s * np.exp((r-q)*t)
 
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         intrinsic_value = np.exp(-r*t) * max(fwd - k, 0.0)
     else:
         intrinsic_value = np.exp(-r*t) * max(k - fwd, 0.0)
 
-    divAdjStockPrice = s * np.exp(-q * t)
+    div_adj_stock_price = s * np.exp(-q * t)
     df = np.exp(-r * t)
 
     # Flip ITM call option to be OTM put and vice-versa using put call parity
     if intrinsic_value > 0.0:
 
         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
-            price = price - (divAdjStockPrice - k * df)
+            price = price - (div_adj_stock_price - k * df)
             option_type_value = OptionTypes.EUROPEAN_PUT.value
         else:
-            price = price + (divAdjStockPrice - k * df)
+            price = price + (div_adj_stock_price - k * df)
             option_type_value = OptionTypes.EUROPEAN_CALL.value
 
         # Update intrinsic based on new option type
         if option_type_value == OptionTypes.EUROPEAN_CALL.value:
             intrinsic_value = np.exp(-r*t) * max(fwd - k, 0.0)
         else:
             intrinsic_value = np.exp(-r*t) * max(k - fwd, 0.0)
 
-    timeValue = price - intrinsic_value
+    time_value = price - intrinsic_value
 
     # Add a tolerance in case it is just numerical imprecision
-    if timeValue < 0.0:
-        print("Time value", timeValue)
+    if time_value < 0.0:
+        print("Time value", time_value)
         raise FinError("Option Price is below the intrinsic value")
 
     ###########################################################################
     # Some approximations which might be used later
     ###########################################################################
 
     if option_type_value == OptionTypes.EUROPEAN_CALL.value:
         call = price
     else:
-        call = price + (divAdjStockPrice - k * df)
+        call = price + (div_adj_stock_price - k * df)
 
     # Notation in SSRN-id567721.pdf
     X = k * np.exp(-r*t)
     S = s*np.exp(-q*t)
     pi = np.pi
 
     ###########################################################################
@@ -313,19 +310,17 @@
     ###########################################################################
     # Hallerbach SSRN-id567721.pdf equation (22)
     ###########################################################################
 
     hsigma = 0.0
     gamma = 2.0
     arg = (2*call+X-S)**2 - gamma * (S+X)*(S-X)*(S-X) / pi / S
+    arg = max(arg, 0.0)
 
-    if arg < 0.0:
-        arg = 0.0
-
-    hsigma = (2 * call + X - S + np.sqrt(arg))
+    hsigma = 2.0 * call + X - S + np.sqrt(arg)
     hsigma = hsigma * np.sqrt(2.0*pi) / 2.0 / (S+X)
     hsigma = hsigma / np.sqrt(t)
 
     sigma0 = hsigma
 
     ###########################################################################
 
@@ -357,15 +352,15 @@
 # https://deriscope.com/docs/Barone_Adesi_Whaley_1987.pdf
 ###############################################################################
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def _fcall(si, *args):
-    """ Function to determine ststar for pricing American call options. """
+    """Function to determine ststar for pricing American call options."""
 
     t = args[0]
     k = args[1]
     r = args[2]
     q = args[3]
     v = args[4]
 
@@ -385,15 +380,15 @@
     return obj_fn
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def _fput(si, *args):
-    """ Function to determine sstar for pricing American put options. """
+    """Function to determine sstar for pricing American put options."""
 
     t = args[0]
     k = args[1]
     r = args[2]
     q = args[3]
     v = args[4]
 
@@ -413,16 +408,16 @@
 ###############################################################################
 # TODO: NUMBA SPEED UP
 ###############################################################################
 
 
 @njit(fastmath=True)
 def baw_value(s, t, k, r, q, v, phi):
-    """ American Option Pricing Approximation using the Barone-Adesi-Whaley
-    approximation for the Black Scholes Model """
+    """American Option Pricing Approximation using the Barone-Adesi-Whaley
+     approximation for the Black Scholes Model"""
 
     b = r - q
 
     if phi == 1:
 
         if b >= r:
             return bs_value(s, t, k, r, q, v, +1)
@@ -437,85 +432,83 @@
         K = 1.0 - np.exp(-r * t)
         d1 = (np.log(sstar/k) + (b + v*v / 2.0) * t) / (v * np.sqrt(t))
         q2 = (-1.0 * (W - 1.0) + np.sqrt((W - 1.0)**2 + 4.0 * M/K)) / 2.0
         A2 = (sstar / q2) * (1.0 - np.exp(-q * t) * n_vect(d1))
 
         if s < sstar:
             return bs_value(s, t, k, r, q, v, OptionTypes.EUROPEAN_CALL.value) + A2 * ((s/sstar)**q2)
-        else:
-            return s - k
+
+        return s - k
 
     elif phi == -1:
 
         argtuple = (t, k, r, q, v)
 
-#        sstar = optimize.newton(_fput, x0=s, fprime=None, args=argtuple,
-#                                tol=1e-7, maxiter=50, fprime2=None)
-
-        sstar = newton_secant(_fput, x0=s, args=argtuple,
-                              tol=1e-7, maxiter=50)
+        sstar = newton_secant(_fput, x0=s, args=argtuple, tol=1e-7, maxiter=50)
 
         v2 = v * v
 
         M = 2.0 * r / v2
         W = 2.0 * b / v2
         K = 1.0 - np.exp(-r * t)
         d1 = (np.log(sstar / k) + (b + v2 / 2.0) * t) / (v * np.sqrt(t))
         q1 = (-1.0 * (W - 1.0) - np.sqrt((W - 1.0)**2 + 4.0 * M/K)) / 2.0
         a1 = -(sstar / q1) * (1 - np.exp(-q * t) * n_vect(-d1))
 
         if s > sstar:
-            return bs_value(s, t, k, r, q, v, OptionTypes.EUROPEAN_PUT.value) + a1 * ((s/sstar)**q1)
+            bsv = bs_value(s, t, k, r, q, v, OptionTypes.EUROPEAN_PUT.value)
+            return bsv + a1 * ((s/sstar)**q1)
         else:
             return k - s
 
     else:
 
         raise FinError("Phi must equal 1 or -1.")
 
 ###############################################################################
 
 
 @njit(fastmath=True)
 def bjerksund_stensland_value(s, t, k, r, q, v, option_type_value):
-    """ Price American Option using the Bjerksund-Stensland
-    approximation (1993) for the Black Scholes Model """
+    """Price American Option using the Bjerksund-Stensland
+     approximation (1993) for the Black Scholes Model"""
     if option_type_value == OptionTypes.AMERICAN_CALL.value:
         pass
     elif option_type_value == OptionTypes.AMERICAN_PUT.value:
         # put-call transformation
         s, k, r, q = k, s, r-q, -q
     else:
         return 0.0
 
     def phi(S, T, gamma, H, X):
-        """ The function corresponding to Eq.(13)
-        in Bjerksund-Stensland approximation (1993)"""
+        """Eq.(13) in Bjerksund-Stensland approximation (1993)."""
         nonlocal r, q
-        lambda0 = (-r + gamma * q + 0.5 * gamma * (gamma - 1.0) * v**2) * T
-        d = - (np.log(S/H) + (q + (gamma - 0.5) * v**2) * T) / (v * np.sqrt(t))
+        lambda0 = (-r + gamma * q + 0.5 * gamma *
+                   (gamma - 1.0) * v**2) * T
+        d = - (np.log(S/H) + (q + (gamma - 0.5) * v**2) * T) / \
+            (v * np.sqrt(t))
         kappa = (2.0 * gamma - 1.0) + (2.0 * q) / v**2
         return (
             np.exp(lambda0) * (S ** gamma)
             * (N(d) - N(d - (2.0 * np.log(X/S)/v/np.sqrt(T))) * ((X/S)**kappa))
         )
+
     # calc trigger price x_t
     beta = (0.5 - q/(v**2)) + np.sqrt((0.5 - q/(v**2))**2 + 2.0 * r/(v**2))
     # avoid division by zero
     if abs(r-q) < 1.e-10:
         beta = 1.0
         x_t = 1.e10
     else:
         b_infty = k * beta / (beta - 1.0)
         b_0 = max(k, k * r/((r-q)))
         h_t = -(q*t + 2.0 * v * np.sqrt(t)) * (b_0 / (b_infty - b_0))
         x_t = b_0 + (b_infty - b_0) * (1.0 - np.exp(h_t))
     # calc option value
     alpha = (x_t - k) * x_t ** (-beta)
-    value = (
-        alpha * (s**beta) - alpha * phi(s, t, beta, x_t, x_t)
-        + phi(s, t, 1.0, x_t, x_t) - phi(s, t, 1.0, k, x_t)
-        - k * phi(s, t, 0.0, x_t, x_t) + k * phi(s, t, 0.0, k, x_t)
-    )
+    value = (alpha * (s**beta) - alpha * phi(s, t, beta, x_t, x_t)
+             + phi(s, t, 1.0, x_t, x_t) - phi(s, t, 1.0, k, x_t)
+             - k * phi(s, t, 0.0, x_t, x_t) + k * phi(s, t, 0.0, k, x_t))
+
     return value
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/black_scholes_mc.py` & `financepy-0.360/financepy/models/black_scholes_mc.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/models/black_scholes_mc_tests.py` & `financepy-0.360/financepy/models/black_scholes_mc_tests.py`

 * *Files 0% similar despite different names*

```diff
@@ -10,15 +10,14 @@
 
 from math import exp, sqrt
 
 ###############################################################################
 
 
 def value_mc1(s0, t, k, r, q, v, num_paths, seed):
-
     v_sqrt_t = v * sqrt(t)
     st = s0 * exp((r - q - v*v / 2.0) * t)
 
     np.random.seed(seed)
     g = np.random.standard_normal(num_paths)
 
     payoff = 0.0
```

### Comparing `financepy-0.350/financepy/models/black_shifted.py` & `financepy-0.360/financepy/models/black_shifted.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,40 +18,40 @@
     """ Black's Model which prices call and put options in the forward
     measure according to the Black-Scholes equation. This model also allows
     the distribution to be shifted to the negative in order to allow for
     negative interest rates. """
 
     def __init__(self, volatility, shift, implementation=0):
         """ Create FinModel black using parameters. """
-        self._volatility = volatility
-        self._shift = shift
-        self._implementation = 0
-        self._num_steps = 0
-        self._seed = 0
-        self._param1 = 0
-        self._param2 = 0
+        self.volatility = volatility
+        self.shift = shift
+        self.implementation = 0
+        self.num_steps = 0
+        self.seed = 0
+        self.param1 = 0
+        self.param2 = 0
 
 ###############################################################################
 
     def value(self,
               forward_rate,    # Forward rate
               strike_rate,     # Strike Rate
               time_to_expiry,  # time to expiry in years
               df,              # Discount Factor to expiry date
               call_or_put):    # Call or put
         """ Price a derivative using Black's model which values in the forward
         measure following a change of measure. The sign of the shift is the
         same as Matlab. """
 
-        s = self._shift
+        s = self.shift
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
         sqrt_t = np.sqrt(t)
-        vol = self._volatility
+        vol = self.volatility
 
         d1 = np.log((f+s)/(k+s)) + vol * vol * t / 2
         d1 = d1 / (vol * sqrt_t)
         d2 = d1 - vol * sqrt_t
 
         if call_or_put == OptionTypes.EUROPEAN_CALL:
             return df * ((f+s) * N(d1) - (k + s) * N(d2))
@@ -59,15 +59,15 @@
             return df * ((k+s) * N(-d2) - (f + s) * N(-d1))
         else:
             raise Exception("Option type must be a European Call(C) or Put(P)")
 
 ###############################################################################
 
     def __repr__(self):
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VOLATILITY", self._volatility)
-        s += label_to_string("SHIFT", self._shift)
-        s += label_to_string("IMPLEMENTATION", self._implementation)
-        s += label_to_string("NUMSTEPS", self._num_steps)
+        s = label_to_string("OBJECT TYPE", type(self)._name__)
+        s += label_to_string("VOLATILITY", self.volatility)
+        s += label_to_string("SHIFT", self.shift)
+        s += label_to_string("IMPLEMENTATION", self.implementation)
+        s += label_to_string("NUMSTEPS", self.num_steps)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/cir_mc.py` & `financepy-0.360/financepy/models/cir_montecarlo.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
+from enum import Enum
 from numba import njit, float64, int64
 import numpy as np
 from ..utils.helpers import label_to_string
 
 ###############################################################################
 # CIR Process
 # dr = a(b-r) + sigma sqrt(r) dW
 # Note that r can hit zero if 2.0 * a * b < sigma*sigma:
 ###############################################################################
 
 # TO DO - DECIDE WHETHER TO OO MODEL
 # CAN DO Z SCALING INSIDE NUMPY ?
 # ANTITHETICS
 
-from enum import Enum
 
 
 class CIRNumericalScheme(Enum):
     EULER = 1
     LOGNORMAL = 2
     MILSTEIN = 3
     KAHLJACKEL = 4
@@ -28,25 +28,24 @@
 
 
 ###############################################################################
 
 # THIS CLASS IS NOT USED BUT MAY BE USED IF WE CREATE AN OO FRAMEWORK
 
 
-class CIR_MC():
+class CIRMonteCarlo():
     ''' This is a Monte Carlo implementation of the Cox-Ingersoll-Ross Model'''
 
     def __init__(self, a, b, sigma):
         self._a = a
         self._b = b
         self._sigma = sigma
 
     def __repr__(self):
         """ Return string with class details. """
-
         s = label_to_string("OBJECT TYPE", type(self).__name__)
         s += label_to_string("Sigma", self._sigma)
         s += label_to_string("a", self._a)
         s += label_to_string("b", self._b)
         return s
 
 
@@ -145,33 +144,33 @@
     rate_path[0] = r0
     num_paths = 1
 
     if scheme == CIRNumericalScheme.EULER.value:
 
         sigmasqrt_dt = sigma * np.sqrt(dt)
 
-        for i_path in range(0, num_paths):
+        for _ in range(0, num_paths):
 
             r = r0
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps-1)
 
             for i_step in range(1, num_steps):
                 r = r + a * (b - r) * dt + \
                     z[i_step - 1] * sigmasqrt_dt * np.sqrt(max(r, 0.0))
                 rate_path[i_step] = r
 
     elif scheme == CIRNumericalScheme.LOGNORMAL.value:
 
         x = np.exp(-a * dt)
         y = 1.0 - x
 
         for i_path in range(0, num_paths):
 
             r = r0
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 mean = x * r + b * y
                 var = sigma * sigma * y * (x * r + 0.50 * b * y) / a
                 sig = np.sqrt(np.log(1.0 + var / (mean * mean)))
                 r = mean * np.exp(-0.5 * sig * sig + sig * z[i_step - 1])
                 rate_path[i_step] = r
@@ -180,15 +179,15 @@
 
         sigmasqrt_dt = sigma * np.sqrt(dt)
         sigma2dt = sigma * sigma * dt / 4.0
 
         for i_path in range(0, num_paths):
 
             r = r0
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 r = r + a * (b - r) * dt + \
                     z[i_step - 1] * sigmasqrt_dt * np.sqrt(max(0.0, r))
                 r = r + sigma2dt * (z[i_step - 1] ** 2 - 1.0)
                 rate_path[i_step] = r
 
@@ -196,15 +195,15 @@
 
         bhat = b - sigma * sigma / 4.0 / a
         sqrt_dt = np.sqrt(dt)
 
         for i_path in range(0, num_paths):
 
             r = r0
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 beta = z[i_step - 1] / sqrt_dt
                 rootr = np.sqrt(max(r, 1e-8))
                 c = 1.0 + (sigma * beta - 2.0 * a * rootr) * dt / 4.0 / rootr
                 r = r + (a * (bhat - r) + sigma * beta * rootr) * c * dt
                 rate_path[i_step] = r
@@ -251,15 +250,15 @@
 
         sigmasqrt_dt = sigma * np.sqrt(dt)
 
         for i_path in range(0, num_paths):
 
             r = r0
             rsum = r
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 r_prev = r
                 r = r + a * (b - r) * dt + \
                     z[i_step - 1] * sigmasqrt_dt * np.sqrt(max(r, 0.0))
                 rsum += (r + r_prev)
 
@@ -271,15 +270,15 @@
         y = 1.0 - x
 
         for i_path in range(0, num_paths):
 
             r = r0
             rsum = r0
 
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 mean = x * r + b * y
                 var = sigma * sigma * y * (x * r + 0.50 * b * y) / a
                 sig = np.sqrt(np.log(1.0 + var / (mean * mean)))
                 r_prev = r
                 r = mean * np.exp(-0.5 * sig * sig + sig * z[i_step - 1])
@@ -292,15 +291,15 @@
         sigmasqrt_dt = sigma * np.sqrt(dt)
         sigma2dt = sigma * sigma * dt / 4.0
 
         for i_path in range(0, num_paths):
 
             r = r0
             rsum = r
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 r_prev = r
                 r = r + a * (b - r) * dt + \
                     z[i_step - 1] * sigmasqrt_dt * np.sqrt(max(0.0, r))
                 r = r + sigma2dt * (z[i_step - 1] ** 2 - 1.0)
                 rsum += (r + r_prev)
@@ -312,15 +311,15 @@
         bhat = b - sigma * sigma / 4.0 / a
         sqrt_dt = np.sqrt(dt)
 
         for i_path in range(0, num_paths):
 
             r = r0
             rsum = r
-            z = np.random.normal(0.0, 1.0, size=(num_steps - 1))
+            z = np.random.normal(0.0, 1.0, size=num_steps - 1)
 
             for i_step in range(1, num_steps):
                 beta = z[i_step - 1] / sqrt_dt
                 rootr = np.sqrt(max(r, 1e-8))
                 c = 1.0 + (sigma * beta - 2.0 * a * rootr) * dt / 4.0 / rootr
                 r_prev = r
                 r = r + (a * (bhat - r) + sigma * beta * rootr) * c * dt
```

### Comparing `financepy-0.350/financepy/models/equity_barrier_models.py` & `financepy-0.360/financepy/models/equity_barrier_models.py`

 * *Files 13% similar despite different names*

```diff
@@ -16,22 +16,22 @@
 @vectorize([float64(float64, float64, float64, float64, float64, float64,
                     float64, int64, int64)], fastmath=True, cache=True)
 def value_barrier(t, k, h, s, r, q, v, option_type, nobs):
     """ This values a single barrier option. Because of its structure it cannot
     easily be vectorised which is why it has been wrapped.
     # number of observations per year
     """
-    lnS0k = np.log(s / k)
-    sqrtT = np.sqrt(t)
+    ln_s0_k = np.log(s / k)
+    sqrt_t = np.sqrt(t)
 
-    sigma_rt_t = v * sqrtT
+    sigma_rt_t = v * sqrt_t
     v2 = v * v
     mu = r - q
-    d1 = (lnS0k + (mu + v2 / 2.0) * t) / sigma_rt_t
-    d2 = (lnS0k + (mu - v2 / 2.0) * t) / sigma_rt_t
+    d1 = (ln_s0_k + (mu + v2 / 2.0) * t) / sigma_rt_t
+    d2 = (ln_s0_k + (mu - v2 / 2.0) * t) / sigma_rt_t
     df = np.exp(-r * t)
     dq = np.exp(-q * t)
 
     c = s * dq * N(d1) - k * df * N(d2)
     p = k * df * N(-d2) - s * dq * N(-d1)
 
     if s >= h:
@@ -42,26 +42,25 @@
             return 0.0
         if option_type == EquityBarrierTypes.UP_AND_IN_CALL.value:
             return c
         if option_type == EquityBarrierTypes.UP_AND_IN_PUT.value:
             return p
 
     else:
-        
+
         if option_type == EquityBarrierTypes.DOWN_AND_OUT_CALL.value:
             return 0.0
         elif option_type == EquityBarrierTypes.DOWN_AND_OUT_PUT.value:
             return 0.0
         elif option_type == EquityBarrierTypes.DOWN_AND_IN_CALL.value:
             return c
         elif option_type == EquityBarrierTypes.DOWN_AND_IN_PUT.value:
             return p
-        
 
-    if 1 == 0:        
+    if 1 == 0:
         if option_type == EquityBarrierTypes.DOWN_AND_OUT_CALL.value and s <= h:
             return 0.0
         elif option_type == EquityBarrierTypes.UP_AND_OUT_CALL.value and s >= h:
             return 0.0
         elif option_type == EquityBarrierTypes.UP_AND_OUT_PUT.value and s >= h:
             return 0.0
         elif option_type == EquityBarrierTypes.DOWN_AND_OUT_PUT.value and s <= h:
@@ -106,98 +105,98 @@
     if abs(v) < 1e-5:
         v = 1e-5
 
     ll = (mu + v*v / 2.0) / v2
     y = np.log(h * h / (s * k)) / sigma_rt_t + ll * sigma_rt_t
     x1 = np.log(s / h) / sigma_rt_t + ll * sigma_rt_t
     y1 = np.log(h / s) / sigma_rt_t + ll * sigma_rt_t
-    hOverS = h / s
+    h_over_s = h / s
 
     if option_type == EquityBarrierTypes.DOWN_AND_OUT_CALL.value:
         if h >= k:
             c_do = s * dq * N(x1) - k * df * N(x1 - sigma_rt_t) \
-                   - s * dq * pow(hOverS, 2.0 * ll) * N(y1) \
-                   + k * df * pow(hOverS, 2.0 * ll - 2.0) * N(y1 - sigma_rt_t)
+                - s * dq * pow(h_over_s, 2.0 * ll) * N(y1) \
+                + k * df * pow(h_over_s, 2.0 * ll - 2.0) * N(y1 - sigma_rt_t)
             price = c_do
         else:
-            c_di = s * dq * pow(hOverS, 2.0 * ll) * N(y) \
-                   - k * df * pow(hOverS, 2.0 * ll - 2.0) * N(y - sigma_rt_t)
+            c_di = s * dq * pow(h_over_s, 2.0 * ll) * N(y) \
+                - k * df * pow(h_over_s, 2.0 * ll - 2.0) * N(y - sigma_rt_t)
             price = c - c_di
     elif option_type == EquityBarrierTypes.DOWN_AND_IN_CALL.value:
         if h <= k:
-            c_di = s * dq * pow(hOverS, 2.0 * ll) * N(y) \
-                   - k * df * pow(hOverS, 2.0 * ll - 2.0) * N(y - sigma_rt_t)
+            c_di = s * dq * pow(h_over_s, 2.0 * ll) * N(y) \
+                - k * df * pow(h_over_s, 2.0 * ll - 2.0) * N(y - sigma_rt_t)
             price = c_di
         else:
             c_do = s * dq * N(x1) \
-                   - k * df * N(x1 - sigma_rt_t) \
-                   - s * dq * pow(hOverS, 2.0 * ll) * N(y1) \
-                   + k * df * pow(hOverS, 2.0 * ll - 2.0) * N(y1 - sigma_rt_t)
+                - k * df * N(x1 - sigma_rt_t) \
+                - s * dq * pow(h_over_s, 2.0 * ll) * N(y1) \
+                + k * df * pow(h_over_s, 2.0 * ll - 2.0) * N(y1 - sigma_rt_t)
             price = c - c_do
     elif option_type == EquityBarrierTypes.UP_AND_IN_CALL.value:
         if h >= k:
             c_ui = s * dq * N(x1) - k * df * N(x1 - sigma_rt_t) \
-                   - s * dq * pow(hOverS, 2.0 * ll) * (N(-y) - N(-y1)) \
-                   + k * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                   (N(-y + sigma_rt_t) - N(-y1 + sigma_rt_t))
+                - s * dq * pow(h_over_s, 2.0 * ll) * (N(-y) - N(-y1)) \
+                + k * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                (N(-y + sigma_rt_t) - N(-y1 + sigma_rt_t))
             price = c_ui
         else:
             price = c
     elif option_type == EquityBarrierTypes.UP_AND_OUT_CALL.value:
         if h > k:
             c_ui = s * dq * N(x1) - k * df * N(x1 - sigma_rt_t) \
-                   - s * dq * pow(hOverS, 2.0 * ll) * (N(-y) - N(-y1)) \
-                   + k * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                   (N(-y + sigma_rt_t) - N(-y1 + sigma_rt_t))
+                - s * dq * pow(h_over_s, 2.0 * ll) * (N(-y) - N(-y1)) \
+                + k * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                (N(-y + sigma_rt_t) - N(-y1 + sigma_rt_t))
             price = c - c_ui
         else:
             price = 0.0
     elif option_type == EquityBarrierTypes.UP_AND_IN_PUT.value:
         if h > k:
-            p_ui = -s * dq * pow(hOverS, 2.0 * ll) * N(-y) \
-                   + k * df * pow(hOverS, 2.0 * ll - 2.0) * N(-y + sigma_rt_t)
+            p_ui = -s * dq * pow(h_over_s, 2.0 * ll) * N(-y) \
+                + k * df * pow(h_over_s, 2.0 * ll - 2.0) * N(-y + sigma_rt_t)
             price = p_ui
         else:
             p_uo = -s * dq * N(-x1) \
-                   + k * df * N(-x1 + sigma_rt_t) \
-                   + s * dq * pow(hOverS, 2.0 * ll) * N(-y1) \
-                   - k * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                   N(-y1 + sigma_rt_t)
+                + k * df * N(-x1 + sigma_rt_t) \
+                + s * dq * pow(h_over_s, 2.0 * ll) * N(-y1) \
+                   - k * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                N(-y1 + sigma_rt_t)
             price = p - p_uo
     elif option_type == EquityBarrierTypes.UP_AND_OUT_PUT.value:
         if h >= k:
-            p_ui = -s * dq * pow(hOverS, 2.0 * ll) * N(-y) \
-                   + k * df * pow(hOverS, 2.0 * ll - 2.0) * N(-y + sigma_rt_t)
+            p_ui = -s * dq * pow(h_over_s, 2.0 * ll) * N(-y) \
+                + k * df * pow(h_over_s, 2.0 * ll - 2.0) * N(-y + sigma_rt_t)
             price = p - p_ui
         else:
             p_uo = -s * dq * N(-x1) \
-                   + k * df * N(-x1 + sigma_rt_t) \
-                   + s * dq * pow(hOverS, 2.0 * ll) * N(-y1) \
-                   - k * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                   N(-y1 + sigma_rt_t)
+                + k * df * N(-x1 + sigma_rt_t) \
+                + s * dq * pow(h_over_s, 2.0 * ll) * N(-y1) \
+                   - k * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                N(-y1 + sigma_rt_t)
             price = p_uo
     elif option_type == EquityBarrierTypes.DOWN_AND_OUT_PUT.value:
         if h >= k:
             price = 0.0
         else:
             p_di = -s * dq * N(-x1) \
-                   + k * df * N(-x1 + sigma_rt_t) \
-                   + s * dq * pow(hOverS, 2.0 * ll) * (N(y) - N(y1)) \
-                   - k * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                   (N(y - sigma_rt_t) - N(y1 - sigma_rt_t))
+                + k * df * N(-x1 + sigma_rt_t) \
+                + s * dq * pow(h_over_s, 2.0 * ll) * (N(y) - N(y1)) \
+                   - k * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                (N(y - sigma_rt_t) - N(y1 - sigma_rt_t))
             price = p - p_di
     elif option_type == EquityBarrierTypes.DOWN_AND_IN_PUT.value:
         if h >= k:
             price = p
         else:
             p_di = -s * dq * N(-x1) \
-                   + k * df * N(-x1 + sigma_rt_t) \
-                   + s * dq * pow(hOverS, 2.0 * ll) * (N(y) - N(y1)) \
-                   - k * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                   (N(y - sigma_rt_t) - N(y1 - sigma_rt_t))
+                + k * df * N(-x1 + sigma_rt_t) \
+                + s * dq * pow(h_over_s, 2.0 * ll) * (N(y) - N(y1)) \
+                   - k * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                (N(y - sigma_rt_t) - N(y1 - sigma_rt_t))
             price = p_di
     else:
         raise FinError("Unknown barrier option type." + str(option_type))
 
     return price
```

### Comparing `financepy-0.350/financepy/models/equity_crr_tree.py` & `financepy-0.360/financepy/models/equity_crr_tree.py`

 * *Files 9% similar despite different names*

```diff
@@ -23,17 +23,15 @@
                  time_to_expiry,
                  option_type,
                  strike_price,
                  isEven):
     """ Value an American option using a Binomial Treee """
 
     num_steps = int(num_steps_per_year * time_to_expiry)
-
-    if num_steps < 30:
-        num_steps = 30
+    num_steps = max(num_steps, 30)
 
     # OVERRIDE JUST TO SEE
     num_steps = num_steps_per_year
 
     # if the number of steps is even but we want odd then make it odd
     if num_steps % 2 == 0 and isEven == 0:
         num_steps += 1
@@ -50,28 +48,28 @@
     num_nodes = int(0.5 * (num_steps + 1) * (num_steps + 2))
     stock_values = np.zeros(num_nodes)
     stock_values[0] = stock_price
 
     option_values = np.zeros(num_nodes)
     u = np.exp(volatility * np.sqrt(dt))
     d = 1.0 / u
-    sLow = stock_price
+    s_low = stock_price
 
     probs = np.zeros(num_steps)
-    periodDiscountFactors = np.zeros(num_steps)
+    period_dfs = np.zeros(num_steps)
 
     # store time independent information for later use in tree
     for i_time in range(0, num_steps):
         a = np.exp((r - q) * dt)
         probs[i_time] = (a - d) / (u - d)
-        periodDiscountFactors[i_time] = np.exp(-r * dt)
+        period_dfs[i_time] = np.exp(-r * dt)
 
     for i_time in range(1, num_steps + 1):
-        sLow *= d
-        s = sLow
+        s_low *= d
+        s = s_low
         for i_node in range(0, i_time + 1):
             index = 0.5 * i_time * (i_time + 1)
             stock_values[int(index + i_node)] = s
             s = s * (u * u)
 
     # work backwards by first setting values at expiry date
     index = int(0.5 * num_steps * (num_steps + 1))
@@ -105,35 +103,35 @@
             elif option_type == OptionTypes.EUROPEAN_PUT.value:
                 exercise_value = 0.0
             elif option_type == OptionTypes.AMERICAN_CALL.value:
                 exercise_value = np.maximum(s - strike_price, 0.0)
             elif option_type == OptionTypes.AMERICAN_PUT.value:
                 exercise_value = np.maximum(strike_price - s, 0.0)
 
-            nextIndex = int(0.5 * (i_time + 1) * (i_time + 2))
+            next_index = int(0.5 * (i_time + 1) * (i_time + 2))
 
-            next_node_dn = nextIndex + i_node
-            next_node_up = nextIndex + i_node + 1
+            next_node_dn = next_index + i_node
+            next_node_up = next_index + i_node + 1
 
-            vUp = option_values[next_node_up]
-            vDn = option_values[next_node_dn]
-            future_expected_value = probs[i_time] * vUp
-            future_expected_value += (1.0 - probs[i_time]) * vDn
-            holdValue = periodDiscountFactors[i_time] * future_expected_value
+            v_up = option_values[next_node_up]
+            v_dn = option_values[next_node_dn]
+            future_expected_value = probs[i_time] * v_up
+            future_expected_value += (1.0 - probs[i_time]) * v_dn
+            hold_value = period_dfs[i_time] * future_expected_value
 
             if option_type == OptionTypes.EUROPEAN_CALL.value:
-                option_values[index + i_node] = holdValue
+                option_values[index + i_node] = hold_value
             elif option_type == OptionTypes.EUROPEAN_PUT.value:
-                option_values[index + i_node] = holdValue
+                option_values[index + i_node] = hold_value
             elif option_type == OptionTypes.AMERICAN_CALL.value:
                 option_values[index +
-                              i_node] = np.maximum(exercise_value, holdValue)
+                              i_node] = np.maximum(exercise_value, hold_value)
             elif option_type == OptionTypes.AMERICAN_PUT.value:
                 option_values[index +
-                              i_node] = np.maximum(exercise_value, holdValue)
+                              i_node] = np.maximum(exercise_value, hold_value)
 
     # We calculate all of the important Greeks in one go
     price = option_values[0]
     delta = (option_values[2] - option_values[1]) / \
         (stock_values[2] - stock_values[1])
     delta_up = (option_values[5] - option_values[4]) / \
         (stock_values[5] - stock_values[4])
```

### Comparing `financepy-0.350/financepy/models/equity_lsmc.py` & `financepy-0.360/financepy/models/equity_lsmc.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 ###############################################################################
 # Copyright (C) 2022 Dominic O'Kane
 ###############################################################################
 
 # https://people.math.ethz.ch/~hjfurrer/teaching/LongstaffSchwartzAmericanOptionsLeastSquareMonteCarlo.pdf
 
-import numpy as np
-
 from enum import Enum, auto
 
+import numpy as np
 from ..utils.global_types import OptionTypes
 from ..utils.polyfit import fit_poly, eval_polynomial
 from ..models.finite_difference import option_payoff
 
 # This is a first implementation of American Monte Carlo using the method of
 # Longstaff and Schwartz. Work is needed to add laguerre Polynomials and
 # other interpolation methods.
```

### Comparing `financepy-0.350/financepy/models/finite_difference.py` & `financepy-0.360/financepy/models/finite_difference.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,18 +2,19 @@
 from functools import partial
 
 import numpy as np
 
 from ..utils.math import band_matrix_multiplication
 from ..utils.math import solve_tridiagonal_matrix
 from ..utils.math import transpose_tridiagonal_matrix
-from financepy.utils.global_types import OptionTypes
-
+from ..utils.global_types import OptionTypes
 
 # @njit
+
+
 def dx(x, wind=0):
     # Intermediate rows
     # Note: As first and last rows are handled separately
     # (at the end of this method)
     # we can use numpy roll without worrying about the end values
     dxl = (x - np.roll(x, 1))
     dxu = (np.roll(x, -1) - x)
```

### Comparing `financepy-0.350/financepy/models/finite_difference_PSOR.py` & `financepy-0.360/financepy/models/finite_difference_PSOR.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from copy import deepcopy
 
 import numpy as np
 from numba import njit
 
 from ..utils.math import band_matrix_multiplication
-from financepy.utils.global_types import OptionTypes
+from ..utils.global_types import OptionTypes
 from .finite_difference import option_payoff, calculate_fd_matrix
 
 
 def black_scholes_fd_PSOR(spot_price, volatility, time_to_expiry,
                           strike_price, risk_free_rate, dividend_yield,
                           option_type, num_time_steps=None, num_samples=2000,
                           num_std=5, theta=0.5, wind=0, digital=False,
```

### Comparing `financepy-0.350/financepy/models/gauss_copula.py` & `financepy-0.360/financepy/models/gauss_copula.py`

 * *Files 8% similar despite different names*

```diff
@@ -11,24 +11,24 @@
 
 ###############################################################################
 # TODO:
 ###############################################################################
 
 
 def default_times_gc(issuer_curves,
-                     correlation_matrix,
+                     corr_matrix,
                      num_trials,
                      seed):
     """ Generate a matrix of default times by credit and trial using a
     Gaussian copula model using a full rank correlation matrix. """
 
     np.random.seed(seed)
     num_credits = len(issuer_curves)
     x = np.random.normal(0.0, 1.0, size=(num_credits, num_trials))
-    c = np.linalg.cholesky(correlation_matrix)
+    c = np.linalg.cholesky(corr_matrix)
     y = np.dot(c, x)
 
     corr_times = np.empty(shape=(num_credits, 2 * num_trials))
 
     for i_credit in range(0, num_credits):
         issuer_curve = issuer_curves[i_credit]
         for i_trial in range(0, num_trials):
```

### Comparing `financepy-0.350/financepy/models/gauss_copula_lhp.py` & `financepy-0.360/financepy/models/gauss_copula_lhp.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,53 +29,53 @@
     if k1 == 0.0 and k2 == 0.0:
         return 0.0
 
     if k1 >= k2:
         raise FinError("K1 >= K2")
 
     p = 0.0
-    portfolioEL = 0.0
+    portfolio_el = 0.0
     for i_credit in range(0, num_credits):
         pd = (1.0 - survival_probs[i_credit])
         p += pd
-        portfolioEL += pd * (1.0 - recovery_rates[i_credit])
+        portfolio_el += pd * (1.0 - recovery_rates[i_credit])
 
     if p == 0.0:
         return 1.0
 
     p = p / num_credits
-    portfolioEL = portfolioEL / num_credits
+    portfolio_el = portfolio_el / num_credits
 
-    recovery = 1.0 - portfolioEL / p
+    recovery = 1.0 - portfolio_el / p
     elk1 = exp_min_lk(k1, p, recovery, 1.0, beta)
     elk2 = exp_min_lk(k2, p, recovery, 1.0, beta)
     value = 1.0 - (elk2 - elk1) / (k2 - k1)
     return value
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def portfolio_cdf_lhp(k, num_credits, qvector, recovery_rates,
                       beta, num_points):
 
     p = 0.0
-    portfolioEL = 0.0
+    portfolio_el = 0.0
 
     for j in range(0, num_credits):
         p += (1.0 - qvector[j])
-        portfolioEL += (1.0 - recovery_rates[j]) * (1 - qvector[j])
+        portfolio_el += (1.0 - recovery_rates[j]) * (1 - qvector[j])
 
     p = p / num_credits
-    portfolioEL /= num_credits
+    portfolio_el /= num_credits
 
     if p == 0:
         return 0.0
 
-    recovery = 1.0 - portfolioEL / p
+    recovery = 1.0 - portfolio_el / p
 
     if beta == 0:
         beta = 0.0000000001
 
     if k >= (1.0 - recovery):
         return 1.0
```

### Comparing `financepy-0.350/financepy/models/gauss_copula_lhplus.py` & `financepy-0.360/financepy/models/gauss_copula_lhplus.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,137 +11,133 @@
 ###############################################################################
 
 
 class LHPlusModel():
     """ Large Homogenous Portfolio model with extra asset. Used for
     approximating full Gaussian copula. """
 
-    def __init__(self, P, R, H, beta, P0, R0, H0, beta_0):
-        self._P = P
-        self._R = R
-        self._H = H
+    def __init__(self, p, r, h, beta, p0, r0, h0, beta_0):
+        self._p = p
+        self._r = r
+        self._h = h
         self._beta = beta
-        self._P0 = P0
-        self._R0 = R0
-        self._H0 = H0
+        self._p0 = p0
+        self._r0 = r0
+        self._h0 = h0
         self._beta_0 = beta_0
 
 ###############################################################################
 
-    def prob_loss_gt_k(self, K):
+    def prob_loss_gt_k(self, k):
         """ Returns P(L>K) where L is the portfolio loss given by model. """
-        if K < (1.0 - self._R0) * self._H0:
+
+        if k < (1.0 - self._r0) * self._h0:
             raise FinError("Function does not work when K<(1-R0)H0")
 
-        c = NormSInv(self._P)
-        c0 = NormSInv(self._P0)
-        arga = K / (1.0 - self._R) / self._H
+        c = NormSInv(self._p)
+        c0 = NormSInv(self._p0)
+        arga = K / (1.0 - self._r) / self._h
         inva = 0.0
 
         if arga < 0.00001:
             inva = -9999999999999
         elif arga >= 1:
             inva = 9999999999999.0
         else:
             inva = NormSInv(arga)
 
         RtOneMinusBeta2 = np.sqrt(1.0 - self._beta * self._beta)
         a = (1.0 / self._beta) * (c - RtOneMinusBeta2 * inva)
-        argb = (K - (1.0 - self._R0) * self._H0) / (1.0 - self._R) / self._H
+        argb = (K - (1.0 - self._r0) * self._h0) / (1.0 - self._r) / self._h
         invb = 0.0
 
         if argb <= 0:
             invb = -9999999999999.0
         elif argb > 1.0:
             invb = 99999999999999.0
         else:
             invb = NormSInv(argb)
 
         b = (1.0 / self._beta) * \
             ((c - RtOneMinusBeta2 * invb))
 
-        probLgtK = N(a) + M(c0, b, self._beta_0) - M(c0, a, self._beta_0)
+        prob_loss_gt_k = N(a) + M(c0, b, self._beta_0) - M(c0, a, self._beta_0)
 
-        return probLgtK
+        return prob_loss_gt_k
 
 ###############################################################################
 
-    def exp_min_lk_integral(self, K, dK):
+    def exp_min_lk_integral(self, k, dk):
 
         k0 = 0.0
-        num_steps = int(K / dK)
-        dK = K / num_steps
+        num_steps = int(k / dk)
+        dk = k / num_steps
         cdf0 = 1.0
         cdf1 = 0.0
         exp_min_lk = 0.0
-        checkSum = 0.0
+        check_sum = 0.0
 
         for _ in range(0, num_steps):
-            k0 += dK
+            k0 += dk
             cdf1 = self.prob_loss_gt_k(k0)
             pdf = cdf0 - cdf1
             cdf0 = cdf1
-            checkSum += pdf
+            check_sum += pdf
             exp_min_lk += pdf * k0
 
-        checkSum += cdf1
+        check_sum += cdf1
         exp_min_lk += cdf1 * K
 
         return exp_min_lk
 
 ###############################################################################
 
-    def exp_min_lk(self, K):
+    def exp_min_lk(self, k):
 
-        if abs(K) < 1e-6:
-            return K
+        if abs(k) < 1e-6:
+            return k
 
-        c = NormSInv(self._P)
-        c0 = NormSInv(self._P0)
-        arga = K / (1.0 - self._R) / self._H
-        argb = (K - (1.0 - self._R0) * self._H0) / (1.0 - self._R) / self._H
+        c = NormSInv(self._p)
+        c0 = NormSInv(self._p0)
+        arga = k / (1.0 - self._r) / self._h
+        argb = (k - (1.0 - self._r0) * self._h0) / (1.0 - self._r) / self._h
 
         if argb < 0:
             raise FinError("Tranche too thin for LHPlus")
 
         inva = NormSInv(arga)
         invb = NormSInv(argb)
-
-        RtOneMinusBeta2 = np.sqrt(1.0 - self._beta * self._beta)
-
-        a = 1.0 / self._beta * (c - RtOneMinusBeta2 * inva)
-        b = 1.0 / self._beta * (c - RtOneMinusBeta2 * invb)
+        rt_one_minus_beta2 = np.sqrt(1.0 - self._beta * self._beta)
+        a = (c - rt_one_minus_beta2 * inva) / self._beta
+        b = (c - rt_one_minus_beta2 * invb) / self._beta
 
         r12 = self._beta
         r13 = self._beta_0
         r23 = self._beta * self._beta_0
-
-        el1 = self._P * self._H * (1.0 - self._R)
-        el2 = self._P0 * self._H0 * (1.0 - self._R0)
+        el1 = self._p * self._h * (1.0 - self._r)
+        el2 = self._p0 * self._h0 * (1.0 - self._r0)
         el3 = -K * (M(c0, a, self._beta_0) - N(a))
-        el4 = - ((1.0 - self._R0) * self._H0 - K) * M(c0, b, self._beta_0)
+        el4 = - ((1.0 - self._r0) * self._h0 - k) * M(c0, b, self._beta_0)
         term1 = M(c, a, self._beta) + phi3(b, c, c0, r12, r13, r23) \
             - phi3(a, c, c0, r12, r13, r23)
-        el5 = - (1.0 - self._R) * self._H * term1
-
+        el5 = - (1.0 - self._r) * self._h * term1
         elk1k2 = el1 + el2 + el3 + el4 + el5
         return elk1k2
 
 ###############################################################################
 
-    def exp_min_lk2(self, K):
-
-        if abs(K) < 1e-6:
-            return K
+    def exp_min_lk2(self, k):
 
-        c = NormSInv(self._P)
-        c0 = NormSInv(self._P0)
+        if abs(k) < 1e-6:
+            return k
 
-        arga = K / (1.0 - self._R) / self._H
-        argb = (K - (1.0 - self._R0) * self._H0) / (1.0 - self._R) / self._H
+        c = NormSInv(self._p)
+        c0 = NormSInv(self._p0)
+        arga = k / (1.0 - self._r) / self._h
+        argb = (k - (1.0 - self._r0) * self._h0) / (1.0 - self._r) / self._h
 
         if argb < 0.0:
             raise FinError("Tranche too thin for LHPlus")
 
         inva = NormSInv(arga)
         invb = NormSInv(argb)
 
@@ -150,23 +146,23 @@
         a = (1.0 / self._beta) * (c - RtOneMinusBeta2 * inva)
         b = (1.0 / self._beta) * (c - RtOneMinusBeta2 * invb)
 
         r12 = self._beta
         r13 = self._beta_0
         r23 = self._beta * self._beta_0
 
-        el1 = self._P * self._H * (1.0 - self._R) + \
-            self._P0 * self._H0 * (1.0 - self._R0)
-        el1 = el1 - K * (M(c0, a, self._beta_0) - N(a))
-        el1 = el1 - ((1.0 - self._R0) * self._H0 - K) * M(c0, b, self._beta_0)
+        el1 = self._p * self._h * (1.0 - self._r) + \
+            self._p0 * self._h0 * (1.0 - self._r0)
+        el1 = el1 - k * (M(c0, a, self._beta_0) - N(a))
+        el1 = el1 - ((1.0 - self._r0) * self._h0 - k) * M(c0, b, self._beta_0)
 
         term = M(c, a, self._beta) + phi3(b, c, c0, r12, r13, r23) \
             - phi3(a, c, c0, r12, r13, r23)
 
-        el1 = el1 - (1.0 - self._R) * self._H * term
+        el1 = el1 - (1.0 - self._r) * self._h * term
         return el1
 
 ###############################################################################
 
     def tranche_survival_prob(self, k1, k2):
 
         if k2 == k1:
```

### Comparing `financepy-0.350/financepy/models/gauss_copula_onefactor.py` & `financepy-0.360/financepy/models/gauss_copula_onefactor.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-##############################################################################
+###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
-##############################################################################
+###############################################################################
 
 from numba import njit, float64, int64
 import numpy as np
 
-##########################################################################
+###############################################################################
 
-from ..utils.math import norminvcdf, N, INVROOT2PI
+from ..utils.math import norminvcdf, N, INV_ROOT_2_PI
 from ..utils.error import FinError
 from .loss_dbn_builder import indep_loss_dbn_recursion_gcd
-from .loss_dbn_builder import indep_loss_dbn_heterogeneous_adj_binomial
+from .loss_dbn_builder import indep_loss_dbn_hetero_adj_binomial
 from .loss_dbn_builder import portfolio_gcd
 
 ###############################################################################
 
 MIN_Z = -6.0
 
 ###############################################################################
@@ -39,16 +39,16 @@
     if len(loss_units) != num_credits:
         raise FinError("Loss units length must equal num credits.")
 
     if len(beta_vector) != num_credits:
         raise FinError("Beta vector length must equal num credits.")
 
     num_loss_units = 1
-    for i in range(0, len(loss_units)):
-        num_loss_units += int(loss_units[i])
+    for lu in loss_units:
+        num_loss_units += int(lu)
 
     uncond_loss_dbn = np.zeros(num_loss_units)
 
     z = MIN_Z
     dz = 2.0 * abs(z) / num_integration_steps
 
     cond_default_probs = np.zeros(num_credits)
@@ -66,21 +66,21 @@
 
         indep_dbn = indep_loss_dbn_recursion_gcd(num_credits,
                                                  cond_default_probs,
                                                  loss_units)
 
         gauss_wt = np.exp(-(z*z)/2.0)
 
-        for i_loss_unit in range(0, num_loss_units):
-            uncond_loss_dbn[i_loss_unit] += indep_dbn[i_loss_unit] * gauss_wt
+        for i_unit in range(0, num_loss_units):
+            uncond_loss_dbn[i_unit] += indep_dbn[i_unit] * gauss_wt
 
         z += dz
 
-    for i_loss_unit in range(0, int(num_loss_units)):
-        uncond_loss_dbn[i_loss_unit] *= INVROOT2PI * dz
+    for i_unit in range(0, int(num_loss_units)):
+        uncond_loss_dbn[i_unit] *= INV_ROOT_2_PI * dz
 
     return uncond_loss_dbn
 
 ###############################################################################
 
 
 @njit(float64[:](float64[:], float64[:], float64[:], int64),
@@ -99,16 +99,16 @@
         raise FinError("Number of credits equals zero")
 
     for i_credit in range(1, num_credits):
         if recovery_rates[i_credit] != recovery_rates[0]:
             raise FinError("Losses are not homogeneous")
 
     m = 0.0
-    for i in range(0, len(beta_vector)):
-        m += beta_vector[i]
+    for beta in beta_vector:
+        m += beta
     m /= len(beta_vector)
 
     # High beta requires more integration steps
     if m > 0.7:
         num_integration_steps *= 2
 
     if m > 0.9:
@@ -117,18 +117,18 @@
     loss_units = np.ones(num_credits)
 
     default_probs = np.zeros(num_credits)
     for i_credit in range(0, num_credits):
         default_probs[i_credit] = 1.0 - survival_probs[i_credit]
 
     loss_dbn = loss_dbn_recursion_gcd(num_credits,
-                                     default_probs,
-                                     loss_units,
-                                     beta_vector,
-                                     num_integration_steps)
+                                      default_probs,
+                                      loss_units,
+                                      beta_vector,
+                                      num_integration_steps)
 
     return loss_dbn
 
 ###############################################################################
 
 
 @njit(float64(float64, float64, int64, float64[:], float64[:], float64[:],
@@ -146,33 +146,33 @@
 
     if k1 == 0.0 and k2 == 0.0:
         return 0.0
 
     if k1 >= k2:
         raise FinError("K1 >= K2")
 
-    commonRecoveryFlag = 1
+    common_recovery_flag = 1
 
     loss_amounts = np.zeros(num_credits)
     for i_credit in range(0, num_credits):
         loss_amounts[i_credit] = (1.0 - recovery_rates[i_credit]) / num_credits
         if loss_amounts[i_credit] != loss_amounts[0]:
-            commonRecoveryFlag = 0
+            common_recovery_flag = 0
 
     gcd = 0.0
 
     m = 0.0
     for i in range(0, len(beta_vector)):
         m += beta_vector[i]
     m /= len(beta_vector)
 
     if m > 0.8:
         num_integration_steps *= 2
 
-    if commonRecoveryFlag == 1:
+    if common_recovery_flag == 1:
         gcd = loss_amounts[0]
     else:
         gcd = portfolio_gcd(loss_amounts)
 
     loss_units = np.zeros(num_credits)
     num_loss_units = 1  # this is the zero loss
 
@@ -182,51 +182,54 @@
 
     default_probs = np.zeros(num_credits)
 
     for i_credit in range(0, num_credits):
         default_probs[i_credit] = 1.0 - survival_probs[i_credit]
 
     loss_dbn = loss_dbn_recursion_gcd(num_credits,
-                                     default_probs,
-                                     loss_units,
-                                     beta_vector,
-                                     num_integration_steps)
+                                      default_probs,
+                                      loss_units,
+                                      beta_vector,
+                                      num_integration_steps)
 
-    trancheEL = 0.0
+    tranche_el = 0.0
     for i_loss_unit in range(0, int(num_loss_units)):
         loss = i_loss_unit * gcd
-        trancheLoss = min(loss, k2) - min(loss, k1)
-        trancheEL = trancheEL + trancheLoss * loss_dbn[i_loss_unit]
+        tranche_loss = min(loss, k2) - min(loss, k1)
+        tranche_el = tranche_el + tranche_loss * loss_dbn[i_loss_unit]
 
-    q = 1.0 - trancheEL / (k2 - k1)
+    q = 1.0 - tranche_el / (k2 - k1)
     return q
 
 ###############################################################################
 
 
 @njit(float64(float64, float64, float64, float64), fastmath=True, cache=True)
 def gauss_approx_tranche_loss(k1, k2, mu, sigma):
 
     if abs(sigma) < 1e-6:
-        gauss_approx_tranche_loss = 0.0
+        tranche_loss = 0.0
         if mu > k1:
-            gauss_approx_tranche_loss += (mu - k1)
+            tranche_loss += (mu - k1)
 
         if mu > k2:
-            gauss_approx_tranche_loss += (mu - k2)
+            tranche_loss += (mu - k2)
     else:
-        
+
         d1 = (mu - k1) / sigma
         d2 = (mu - k2) / sigma
 
-        gauss_approx_tranche_loss = ((mu - k1) * N(d1) - (mu - k2) * N(d2) 
-        + sigma * np.exp(-0.5 * d1 * d1) * INVROOT2PI 
-        - sigma * np.exp(-0.5 * d2 * d2) * INVROOT2PI)
+        expd1 = np.exp(-0.5 * d1 * d1)
+        expd2 = np.exp(-0.5 * d2 * d2)
+
+        tranche_loss = ((mu - k1) * N(d1) - (mu - k2) * N(d2)
+                        + sigma * expd1 * INV_ROOT_2_PI
+                        - sigma * expd2 * INV_ROOT_2_PI)
 
-    return gauss_approx_tranche_loss
+    return tranche_loss
 
 ###############################################################################
 
 
 @njit(float64(float64, float64, int64, float64[:], float64[:], float64[:],
               int64), fastmath=True, cache=True)
 def tranch_surv_prob_gaussian(k1,
@@ -280,15 +283,15 @@
         sigma = np.sqrt(var)
         el = gauss_approx_tranche_loss(k1, k2, mu, sigma)
         gauss_wt = np.exp(-(z**2) / 2.0)
 
         v += el * gauss_wt
         z += dz
 
-    v *= INVROOT2PI * dz
+    v *= INV_ROOT_2_PI * dz
     q = 1.0 - v / (k2 - k1)
     return q
 
 ###############################################################################
 
 
 @njit(float64[:](int64, float64[:], float64[:], float64[:], int64),
@@ -310,34 +313,35 @@
     thresholds = np.zeros(num_credits)
     for i_credit in range(0, num_credits):
         thresholds[i_credit] = norminvcdf(default_probs[i_credit])
 
     dz = 2.0 * abs(MIN_Z) / num_integration_steps
     z = MIN_Z
 
-    for i_step in range(0, num_integration_steps):
+    for _ in range(0, num_integration_steps):
+
         for i_credit in range(0, num_credits):
             beta = beta_vector[i_credit]
             denom = np.sqrt(1.0 - beta * beta)
             argz = (thresholds[i_credit] - beta * z) / denom
             cond_default_probs[i_credit] = N(argz)
 
-        indep_dbn = indep_loss_dbn_heterogeneous_adj_binomial(num_credits,
-                                                              cond_default_probs,
-                                                              loss_ratio)
+        indep_dbn = indep_loss_dbn_hetero_adj_binomial(num_credits,
+                                                       cond_default_probs,
+                                                       loss_ratio)
 
-        gauss_wt = np.exp(-(z**2) / 2.0)
+        gauss_wt = np.exp(-z*z / 2.0)
 
         for i_loss_unit in range(0, num_loss_units):
             uncond_loss_dbn[i_loss_unit] += indep_dbn[i_loss_unit] * gauss_wt
 
         z = z + dz
 
     for i_loss_unit in range(0, num_loss_units):
-        uncond_loss_dbn[i_loss_unit] *= INVROOT2PI * dz
+        uncond_loss_dbn[i_loss_unit] *= INV_ROOT_2_PI * dz
 
     return uncond_loss_dbn
 
 ###############################################################################
 
 
 @njit(float64(float64, float64, int64, float64[:], float64[:], float64[:],
@@ -360,35 +364,35 @@
     if k1 >= k2:
         raise FinError("K1 >= K2")
 
     default_probs = np.zeros(num_credits)
     for i_credit in range(0, num_credits):
         default_probs[i_credit] = 1.0 - survival_probs[i_credit]
 
-    totalLoss = 0.0
+    total_loss = 0.0
     for i_credit in range(0, num_credits):
-        totalLoss += (1.0 - recovery_rates[i_credit])
-    totalLoss /= num_credits
+        total_loss += (1.0 - recovery_rates[i_credit])
+    total_loss /= num_credits
 
-    avgLoss = totalLoss / num_credits
+    avg_loss = total_loss / num_credits
 
     loss_ratio = np.zeros(num_credits)
     for i_credit in range(0, num_credits):
         loss_ratio[i_credit] = (
-            1.0 - recovery_rates[i_credit]) / num_credits / avgLoss
+            1.0 - recovery_rates[i_credit]) / num_credits / avg_loss
 
     loss_dbn = loss_dbn_hetero_adj_binomial(num_credits,
-                                           default_probs,
-                                           loss_ratio,
-                                           beta_vector,
-                                           num_integration_steps)
-    trancheEL = 0.0
+                                            default_probs,
+                                            loss_ratio,
+                                            beta_vector,
+                                            num_integration_steps)
+    tranche_el = 0.0
     num_loss_units = num_credits + 1
     for i_loss_unit in range(0, num_loss_units):
-        loss = i_loss_unit * avgLoss
-        trancheLoss = min(loss, k2) - min(loss, k1)
-        trancheEL += trancheLoss * loss_dbn[i_loss_unit]
+        loss = i_loss_unit * avg_loss
+        tranche_loss = min(loss, k2) - min(loss, k1)
+        tranche_el += tranche_loss * loss_dbn[i_loss_unit]
 
-    q = 1.0 - trancheEL / (k2 - k1)
+    q = 1.0 - tranche_el / (k2 - k1)
     return q
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/gbm_process_simulator.py` & `financepy-0.360/financepy/models/gbm_process_simulator.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/models/heston.py` & `financepy-0.360/financepy/models/heston.py`

 * *Files 4% similar despite different names*

```diff
@@ -41,16 +41,16 @@
                     float64, float64, float64, float64, int64, int64, int64),
       cache=True, fastmath=True)
 def get_paths(s0, r, q, v0, kappa, theta, sigma, rho, t, dt, num_paths,
               seed, scheme):
 
     np.random.seed(seed)
     num_steps = int(t / dt)
-    sPaths = np.zeros(shape=(num_paths, num_steps))
-    sPaths[:, 0] = s0
+    s_paths = np.zeros(shape=(num_paths, num_steps))
+    s_paths[:, 0] = s0
     sdt = np.sqrt(dt)
     rhohat = np.sqrt(1.0 - rho * rho)
     sigma2 = sigma * sigma
 
     if scheme == HestonNumericalScheme.EULER.value:
         # Basic scheme to first order with truncation on variance
         for i_path in range(0, num_paths):
@@ -63,30 +63,30 @@
                 zS = rho * z1 + rhohat * z2
                 vplus = max(v, 0.0)
                 rtvplus = np.sqrt(vplus)
                 v += kappa * (theta - vplus) * dt + sigma * \
                     rtvplus * zV + 0.25 * sigma2 * (zV * zV - dt)
                 s += (r - q) * s * dt + rtvplus * s * \
                     zS + 0.5 * s * vplus * (zV * zV - dt)
-                sPaths[i_path, i_step] = s
+                s_paths[i_path, i_step] = s
 
     elif scheme == HestonNumericalScheme.EULERLOG.value:
         # Basic scheme to first order with truncation on variance
         for i_path in range(0, num_paths):
             x = log(s0)
             v = v0
             for i_step in range(1, num_steps):
                 zV = np.random.normal(0.0, 1.0) * sdt
                 zS = rho * zV + rhohat * np.random.normal(0.0, 1.0) * sdt
                 vplus = max(v, 0.0)
                 rtvplus = np.sqrt(vplus)
                 x += (r - q - 0.5 * vplus) * dt + rtvplus * zS
                 v += kappa * (theta - vplus) * dt + sigma * \
                     rtvplus * zV + sigma2 * (zV * zV - dt) / 4.0
-                sPaths[i_path, i_step] = exp(x)
+                s_paths[i_path, i_step] = exp(x)
 
     elif scheme == HestonNumericalScheme.QUADEXP.value:
         # Due to Leif Andersen(2006)
         Q = exp(-kappa * dt)
         psic = 1.50
         gamma1 = 0.50
         gamma2 = 0.50
@@ -132,20 +132,20 @@
                         vnp = log((1.0 - p) / (1.0 - u)) / beta
 
                     M = p + beta * (1.0 - p) / (beta - A)
                     K0 = -log(M) - (K1 + 0.5 * K3) * vn
 
                 x += mu * dt + K0 + (K1 * vn + K2 * vnp) + \
                     np.sqrt(K3 * vn + K4 * vnp) * zS
-                sPaths[i_path, i_step] = exp(x)
+                s_paths[i_path, i_step] = exp(x)
                 vn = vnp
     else:
         raise FinError("Unknown FinHestonNumericalSchme")
 
-    return sPaths
+    return s_paths
 
 ###############################################################################
 
 
 class Heston():
 
     def __init__(self, v0, kappa, theta, sigma, rho):
@@ -170,38 +170,38 @@
                  interest_rate,
                  dividend_yield,
                  num_paths,
                  num_steps_per_year,
                  seed,
                  scheme=HestonNumericalScheme.EULERLOG):
 
-        tau = (option._expiry_dt - value_dt) / gDaysInYear
+        tau = (option.expiry_dt - value_dt) / gDaysInYear
 
-        K = option._strike_price
+        K = option.strike_price
         dt = 1.0 / num_steps_per_year
         schemeValue = float(scheme.value)
 
-        sPaths = get_paths(stock_price,
-                           interest_rate,
-                           dividend_yield,
-                           self._v0,
-                           self._kappa,
-                           self._theta,
-                           self._sigma,
-                           self._rho,
-                           tau,
-                           dt,
-                           num_paths,
-                           seed,
-                           schemeValue)
-
-        if option._option_type == OptionTypes.EUROPEAN_CALL:
-            path_payoff = np.maximum(sPaths[:, -1] - K, 0.0)
-        elif option._option_type == OptionTypes.EUROPEAN_PUT:
-            path_payoff = np.maximum(K - sPaths[:, -1], 0.0)
+        s_paths = get_paths(stock_price,
+                            interest_rate,
+                            dividend_yield,
+                            self._v0,
+                            self._kappa,
+                            self._theta,
+                            self._sigma,
+                            self._rho,
+                            tau,
+                            dt,
+                            num_paths,
+                            seed,
+                            schemeValue)
+
+        if option.option_type == OptionTypes.EUROPEAN_CALL:
+            path_payoff = np.maximum(s_paths[:, -1] - K, 0.0)
+        elif option.option_type == OptionTypes.EUROPEAN_PUT:
+            path_payoff = np.maximum(K - s_paths[:, -1], 0.0)
         else:
             raise FinError("Unknown option type.")
 
         payoff = np.mean(path_payoff)
         v = payoff * exp(-interest_rate * tau)
         return v
 
@@ -210,27 +210,27 @@
     def value_lewis(self,
                     value_dt,
                     option,
                     stock_price,
                     interest_rate,
                     dividend_yield):
 
-        tau = (option._expiry_dt - value_dt) / gDaysInYear
+        tau = (option.expiry_dt - value_dt) / gDaysInYear
 
         rho = self._rho
         sigma = self._sigma
         v0 = self._v0
         kappa = self._kappa
         theta = self._theta
 
         r = interest_rate
         q = dividend_yield
-        S0 = stock_price
-        K = option._strike_price
-        F = S0 * exp((r - q) * tau)
+        s0 = stock_price
+        K = option.strike_price
+        F = s0 * exp((r - q) * tau)
         V = sigma * sigma
 
         def phi(k_in,):
             k = k_in + 0.5 * 1j
             b = kappa + 1j * rho * sigma * k
             d = np.sqrt(b**2 + V * k * (k - 1j))
             g = (b - d) / (b + d)
@@ -246,27 +246,27 @@
             def integrand(k): return 2.0 * np.real(np.exp(-1j * k * x)
                                                    * phi(k)) / (k**2 + 1.0 / 4.0)
             return integrate.quad(integrand, 0, np.inf)[0]
 
         x = log(F / K)
         I1 = phi_transform(x) / (2.0 * pi)
         v1 = F * exp(-r * tau) - np.sqrt(K * F) * exp(-r * tau) * I1
-#        v2 = S0 * exp(-q*tau) - K * exp(-r*tau) * I1
+#        v2 = s0 * exp(-q*tau) - K * exp(-r*tau) * I1
         return v1
 
 ###############################################################################
 
     def value_lewis_rouah(self,
                           value_dt,
                           option,
                           stock_price,
                           interest_rate,
                           dividend_yield):
 
-        tau = (option._expiry_dt - value_dt) / gDaysInYear
+        tau = (option.expiry_dt - value_dt) / gDaysInYear
 
         rho = self._rho
         sigma = self._sigma
         v0 = self._v0
         kappa = self._kappa
         theta = self._theta
 
@@ -279,68 +279,68 @@
             b = (2.0 / V) * (1j * k * rho * sigma + kappa)
             e = np.sqrt(b**2 + 4.0 * k * (k - 1j) / V)
             g = (b - e) / 2.0
             h = (b - e) / (b + e)
             q = V * tau / 2.0
             Q = np.exp(-e * q)
             H = np.exp((2.0 * kappa * theta / V) * (q * g - np.log((1.0 -
-                h * Q) / (1.0 - h))) + v0 * g * (1.0 - Q) / (1.0 - h * Q))
+                                                                    h * Q) / (1.0 - h))) + v0 * g * (1.0 - Q) / (1.0 - h * Q))
             integrand = H * np.exp(-1j * k * X) / (k * k - 1j * k)
             return integrand.real
 
-        S0 = stock_price
-        F = S0 * exp((r - q) * tau)
-        K = option._strike_price
+        s0 = stock_price
+        F = s0 * exp((r - q) * tau)
+        K = option.strike_price
         X = log(F / K)
         integral = integrate.quad(f, 0.0, np.inf)[0] * (1.0 / pi)
-        v = S0 * exp(-q * tau) - K * exp(-r * tau) * integral
+        v = s0 * exp(-q * tau) - K * exp(-r * tau) * integral
         return (v)
 
 ###############################################################################
 # Taken from Nick Weber's VBA Finance book
 ###############################################################################
 
     def value_weber(self,
                     value_dt,
                     option,
                     stock_price,
                     interest_rate,
                     dividend_yield):
 
-        tau = (option._expiry_dt - value_dt) / gDaysInYear
+        tau = (option.expiry_dt - value_dt) / gDaysInYear
 
         rho = self._rho
         sigma = self._sigma
         v0 = self._v0
         kappa = self._kappa
         theta = self._theta
 
         q = dividend_yield
         r = interest_rate
-        S0 = stock_price
-        K = option._strike_price
+        s0 = stock_price
+        K = option.strike_price
         V = sigma**2
 
         def f(s, b):
             def integrand(u):
                 beta = b - 1j * rho * sigma * u
                 d = np.sqrt((beta**2) - V * u * (s * 1j - u))
                 g = (beta - d) / (beta + d)
                 Q = np.exp(-d * tau)
                 B = (beta - d) * (1.0 - Q) / (1.0 - g * Q) / V
                 A = kappa * ((beta - d) * tau - 2.0 *
                              np.log((1.0 - g * Q) / (1.0 - g))) / V
                 v = np.exp(A * theta + B * v0 + 1j * u *
-                           np.log(S0 / (K * np.exp(-(r - q) * tau)))) / (u * 1j)
+                           np.log(s0 / (K * np.exp(-(r - q) * tau)))) / (u * 1j)
                 return v.real
 
             area = 0.50 + (1.0 / pi) * integrate.quad(integrand, 0, np.inf)[0]
             return area
 
-        v = S0 * exp(-q * tau) * f(1.0, kappa - rho * sigma) - \
+        v = s0 * exp(-q * tau) * f(1.0, kappa - rho * sigma) - \
             exp(-r * tau) * K * f(-1.0, kappa)
 
         return v
 
 ###############################################################################
 # Gatheral book page 19 with definition of x given on page 16 and noting
 # that the value C is a forward value and so needs to be discounted
@@ -349,27 +349,27 @@
     def value_gatheral(self,
                        value_dt,
                        option,
                        stock_price,
                        interest_rate,
                        dividend_yield):
 
-        tau = (option._expiry_dt - value_dt) / gDaysInYear
+        tau = (option.expiry_dt - value_dt) / gDaysInYear
 
         rho = self._rho
         sigma = self._sigma
         v0 = self._v0
         kappa = self._kappa
         theta = self._theta
 
         q = dividend_yield
         r = interest_rate
-        S0 = stock_price
-        K = option._strike_price
-        F = S0 * exp((r - q) * tau)
+        s0 = stock_price
+        K = option.strike_price
+        F = s0 * exp((r - q) * tau)
         x0 = log(F / K)
 
         def ff(j):
             def integrand(u):
                 V = sigma * sigma
                 A = -u * u / 2.0 - 1j * u / 2.0 + 1j * j * u
                 B = kappa - rho * sigma * j - rho * sigma * 1j * u
@@ -384,11 +384,11 @@
                              np.log((1.0 - R * Q) / (1.0 - R)))
                 phi = np.exp(C * theta + D * v0 + 1j * u * x0) / (1j * u)
                 return phi.real
 
             area = 0.50 + 1.0 / pi * integrate.quad(integrand, 0.0, np.inf)[0]
             return area
 
-        v = S0 * exp(-q * tau) * ff(1) - K * exp(-r * tau) * ff(0)
+        v = s0 * exp(-q * tau) * ff(1) - K * exp(-r * tau) * ff(0)
         return v
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/hw_tree.py` & `financepy-0.360/financepy/models/hw_tree.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
+from math import ceil
+
 from enum import Enum
 import numpy as np
 from scipy import optimize
 from numba import njit
-from math import ceil
 
 from ..utils.error import FinError
 from ..utils.math import N, accrued_interpolator
 from ..market.curves.interpolator import InterpTypes, _uinterpolate
 from ..utils.helpers import label_to_string
 from ..utils.global_types import FinExerciseTypes
-from ..utils.global_vars import gSmall
+from ..utils.global_vars import g_small
 
-interp = InterpTypes.FLAT_FWD_RATES.value
+INTERP = InterpTypes.FLAT_FWD_RATES.value
 
-small = 1e-10
+SMALL = 1e-10
 
 ###############################################################################
 # TODO: Put Jamshidian code into Numba to get speed up
 ###############################################################################
 
 ###############################################################################
 # dr = (theta(t) - r) dt + sigma * dW
@@ -33,38 +34,38 @@
     JAMSHIDIAN = 1,
     EXPIRY_ONLY = 2,
     EXPIRY_TREE = 3
 
 ###############################################################################
 
 
-def option_exercise_types_to_int(optionExerciseType):
+def option_exercise_types_to_int(option_exercise_type):
 
-    if optionExerciseType == FinExerciseTypes.EUROPEAN:
+    if option_exercise_type == FinExerciseTypes.EUROPEAN:
         return 1
-    if optionExerciseType == FinExerciseTypes.BERMUDAN:
+    if option_exercise_type == FinExerciseTypes.BERMUDAN:
         return 2
-    if optionExerciseType == FinExerciseTypes.AMERICAN:
+    if option_exercise_type == FinExerciseTypes.AMERICAN:
         return 3
     else:
         raise FinError("Unknown option exercise type.")
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def p_fast(t, T, r_t, delta, pt, ptd, pT, _sigma, _a):
     """ Forward discount factor as seen at some time t which may be in the
-    future for payment at time T where r_t is the delta-period shor_t rate
+    future for payment at time T where r_t is the delta-period short rate
     seen at time t and pt is the discount factor to time t, ptd is the one
     period discount factor to time t+dt and pT is the discount factor from
     now until the payment of the 1 dollar of the discount factor. """
 
-    if abs(_a) < small:
-        _a = small
+    if abs(_a) < SMALL:
+        _a = SMALL
 
     BtT = (1.0 - np.exp(-_a*(T-t)))/_a
     BtDelta = (1.0 - np.exp(-_a * delta))/_a
 
     term1 = np.log(pT/pt) - (BtT/BtDelta) * np.log(ptd/pt)
 
     term2 = (_sigma**2)*(1.0-np.exp(-2.0*_a*t)) \
@@ -77,25 +78,25 @@
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def build_tree_fast(a, sigma, tree_times, num_time_steps, discount_factors):
     """ Fast tree construction using Numba. """
-    treeMaturity = tree_times[-1]
-    dt = treeMaturity / (num_time_steps+1)
+    tree_maturity = tree_times[-1]
+    dt = tree_maturity / (num_time_steps+1)
     dR = sigma * np.sqrt(3.0 * dt)
     j_max = ceil(0.1835/(a * dt))
     N = j_max
 
-    pu = np.zeros(shape=(2*j_max+1))
-    pm = np.zeros(shape=(2*j_max+1))
-    pd = np.zeros(shape=(2*j_max+1))
+    pu = np.zeros(shape=2*j_max+1)
+    pm = np.zeros(shape=2*j_max+1)
+    pd = np.zeros(shape=2*j_max+1)
 
-    # The shor_t rate goes out one step extra to have the final shor_t rate
+    # The short rate goes out one step extra to have the final short rate
     r_t = np.zeros(shape=(num_time_steps+2, 2*j_max+1))
 
     # probabilities star_t at time 0 and go out to one step before T
     # Branching is simple trinomial out to time step m=1 after which
     # the top node and bottom node connect internally to two lower nodes
     # and two upper nodes respectively. The probabilities only depend on j
 
@@ -124,19 +125,19 @@
     # Time zero is trivial for the Arrow-Debreu price
     Q[0, N] = 1.0
 
     # Big loop over time steps
     for m in range(0, num_time_steps + 1):
 
         nm = min(m, j_max)
-        sumQZ = 0.0
+        sum_qz = 0.0
         for j in range(-nm, nm+1):
             rdt = j*dR*dt
-            sumQZ += Q[m, j+N] * np.exp(-rdt)
-        alpha[m] = np.log(sumQZ/discount_factors[m+1]) / dt
+            sum_qz += Q[m, j+N] * np.exp(-rdt)
+        alpha[m] = np.log(sum_qz/discount_factors[m+1]) / dt
 
         for j in range(-nm, nm+1):
             jN = j + N
             r_t[m, jN] = alpha[m] + j*dR
 
         # Loop over all nodes at time m to calculate next values of Q
         for j in range(-nm, nm+1):
@@ -173,61 +174,61 @@
                                    _a,
                                    _Q,
                                    _pu, _pm, _pd,
                                    _r_t,
                                    _dt,
                                    _tree_times,
                                    _df_times, _df_values):
-    """ Value an option on a bond with coupons that can have European or
-    American exercise. Some minor issues to do with handling coupons on
+    """ Value an option on a bond with cpns that can have European or
+    American exercise. Some minor issues to do with handling cpns on
     the option expiry date need to be solved. """
 
     DEBUG = False
     if DEBUG:
         print("Entering AmerBondOption")
-        print("coupon Times", cpn_times)
+        print("Coupon Times", cpn_times)
         print("Coupon Amounts", cpn_amounts)
 
     num_time_steps, num_nodes = _Q.shape
     dt = _dt
     j_max = ceil(0.1835/(_a * dt))
     expiry_step = int(t_exp/dt + 0.50)
 
     ###########################################################################
 
-    # Want to add coupons before expiry to the grid so that we can value
+    # Want to add cpns before expiry to the grid so that we can value
     # their impact on the decision to exercise the option early
-    treeFlows = np.zeros(num_time_steps)
+    tree_flows = np.zeros(num_time_steps)
     num_cpns = len(cpn_times)
 
     # Flows that fall on the expiry date included. The tree only goes out to
-    # the expiry date so coupons after this date do not go onto the tree.
+    # the expiry date so cpns after this date do not go onto the tree.
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        if tcpn <= t_exp:
-            n = int(tcpn/dt + 0.50)
+        t_cpn = cpn_times[i]
+        if t_cpn <= t_exp:
+            n = int(t_cpn/dt + 0.50)
             ttree = _tree_times[n]
-            df_flow = _uinterpolate(tcpn, _df_times, _df_values, interp)
-            df_tree = _uinterpolate(ttree, _df_times, _df_values, interp)
-            treeFlows[n] += cpn_amounts[i] * 1.0 * df_flow / df_tree
+            df_flow = _uinterpolate(t_cpn, _df_times, _df_values, INTERP)
+            df_tree = _uinterpolate(ttree, _df_times, _df_values, INTERP)
+            tree_flows[n] += cpn_amounts[i] * 1.0 * df_flow / df_tree
 
     ###########################################################################
     # Mapped times stores the mapped times and flows and is used to calculate
     # accrued interest in a consistent manner as using actual flows will
     # result in some convergence noise issues as it is inconsistent
     ###########################################################################
 
-    # I star_t the tree with the previous coupon time and amount
+    # I star_t the tree with the previous cpn time and amount
     # (does not matter)
     mapped_times = np.zeros(0)   # CHANGE
     mapped_amounts = np.zeros(0)  # CHANGE
     for n in range(0, len(_tree_times)):
-        if treeFlows[n] > 0.0:
+        if tree_flows[n] > 0.0:
             mapped_times = np.append(mapped_times, _tree_times[n])
-            mapped_amounts = np.append(mapped_amounts, treeFlows[n])
+            mapped_amounts = np.append(mapped_amounts, tree_flows[n])
 
     # Need future cash flows which are exact time and size for accrued at t_exp
     for n in range(0, num_cpns):
         if cpn_times[n] > t_exp:
             mapped_times = np.append(mapped_times, cpn_times[n])
             mapped_amounts = np.append(mapped_amounts, cpn_amounts[n])
 
@@ -241,29 +242,29 @@
     for m in range(0, expiry_step+1):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, cpn_times, cpn_amounts)
         accrued[m] *= face_amount
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if treeFlows[m] > 0.0:
-            accrued[m] = treeFlows[m] * face_amount
+        if tree_flows[m] > 0.0:
+            accrued[m] = tree_flows[m] * face_amount
 
     if DEBUG:
         for i in range(0, expiry_step+1):
-            print(i, treeFlows[i], accrued[i])
+            print(i, tree_flows[i], accrued[i])
 
     ###########################################################################
 
     call_option_values = np.zeros(shape=(num_time_steps, num_nodes))
     put_option_values = np.zeros(shape=(num_time_steps, num_nodes))
     bond_values = np.zeros(shape=(num_time_steps, num_nodes))
 
-    pt_exp = _uinterpolate(t_exp, _df_times, _df_values, interp)
-    ptdelta = _uinterpolate(t_exp+dt, _df_times, _df_values, interp)
+    pt_exp = _uinterpolate(t_exp, _df_times, _df_values, INTERP)
+    ptdelta = _uinterpolate(t_exp+dt, _df_times, _df_values, INTERP)
 
     cpn = 0.0
     zcb = 0.0
 
     ###########################################################################
     # As the HW model has a closed form solution for the bond price, I use
     # this fact to calculate the bond price at expiry on the tree nodes
@@ -273,50 +274,50 @@
     for k in range(-nm, nm+1):
         kN = k + j_max
         r_t = _r_t[expiry_step, kN]
         bond_price = 0.0
         for i in range(0, num_cpns):
             tflow = cpn_times[i]
             if tflow >= t_exp:
-                ptflow = _uinterpolate(tflow, _df_times, _df_values, interp)
+                ptflow = _uinterpolate(tflow, _df_times, _df_values, INTERP)
                 zcb = p_fast(t_exp, tflow, r_t, dt, pt_exp, ptdelta, ptflow,
                              _sigma, _a)
                 cpn = cpn_amounts[i]
                 bond_price += cpn * face_amount * zcb
 
         bond_price += zcb * face_amount
 
         # The flow on this date has been added
         bond_values[expiry_step, kN] = bond_price
 
     # Now consider exercise of the option on the expiry date
     nm = min(expiry_step, j_max)
     for k in range(-nm, nm+1):
         kN = k + j_max
-        dir_ty_price = bond_values[expiry_step, kN]
-        clean_price = dir_ty_price - accrued[expiry_step]
+        dirty_price = bond_values[expiry_step, kN]
+        clean_price = dirty_price - accrued[expiry_step]
         call_exercise = max(clean_price - strike_price, 0.0)
         put_exercise = max(strike_price - clean_price, 0.0)
         call_option_values[expiry_step, kN] = call_exercise
         put_option_values[expiry_step, kN] = put_exercise
 
     m = expiry_step
 
     if DEBUG:
         print("-----------------------------------------")
-        print("EXP", _tree_times[m], accrued[m], dir_ty_price, clean_price,
+        print("EXP", _tree_times[m], accrued[m], dirty_price, clean_price,
               call_exercise, put_exercise)
 
 #        print(kN, bond_values[expiry_step, kN], "CLEAN", clean_price)
 #        print("EXPIRY DATE", kN, clean_price, accrued[expiry_step], strike_price)
 
     # Now step back to today considering exercise at expiry and before
     for m in range(expiry_step-1, -1, -1):
         nm = min(m, j_max)
-        flow = treeFlows[m] * face_amount
+        flow = tree_flows[m] * face_amount
 
         for k in range(-nm, nm+1):
             kN = k + j_max
             r = _r_t[m, kN]
             df = np.exp(-r*dt)
 
             pu = _pu[kN]
@@ -379,124 +380,124 @@
                 vu = put_option_values[m+1, kN+1]
                 vm = put_option_values[m+1, kN]
                 vd = put_option_values[m+1, kN-1]
                 vput = (pu*vu + pm*vm + pd*vd) * df
 
             put_option_values[m, kN] = vput
 
-            dir_ty_price = bond_values[m, kN]
-            clean_price = dir_ty_price - accrued[m]
+            dirty_price = bond_values[m, kN]
+            clean_price = dirty_price - accrued[m]
             call_exercise = max(clean_price - strike_price, 0.0)
             put_exercise = max(strike_price - clean_price, 0.0)
 
-            holdCall = call_option_values[m, kN]
-            holdPut = put_option_values[m, kN]
+            hold_call = call_option_values[m, kN]
+            hold_put = put_option_values[m, kN]
 
             if m == expiry_step:
 
-                call_option_values[m, kN] = max(call_exercise, holdCall)
-                put_option_values[m, kN] = max(put_exercise, holdPut)
+                call_option_values[m, kN] = max(call_exercise, hold_call)
+                put_option_values[m, kN] = max(put_exercise, hold_put)
 
             elif exercise_typeInt == 3 and m < expiry_step:  # AMERICAN
 
-                call_option_values[m, kN] = max(call_exercise, holdCall)
-                put_option_values[m, kN] = max(put_exercise, holdPut)
+                call_option_values[m, kN] = max(call_exercise, hold_call)
+                put_option_values[m, kN] = max(put_exercise, hold_put)
 
         if DEBUG:
-            print(m, _tree_times[m], accrued[m], dir_ty_price, clean_price,
+            print(m, _tree_times[m], accrued[m], dirty_price, clean_price,
                   call_exercise, put_exercise)
 
     return call_option_values[0, j_max], put_option_values[0, j_max]
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def bermudan_swaption_tree_fast(t_exp, t_mat, strike_price, face_amount,
                                 cpn_times, cpn_flows,
                                 exercise_typeInt,
                                 _df_times, _df_values,
                                 _tree_times, _Q, _pu, _pm, _pd, _r_t, _dt, _a):
-    """ Option to enter into a swap that can be exercised on coupon payment
+    """ Option to enter into a swap that can be exercised on cpn payment
     dates after the star_t of the exercise period. Due to multiple exercise
     times we need to extend tree out to bond maturity and take into account
     cash flows through time. """
 
     num_time_steps, num_nodes = _Q.shape
     j_max = ceil(0.1835/(_a * _dt))
     expiry_step = int(t_exp/_dt + 0.50)
-    maturityStep = int(t_mat/_dt + 0.50)
+    maturity_step = int(t_mat/_dt + 0.50)
 
     ###########################################################################
 
     fixed_leg_flows = np.zeros(num_time_steps)
     float_leg_values = np.zeros(num_time_steps)
     num_cpns = len(cpn_times)
 
     # Tree flows go all the way out to the bond maturity date
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        n = int(round(tcpn/_dt, 0))
+        t_cpn = cpn_times[i]
+        n = int(round(t_cpn/_dt, 0))
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, interp)
-        df_tree = _uinterpolate(ttree, _df_times, _df_values, interp)
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, INTERP)
+        df_tree = _uinterpolate(ttree, _df_times, _df_values, INTERP)
         fixed_leg_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
         float_leg_values[n] = strike_price * df_flow / df_tree
 
     ###########################################################################
     # Mapped times stores the mapped times and flows and is used to calculate
     # accrued interest in a consistent manner as using actual flows will
     # result in some convergence noise issues as it is inconsistent
     ###########################################################################
 
     mapped_times = np.array([0.0])
     mapped_amounts = np.array([0.0])
 
     for n in range(1, len(_tree_times)):
 
-        accdAtExpiry = 0.0
+        accd_at_expiry = 0.0
         if _tree_times[n-1] < t_exp and _tree_times[n] >= t_exp:
             mapped_times = np.append(mapped_times, t_exp)
-            mapped_amounts = np.append(mapped_amounts, accdAtExpiry)
+            mapped_amounts = np.append(mapped_amounts, accd_at_expiry)
 
         if fixed_leg_flows[n] > 0.0:
             mapped_times = np.append(mapped_times, _tree_times[n])
             mapped_amounts = np.append(mapped_amounts, fixed_leg_flows[n])
 
     ###########################################################################
 
     accrued = np.zeros(num_time_steps)
-    for m in range(0, maturityStep+1):
+    for m in range(0, maturity_step+1):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, mapped_times, mapped_amounts)
         accrued[m] *= face_amount
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if fixed_leg_flows[m] > gSmall:
+        if fixed_leg_flows[m] > g_small:
             accrued[m] = fixed_leg_flows[m] * face_amount
 
     ###########################################################################
 
     # The value of the swap at each time and node. Principal is exchanged.
     fixed_leg_values = np.zeros(shape=(num_time_steps, num_nodes))
     # The value of the option to enter into a payer swap
     pay_values = np.zeros(shape=(num_time_steps, num_nodes))
     # The value of the option to enter into a receiver swap
     rec_values = np.zeros(shape=(num_time_steps, num_nodes))
 
     # Star_t with the value of the bond at maturity
     for k in range(0, num_nodes):
-        flow = 1.0 + fixed_leg_flows[maturityStep]
-        fixed_leg_values[maturityStep, k] = flow * face_amount
+        flow = 1.0 + fixed_leg_flows[maturity_step]
+        fixed_leg_values[maturity_step, k] = flow * face_amount
 
     N = j_max
 
     # Now step back to today considering early exercise
-    for m in range(maturityStep-1, -1, -1):
+    for m in range(maturity_step-1, -1, -1):
         nm = min(m, j_max)
         flow = fixed_leg_flows[m] * face_amount
 
         for k in range(-nm, nm+1):
             kN = k + N
             r_t = _r_t[m, kN]
             df = np.exp(-r_t * _dt)
@@ -574,15 +575,15 @@
             rec_exercise = max(fixed_leg_value - float_leg_value, 0.0)
 
             if m == expiry_step:
 
                 pay_values[m, kN] = max(pay_exercise, hold_pay)
                 rec_values[m, kN] = max(rec_exercise, hold_rec)
 
-            elif exercise_typeInt == 2 and flow > gSmall and m >= expiry_step:
+            elif exercise_typeInt == 2 and flow > g_small and m >= expiry_step:
 
                 pay_values[m, kN] = max(pay_exercise, hold_pay)
                 rec_values[m, kN] = max(rec_exercise, hold_rec)
 
             elif exercise_typeInt == 3 and m >= expiry_step:
 
                 pay_values[m, kN] = max(pay_exercise, hold_pay)
@@ -602,74 +603,74 @@
 @njit(fastmath=True, cache=True)
 def callable_puttable_bond_tree_fast(cpn_times, cpn_flows,
                                      call_times, call_prices,
                                      put_times, put_prices, face,
                                      _sigma, _a, _Q,  # IS SIGMA USED ?
                                      _pu, _pm, _pd, _r_t, _dt, _tree_times,
                                      _df_times, _df_values):
-    """ Value an option on a bond with coupons that can have European or
-    American exercise. Some minor issues to do with handling coupons on
+    """ Value an option on a bond with cpns that can have European or
+    American exercise. Some minor issues to do with handling cpns on
     the option expiry date need to be solved. """
 
 #    print("Coupon Times:", cpn_times)
 #    print("Coupon Flows:", cpn_flows)
 
 #    print("DF Times:", _df_times)
 #    print("DF Values:", _df_values)
 
     if np.any(cpn_times < 0.0):
-        raise FinError("No coupon times can be before the value date.")
+        raise FinError("No cpn times can be before the value date.")
 
     num_time_steps, num_nodes = _Q.shape
     dt = _dt
     j_max = ceil(0.1835/(_a * dt))
     t_mat = cpn_times[-1]
-    maturityStep = int(t_mat/dt + 0.50)
+    maturity_step = int(t_mat/dt + 0.50)
 
     ###########################################################################
-    # Map coupons onto tree while preserving their present value
+    # Map cpns onto tree while preserving their present value
     ###########################################################################
 
-    treeFlows = np.zeros(num_time_steps)
+    tree_flows = np.zeros(num_time_steps)
 
     num_cpns = len(cpn_times)
     for i in range(0, num_cpns):
-        tcpn = cpn_times[i]
-        n = int(round(tcpn/dt, 0))
+        t_cpn = cpn_times[i]
+        n = int(round(t_cpn/dt, 0))
         ttree = _tree_times[n]
-        df_flow = _uinterpolate(tcpn, _df_times, _df_values, interp)
-        df_tree = _uinterpolate(ttree, _df_times, _df_values, interp)
-        treeFlows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
+        df_flow = _uinterpolate(t_cpn, _df_times, _df_values, INTERP)
+        df_tree = _uinterpolate(ttree, _df_times, _df_values, INTERP)
+        tree_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
 
-#    print("Tree flows:", treeFlows)
+#    print("Tree flows:", tree_flows)
 
     ###########################################################################
     # Mapped times stores the mapped times and flows and is used to calculate
     # accrued interest in a consistent manner as using actual flows will
     # result in some convergence noise issues as it is inconsistent
     ###########################################################################
 
     mapped_times = np.array([0.0])
     mapped_amounts = np.array([0.0])
 
     for n in range(1, len(_tree_times)):
-        if treeFlows[n] > 0.0:
+        if tree_flows[n] > 0.0:
             mapped_times = np.append(mapped_times, _tree_times[n])
-            mapped_amounts = np.append(mapped_amounts, treeFlows[n])
+            mapped_amounts = np.append(mapped_amounts, tree_flows[n])
 
     accrued = np.zeros(num_time_steps)
     for m in range(0, num_time_steps):
         ttree = _tree_times[m]
         accrued[m] = accrued_interpolator(ttree, mapped_times, mapped_amounts)
         accrued[m] *= face
 
         # This is a bit of a hack for when the interpolation does not put the
         # full accrued on flow date. Another scheme may work but so does this
-        if treeFlows[m] > 0.0:
-            accrued[m] = treeFlows[m] * face
+        if tree_flows[m] > 0.0:
+            accrued[m] = tree_flows[m] * face
 
     ###########################################################################
     # map call onto tree - must have no calls at high value
     ###########################################################################
 
     tree_call_value = np.ones(num_time_steps) * face * 1000.0
     num_calls = len(call_times)
@@ -686,53 +687,53 @@
         n = int(round(put_time/dt, 0))
         tree_put_value[n] = put_prices[i]
 
     ###########################################################################
     # Value the bond by backward induction star_ting at bond maturity
     ###########################################################################
 
-    callPutBondValues = np.zeros(shape=(num_time_steps, num_nodes))
+    call_put_bond_values = np.zeros(shape=(num_time_steps, num_nodes))
     bond_values = np.zeros(shape=(num_time_steps, num_nodes))
 
     DEBUG = True
     if DEBUG:
         df = 1.0
         px = 0.0
-        for i in range(0, maturityStep+1):
-            flow = treeFlows[i]
+        for i in range(0, maturity_step+1):
+            flow = tree_flows[i]
             t = _tree_times[i]
-            df = _uinterpolate(t, _df_times, _df_values, interp)
+            df = _uinterpolate(t, _df_times, _df_values, INTERP)
 
-            if flow > gSmall:
+            if flow > g_small:
                 pv = flow * df
                 px += pv
 
         px += df
 
     ###########################################################################
     # Now step back to today considering early exercise
     ###########################################################################
 
-    m = maturityStep
-    nm = min(maturityStep, j_max)
+    m = maturity_step
+    nm = min(maturity_step, j_max)
     vcall = tree_call_value[m]
     vput = tree_put_value[m]
-    vhold = (1.0 + treeFlows[m]) * face
+    vhold = (1.0 + tree_flows[m]) * face
     vclean = vhold - accrued[m]
     value = min(max(vclean, vput), vcall) + accrued[m]
 
     for k in range(-nm, nm+1):
         kN = k + j_max
-        bond_values[m, kN] = (1.0 + treeFlows[m]) * face
-        callPutBondValues[m, kN] = value
+        bond_values[m, kN] = (1.0 + tree_flows[m]) * face
+        call_put_bond_values[m, kN] = value
 
     # Now step back to today considering early put and call
-    for m in range(maturityStep-1, -1, -1):
+    for m in range(maturity_step-1, -1, -1):
         nm = min(m, j_max)
-        flow = treeFlows[m] * face
+        flow = tree_flows[m] * face
         vcall = tree_call_value[m]
         vput = tree_put_value[m]
 
         for k in range(-nm, nm+1):
             kN = k + j_max
             r_t = _r_t[m, kN]
             df = np.exp(-r_t*dt)
@@ -754,80 +755,80 @@
                 vd = bond_values[m+1, kN-1]
 
             v = (pu*vu + pm*vm + pd*vd) * df
             bond_values[m, kN] = v
             bond_values[m, kN] += flow
 
             if k == j_max:
-                vu = callPutBondValues[m+1, kN]
-                vm = callPutBondValues[m+1, kN-1]
-                vd = callPutBondValues[m+1, kN-2]
+                vu = call_put_bond_values[m+1, kN]
+                vm = call_put_bond_values[m+1, kN-1]
+                vd = call_put_bond_values[m+1, kN-2]
             elif k == -j_max:
-                vu = callPutBondValues[m+1, kN+2]
-                vm = callPutBondValues[m+1, kN+1]
-                vd = callPutBondValues[m+1, kN]
+                vu = call_put_bond_values[m+1, kN+2]
+                vm = call_put_bond_values[m+1, kN+1]
+                vd = call_put_bond_values[m+1, kN]
             else:
-                vu = callPutBondValues[m+1, kN+1]
-                vm = callPutBondValues[m+1, kN]
-                vd = callPutBondValues[m+1, kN-1]
+                vu = call_put_bond_values[m+1, kN+1]
+                vm = call_put_bond_values[m+1, kN]
+                vd = call_put_bond_values[m+1, kN-1]
 
             vhold = (pu*vu + pm*vm + pd*vd) * df
-            # Need to make add on coupons paid if we hold
+            # Need to make add on cpns paid if we hold
             vhold = vhold + flow
             value = min(max(vhold - accrued[m], vput), vcall) + accrued[m]
-            callPutBondValues[m, kN] = value
+            call_put_bond_values[m, kN] = value
 
-    return {'bondwithoption': callPutBondValues[0, j_max],
+    return {'bondwithoption': call_put_bond_values[0, j_max],
             'bondpure': bond_values[0, j_max]}
 
 ###############################################################################
 
 
-def fwd_dir_ty_bond_price(r_t, *args):
-    """ Price a coupon bearing bond on the option expiry date and return
+def fwd_dirty_bond_price(r_t, *args):
+    """ Price a cpn bearing bond on the option expiry date and return
     the difference from a strike price. This is used in a root search to
-    find the future expiry time shor_t rate that makes the bond price equal
+    find the future expiry time short rate that makes the bond price equal
     to the option strike price. It is a key step in the Jamshidian bond
     decomposition approach. The strike is a clean price. """
 
     self = args[0]
     t_exp = args[1]
     cpn_times = args[2]
     cpn_amounts = args[3]
     df_times = args[4]
     df_values = args[5]
     strike_price = args[6]
     face = args[7]
 
     dt = 0.001
     tdelta = t_exp + dt
-    pt_exp = _uinterpolate(t_exp, df_times, df_values, interp)
-    ptdelta = _uinterpolate(tdelta, df_times, df_values, interp)
+    pt_exp = _uinterpolate(t_exp, df_times, df_values, INTERP)
+    ptdelta = _uinterpolate(tdelta, df_times, df_values, INTERP)
 
 #    print("TEXP", t_exp, pt_exp)
 
     num_flows = len(cpn_times)
     pv = 0.0
 
     for i in range(1, num_flows):
 
-        tcpn = cpn_times[i]
+        t_cpn = cpn_times[i]
         cpn = cpn_amounts[i]
 
-        if tcpn > t_exp:
-            ptcpn = _uinterpolate(tcpn, df_times, df_values, interp)
-            zcb = p_fast(t_exp, tcpn, r_t, dt, pt_exp, ptdelta, ptcpn,
-                         self._sigma, self._a)
+        if t_cpn > t_exp:
+            pt_cpn = _uinterpolate(t_cpn, df_times, df_values, INTERP)
+            zcb = p_fast(t_exp, t_cpn, r_t, dt, pt_exp, ptdelta, pt_cpn,
+                         self.sigma, self.a)
             pv = pv + zcb * cpn
-#            print("TCPN", tcpn, "ZCB", zcb, "CPN", cpn, "PV", pv)
+#            print("TCPN", t_cpn, "ZCB", zcb, "CPN", cpn, "PV", pv)
 
-    if tcpn >= t_exp:
+    if t_cpn >= t_exp:
         pv = pv + zcb
 
-#    print("TCPN", tcpn, "ZCB", zcb, "PRI", 1.0, "PV", pv)
+#    print("TCPN", t_cpn, "ZCB", zcb, "PRI", 1.0, "PV", pv)
 
     accd = accrued_interpolator(t_exp, cpn_times, cpn_amounts)
 #    print("Accrued:", accd)
 #    print("t_exp:", t_exp)
 #    print("cpn_times:", cpn_times)
 #    print("cpn_amounts:", cpn_amounts)
 
@@ -842,75 +843,80 @@
 
 class HWTree():
 
     def __init__(self,
                  sigma,
                  a,
                  num_time_steps=100,
-                 europeanCalcType=FinHWEuropeanCalcType.EXPIRY_TREE):
+                 european_calc_type=FinHWEuropeanCalcType.EXPIRY_TREE):
         """ Constructs the Hull-White rate model. The speed of mean reversion
-        a and volatility are passed in. The shor_t rate process is given by
+        a and volatility are passed in. The short rate process is given by
         dr = (theta(t) - ar) * dt  + sigma * dW. The model will switch to use
         Jamshidian's approach where possible unless the useJamshidian flag is
         set to false in which case it uses the trinomial Tree. """
 
         if sigma < 0.0:
             raise FinError("Negative volatility not allowed.")
 
         if a < 0.0:
             raise FinError("Mean reversion speed parameter should be >= 0.")
 
-        self._sigma = sigma
-        self._a = a
-        self._num_time_steps = num_time_steps
-        self._europeanCalcType = europeanCalcType
-
-        self._Q = None
-        self._r = None
-        self._tree_times = None
-        self._pu = None
-        self._pm = None
-        self._pd = None
-        self._discount_curve = None
-        self._treeBuilt = False
+        self.sigma = sigma
+        self.a = a
+        self.num_time_steps = num_time_steps
+        self.european_calc_type = european_calc_type
+
+        self.Q = None
+        self.r = None
+        self.tree_times = None
+        self.pu = None
+        self.pm = None
+        self.pd = None
+        self.discount_curve = None
+        self.tree_built = False
+        self.df_times = None
+        self.dfs = None
+        self.r_t = None
+        self.dt = None
 
 ###############################################################################
 
     def option_on_zcb(self,
                       t_exp, t_mat,
                       strike, face_amount,
                       df_times, df_values):
-        """ Price an option on a zero coupon bond using analytical solution of
+        """ Price an option on a zero cpn bond using analytical solution of
         Hull-White model. User provides bond face and option strike and expiry
         date and maturity date. """
 
         if t_exp > t_mat:
             raise FinError("Option expiry after bond matures.")
 
         if t_exp < 0.0:
             raise FinError("Option expiry time negative.")
 
-        pt_exp = _uinterpolate(t_exp, df_times, df_values, interp)
-        pt_mat = _uinterpolate(t_mat, df_times, df_values, interp)
+        pt_exp = _uinterpolate(t_exp, df_times, df_values, INTERP)
+        pt_mat = _uinterpolate(t_mat, df_times, df_values, INTERP)
 
-        sigma = self._sigma
-        a = self._a
+        sigma = self.sigma
+        a = self.a
 
-        if abs(a) < small:
-            a = small
+        if abs(a) < SMALL:
+            a = SMALL
 
         sigmap = (sigma/a) * (1.0 - np.exp(-a*(t_mat-t_exp)))
-        sigmap *= np.sqrt((1.0-np.exp(-2.0*a*t_exp))/2.0/a)
+        sigmap = sigmap * np.sqrt((1.0-np.exp(-2.0*a*t_exp))/2.0/a)
 
-        if abs(sigmap) < small:
-            sigmap = small
+        if abs(sigmap) < SMALL:
+            sigmap = SMALL
 
         h = np.log((face_amount*pt_mat)/(strike * pt_exp)) / \
             sigmap + sigmap / 2.0
-        call_value = face_amount * pt_mat * N(h) - strike * pt_exp * N(h - sigmap)
+        call_value = face_amount * pt_mat * \
+            N(h) - strike * pt_exp * N(h - sigmap)
         put_value = strike * pt_exp * \
             N(-h + sigmap) - face_amount * pt_mat * N(-h)
 
         return {'call': call_value, 'put': put_value}
 
 ###############################################################################
 
@@ -919,55 +925,55 @@
                                         strike_price,
                                         face,
                                         cpn_times,
                                         cpn_amounts,
                                         df_times,
                                         df_values):
         """ Valuation of a European bond option using the Jamshidian
-        deconstruction of the bond into a strip of zero coupon bonds with the
-        shor_t rate that would make the bond option be at the money forward. """
+        deconstruction of the bond into a strip of zero cpn bonds with the
+        short rate that would make the bond option be at the money forward. """
 
 #        print(df_times)
 #        print(df_values)
 
         num_cpns = len(cpn_times)
 
         argtuple = (self, t_exp, cpn_times, cpn_amounts,
                     df_times, df_values, strike_price, face)
 
         # Can I improve on this initial guess ?
         x0 = 0.05
 
-        rstar = optimize.newton(fwd_dir_ty_bond_price, x0=x0, fprime=None,
+        rstar = optimize.newton(fwd_dirty_bond_price, x0=x0, fprime=None,
                                 args=argtuple, tol=1e-10, maxiter=50,
                                 fprime2=None)
 
-        # Now we price a series of zero coupon bonds using this shor_t rate
+        # Now we price a series of zero cpn bonds using this short rate
         dt = 1e-6
 
-        pt_exp = _uinterpolate(t_exp, df_times, df_values, interp)
-        ptdelta = _uinterpolate(t_exp+dt, df_times, df_values, interp)
+        pt_exp = _uinterpolate(t_exp, df_times, df_values, INTERP)
+        ptdelta = _uinterpolate(t_exp+dt, df_times, df_values, INTERP)
 
         call_value = 0.0
         put_value = 0.0
 
         # Adjust strike to handle
         for i in range(0, num_cpns):
 
-            tcpn = cpn_times[i]
+            t_cpn = cpn_times[i]
             cpn = cpn_amounts[i]
 
-            if tcpn >= t_exp:  # coupons on the expiry date are included
+            if t_cpn >= t_exp:  # cpns on the expiry date are included
 
-                ptcpn = _uinterpolate(tcpn, df_times, df_values, interp)
+                pt_cpn = _uinterpolate(t_cpn, df_times, df_values, INTERP)
 
-                strike = p_fast(t_exp, tcpn, rstar, dt, pt_exp, ptdelta,
-                                ptcpn, self._sigma, self._a)
+                strike = p_fast(t_exp, t_cpn, rstar, dt, pt_exp, ptdelta,
+                                pt_cpn, self.sigma, self.a)
 
-                v = self.option_on_zcb(t_exp, tcpn, strike, 1.0,
+                v = self.option_on_zcb(t_exp, t_cpn, strike, 1.0,
                                        df_times, df_values)
 
                 call = v['call']
                 put = v['put']
 
                 call_value += call * cpn * face
                 put_value += put * cpn * face
@@ -981,126 +987,126 @@
 
     def european_bond_option_expiry_only(self,
                                          t_exp,
                                          strike_price,
                                          face_amount,
                                          cpn_times,
                                          cpn_amounts):
-        """ Price a European option on a coupon-paying bond using a tree to
-        generate shor_t rates at the expiry date and then to use the analytical
-        solution of zero coupon bond prices in the HW model to calculate the
+        """ Price a European option on a cpn-paying bond using a tree to
+        generate short rates at the expiry date and then to use the analytical
+        solution of zero cpn bond prices in the HW model to calculate the
         corresponding bond price. User provides bond object and option details.
         """
 
-        dt = self._dt
+        dt = self.dt
         tdelta = t_exp + dt
 
-        pt_exp = _uinterpolate(t_exp, self._df_times, self._dfs, interp)
-        ptdelta = _uinterpolate(tdelta, self._df_times, self._dfs, interp)
+        pt_exp = _uinterpolate(t_exp, self.df_times, self.dfs, INTERP)
+        ptdelta = _uinterpolate(tdelta, self.df_times, self.dfs, INTERP)
 
-        _, num_nodes = self._Q.shape
+        _, num_nodes = self.Q.shape
         expiry_step = int(t_exp/dt+0.50)
 
         call_value = 0.0
         put_value = 0.0
         num_cpns = len(cpn_times)
 
         #######################################################################
 
         for k in range(0, num_nodes):
 
-            q = self._Q[expiry_step, k]
-            r_t = self._r_t[expiry_step, k]
+            q = self.Q[expiry_step, k]
+            r_t = self.r_t[expiry_step, k]
 
             pv = 0.0
 
             for i in range(0, num_cpns):
 
-                tcpn = cpn_times[i]
+                t_cpn = cpn_times[i]
                 cpn = cpn_amounts[i]
 
-                if tcpn >= t_exp:
+                if t_cpn >= t_exp:
 
-                    ptcpn = _uinterpolate(tcpn, self._df_times, self._dfs,
-                                          interp)
+                    pt_cpn = _uinterpolate(t_cpn, self.df_times, self.dfs,
+                                          INTERP)
 
-                    zcb = p_fast(t_exp, tcpn, r_t, dt, pt_exp, ptdelta, ptcpn,
-                                 self._sigma, self._a)
+                    zcb = p_fast(t_exp, t_cpn, r_t, dt, pt_exp, ptdelta, pt_cpn,
+                                 self.sigma, self.a)
 
                     pv += cpn * zcb
 
             pv += zcb
 
 #            print(t_exp)
 #            print(cpn_times)
 #            print(cpn_amounts)
 
             accrued = accrued_interpolator(t_exp, cpn_times, cpn_amounts)
 
             pv = pv - accrued
 #            print(accrued)
 
-            putPayoff = max(strike_price - pv * face_amount, 0.0)
-            callPayoff = max(pv * face_amount - strike_price, 0.0)
+            put_payoff = max(strike_price - pv * face_amount, 0.0)
+            call_payoff = max(pv * face_amount - strike_price, 0.0)
 
-            put_value += q * putPayoff
-            call_value += q * callPayoff
+            put_value += q * put_payoff
+            call_value += q * call_payoff
 
         #######################################################################
 
         return {'call': call_value, 'put': put_value}
 
 ###############################################################################
 
-    def option_on_zero_coupon_bond_tree(self,
+    def option_on_zero_cpn_bond_tree(self,
                                         t_exp,
                                         t_mat,
                                         strike_price,
                                         face_amount):
-        """ Price an option on a zero coupon bond using a HW trinomial
+        """ Price an option on a zero cpn bond using a HW trinomial
         tree. The discount curve was already supplied to the tree build. """
 
         if t_exp > t_mat:
             raise FinError("Option expiry after bond matures.")
 
         if t_exp < 0.0:
             raise FinError("Option expiry time negative.")
 
-        if self._tree_times is None:
+        if self.tree_times is None:
             raise FinError("Tree has not been constructed.")
 
-        if self._tree_times[-1] < t_exp:
+        if self.tree_times[-1] < t_exp:
             raise FinError("Tree expiry must be >= option expiry date.")
 
-        dt = self._dt
+        dt = self.dt
         tdelta = t_exp + dt
 
-        pt_exp = _uinterpolate(t_exp, self._df_times, self._dfs, interp)
-        ptdelta = _uinterpolate(tdelta, self._df_times, self._dfs, interp)
-        pt_mat = _uinterpolate(t_mat, self._df_times, self._dfs, interp)
+        pt_exp = _uinterpolate(t_exp, self.df_times, self.dfs, INTERP)
+        ptdelta = _uinterpolate(tdelta, self.df_times, self.dfs, INTERP)
+        pt_mat = _uinterpolate(t_mat, self.df_times, self.dfs, INTERP)
 
-        _, num_nodes = self._Q.shape
+        _, num_nodes = self.Q.shape
         expiry_step = int(t_exp/dt+0.50)
 
         call_value = 0.0
         put_value = 0.0
 
         for k in range(0, num_nodes):
 
-            q = self._Q[expiry_step, k]
-            r_t = self._r_t[expiry_step, k]
+            q = self.Q[expiry_step, k]
+            r_t = self.r_t[expiry_step, k]
 
             zcb = p_fast(t_exp, t_mat,
                          r_t, dt, pt_exp, ptdelta, pt_mat,
-                         self._sigma, self._a)
+                         self.sigma, self.a)
 
-            putPayoff = max(strike_price - zcb * face_amount, 0.0)
-            callPayoff = max(zcb * face_amount - strike_price, 0.0)
-            put_value += q * putPayoff
-            call_value += q * callPayoff
+            put_payoff = max(strike_price - zcb * face_amount, 0.0)
+            call_payoff = max(zcb * face_amount - strike_price, 0.0)
+            put_value += q * put_payoff
+            call_value += q * call_payoff
 
         return {'call': call_value, 'put': put_value}
 
 ###############################################################################
 
     def bermudan_swaption(self, t_exp, t_mat, strike, face,
                           cpn_times, cpn_flows, exercise_type):
@@ -1116,108 +1122,108 @@
             raise FinError("Option expiry after bond matures.")
 
         if t_exp < 0.0:
             raise FinError("Option expiry time negative.")
 
         #######################################################################
 
-        payValue, recValue \
+        pay_value, rec_value \
             = bermudan_swaption_tree_fast(t_exp, t_mat, strike, face,
                                           cpn_times, cpn_flows,
                                           exercise_typeInt,
-                                          self._df_times, self._dfs,
-                                          self._tree_times, self._Q,
-                                          self._pu, self._pm, self._pd,
-                                          self._r_t,
-                                          self._dt, self._a)
+                                          self.df_times, self.dfs,
+                                          self.tree_times, self.Q,
+                                          self.pu, self.pm, self.pd,
+                                          self.r_t,
+                                          self.dt, self.a)
 
-        return {'pay': payValue, 'rec': recValue}
+        return {'pay': pay_value, 'rec': rec_value}
 
 ###############################################################################
 
     def bond_option(self, t_exp, strike_price, face_amount,
                     cpn_times, cpn_flows, exercise_type):
         """ Value a bond option that can have European or American exercise.
         This is done using a trinomial tree that we extend out to bond
         maturity. For European bond options, Jamshidian's model is
         faster and is used instead i.e. not this function. """
 
         exercise_typeInt = option_exercise_types_to_int(exercise_type)
 
         if exercise_typeInt == 1:
 
-            if self._europeanCalcType == FinHWEuropeanCalcType.JAMSHIDIAN:
+            if self.european_calc_type == FinHWEuropeanCalcType.JAMSHIDIAN:
 
                 v = self.european_bond_option_jamshidian(t_exp,
                                                          strike_price,
                                                          face_amount,
                                                          cpn_times,
                                                          cpn_flows,
-                                                         self._df_times,
-                                                         self._dfs)
+                                                         self.df_times,
+                                                         self.dfs)
 
                 call_value = v['call']
                 put_value = v['put']
 
-            elif self._europeanCalcType == FinHWEuropeanCalcType.EXPIRY_ONLY:
+            elif self.european_calc_type == FinHWEuropeanCalcType.EXPIRY_ONLY:
 
                 v = self.european_bond_option_expiry_only(t_exp,
                                                           strike_price,
                                                           face_amount,
                                                           cpn_times,
                                                           cpn_flows)
 
                 call_value = v['call']
                 put_value = v['put']
 
-            elif self._europeanCalcType == FinHWEuropeanCalcType.EXPIRY_TREE:
+            elif self.european_calc_type == FinHWEuropeanCalcType.EXPIRY_TREE:
 
                 call_value, put_value \
                     = american_bond_option_tree_fast(t_exp,
                                                      strike_price, face_amount,
                                                      cpn_times, cpn_flows,
                                                      exercise_typeInt,
-                                                     self._sigma, self._a,
-                                                     self._Q,
-                                                     self._pu, self._pm, self._pd,
-                                                     self._r_t, self._dt,
-                                                     self._tree_times,
-                                                     self._df_times, self._dfs)
+                                                     self.sigma, self.a,
+                                                     self.Q,
+                                                     self.pu, self.pm, self.pd,
+                                                     self.r_t, self.dt,
+                                                     self.tree_times,
+                                                     self.df_times, self.dfs)
 
             else:
                 raise FinError("Unknown HW model implementation choice.")
 
         else:
 
             call_value, put_value \
                 = american_bond_option_tree_fast(t_exp,
                                                  strike_price, face_amount,
                                                  cpn_times, cpn_flows,
                                                  exercise_typeInt,
-                                                 self._sigma, self._a,
-                                                 self._Q,
-                                                 self._pu, self._pm, self._pd,
-                                                 self._r_t, self._dt,
-                                                 self._tree_times,
-                                                 self._df_times, self._dfs)
+                                                 self.sigma, self.a,
+                                                 self.Q,
+                                                 self.pu, self.pm, self.pd,
+                                                 self.r_t, self.dt,
+                                                 self.tree_times,
+                                                 self.df_times, self.dfs)
 
         return {'call': call_value, 'put': put_value}
 
 ###############################################################################
 
     def callable_puttable_bond_tree(self,
                                     cpn_times,
                                     cpn_flows,
                                     call_times,
                                     call_prices,
                                     put_times,
                                     put_prices,
                                     face_amount):
-        """ Value an option on a bond with coupons that can have European or
-        American exercise. Some minor issues to do with handling coupons on
+        """ Value an option on a bond with cpns that can have European or
+        American exercise. Some minor issues to do with handling cpns on
         the option expiry date need to be solved. Also this function should be
         moved out of the class so it can be sped up using NUMBA. """
 
         cpn_times = np.array(cpn_times)
         cpn_flows = np.array(cpn_flows)
 
         call_times = np.array(call_times)
@@ -1226,90 +1232,90 @@
         call_prices = np.array(call_prices)
         put_prices = np.array(put_prices)
 
         v = callable_puttable_bond_tree_fast(cpn_times, cpn_flows,
                                              call_times, call_prices,
                                              put_times, put_prices,
                                              face_amount,
-                                             self._sigma, self._a,
-                                             self._Q,
-                                             self._pu, self._pm, self._pd,
-                                             self._r_t, self._dt,
-                                             self._tree_times,
-                                             self._df_times, self._dfs)
+                                             self.sigma, self.a,
+                                             self.Q,
+                                             self.pu, self.pm, self.pd,
+                                             self.r_t, self.dt,
+                                             self.tree_times,
+                                             self.df_times, self.dfs)
 
         return {'bondwithoption': v['bondwithoption'],
                 'bondpure': v['bondpure']}
 
 ###############################################################################
 
     def df_tree(self, t_mat):
         """ Discount factor as seen from now to time t_mat as long as the time
         is on the tree grid. """
 
         if t_mat == 0.0:
             return 1.0
 
-        _, num_nodes = self._Q.shape
-        fn1 = t_mat/self._dt
-        fn2 = float(int(t_mat/self._dt))
+        _, num_nodes = self.Q.shape
+        fn1 = t_mat/self.dt
+        fn2 = float(int(t_mat/self.dt))
         if abs(fn1 - fn2) > 1e-6:
             raise FinError("Time not on tree time grid")
 
-        timeStep = int(t_mat / self._dt) + 1
+        time_step = int(t_mat / self.dt) + 1
 
         p = 0.0
         for i in range(0, num_nodes):
-            ad = self._Q[timeStep, i]
+            ad = self.Q[time_step, i]
             p += ad
         zero_rate = -np.log(p)/t_mat
         return p, zero_rate
 
 ###############################################################################
 
-    def build_tree(self, treeMat, df_times, df_values):
+    def build_tree(self, tree_mat, df_times, df_values):
         """ Build the trinomial tree. """
 
         if isinstance(df_times, np.ndarray) is False:
             raise FinError("DF TIMES must be a numpy vector")
 
         if isinstance(df_values, np.ndarray) is False:
             raise FinError("DF VALUES must be a numpy vector")
 
         # I wish to add on an additional time to the tree so that the second
-        # last time corresponds to a maturity treeMat. For this reason I scale
+        # last time corresponds to a maturity tree_mat. For this reason I scale
         # up the maturity date of the tree as follows
-        treeMaturity = treeMat * (self._num_time_steps+1)/self._num_time_steps
+        tree_maturity = tree_mat * (self.num_time_steps + 1) / self.num_time_steps
 
         # The vector of times goes out to this maturity
-        tree_times = np.linspace(0.0, treeMaturity, self._num_time_steps + 2)
-        self._tree_times = tree_times
+        tree_times = np.linspace(0.0, tree_maturity, self.num_time_steps + 2)
+        self.tree_times = tree_times
 
-        dfTree = np.zeros(shape=(self._num_time_steps+2))
-        dfTree[0] = 1.0
+        df_tree = np.zeros(shape=self.num_time_steps+2)
+        df_tree[0] = 1.0
 
-        for i in range(1, self._num_time_steps+2):
+        for i in range(1, self.num_time_steps+2):
             t = tree_times[i]
-            dfTree[i] = _uinterpolate(t, df_times, df_values, interp)
+            df_tree[i] = _uinterpolate(t, df_times, df_values, INTERP)
 
-        self._df_times = df_times
-        self._dfs = df_values
+        self.df_times = df_times
+        self.dfs = df_values
 
-        self._Q, self._pu, self._pm, self._pd, self._r_t, self._dt \
-            = build_tree_fast(self._a, self._sigma,
-                              tree_times, self._num_time_steps, dfTree)
+        self.Q, self.pu, self.pm, self.pd, self.r_t, self.dt \
+            = build_tree_fast(self.a, self.sigma,
+                              tree_times, self.num_time_steps, df_tree)
 
         return
 
 ###############################################################################
 
     def __repr__(self):
         """ Return string with class details. """
 
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("Sigma", self._sigma)
-        s += label_to_string("a", self._a)
-        s += label_to_string("num_time_steps", self._num_time_steps)
-        s += label_to_string("EuropeanCalcTypes", self._europeanCalcType)
+        s = label_to_string("OBJECT TYPE", type(self)._name__)
+        s += label_to_string("Sigma", self.sigma)
+        s += label_to_string("a", self.a)
+        s += label_to_string("num_time_steps", self.num_time_steps)
+        s += label_to_string("european_calc_types", self.european_calc_type)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/lmm_mc.py` & `financepy-0.360/financepy/models/lmm_mc.py`

 * *Files 7% similar despite different names*

```diff
@@ -11,21 +11,21 @@
 from ..utils.math import norminvcdf
 from ..models.sobol import get_uniform_sobol
 
 # TO DO: SHIFTED LOGNORMAL
 # TO DO: TERMINAL MEASURE
 # TO DO:: CALIBRATION
 
-useParallel = False
+USE_PARALLEL = False
 
 ###############################################################################
 
 """ This module manages the Ibor Market Model and so stores a specific MC
-    forward rate simulation of a 3D matrix of num_paths x numForwards
-    x (numForwards-1)/2 elements. This is a lognormal model although a shifted
+    forward rate simulation of a 3D matrix of num_paths x num_fwds
+    x (num_fwds-1)/2 elements. This is a lognormal model although a shifted
     Lognormal rate is also allowed. Implementations include 1 factor, M factor
     where the volatility curve per factor is provided and a full N-factor corr-
     elation matrix where a Cholesky is done to decompose the N factors. """
 
 ###############################################################################
 
 
@@ -38,28 +38,28 @@
 
 
 def lmm_print_forwards(fwds):
     """ Helper function to display the simulated Ibor rates. """
 
     num_paths = len(fwds)
     num_times = len(fwds[0])
-    numFwds = len(fwds[0][0])
+    num_fwds = len(fwds[0][0])
 
     if num_paths > 10:
         return
 
     for ip in range(0, num_paths):
         for it in range(0, num_times):
 
             print("Path: %3d Time: %3d" % (ip, it), end=""),
 
             for ifwd in range(0, it):
                 print("%8s" % ("-"), end=""),
 
-            for ifwd in range(it, numFwds):
+            for ifwd in range(it, num_fwds):
                 print("%8.4f" % (fwds[ip][it][ifwd]*100.0), end=""),
 
             print("")
 
 
 ###############################################################################
 
@@ -103,61 +103,61 @@
         pv01ab += taus[k] * p[k]
 
     sab = (p[a] - p[b-1])/pv01ab
 
     for i in range(a, b):
         wts[i] = taus[i] * p[i] / pv01ab
 
-    swaptionVar = 0.0
+    swaption_var = 0.0
     for i in range(a, b):
         for j in range(a, b):
             wti = wts[i]
             wtj = wts[j]
             fi = fwd0[i]
             fj = fwd0[j]
             intsigmaij = 0.0
 
             for k in range(0, a):
                 intsigmaij += zetas[i] * zetas[j] * taus[k]
 
             term = wti * wtj * fi * fj * rho[i][j] * intsigmaij / (sab**2)
-            swaptionVar += term
+            swaption_var += term
 
     taua = 0.0
     for i in range(0, a):
         taua += taus[i]
 
     taub = 0.0
     for i in range(0, b):
         taub += taus[i]
 
-    swaptionVol = np.sqrt(swaptionVar/taua)
-    return swaptionVol
+    swaption_vol = np.sqrt(swaption_var/taua)
+    return swaption_vol
 
 
 ###############################################################################
 
 
 @njit(float64(int64, int64, float64[:], float64[:, :, :], float64[:]),
       cache=True, fastmath=True)
 def lmm_sim_swaption_vol(a, b, fwd0, fwds, taus):
     """ Calculates the swap rate volatility using the forwards generated in the
     simulation to see how it compares to Rebonatto estimate. """
 
     num_paths = len(fwds)
-    numForwards = len(fwds[0])
+    num_fwds = len(fwds[0])
 
-    if a > numForwards:
-        raise FinError("NumPeriods > numForwards")
+    if a > num_fwds:
+        raise FinError("NumPeriods > num_fwds")
 
     if a >= b:
         raise FinError("Swap maturity is before expiry date")
 
-    fwdSwapRateMean = 0.0
-    fwdSwapRateVar = 0.0
+    fwd_swap_rate_mean = 0.0
+    fwd_swap_rate_var = 0.0
 
     for i_path in range(0, num_paths):  # changed from prange
 
         numeraire = 1.0
 
         for k in range(0, a):
             numeraire *= (1.0 + taus[k] * fwds[i_path, k, k])
@@ -167,53 +167,53 @@
 
         for k in range(a, b):
             f = fwds[i_path, a, k]
             tau = taus[k]
             df = df / (1.0 + tau * f)
             pv01 = pv01 + tau * df
 
-        fwdSwapRate = (1.0 - df) / pv01
+        fwd_swap_rate = (1.0 - df) / pv01
 
-        fwdSwapRateMean += fwdSwapRate
-        fwdSwapRateVar += fwdSwapRate**2
+        fwd_swap_rate_mean += fwd_swap_rate
+        fwd_swap_rate_var += fwd_swap_rate**2
 
     taua = 0.0
     for i in range(0, a):
         taua += taus[i]
 
-    fwdSwapRateMean /= num_paths
-    fwdSwapRateVar = fwdSwapRateVar/num_paths - fwdSwapRateMean**2
-    fwdSwapRateVol = np.sqrt(fwdSwapRateVar/taua)
-    fwdSwapRateVol /= fwdSwapRateMean
-    return fwdSwapRateVol
+    fwd_swap_rate_mean /= num_paths
+    fwd_swap_rate_var = fwd_swap_rate_var/num_paths - fwd_swap_rate_mean**2
+    fwd_swap_rate_vol = np.sqrt(fwd_swap_rate_var/taua)
+    fwd_swap_rate_vol /= fwd_swap_rate_mean
+    return fwd_swap_rate_vol
 
 ###############################################################################
 
 
 @njit(float64[:, :](int64, int64, int64, float64[:, :, :]),
       cache=True, fastmath=True)
-def lmm_fwd_fwd_correlation(numForwards, num_paths, i_time, fwds):
+def lmm_fwd_fwd_correlation(num_fwds, num_paths, i_time, fwds):
     """ Extract forward forward correlation matrix at some future time index
     from the simulated forward rates and return the matrix. """
 
-    size = numForwards - i_time
-    fwdCorr = np.zeros((size, size))
+    size = num_fwds - i_time
+    fwd_corr = np.zeros((size, size))
 
-    for iFwd in range(i_time, numForwards):
-        for jFwd in range(iFwd, numForwards):
+    for i_fwd in range(i_time, num_fwds):
+        for j_fwd in range(i_fwd, num_fwds):
 
             sumfwdi = 0.0
             sumfwdj = 0.0
             sumfwdifwdi = 0.0
             sumfwdifwdj = 0.0
             sumfwdjfwdj = 0.0
 
             for p in range(0, num_paths):  # changed from prange
-                dfwdi = fwds[p, i_time, iFwd] - fwds[p, i_time-1, iFwd]
-                dfwdj = fwds[p, i_time, jFwd] - fwds[p, i_time-1, jFwd]
+                dfwdi = fwds[p, i_time, i_fwd] - fwds[p, i_time-1, i_fwd]
+                dfwdj = fwds[p, i_time, j_fwd] - fwds[p, i_time-1, j_fwd]
                 sumfwdi += dfwdi
                 sumfwdj += dfwdj
                 sumfwdifwdi += dfwdi * dfwdi
                 sumfwdifwdj += dfwdi * dfwdj
                 sumfwdjfwdj += dfwdj * dfwdj
 
             avgfwdi = sumfwdi / num_paths
@@ -224,54 +224,54 @@
 
             covii = avgfwdifwdi - avgfwdi * avgfwdi
             covjj = avgfwdjfwdj - avgfwdj * avgfwdj
             covij = avgfwdifwdj - avgfwdi * avgfwdj
             corr = covij / np.sqrt(covii*covjj)
 
             if abs(covii*covjj) > 1e-20:
-                fwdCorr[iFwd-i_time][jFwd-i_time] = corr
-                fwdCorr[jFwd-i_time][iFwd-i_time] = corr
+                fwd_corr[i_fwd-i_time][j_fwd-i_time] = corr
+                fwd_corr[j_fwd-i_time][i_fwd-i_time] = corr
             else:
-                fwdCorr[iFwd-i_time][jFwd-i_time] = 0.0
-                fwdCorr[jFwd-i_time][iFwd-i_time] = 0.0
+                fwd_corr[i_fwd-i_time][j_fwd-i_time] = 0.0
+                fwd_corr[j_fwd-i_time][i_fwd-i_time] = 0.0
 
-    return fwdCorr
+    return fwd_corr
 
 ###############################################################################
 
 
 @njit(float64[:](float64[:], float64[:], int64, float64, float64[:]),
       cache=True, fastmath=True)
-def lmm_price_caps_black(fwd0, volCaplet, p, K, taus):
+def lmm_price_caps_black(fwd0, vol_caplet, p, K, taus):
     """ Price a strip of capfloorlets using Black's model using the time grid
     of the LMM model. The prices can be compared with the LMM model prices. """
 
     caplet = np.zeros(p+1)
-    discFwd = np.zeros(p+1)
+    disc_fwd = np.zeros(p+1)
 
     if K <= 0.0:
         raise FinError("Negative strike not allowed.")
 
     # Set up initial term structure
-    discFwd[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    disc_fwd[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
     for i in range(1, p):
-        discFwd[i] = discFwd[i-1] / (1.0 + fwd0[i] * taus[i])
+        disc_fwd[i] = disc_fwd[i-1] / (1.0 + fwd0[i] * taus[i])
 
     # Price ATM caplets
     t_exp = 0.0
 
     for i in range(1, p):  # 1 to p-1
 
         K = fwd0[i]
         t_exp += taus[i]
-        vol = volCaplet[i]
+        vol = vol_caplet[i]
         F = fwd0[i]
         d1 = (np.log(F/K) + vol * vol * t_exp / 2.0) / vol / np.sqrt(t_exp)
         d2 = d1 - vol * np.sqrt(t_exp)
-        caplet[i] = (F * N(d1) - K * N(d2)) * taus[i] * discFwd[i]
+        caplet[i] = (F * N(d1) - K * N(d2)) * taus[i] * disc_fwd[i]
 
     return caplet
 
 ###############################################################################
 
 
 @njit(float64[:, :](float64[:, :], int64), cache=True, fastmath=True)
@@ -311,25 +311,25 @@
     WARNING: NEED TO CHECK THAT CORRECT VOLATILITY IS BEING USED (OFF BY ONE
     BUG NEEDS TO BE RULED OUT) """
 
     np.random.seed(seed)
 
     # Even number of paths for antithetics
     num_paths = 2 * int(num_paths/2)
-    halfNumPaths = int(num_paths/2)
+    half_num_paths = int(num_paths/2)
 
     fwd = np.empty((num_paths, num_fwds, num_fwds))
     fwdB = np.zeros(num_fwds)
 
-    discFwd = np.zeros(num_fwds)
+    disc_fwd = np.zeros(num_fwds)
 
     # Set up initial term structure
-    discFwd[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    disc_fwd[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
     for ix in range(1, num_fwds):
-        discFwd[ix] = discFwd[ix-1] / (1.0 + fwd0[ix] * taus[ix])
+        disc_fwd[ix] = disc_fwd[ix-1] / (1.0 + fwd0[ix] * taus[ix])
 
     corr = [None]  # from 0 to p-1
     factors = [None]  # from 0 to p-1
 
     for ix in range(1, num_fwds):  # from 1 to p-1
         matrix = sub_matrix(correl, ix - 1)
         corr.append(matrix)
@@ -338,31 +338,31 @@
 
     ###########################################################################
     # I HAVE PROBLEMS AS THE PARALLELISATION CHANGES THE OUTPUT IF RANDS ARE
     # CALCULATED INSIDE THE MAIN LOOP SO I CALCULATE THEM NOW
     ###########################################################################
 
     if 1 == 1:
-        gMatrix = np.empty((num_paths, num_fwds, num_fwds))
-        for i_path in range(0, halfNumPaths):
+        g_matrix = np.empty((num_paths, num_fwds, num_fwds))
+        for i_path in range(0, half_num_paths):
             for j in range(1, num_fwds):
                 for k in range(0, num_fwds-j):
                     g = np.random.normal()
                     # ANTITHETICS
-                    gMatrix[i_path, j, k] = g
-                    gMatrix[i_path + halfNumPaths, j, k] = -g
+                    g_matrix[i_path, j, k] = g
+                    g_matrix[i_path + half_num_paths, j, k] = -g
 
     avgg = 0.0
     stdg = 0.0
 
     for i_path in range(0, num_paths):
 
         # Initial value of forward curve at time 0
-        for iFwd in range(0, num_fwds):
-            fwd[i_path, 0, iFwd] = fwd0[iFwd]
+        for i_fwd in range(0, num_fwds):
+            fwd[i_path, 0, i_fwd] = fwd0[i_fwd]
 
         for j in range(1, num_fwds):  # TIME LOOP
 
             dt = taus[j]
             sqrt_dt = np.sqrt(dt)
 
             for i in range(j, num_fwds):  # FORWARDS LOOP
@@ -376,15 +376,15 @@
                     zk = zetas[k]
                     tk = taus[k]
                     muA += zi * fk * tk * zk * rho / (1.0 + fk * tk)
 
                 w = 0.0
                 for k in range(0, num_fwds-j):
                     f = factors[j][i-j, k]
-                    w = w + f * gMatrix[i_path, j, k]
+                    w = w + f * g_matrix[i_path, j, k]
 
                 avgg += w
                 stdg += w*w
 
                 fwdB[i] = fwd[i_path, j-1, i] \
                     * np.exp(muA * dt - 0.5 * (zi**2) * dt + zi * w * sqrt_dt)
 
@@ -403,15 +403,15 @@
     return fwd
 
 ###############################################################################
 
 
 @njit(float64[:, :, :](int64, int64, int64, float64[:], float64[:], float64[:],
                        int64, int64), cache=True, fastmath=True)
-def lmm_simulate_fwds_1f(num_fwds, num_paths, numeraireIndex, fwd0, gammas,
+def lmm_simulate_fwds_1f(num_fwds, num_paths, numeraire_index, fwd0, gammas,
                          taus, use_sobol, seed):
     """ One factor Arbitrage-free simulation of forward Ibor discount in the
     spot measure following Hull Page 768. Given an initial forward curve,
     volatility term structure. The 3D matrix of forward rates by path, time
     and forward point is returned. This function is kept mainly for its
     simplicity and speed.
 
@@ -428,57 +428,57 @@
     Hull examples, you need to simulate 41 (or in this case 11) forwards as the
     final cap or ratchet has its reset in 10 years. """
 
     if len(gammas) != num_fwds:
         raise FinError("Gamma vector does not have right number of forwards")
 
     if len(fwd0) != num_fwds:
-        raise FinError("The length of fwd0 is not equal to numForwards")
+        raise FinError("The length of fwd0 is not equal to num_fwds")
 
     if len(taus) != num_fwds:
-        raise FinError("The length of Taus is not equal to numForwards")
+        raise FinError("The length of Taus is not equal to num_fwds")
 
     np.random.seed(seed)
     # Even number of paths for antithetics
     num_paths = 2 * int(num_paths/2)
-    halfNumPaths = int(num_paths/2)
+    half_num_paths = int(num_paths/2)
     fwd = np.empty((num_paths, num_fwds, num_fwds))
     fwdB = np.zeros(num_fwds)
 
     num_times = num_fwds
 
     if use_sobol == 1:
-        numDimensions = num_times
-        rands = get_uniform_sobol(halfNumPaths, numDimensions)
-        gMatrix = np.empty((num_paths, num_times))
-        for i_path in range(0, halfNumPaths):
+        num_dimensions = num_times
+        rands = get_uniform_sobol(half_num_paths, num_dimensions)
+        g_matrix = np.empty((num_paths, num_times))
+        for i_path in range(0, half_num_paths):
             for j in range(0, num_times):
                 u = rands[i_path, j]
                 g = norminvcdf(u)
-                gMatrix[i_path, j] = g
-                gMatrix[i_path + halfNumPaths, j] = -g
+                g_matrix[i_path, j] = g
+                g_matrix[i_path + half_num_paths, j] = -g
     elif use_sobol == 0:
-        gMatrix = np.empty((num_paths, num_times))
-        for i_path in range(0, halfNumPaths):
+        g_matrix = np.empty((num_paths, num_times))
+        for i_path in range(0, half_num_paths):
             for j in range(0, num_times):
                 g = np.random.normal()
-                gMatrix[i_path, j] = g
-                gMatrix[i_path + halfNumPaths, j] = -g
+                g_matrix[i_path, j] = g
+                g_matrix[i_path + half_num_paths, j] = -g
     else:
         raise FinError("Use Sobol must be 0 or 1")
 
     for i_path in range(0, num_paths):  # changed from prange
         # Initial value of forward curve at time 0
-        for iFwd in range(0, num_fwds):
-            fwd[i_path, 0, iFwd] = fwd0[iFwd]
+        for i_fwd in range(0, num_fwds):
+            fwd[i_path, 0, i_fwd] = fwd0[i_fwd]
 
         for j in range(0, num_fwds-1):  # TIME LOOP
             dtj = taus[j]
             sqrt_dtj = np.sqrt(dtj)
-            w = gMatrix[i_path, j]
+            w = g_matrix[i_path, j]
 
             for k in range(j, num_fwds):  # FORWARDS LOOP
                 zkj = gammas[k-j]
                 muA = 0.0
 
                 for i in range(j+1, k+1):
                     fi = fwd[i_path, j, i]
@@ -505,271 +505,272 @@
     return fwd
 
 ###############################################################################
 
 
 @njit(float64[:, :, :](int64, int64, int64, int64, float64[:], float64[:, :],
                        float64[:], int64, int64), cache=True, fastmath=True)
-def lmm_simulate_fwds_mf(num_fwds, numFactors, num_paths, numeraireIndex,
+def lmm_simulate_fwds_mf(num_fwds, num_factors, num_paths, numeraire_index,
                          fwd0, lambdas, taus, use_sobol, seed):
     """ Multi-Factor Arbitrage-free simulation of forward Ibor discount in the
     spot measure following Hull Page 768. Given an initial forward curve,
     volatility factor term structure. The 3D matrix of forward rates by path,
     time and forward point is returned. """
 
     np.random.seed(seed)
 
-    if len(lambdas) != numFactors:
+    if len(lambdas) != num_factors:
         raise FinError("Lambda does not have the right number of factors")
 
     if len(lambdas[0]) != num_fwds:
         raise FinError("Lambda does not have the right number of forwards")
 
     # Even number of paths for antithetics
     num_paths = 2 * int(num_paths/2)
-    halfNumPaths = int(num_paths/2)
+    half_num_paths = int(num_paths/2)
     fwd = np.empty((num_paths, num_fwds, num_fwds))
     fwdB = np.zeros(num_fwds)
 
     num_times = num_fwds
 
     if use_sobol == 1:
-        numDimensions = num_times * numFactors
-        rands = get_uniform_sobol(halfNumPaths, numDimensions)
-        gMatrix = np.empty((num_paths, num_times, numFactors))
-        for i_path in range(0, halfNumPaths):
+        num_dimensions = num_times * num_factors
+        rands = get_uniform_sobol(half_num_paths, num_dimensions)
+        g_matrix = np.empty((num_paths, num_times, num_factors))
+        for i_path in range(0, half_num_paths):
             for j in range(0, num_times):
-                for q in range(0, numFactors):
-                    col = j*numFactors + q
+                for q in range(0, num_factors):
+                    col = j*num_factors + q
                     u = rands[i_path, col]
                     g = norminvcdf(u)
-                    gMatrix[i_path, j, q] = g
-                    gMatrix[i_path + halfNumPaths, j, q] = -g
+                    g_matrix[i_path, j, q] = g
+                    g_matrix[i_path + half_num_paths, j, q] = -g
     elif use_sobol == 0:
-        gMatrix = np.empty((num_paths, num_times, numFactors))
-        for i_path in range(0, halfNumPaths):
+        g_matrix = np.empty((num_paths, num_times, num_factors))
+        for i_path in range(0, half_num_paths):
             for j in range(0, num_times):
-                for q in range(0, numFactors):
+                for q in range(0, num_factors):
                     g = np.random.normal()
-                    gMatrix[i_path, j, q] = g
-                    gMatrix[i_path + halfNumPaths, j, q] = -g
+                    g_matrix[i_path, j, q] = g
+                    g_matrix[i_path + half_num_paths, j, q] = -g
     else:
         raise FinError("Use Sobol must be 0 or 1.")
 
     for i_path in range(0, num_paths):
         # Initial value of forward curve at time 0
-        for iFwd in range(0, num_fwds):
-            fwd[i_path, 0, iFwd] = fwd0[iFwd]
+        for i_fwd in range(0, num_fwds):
+            fwd[i_path, 0, i_fwd] = fwd0[i_fwd]
 
         for j in range(0, num_fwds-1):  # TIME LOOP
             dtj = taus[j]
             sqrt_dtj = np.sqrt(dtj)
 
             for k in range(j, num_fwds):  # FORWARDS LOOP
 
                 muA = 0.0
                 for i in range(j+1, k+1):
                     fi = fwd[i_path, j, i]
                     ti = taus[i]
                     zz = 0.0
-                    for q in range(0, numFactors):
+                    for q in range(0, num_factors):
                         zij = lambdas[q][i-j]
                         zkj = lambdas[q][k-j]
                         zz += zij * zkj
                     muA += fi * ti * zz / (1.0 + fi * ti)
 
                 itoTerm = 0.0
-                for q in range(0, numFactors):
+                for q in range(0, num_factors):
                     itoTerm += lambdas[q][k-j] * lambdas[q][k-j]
 
-                randomTerm = 0.0
-                for q in range(0, numFactors):
-                    wq = gMatrix[i_path, j, q]
-                    randomTerm += lambdas[q][k-j] * wq
-                randomTerm *= sqrt_dtj
+                random_term = 0.0
+                for q in range(0, num_factors):
+                    wq = g_matrix[i_path, j, q]
+                    random_term += lambdas[q][k-j] * wq
+                random_term *= sqrt_dtj
 
-                x = np.exp(muA * dtj - 0.5 * itoTerm * dtj + randomTerm)
+                x = np.exp(muA * dtj - 0.5 * itoTerm * dtj + random_term)
                 fwdB[k] = fwd[i_path, j, k] * x
 
                 muB = 0.0
                 for i in range(j+1, k+1):
                     fi = fwdB[k]
                     ti = taus[i]
                     zz = 0.0
-                    for q in range(0, numFactors):
+                    for q in range(0, num_factors):
                         zij = lambdas[q][i-j]
                         zkj = lambdas[q][k-j]
                         zz += zij * zkj
                     muB += fi * ti * zz / (1.0 + fi * ti)
 
                 muC = 0.5 * (muA + muB)
 
-                x = np.exp(muC * dtj - 0.5 * itoTerm * dtj + randomTerm)
+                x = np.exp(muC * dtj - 0.5 * itoTerm * dtj + random_term)
                 fwd[i_path, j+1, k] = fwd[i_path, j, k] * x
 
     return fwd
 
 ###############################################################################
 
 
 @njit(float64[:](int64, int64, float64, float64[:], float64[:, :, :],
                  float64[:], int64),
       cache=True, fastmath=True)
-def lmm_cap_flr_pricer(num_fwds, num_paths, K, fwd0, fwds, taus, isCap):
+def lmm_cap_flr_pricer(num_fwds, num_paths, K, fwd0, fwds, taus, is_cap):
     """ Function to price a strip of cap or floorlets in accordance with the
     simulated forward curve dynamics. """
 
     max_paths = len(fwds)
     max_fwds = len(fwds[0])
 
     if num_fwds > max_fwds:
-        raise FinError("NumForwards > maxForwards")
+        raise FinError("num_fwds > max_fwds")
 
     if num_paths > max_paths:
         raise FinError("NumPaths > MaxPaths")
 
-    discFactor = np.zeros(num_fwds)
+    df = np.zeros(num_fwds)
     capFlrLets = np.zeros(num_fwds-1)
     capFlrLetValues = np.zeros(num_fwds-1)
     numeraire = np.zeros(num_fwds)
 
     for i_path in range(0, num_paths):
 
-        periodRoll = 1.0
+        period_roll = 1.0
         libor = fwds[i_path, 0, 0]
         capFlrLets[0] = max(K - libor, 0.0) * taus[0]
 
         # Now loop over the caplets starting with one that fixes immediately
         # but which may have intrinsic value that cannot be ignored.
         for j in range(0, num_fwds):
 
             libor = fwds[i_path, j, j]
             if j == 1:
-                if isCap == 0:
+                if is_cap == 0:
                     capFlrLets[j] = max(K - libor, 0.0) * taus[j]
                 else:
                     capFlrLets[j] = max(libor - K, 0.0) * taus[j]
 
-                numeraire[0] = 1.0 / discFactor[0]
+                numeraire[0] = 1.0 / df[0]
             else:
-                if isCap == 1:
+                if is_cap == 1:
                     capFlrLets[j] = max(libor - K, 0.0) * taus[j]
-                elif isCap == 0:
+                elif is_cap == 0:
                     capFlrLets[j] = max(K - libor, 0.0) * taus[j]
                 else:
-                    raise FinError("isCap should be 0 or 1")
+                    raise FinError("is_cap should be 0 or 1")
 
-            periodRoll = (1.0 + libor * taus[j])
-            numeraire[j] = numeraire[j - 1] * periodRoll
+            period_roll = 1.0 + libor * taus[j]
+            numeraire[j] = numeraire[j - 1] * period_roll
 
-        for iFwd in range(0, num_fwds):
-            denom = abs(numeraire[iFwd]) + 1e-12
-            capFlrLetValues[iFwd] += capFlrLets[iFwd] / denom
+        for i_fwd in range(0, num_fwds):
+            denom = abs(numeraire[i_fwd]) + 1e-12
+            capFlrLetValues[i_fwd] += capFlrLets[i_fwd] / denom
 
-    for iFwd in range(0, num_fwds):
-        capFlrLetValues[iFwd] /= num_paths
+    for i_fwd in range(0, num_fwds):
+        capFlrLetValues[i_fwd] /= num_paths
 
     return capFlrLetValues
 
 ###############################################################################
 
 
 @njit(float64(float64, int64, int64, float64[:], float64[:, :, :],
               float64[:]), cache=True, fastmath=True)
 def lmm_swap_pricer(cpn, num_periods, num_paths, fwd0, fwds, taus):
     """ Function to reprice a basic swap using the simulated forward Ibors.
     """
 
-    maxPaths = len(fwds)
-    maxForwards = len(fwds[0])
+    max_paths = len(fwds)
+    max_fwds = len(fwds[0])
 
-    if num_periods > maxForwards:
-        raise FinError("NumPeriods > numForwards")
+    if num_periods > max_fwds:
+        raise FinError("NumPeriods > num_fwds")
 
-    if num_paths > maxPaths:
+    if num_paths > max_paths:
         raise FinError("NumPaths > MaxPaths")
 
-    discFactor = np.zeros(maxForwards)
-    numeraire = np.zeros(maxForwards)
-    sumFixed = 0.0
-    sumFloat = 0.0
-    fixedFlows = np.zeros(maxForwards)
-    floatFlows = np.zeros(maxForwards)
+    df = np.zeros(max_fwds)
+    numeraire = np.zeros(max_fwds)
+    sum_fixed = 0.0
+    sun_float = 0.0
+    fixed_flows = np.zeros(max_fwds)
+    float_flows = np.zeros(max_fwds)
 
     # Set up initial term structure
-    discFactor[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
-    for ix in range(1, maxForwards):
-        discFactor[ix] = discFactor[ix-1] / (1.0 + fwd0[ix] * taus[ix])
+    df[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    for ix in range(1, max_fwds):
+        df[ix] = df[ix-1] / (1.0 + fwd0[ix] * taus[ix])
 
     for i_path in range(0, num_paths):
 
-        periodRoll = 1.0
+        period_roll = 1.0
         libor = fwds[i_path, 0, 0]
-        floatFlows[0] = libor * taus[0]
-        fixedFlows[0] = cpn * taus[0]
-        numeraire[0] = 1.0 / discFactor[0]
+        float_flows[0] = libor * taus[0]
+        fixed_flows[0] = cpn * taus[0]
+        numeraire[0] = 1.0 / df[0]
 
         for j in range(1, num_periods):  # TIME LOOP
 
             libor = fwds[i_path, j, j]
 
             if j == 1:
-                fixedFlows[j] = cpn * taus[j]
-                floatFlows[j] = libor * taus[j]
+                fixed_flows[j] = cpn * taus[j]
+                float_flows[j] = libor * taus[j]
             else:
-                fixedFlows[j] = fixedFlows[j-1] * periodRoll + cpn * taus[j]
-                floatFlows[j] = floatFlows[j-1] * periodRoll + libor * taus[j]
-
-            periodRoll = (1.0 + libor * taus[j])
-            numeraire[j] = numeraire[j - 1] * periodRoll
+                fixed_flows[j] = fixed_flows[j-1] * period_roll + cpn * taus[j]
+                float_flows[j] = float_flows[j-1] * \
+                    period_roll + libor * taus[j]
+
+            period_roll = 1.0 + libor * taus[j]
+            numeraire[j] = numeraire[j - 1] * period_roll
+
+        for i_fwd in range(0, num_periods):
+            sun_float += float_flows[i_fwd] / numeraire[i_fwd]
+            sum_fixed += fixed_flows[i_fwd] / numeraire[i_fwd]
+
+    sun_float /= num_paths
+    sum_fixed /= num_paths
+    v = sum_fixed - sun_float
+    pv01 = sum_fixed/cpn
+    swap_rate = sun_float/pv01
 
-        for iFwd in range(0, num_periods):
-            sumFloat += floatFlows[iFwd] / numeraire[iFwd]
-            sumFixed += fixedFlows[iFwd] / numeraire[iFwd]
-
-    sumFloat /= num_paths
-    sumFixed /= num_paths
-    v = sumFixed - sumFloat
-    pv01 = sumFixed/cpn
-    swap_rate = sumFloat/pv01
-
-    print("FLOAT LEG:", sumFloat)
-    print("FIXED LEG:", sumFixed)
+    print("FLOAT LEG:", sun_float)
+    print("FIXED LEG:", sum_fixed)
     print("SWAP RATE:", swap_rate)
     print("NET VALUE:", v)
     return v
 
 ###############################################################################
 
 
 @njit(float64(float64, int64, int64, int64, float64[:], float64[:, :, :],
               float64[:], int64), cache=True, fastmath=True)
-def lmm_swaption_pricer(strike, a, b, num_paths, fwd0, fwds, taus, isPayer):
+def lmm_swaption_pricer(strike, a, b, num_paths, fwd0, fwds, taus, is_payer):
     """ Function to price a European swaption using the simulated forward
     discount. """
 
-    maxPaths = len(fwds)
-    maxForwards = len(fwds[0])
+    max_paths = len(fwds)
+    max_fwds = len(fwds[0])
 
-    if a > maxForwards:
-        raise FinError("NumPeriods > numForwards")
+    if a > max_fwds:
+        raise FinError("NumPeriods > num_fwds")
 
     if a >= b:
         raise FinError("Swap maturity is before expiry date")
 
-    if num_paths > maxPaths:
+    if num_paths > max_paths:
         raise FinError("NumPaths > MaxPaths")
 
-    discFactor = np.zeros(maxForwards)
-#    pv01 = np.zeros(maxForwards)
+    df = np.zeros(max_fwds)
+#    pv01 = np.zeros(max_fwds)
 
     # Set up initial term structure
-    discFactor[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    df[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
     for ix in range(1, b):
-        discFactor[ix] = discFactor[ix-1] / (1.0 + fwd0[ix] * taus[ix])
+        df[ix] = df[ix-1] / (1.0 + fwd0[ix] * taus[ix])
 
     sumPayRecSwaption = 0.0
 
     for i_path in range(0, num_paths):
 
         numeraire = 1.0
         for k in range(0, a):
@@ -781,20 +782,20 @@
         # Value the swap as if we were at time a with forward curve known
         for k in range(a, b):
             f = fwds[i_path, a, k]
             tau = taus[k]
             df = df / (1.0 + tau * f)
             pv01 = pv01 + tau * df
 
-        fwdSwapRate = (1.0 - df) / pv01
+        fwd_swap_rate = (1.0 - df) / pv01
 
-        if isPayer == 1:
-            payRecSwaption = max(fwdSwapRate - strike, 0.0) * pv01
-        elif isPayer == 0:
-            payRecSwaption = max(strike - fwdSwapRate, 0.0) * pv01
+        if is_payer == 1:
+            payRecSwaption = max(fwd_swap_rate - strike, 0.0) * pv01
+        elif is_payer == 0:
+            payRecSwaption = max(strike - fwd_swap_rate, 0.0) * pv01
         else:
             raise FinError("Unknown payRecSwaption value - must be 0 or 1")
 
         sumPayRecSwaption += payRecSwaption / (abs(numeraire) + 1e-10)
 
     payRecPrice = sumPayRecSwaption / num_paths
     return payRecPrice
@@ -803,178 +804,180 @@
 
 
 @njit(float64[:](float64, int64, int64, float64[:], float64[:, :, :],
                  float64[:]), cache=True, fastmath=True)
 def lmm_ratchet_caplet_pricer(spd, num_periods, num_paths, fwd0, fwds, taus):
     """ Price a ratchet using the simulated Ibor rates."""
 
-    maxPaths = len(fwds)
-    maxForwards = len(fwds[0][0])
+    max_paths = len(fwds)
+    max_fwds = len(fwds[0][0])
 
-    if num_periods > maxForwards:
-        raise FinError("NumPeriods > numForwards")
+    if num_periods > max_fwds:
+        raise FinError("NumPeriods > num_fwds")
 
-    if num_paths > maxPaths:
+    if num_paths > max_paths:
         raise FinError("NumPaths > MaxPaths")
 
-    discFactor = np.zeros(maxForwards)
-    numeraire = np.zeros(maxForwards)
-    ratchetCaplets = np.zeros(maxForwards)
-    ratchetCapletValues = np.zeros(maxForwards)
+    df = np.zeros(max_fwds)
+    numeraire = np.zeros(max_fwds)
+    rachet_caplets = np.zeros(max_fwds)
+    rachet_caplet_values = np.zeros(max_fwds)
 
     # Set up initial term structure
-    discFactor[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
-    for ix in range(1, maxForwards):
-        discFactor[ix] = discFactor[ix-1] / (1.0 + fwd0[ix] * taus[ix])
+    df[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    for ix in range(1, max_fwds):
+        df[ix] = df[ix-1] / (1.0 + fwd0[ix] * taus[ix])
 
     for i_path in range(0, num_paths):
 
-        periodRoll = 1.0
+        period_roll = 1.0
         libor = fwds[i_path, 0, 0]
-        ratchetCaplets[0] = 0.0
+        rachet_caplets[0] = 0.0
 
         for j in range(1, num_periods):  # TIME LOOP
 
             prevIbor = libor
             K = prevIbor + spd
             libor = fwds[i_path, j, j]
 
             if j == 1:
-                ratchetCaplets[j] = max(libor - K, 0.0) * taus[j]
-                numeraire[0] = 1.0 / discFactor[0]
+                rachet_caplets[j] = max(libor - K, 0.0) * taus[j]
+                numeraire[0] = 1.0 / df[0]
             else:
-                ratchetCaplets[j] = max(libor - K, 0.0) * taus[j]
+                rachet_caplets[j] = max(libor - K, 0.0) * taus[j]
 
-            periodRoll = (1.0 + libor * taus[j])
-            numeraire[j] = numeraire[j - 1] * periodRoll
+            period_roll = 1.0 + libor * taus[j]
+            numeraire[j] = numeraire[j - 1] * period_roll
 
-        for iFwd in range(0, num_periods):
-            ratchetCapletValues[iFwd] += ratchetCaplets[iFwd] / numeraire[iFwd]
+        for i_fwd in range(0, num_periods):
+            rachet_caplet_values[i_fwd] += rachet_caplets[i_fwd] / \
+                numeraire[i_fwd]
 
-    for iFwd in range(0, num_periods):
-        ratchetCapletValues[iFwd] /= num_paths
+    for i_fwd in range(0, num_periods):
+        rachet_caplet_values[i_fwd] /= num_paths
 
-    return ratchetCapletValues
+    return rachet_caplet_values
 
 ###############################################################################
 
 
 @njit(float64(int64, float64, int64, int64, float64[:], float64[:, :, :],
               float64[:]), cache=True, fastmath=True)
 def lmm_flexi_cap_pricer(maxCaplets, K, num_periods, num_paths,
                          fwd0, fwds, taus):
     """ Price a flexicap using the simulated Ibor rates."""
 
-    maxPaths = len(fwds)
-    maxForwards = len(fwds[0][0])
+    max_paths = len(fwds)
+    max_fwds = len(fwds[0][0])
 
-    if num_periods > maxForwards:
-        raise FinError("NumPeriods > numForwards")
+    if num_periods > max_fwds:
+        raise FinError("NumPeriods > num_fwds")
 
-    if num_paths > maxPaths:
+    if num_paths > max_paths:
         raise FinError("NumPaths > MaxPaths")
 
-    discFactor = np.zeros(maxForwards)
-    numeraire = np.zeros(maxForwards)
-    flexiCaplets = np.zeros(maxForwards)
-    flexiCapletValues = np.zeros(maxForwards)
+    df = np.zeros(max_fwds)
+    numeraire = np.zeros(max_fwds)
+    flexi_caplets = np.zeros(max_fwds)
+    flexi_caplet_values = np.zeros(max_fwds)
 
     # Set up initial term structure
-    discFactor[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
-    for ix in range(1, maxForwards):
-        discFactor[ix] = discFactor[ix-1] / (1.0 + fwd0[ix] * taus[ix])
+    df[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    for ix in range(1, max_fwds):
+        df[ix] = df[ix-1] / (1.0 + fwd0[ix] * taus[ix])
 
     for i_path in range(0, num_paths):
 
-        periodRoll = 1.0
+        period_roll = 1.0
         libor = fwds[i_path, 0, 0]
-        flexiCaplets[0] = 0.0
+        flexi_caplets[0] = 0.0
 
-        numCapletsLeft = maxCaplets
+        num_caplets_left = maxCaplets
 
         for j in range(1, num_periods):  # TIME LOOP
 
             libor = fwds[i_path, j, j]
 
             if j == 1:
-                if libor > K and numCapletsLeft > 0:
-                    flexiCaplets[j] = max(libor - K, 0.0) * taus[j]
-                    numCapletsLeft -= 1
-                numeraire[0] = 1.0 / discFactor[0]
+                if libor > K and num_caplets_left > 0:
+                    flexi_caplets[j] = max(libor - K, 0.0) * taus[j]
+                    num_caplets_left -= 1
+                numeraire[0] = 1.0 / df[0]
             else:
-                if libor > K and numCapletsLeft > 0:
-                    flexiCaplets[j] = max(libor - K, 0.0) * taus[j]
-                    numCapletsLeft -= 1
+                if libor > K and num_caplets_left > 0:
+                    flexi_caplets[j] = max(libor - K, 0.0) * taus[j]
+                    num_caplets_left -= 1
 
-            periodRoll = (1.0 + libor * taus[j])
-            numeraire[j] = numeraire[j - 1] * periodRoll
+            period_roll = 1.0 + libor * taus[j]
+            numeraire[j] = numeraire[j - 1] * period_roll
 
-        for iFwd in range(0, num_periods):
-            flexiCapletValues[iFwd] += flexiCaplets[iFwd] / numeraire[iFwd]
+        for i_fwd in range(0, num_periods):
+            flexi_caplet_values[i_fwd] += flexi_caplets[i_fwd] / numeraire[i_fwd]
 
-    for iFwd in range(0, num_periods):
-        flexiCapletValues[iFwd] /= num_paths
+    for i_fwd in range(0, num_periods):
+        flexi_caplet_values[i_fwd] /= num_paths
 
-    flexiCapValue = 0.0
-    for iFwd in range(0, num_periods):
-        flexiCapValue += flexiCapletValues[iFwd]
+    flexi_cap_value = 0.0
+    for i_fwd in range(0, num_periods):
+        flexi_cap_value += flexi_caplet_values[i_fwd]
 
-    return flexiCapValue
+    return flexi_cap_value
 
 ###############################################################################
 
 
 @njit(float64[:](float64, int64, int64, float64[:], float64[:, :, :],
                  float64[:]), cache=True, fastmath=True)
 def lmm_sticky_caplet_pricer(spread, num_periods, num_paths, fwd0, fwds, taus):
     """ Price a sticky cap using the simulated Ibor rates. """
 
-    maxPaths = len(fwds)
-    maxForwards = len(fwds[0][0])
+    max_paths = len(fwds)
+    max_fwds = len(fwds[0][0])
 
-    if num_periods > maxForwards:
-        raise FinError("NumPeriods > numForwards")
+    if num_periods > max_fwds:
+        raise FinError("NumPeriods > num_fwds")
 
-    if num_paths > maxPaths:
+    if num_paths > max_paths:
         raise FinError("NumPaths > MaxPaths")
 
-    discFactor = np.zeros(maxForwards)
-    numeraire = np.zeros(maxForwards)
-    stickyCaplets = np.zeros(maxForwards)
-    stickyCapletValues = np.zeros(maxForwards)
+    df = np.zeros(max_fwds)
+    numeraire = np.zeros(max_fwds)
+    stickyCaplets = np.zeros(max_fwds)
+    stickyCapletValues = np.zeros(max_fwds)
 
     # Set up initial term structure
-    discFactor[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
-    for ix in range(1, maxForwards):
-        discFactor[ix] = discFactor[ix-1] / (1.0 + fwd0[ix] * taus[ix])
+    df[0] = 1.0 / (1.0 + fwd0[0] * taus[0])
+    for ix in range(1, max_fwds):
+        df[ix] = df[ix-1] / (1.0 + fwd0[ix] * taus[ix])
 
     for i_path in range(0, num_paths):
 
-        periodRoll = 1.0
+        period_roll = 1.0
         libor = fwds[i_path, 0, 0]
         stickyCaplets[0] = 0.0
         K = libor
 
         for j in range(1, num_periods):  # TIME LOOP
 
             prevIbor = libor
             K = min(prevIbor, K) + spread
             libor = fwds[i_path, j, j]
 
             if j == 1:
                 stickyCaplets[j] = max(libor-K, 0.0) * taus[j]
-                numeraire[0] = 1.0 / discFactor[0]
+                numeraire[0] = 1.0 / df[0]
             else:
                 stickyCaplets[j] = max(libor - K, 0.0) * taus[j]
 
-            periodRoll = (1.0 + libor * taus[j])
-            numeraire[j] = numeraire[j - 1] * periodRoll
+            period_roll = (1.0 + libor * taus[j])
+            numeraire[j] = numeraire[j - 1] * period_roll
 
-        for iFwd in range(0, num_periods):
-            stickyCapletValues[iFwd] += stickyCaplets[iFwd] / numeraire[iFwd]
+        for i_fwd in range(0, num_periods):
+            stickyCapletValues[i_fwd] += stickyCaplets[i_fwd] / \
+                numeraire[i_fwd]
 
-    for iFwd in range(0, num_periods):
-        stickyCapletValues[iFwd] /= num_paths
+    for i_fwd in range(0, num_periods):
+        stickyCapletValues[i_fwd] /= num_paths
 
     return stickyCapletValues
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/loss_dbn_builder.py` & `financepy-0.360/financepy/models/loss_dbn_builder.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,17 +7,17 @@
 
 from ..utils.math import pair_gcd
 
 ###############################################################################
 
 
 @njit(float64[:](int64, float64[:], float64[:]), fastmath=True, cache=True)
-def indep_loss_dbn_heterogeneous_adj_binomial(num_credits,
-                                              cond_probs,
-                                              loss_ratio):
+def indep_loss_dbn_hetero_adj_binomial(num_credits,
+                                       cond_probs,
+                                       loss_ratio):
 
     # Algorithm due to D. O'Kane.
 
     num_losses = num_credits + 1
     indep_dbn = np.zeros(num_losses)
 
     p = 0.0
@@ -95,16 +95,16 @@
 
     temp = (int)(actual_losses[0] * scaling)
 
     for i_credit in range(1, num_credits):
         num2 = int(actual_losses[i_credit] * scaling)
         temp = pair_gcd(temp, num2)
 
-    portfolioGCD = float(temp / scaling)
-    return portfolioGCD
+    portfolio_gcd = float(temp / scaling)
+    return portfolio_gcd
 
 ###############################################################################
 
 
 @njit(float64[:](int64, float64[:], float64[:]), fastmath=True, cache=True)
 def indep_loss_dbn_recursion_gcd(num_credits,
                                  cond_default_probs,
```

### Comparing `financepy-0.350/financepy/models/merton_firm.py` & `financepy-0.360/financepy/models/merton_firm.py`

 * *Files 12% similar despite different names*

```diff
@@ -17,31 +17,31 @@
 class MertonFirm():
     """ Implementation of the Merton Firm Value Model according to the original
     formulation by Merton with the inputs being the asset value of the firm,
     the liabilities (bond face), the time to maturity in years, the risk-free
     rate, the asset growth rate and the asset value volatility. """
 
     def __init__(self,
-                 assetValue: (float, list, np.ndarray),
-                 bondFace: (float, list, np.ndarray),
-                 timeToMaturity: (float, list, np.ndarray),
+                 asset_value: (float, list, np.ndarray),
+                 bond_face: (float, list, np.ndarray),
+                 years_to_maturity: (float, list, np.ndarray),
                  risk_free_rate: (float, list, np.ndarray),
-                 assetGrowthRate: (float, list, np.ndarray),
-                 assetVolatility: (float, list, np.ndarray)):
+                 asset_growth_rate: (float, list, np.ndarray),
+                 asset_volatility: (float, list, np.ndarray)):
         """ Create an object that holds all of the model parameters. These
         parameters may be vectorised. """
 
         check_argument_types(self.__init__, locals())
 
-        self._A = np.array(assetValue)
-        self._L = np.array(bondFace)
-        self._t = np.array(timeToMaturity)
+        self._A = np.array(asset_value)
+        self._L = np.array(bond_face)
+        self._t = np.array(years_to_maturity)
         self._r = np.array(risk_free_rate)
-        self._mu = np.array(assetGrowthRate)
-        self._vA = np.array(assetVolatility)
+        self._mu = np.array(asset_growth_rate)
+        self._vA = np.array(asset_volatility)
         self._D = self.debt_value()
         self._E = self.equity_value()
         self._vE = self.equity_vol()
 
 ###############################################################################
 
     def leverage(self):
@@ -68,44 +68,44 @@
 
     def equity_vol(self):
         """ Calculate the equity volatility. """
 
         E = self.equity_value()
 
         lvg = self._A / self._L
-        sigmaRootT = self._vA * np.sqrt(self._t)
+        sigma_root_t = self._vA * np.sqrt(self._t)
 
         d1 = np.log(lvg) + (self._r + 0.5 * self._vA ** 2) * self._t
-        d1 = d1 / sigmaRootT
+        d1 = d1 / sigma_root_t
         evol = (self._A / E) * N(d1) * self._vA
         return evol
 
 ###############################################################################
 
     def equity_value(self):
         """ Calculate the equity value. """
 
         lvg = self._A / self._L
-        sigmaRootT = self._vA * np.sqrt(self._t)
+        sigma_root_t = self._vA * np.sqrt(self._t)
         d1 = np.log(lvg) + (self._r + 0.5 * self._vA ** 2) * self._t
-        d1 = d1 / sigmaRootT
-        d2 = d1 - sigmaRootT
+        d1 = d1 / sigma_root_t
+        d2 = d1 - sigma_root_t
         evalue = self._A * N(d1) - self._L * np.exp(-self._r * self._t) * N(d2)
         return evalue
 
 ###############################################################################
 
     def debt_value(self):
         """ Calculate the debt value """
 
         lvg = self._A / self._L
-        sigmaRootT = self._vA * np.sqrt(self._t)
+        sigma_root_t = self._vA * np.sqrt(self._t)
         d1 = np.log(lvg) + (self._r + 0.5 * self._vA ** 2) * self._t
-        d1 = d1 / sigmaRootT
-        d2 = d1 - sigmaRootT
+        d1 = d1 / sigma_root_t
+        d2 = d1 - sigma_root_t
         dvalue = self._A * N(-d1) + self._L * \
             np.exp(-self._r * self._t) * N(d2)
         return dvalue
 
 ###############################################################################
 
     def credit_spread(self):
```

### Comparing `financepy-0.350/financepy/models/merton_firm_mkt.py` & `financepy-0.360/financepy/models/merton_firm_mkt.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,15 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
-
-from ..utils.math import N
-
 from scipy import optimize
 
+from ..utils.math import N
 from ..utils.helpers import label_to_string, check_argument_types
 from ..utils.error import FinError
 from .merton_firm import MertonFirm
 
 ###############################################################################
 
 
@@ -38,56 +36,58 @@
 
     return obj
 
 ###############################################################################
 
 
 class MertonFirmMkt(MertonFirm):
-    """ Market Extension of the Merton Firm Model according to the original
+    """
+    Market Extension of the Merton Firm Model according to the original
     formulation by Merton with the inputs being the equity value of the firm,
     the liabilities (bond face), the time to maturity in years, the risk-free
     rate, the asset growth rate and the equity volatility. The asset value and
     asset volatility are computed internally by solving two non-linear
-    simultaneous equations. """
+    simultaneous equations.
+    """
 
     def __init__(self,
                  equity_value: (float, list, np.ndarray),
-                 bondFace: (float, list, np.ndarray),
-                 timeToMaturity: (float, list, np.ndarray),
+                 bond_face: (float, list, np.ndarray),
+                 years_to_maturity: (float, list, np.ndarray),
                  risk_free_rate: (float, list, np.ndarray),
-                 assetGrowthRate: (float, list, np.ndarray),
+                 asset_growth_rate: (float, list, np.ndarray),
                  equity_volatility: (float, list, np.ndarray)):
         """ Create an object that holds all of the model parameters. These
         parameters may be vectorised. """
 
         check_argument_types(self.__init__, locals())
 
         if isinstance(equity_value, float):
             equity_value = [equity_value]
 
-        if isinstance(bondFace, float):
-            bondFace = [bondFace]
+        if isinstance(bond_face, float):
+            bond_face = [bond_face]
 
-        if isinstance(timeToMaturity, float):
-            timeToMaturity = [timeToMaturity]
+        if isinstance(years_to_maturity, float):
+            years_to_maturity = [years_to_maturity]
 
         if isinstance(risk_free_rate, float):
             risk_free_rate = [risk_free_rate]
 
-        if isinstance(assetGrowthRate, float):
-            assetGrowthRate = [assetGrowthRate]
+        if isinstance(asset_growth_rate, float):
+            asset_growth_rate = [asset_growth_rate]
 
         if isinstance(equity_volatility, float):
             equity_volatility = [equity_volatility]
 
         self._E = np.array(equity_value)
-        self._L = np.array(bondFace)
-        self._t = np.array(timeToMaturity)
+        self._L = np.array(bond_face)
+        self._t = np.array(years_to_maturity)
         self._r = np.array(risk_free_rate)
-        self._mu = np.array(assetGrowthRate)
+        self._mu = np.array(asset_growth_rate)
         self._vE = np.array(equity_volatility)
 
         nmax = max(len(self._E),
                    len(self._L),
                    len(self._t),
                    len(self._r),
                    len(self._mu),
```

### Comparing `financepy-0.350/financepy/models/option_implied_dbn.py` & `financepy-0.360/financepy/models/option_implied_dbn.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/models/process_simulator.py` & `financepy-0.360/financepy/models/process_simulator.py`

 * *Files 3% similar despite different names*

```diff
@@ -31,58 +31,60 @@
         pass
 
     def get_process(
             self,
             process_type,
             t,
             model_params,
-            numAnnSteps,
+            num_annual_steps,
             num_paths,
             seed):
 
         if process_type == ProcessTypes.GBM:
             (stock_price, drift, volatility, scheme) = model_params
-            paths = get_gbm_paths(num_paths, numAnnSteps, t, drift,
+            paths = get_gbm_paths(num_paths, num_annual_steps, t, drift,
                                   stock_price, volatility, scheme.value, seed)
             return paths
 
         elif process_type == ProcessTypes.HESTON:
+
             (stock_price, drift, v0, kappa, theta,
              sigma, rho, scheme) = model_params
             paths = get_heston_paths(num_paths,
-                                     numAnnSteps,
+                                     num_annual_steps,
                                      t,
                                      drift,
                                      stock_price,
                                      v0,
                                      kappa,
                                      theta,
                                      sigma,
                                      rho,
                                      scheme.value,
                                      seed)
             return paths
 
         elif process_type == ProcessTypes.VASICEK:
+
             (r0, kappa, theta, sigma, scheme) = model_params
             paths = get_vasicek_paths(
                 num_paths,
-                numAnnSteps,
+                num_annual_steps,
                 t,
                 r0,
                 kappa,
                 theta,
                 sigma,
                 scheme.value,
                 seed)
             return paths
 
         elif process_type == ProcessTypes.CIR:
             (r0, kappa, theta, sigma, scheme) = model_params
-            paths = get_cir_paths(num_paths, numAnnSteps, t,
+            paths = get_cir_paths(num_paths, num_annual_steps, t,
                                   r0, kappa, theta, sigma, scheme.value, seed)
             return paths
 
         else:
             raise FinError("Unknown process" + str(process_type))
 
 ###############################################################################
@@ -96,67 +98,67 @@
 ###############################################################################
 
 
 @njit(float64[:, :](int64, int64, float64, float64, float64, float64, float64,
                     float64, float64, float64, int64, int64),
       cache=True, fastmath=True)
 def get_heston_paths(num_paths,
-                     numAnnSteps,
+                     num_annual_steps,
                      t,
                      drift,
                      s0,
                      v0,
                      kappa,
                      theta,
                      sigma,
                      rho,
                      scheme,
                      seed):
 
     np.random.seed(seed)
-    dt = 1.0 / numAnnSteps
+    dt = 1.0 / num_annual_steps
     num_steps = int(t / dt)
-    sPaths = np.empty(shape=(num_paths, num_steps + 1))
-    sPaths[:, 0] = s0
+    s_paths = np.empty(shape=(num_paths, num_steps + 1))
+    s_paths[:, 0] = s0
     sdt = sqrt(dt)
     rhohat = sqrt(1.0 - rho * rho)
     sigma2 = sigma * sigma
 
     if scheme == FinHestonNumericalScheme.EULER.value:
         # Basic scheme to first order with truncation on variance
         for i_path in range(0, num_paths):
             s = s0
             v = v0
             for i_step in range(1, num_steps + 1):
                 z1 = np.random.normal(0.0, 1.0) * sdt
                 z2 = np.random.normal(0.0, 1.0) * sdt
                 zV = z1
                 zS = rho * z1 + rhohat * z2
-                vplus = max(v, 0.0)
-                rtvplus = sqrt(vplus)
-                v += kappa * (theta - vplus) * dt + sigma * \
-                    rtvplus * zV + 0.25 * sigma2 * (zV * zV - dt)
-                s += drift * s * dt + rtvplus * s * \
-                    zS + 0.5 * s * vplus * (zV * zV - dt)
-                sPaths[i_path, i_step] = s
+                v_plus = max(v, 0.0)
+                rtv_plus = sqrt(v_plus)
+                v += kappa * (theta - v_plus) * dt + sigma * \
+                    rtv_plus * zV + 0.25 * sigma2 * (zV * zV - dt)
+                s += drift * s * dt + rtv_plus * s * \
+                    zS + 0.5 * s * v_plus * (zV * zV - dt)
+                s_paths[i_path, i_step] = s
 
     elif scheme == FinHestonNumericalScheme.EULERLOG.value:
         # Basic scheme to first order with truncation on variance
         for i_path in range(0, num_paths):
             x = log(s0)
             v = v0
             for i_step in range(1, num_steps + 1):
                 zV = np.random.normal(0.0, 1.0) * sdt
                 zS = rho * zV + rhohat * np.random.normal(0.0, 1.0) * sdt
-                vplus = max(v, 0.0)
-                rtvplus = sqrt(vplus)
-                x += (drift - 0.5 * vplus) * dt + rtvplus * zS
-                v += kappa * (theta - vplus) * dt + sigma * \
-                    rtvplus * zV + sigma2 * (zV * zV - dt) / 4.0
-                sPaths[i_path, i_step] = exp(x)
+                v_plus = max(v, 0.0)
+                rtv_plus = sqrt(v_plus)
+                x += (drift - 0.5 * v_plus) * dt + rtv_plus * zS
+                v += kappa * (theta - v_plus) * dt + sigma * \
+                    rtv_plus * zV + sigma2 * (zV * zV - dt) / 4.0
+                s_paths[i_path, i_step] = exp(x)
 
     elif scheme == FinHestonNumericalScheme.QUADEXP.value:
         # Due to Leif Andersen(2006)
         Q = exp(-kappa * dt)
         psic = 1.50
         gamma1 = 0.50
         gamma2 = 0.50
@@ -202,37 +204,37 @@
                         vnp = log((1.0 - p) / (1.0 - u)) / beta
 
                     M = p + beta * (1.0 - p) / (beta - A)
                     K0 = -log(M) - (K1 + 0.5 * K3) * vn
 
                 x += mu * dt + K0 + (K1 * vn + K2 * vnp) + \
                     sqrt(K3 * vn + K4 * vnp) * zS
-                sPaths[i_path, i_step] = exp(x)
+                s_paths[i_path, i_step] = exp(x)
                 vn = vnp
     else:
         raise FinError("Unknown FinHestonNumericalSchme")
 
-    return sPaths
+    return s_paths
 
 ###############################################################################
 
 
 class FinGBMNumericalScheme(Enum):
     NORMAL = 1
     ANTITHETIC = 2
 
 ###############################################################################
 
 
 @njit(float64[:, :](int64, int64, float64, float64, float64,
                     float64, int64, int64), cache=True, fastmath=True)
-def get_gbm_paths(num_paths, numAnnSteps, t, mu, stock_price, sigma, scheme, seed):
+def get_gbm_paths(num_paths, num_annual_steps, t, mu, stock_price, sigma, scheme, seed):
 
     np.random.seed(seed)
-    dt = 1.0 / numAnnSteps
+    dt = 1.0 / num_annual_steps
     num_time_steps = int(t / dt + 0.50)
     vsqrt_dt = sigma * sqrt(dt)
     m = exp((mu - sigma * sigma / 2.0) * dt)
 
     if scheme == FinGBMNumericalScheme.NORMAL.value:
 
         s_all = np.empty((num_paths, num_time_steps + 1))
@@ -248,23 +250,24 @@
         s_all = np.empty((2 * num_paths, num_time_steps + 1))
         s_all[:, 0] = stock_price
         for it in range(1, num_time_steps + 1):
             g1D = np.random.standard_normal((num_paths))
             for ip in range(0, num_paths):
                 w = np.exp(g1D[ip] * vsqrt_dt)
                 s_all[ip, it] = s_all[ip, it - 1] * m * w
-                s_all[ip + num_paths, it] = s_all[ip + num_paths, it - 1] * m / w
+                s_all[ip + num_paths, it] = s_all[ip +
+                                                  num_paths, it - 1] * m / w
 
     else:
 
         raise FinError("Unknown FinGBMNumericalScheme")
 
 #    m = np.mean(s_all[:, -1])
 #    v = np.var(s_all[:, -1]/s_all[:, 0])
-#    print("GBM", num_paths, numAnnSteps, t, mu, stock_price, sigma, scheme, m,v)
+#    print("GBM", num_paths, num_annual_steps, t, mu, stock_price, sigma, scheme, m,v)
 
     return s_all
 
 ###############################################################################
 
 
 class FinVasicekNumericalScheme(Enum):
@@ -273,49 +276,49 @@
 
 ###############################################################################
 
 
 @njit(float64[:, :](int64, int64, float64, float64, float64,
                     float64, float64, int64, int64), cache=True, fastmath=True)
 def get_vasicek_paths(num_paths,
-                      numAnnSteps,
+                      num_annual_steps,
                       t,
                       r0,
                       kappa,
                       theta,
                       sigma,
                       scheme,
                       seed):
 
     np.random.seed(seed)
-    dt = 1.0 / numAnnSteps
+    dt = 1.0 / num_annual_steps
     num_steps = int(t / dt)
-    sigmasqrt_dt = sigma * sqrt(dt)
+    sigma_sqrt_dt = sigma * sqrt(dt)
 
     if scheme == FinVasicekNumericalScheme.NORMAL.value:
         rate_path = np.empty((num_paths, num_steps + 1))
         rate_path[:, 0] = r0
         for i_path in range(0, num_paths):
             r = r0
             z = np.random.normal(0.0, 1.0, size=(num_steps))
             for i_step in range(1, num_steps + 1):
-                r += kappa * (theta - r) * dt + z[i_step - 1] * sigmasqrt_dt
+                r += kappa * (theta - r) * dt + z[i_step - 1] * sigma_sqrt_dt
                 rate_path[i_path, i_step] = r
     elif scheme == FinVasicekNumericalScheme.ANTITHETIC.value:
         rate_path = np.empty((2 * num_paths, num_steps + 1))
         rate_path[:, 0] = r0
         for i_path in range(0, num_paths):
             r1 = r0
             r2 = r0
             z = np.random.normal(0.0, 1.0, size=(num_steps))
             for i_step in range(1, num_steps + 1):
                 r1 = r1 + kappa * (theta - r1) * dt + \
-                    z[i_step - 1] * sigmasqrt_dt
+                    z[i_step - 1] * sigma_sqrt_dt
                 r2 = r2 + kappa * (theta - r2) * dt - \
-                    z[i_step - 1] * sigmasqrt_dt
+                    z[i_step - 1] * sigma_sqrt_dt
                 rate_path[i_path, i_step] = r1
                 rate_path[i_path + num_paths, i_step] = r2
     return rate_path
 
 ###############################################################################
 
 
@@ -328,39 +331,39 @@
 
 ###############################################################################
 
 
 @njit(float64[:, :](int64, int64, float64, float64, float64,
                     float64, float64, int64, int64), cache=True, fastmath=True)
 def get_cir_paths(num_paths,
-                  numAnnSteps,
+                  num_annual_steps,
                   t,
                   r0,
                   kappa,
                   theta,
                   sigma,
                   scheme,
                   seed):
 
     np.random.seed(seed)
-    dt = 1.0 / numAnnSteps
+    dt = 1.0 / num_annual_steps
     num_steps = int(t / dt)
     rate_path = np.empty(shape=(num_paths, num_steps + 1))
     rate_path[:, 0] = r0
 
     if scheme == CIRNumericalScheme.EULER.value:
-        sigmasqrt_dt = sigma * sqrt(dt)
+        sigma_sqrt_dt = sigma * sqrt(dt)
         for i_path in range(0, num_paths):
             r = r0
             z = np.random.normal(0.0, 1.0, size=(num_steps))
             for i_step in range(1, num_steps + 1):
                 rplus = max(r, 0.0)
-                sqrtrplus = sqrt(rplus)
+                sqrt_rplus = sqrt(rplus)
                 r = r + kappa * (theta - rplus) * dt + \
-                    sigmasqrt_dt * z[i_step - 1] * sqrtrplus
+                    sigma_sqrt_dt * z[i_step - 1] * sqrt_rplus
                 rate_path[i_path, i_step] = r
 
     elif scheme == CIRNumericalScheme.LOGNORMAL.value:
         x = exp(-kappa * dt)
         y = 1.0 - x
         for i_path in range(0, num_paths):
             r = r0
@@ -369,37 +372,37 @@
                 mean = x * r + theta * y
                 var = sigma * sigma * y * (x * r + 0.50 * theta * y) / kappa
                 sig = sqrt(log(1.0 + var / (mean * mean)))
                 r = mean * exp(-0.5 * sig * sig + sig * z[i_step - 1])
                 rate_path[i_path, i_step] = r
 
     elif scheme == CIRNumericalScheme.MILSTEIN.value:
-        sigmasqrt_dt = sigma * sqrt(dt)
+        sigma_sqrt_dt = sigma * sqrt(dt)
         sigma2dt = sigma * sigma * dt / 4.0
         for i_path in range(0, num_paths):
             r = r0
             z = np.random.normal(0.0, 1.0, size=(num_steps))
             for i_step in range(1, num_steps + 1):
-                sqrtrplus = sqrt(max(r, 0.0))
+                sqrt_rplus = sqrt(max(r, 0.0))
                 r = r + kappa * (theta - r) * dt + \
-                    z[i_step - 1] * sigmasqrt_dt * sqrtrplus
+                    z[i_step - 1] * sigma_sqrt_dt * sqrt_rplus
                 r = r + sigma2dt * (z[i_step - 1]**2 - 1.0)
                 rate_path[i_path, i_step] = r
 
     elif scheme == CIRNumericalScheme.KAHLJACKEL.value:
         bhat = theta - sigma * sigma / 4.0 / kappa
         sqrt_dt = sqrt(dt)
         for i_path in range(0, num_paths):
             r = r0
             z = np.random.normal(0.0, 1.0, size=(num_steps))
             for i_step in range(1, num_steps + 1):
                 beta = z[i_step - 1] / sqrt_dt
-                sqrtrplus = sqrt(max(r, 0.0))
+                sqrt_rplus = sqrt(max(r, 0.0))
                 c = 1.0 + (sigma * beta - 2.0 * kappa *
-                           sqrtrplus) * dt / 4.0 / sqrtrplus
+                           sqrt_rplus) * dt / 4.0 / sqrt_rplus
                 r = r + (kappa * (bhat - r) + sigma *
-                         beta * sqrtrplus) * c * dt
+                         beta * sqrt_rplus) * c * dt
                 rate_path[i_path, i_step] = r
 
     return rate_path
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/rates_ho_lee.py` & `financepy-0.360/financepy/models/rates_ho_lee.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/models/sabr.py` & `financepy-0.360/financepy/models/sabr.py`

 * *Files 10% similar despite different names*

```diff
@@ -30,34 +30,33 @@
     """ Black volatility implied by SABR model. """
 
     alpha = params[0]
     beta = params[1]
     rho = params[2]
     nu = params[3]
 
-    if alpha < 1e-10:
-        alpha = 1e-10
+    alpha = max(1e-10, alpha)
 
     # Negative strikes or forwards
     if k <= 0:
         raise FinError("Strike must be positive")
 
     if f <= 0:
         raise FinError("Forward must be positive")
 
-    logfk = np.log(f / k)
+    ln_f_over_k = np.log(f / k)
     b = 1.0 - beta
     fkb = (f*k)**b
     a = b**2 * alpha**2 / (24.0 * fkb)
     b = 0.25 * rho * beta * nu * alpha / fkb**0.5
     c = (2.0 - 3.0*rho**2.0) * nu**2.0 / 24
     d = fkb**0.5
-    v = b**2 * logfk**2 / 24.0
-    w = b**4 * logfk**4 / 1920.0
-    z = nu * fkb**0.5 * logfk / alpha
+    v = b**2 * ln_f_over_k**2 / 24.0
+    w = b**4 * ln_f_over_k**4 / 1920.0
+    z = nu * fkb**0.5 * ln_f_over_k / alpha
 
     eps = 1e-07
 
     if abs(z) > eps:
         vz = alpha * z * (1.0 + (a + b + c) * t) / \
             (d * (1.0 + v + w) * _x(rho, z))
         return vz
@@ -86,30 +85,30 @@
         rho = -0.99
 
     m = f / k
 
     if abs(m - 1.0) > 1e-6:
 
         sigma = 1.0
-        numTerm1 = 0.0
-        numTerm2 = rho * nu * alpha / 4.0
-        numTerm3 = nu * nu * ((2.0 - 3.0 * (rho**2.0)) / 24.0)
-        num = alpha * (1.0 + (numTerm1 + numTerm2 + numTerm3) * t)
-        logM = np.log(m)
-        z = nu / alpha * logM
+        num_term1 = 0.0
+        num_term2 = rho * nu * alpha / 4.0
+        num_term3 = nu * nu * ((2.0 - 3.0 * (rho**2.0)) / 24.0)
+        num = alpha * (1.0 + (num_term1 + num_term2 + num_term3) * t)
+        log_m = np.log(m)
+        z = nu / alpha * log_m
         denom = 1.0
         x = np.log((np.sqrt(1.0 - 2.0*rho*z + z**2.0) + z - rho)/(1.0 - rho))
         sigma = num*z/(denom*x)
 
-    else:
-        # when the option is at the money
-        numTerm1 = 0.0
-        numTerm2 = rho * nu * alpha / 4.0
-        numTerm3 = nu * nu * ((2.0 - 3.0 * (rho**2.0)) / 24.0)
-        num = alpha * (1.0 + (numTerm1 + numTerm2 + numTerm3) * t)
+    else: # when the option is at the money
+
+        num_term1 = 0.0
+        num_term2 = rho * nu * alpha / 4.0
+        num_term3 = nu * nu * ((2.0 - 3.0 * (rho**2.0)) / 24.0)
+        num = alpha * (1.0 + (num_term1 + num_term2 + num_term3) * t)
         denom = 1.0
         sigma = num / denom
 
     return sigma
 
 ###############################################################################
 
@@ -118,19 +117,17 @@
       fastmath=True, cache=True)
 def vol_function_sabr_beta_half(params, f, k, t):
     """ Black volatility implied by SABR model. """
 
     alpha = params[0]
     rho = params[1]
     nu = params[2]
-
     beta = 0.50
 
-    if alpha < 1e-10:
-        alpha = 1e-10
+    alpha = max(1e-10, alpha)
 
     # Negative strikes or forwards
     if k <= 0:
         raise FinError("Strike must be positive")
 
     if f <= 0:
         raise FinError("Forward must be positive")
@@ -167,25 +164,25 @@
     underlying and the volatility process. """
 
     def __init__(self, alpha, beta, rho, nu):
         """ Create SABR with all of the model parameters. We will
         also provide functions below to assist with the calibration of the
         value of alpha. """
 
-        self._alpha = alpha
-        self._beta = beta
-        self._rho = rho
-        self._nu = nu
+        self.alpha = alpha
+        self.beta = beta
+        self.rho = rho
+        self.nu = nu
 
 ###############################################################################
 
     def black_vol(self, f, k, t):
         """ Black volatility from SABR model using Hagan et al. approx. """
 
-        params = np.array([self._alpha, self._beta, self._rho, self._nu])
+        params = np.array([self.alpha, self.beta, self.rho, self.nu])
 
         # I wish to enable vectorisations
         if isinstance(f, np.ndarray):
             vols = []
             for x in f:
                 v = vol_function_sabr(params, x, k, t)
                 vols.append(v)
@@ -200,25 +197,25 @@
 
         elif isinstance(t, np.ndarray):
             vols = []
             for x in t:
                 v = vol_function_sabr(params, f, k, x)
                 vols.append(v)
             return np.array(vols)
-        else:
-            v = vol_function_sabr(params, f, k, t)
-            return v
+        
+        v = vol_function_sabr(params, f, k, t)
+        return v
 
 ###############################################################################
 
     def black_vol_with_alpha(self, alpha, f, k, t):
 
-        self._alpha = alpha[0]
-        blackVol = self.black_vol(f, k, t)
-        return blackVol
+        self.alpha = alpha[0]
+        black_vol = self.black_vol(f, k, t)
+        return black_vol
 
 ###############################################################################
 
     def value(self,
               forward_rate,   # Forward rate
               strike_rate,    # Strike Rate
               time_to_expiry,  # time to expiry in years
@@ -226,94 +223,91 @@
               call_or_put):    # Call or put
         """ Price an option using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        sqrtT = np.sqrt(t)
+        sqrt_t = np.sqrt(t)
         vol = self.black_vol(f, k, t)
 
         d1 = np.log(f/k) + vol * vol * t / 2
-        d1 = d1 / (vol * sqrtT)
-        d2 = d1 - vol * sqrtT
+        d1 = d1 / (vol * sqrt_t)
+        d2 = d1 - vol * sqrt_t
 
         if call_or_put == OptionTypes.EUROPEAN_CALL:
             return df * (f * N(d1) - k * N(d2))
         elif call_or_put == OptionTypes.EUROPEAN_PUT:
             return df * (k * N(-d2) - f * N(-d1))
         else:
             raise Exception("Option type must be a European Call(C) or Put(P)")
 
 ###############################################################################
 
     def set_alpha_from_black_vol(self,
-                                 blackVol,
+                                 black_vol,
                                  forward,
                                  strike,
                                  time_to_expiry):
         """ Estimate the value of the alpha coefficient of the SABR model
         by solving for the value of alpha that makes the SABR black vol equal
         to the input black vol. This uses a numerical 1D solver. """
-
         t_exp = time_to_expiry
         f = forward
-        K = strike
+        k = strike
 
         # The starting point is based on assuming that the strike is ATM
-        self.set_alpha_from_atm_black_vol(blackVol, strike, time_to_expiry)
+        self.set_alpha_from_atm_black_vol(black_vol, strike, time_to_expiry)
 
-        initAlpha = self._alpha
+        init_alpha = self.alpha
 
-        if initAlpha != blackVol:
+        if init_alpha != black_vol:
             # Objective function
             def fn(x): return np.sqrt(
-                (blackVol - self.black_vol_with_alpha(x, f, K, t_exp)) ** 2)
+                (black_vol - self.black_vol_with_alpha(x, f, k, t_exp)) ** 2)
             bnds = ((0.0, None),)
-            x0 = initAlpha
+            x0 = init_alpha
             results = minimize(fn, x0, method="L-BFGS-B",
                                bounds=bnds, tol=1e-8)
             alpha = results.x[0]
         else:
-            alpha = initAlpha
+            alpha = init_alpha
 
-        self._alpha = alpha
+        self.alpha = alpha
 
 ###############################################################################
 
-    def set_alpha_from_atm_black_vol(self, blackVol, atmStrike, time_to_expiry):
+    def set_alpha_from_atm_black_vol(self, black_vol, atm_strike, time_to_expiry):
         """ We solve cubic equation for the unknown variable alpha for the
         special ATM case of the strike equalling the forward following Hagan
         and al. equation (3.3). We take the smallest real root as the preferred
         solution. This is useful for calibrating the model when beta has been
         chosen."""
-
-        beta = self._beta
-        rho = self._rho
-        nu = self._nu
+        beta = self.beta
+        rho = self.rho
+        nu = self.nu
         t_exp = time_to_expiry
-        K = atmStrike
+        K = atm_strike
 
-        coeff0 = -blackVol * (K**(1.0 - self._beta))
+        coeff0 = -black_vol * (K**(1.0 - self.beta))
         coeff1 = 1.0 + ((2.0 - 3.0 * rho**2) / 24.0) * (nu**2) * t_exp
         coeff2 = (rho * beta * nu * t_exp) / (4.0 * (K**(1.0 - beta)))
         coeff3 = (((1.0 - beta)**2) * t_exp) / (24.0 * (K**(2.0 - 2.0 * beta)))
         coeffs = [coeff3, coeff2, coeff1, coeff0]
         roots = np.roots(coeffs)
 
         # Selecting the smallest positive real root
         alpha = np.min([coeff.real for coeff in roots if coeff.real > 0])
-        self._alpha = alpha
+        self.alpha = alpha
 
 ###############################################################################
 
     def __repr__(self):
         """ Return string with class details. """
-
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("Alpha", self._alpha)
-        s += label_to_string("Beta", self._beta)
-        s += label_to_string("Nu", self._nu)
-        s += label_to_string("Rho", self._rho)
+        s = label_to_string("OBJECT TYPE", type(self)._name__)
+        s += label_to_string("Alpha", self.alpha)
+        s += label_to_string("Beta", self.beta)
+        s += label_to_string("Nu", self.nu)
+        s += label_to_string("Rho", self.rho)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/sabr_shifted.py` & `financepy-0.360/financepy/models/sabr_shifted.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,40 +12,38 @@
 from ..utils.helpers import label_to_string
 
 ###############################################################################
 # TODO: Should I merge this with SABR ?
 ###############################################################################
 
 ###############################################################################
-###############################################################################
-
 
 @njit
 def _x(rho, z):
     """Return function x used in Hagan's 2002 SABR lognormal vol expansion."""
     a = (1.0 - 2.0*rho*z + z**2)**.5 + z - rho
     b = 1.0 - rho
     return np.log(a / b)
 
+###############################################################################
 
 @njit
 def vol_function_shifted_sabr(params, f, k, t):
     """ Black volatility implied by SABR model. """
 
     alpha = params[0]
     beta = params[1]
     rho = params[2]
     nu = params[3]
     shift = params[4]
 
     f = f + shift
     k = k + shift
 
-    if alpha < 1e-10:
-        alpha = 1e-10
+    alpha = max(alpha, 1e-10)
 
     # Negative strikes or forwards
     if k <= 0:
         raise FinError("Strike must be positive")
 
     if f <= 0:
         raise FinError("Forward must be positive")
@@ -63,17 +61,17 @@
 
     eps = 1e-07
 
     if abs(z) > eps:
         vz = alpha * z * (1.0 + (a + b + c) * t) / \
             (d * (1.0 + v + w) * _x(rho, z))
         return vz
-    else:
-        v0 = alpha * (1.0 + (a + b + c) * t) / (d * (1.0 + v + w))
-        return v0
+
+    v0 = alpha * (1.0 + (a + b + c) * t) / (d * (1.0 + v + w))
+    return v0
 
 ###############################################################################
 
 
 class SABRShifted():
     """ SABR - Shifted Stochastic alpha beta rho model by Hagan et al. is a
     stochastic volatility model where alpha controls the implied volatility,
@@ -109,15 +107,14 @@
             return np.array(vols)
         elif isinstance(k, np.ndarray):
             vols = []
             for x in k:
                 v = vol_function_shifted_sabr(params, f, x, t)
                 vols.append(v)
             return np.array(vols)
-
         elif isinstance(t, np.ndarray):
             vols = []
             for x in t:
                 v = vol_function_shifted_sabr(params, f, k, x)
                 vols.append(v)
             return np.array(vols)
         else:
@@ -125,16 +122,16 @@
             return v
 
 ###############################################################################
 
     def black_vol_with_alpha(self, alpha, f, k, t):
 
         self._alpha = alpha[0]
-        blackVol = self.black_vol(f, k, t)
-        return blackVol
+        black_vol = self.black_vol(f, k, t)
+        return black_vol
 
 ###############################################################################
 
     def value(self,
               forward_rate,   # Forward rate F
               strike_rate,    # Strike Rate K
               time_to_expiry,  # Time to Expiry (years)
@@ -142,80 +139,80 @@
               call_or_put):    # Call or put
         """ Price an option using Black's model which values in the forward
         measure following a change of measure. """
 
         f = forward_rate
         t = time_to_expiry
         k = strike_rate
-        sqrtT = np.sqrt(t)
+        sqrt_t = np.sqrt(t)
         vol = self.black_vol(f, k, t)
 
-        d1 = (np.log((f)/(k)) + vol * vol * t / 2) / (vol * sqrtT)
-        d2 = d1 - vol*sqrtT
+        d1 = (np.log((f)/(k)) + vol * vol * t / 2) / (vol * sqrt_t)
+        d2 = d1 - vol*sqrt_t
 
         if call_or_put == OptionTypes.EUROPEAN_CALL:
             return df * (f * N(d1) - k * N(d2))
         elif call_or_put == OptionTypes.EUROPEAN_PUT:
             return df * (k * N(-d2) - f * N(-d1))
         else:
             raise Exception("Option type must be a European Call(C) or Put(P)")
 
 ###############################################################################
 
-    def set_alpha_from_black_vol(self, blackVol,
+    def set_alpha_from_black_vol(self, black_vol,
                                  forward,
                                  strike,
                                  time_to_expiry):
         """ Estimate the value of the alpha coefficient of the SABR model
         by solving for the value of alpha that makes the SABR black vol equal
         to the input black vol. This uses a numerical 1D solver. """
 
         t_exp = time_to_expiry
         f = forward
         K = strike
 
         # The starting point is based on assuming that the strike is ATM
-        self.set_alpha_from_atm_black_vol(blackVol, strike, time_to_expiry)
+        self.set_alpha_from_atm_black_vol(black_vol, strike, time_to_expiry)
 
-        initAlpha = self._alpha
+        init_alpha = self._alpha
 
-        if initAlpha != blackVol:
+        if init_alpha != black_vol:
             # Objective function
             def fn(x): return np.sqrt(
-                (blackVol - self.black_vol_with_alpha(x, f, K, t_exp)) ** 2)
+                (black_vol - self.black_vol_with_alpha(x, f, K, t_exp)) ** 2)
             bnds = ((0.0, None),)
-            x0 = initAlpha
+            x0 = init_alpha
             results = minimize(fn, x0, method="L-BFGS-B",
                                bounds=bnds, tol=1e-8)
             alpha = results.x[0]
         else:
-            alpha = initAlpha
+            alpha = init_alpha
 
         self._alpha = alpha
 
 ###############################################################################
 
-    def set_alpha_from_atm_black_vol(self, blackVol, atmStrike,
+    def set_alpha_from_atm_black_vol(self, black_vol, atm_strike,
                                      time_to_expiry):
         """ We solve cubic equation for the unknown variable alpha for the
         special ATM case of the strike equalling the forward following Hagan
         and al. equation (3.3). We take the smallest real root as the preferred
         solution. This is useful for calibrating the model when beta has been
         chosen."""
 
         # For shifted SABR
-        atmStrike = atmStrike + self._shift
+        atm_strike = atm_strike + self._shift
 
         beta = self._beta
         rho = self._rho
         nu = self._nu
         t_exp = time_to_expiry
-        K = atmStrike
+        K = atm_strike
 
-        coeff0 = -blackVol * (K**(1.0 - self._beta))
+        coeff0 = -black_vol * (K**(1.0 - self._beta))
         coeff1 = 1.0 + ((2.0 - 3.0 * rho**2) / 24.0) * (nu**2) * t_exp
         coeff2 = (rho * beta * nu * t_exp) / (4.0 * (K**(1.0 - beta)))
         coeff3 = (((1.0 - beta)**2) * t_exp) / (24.0 * (K**(2.0 - 2.0 * beta)))
         coeffs = [coeff3, coeff2, coeff1, coeff0]
         roots = np.roots(coeffs)
 
         # Selecting the smallest positive real root
```

### Comparing `financepy-0.350/financepy/models/sobol.py` & `financepy-0.360/financepy/models/sobol.py`

 * *Files 2% similar despite different names*

```diff
@@ -30,27 +30,27 @@
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 """
 
 import os
 import numpy as np
 from numba import njit
 
-from financepy.utils.math import norminvcdf
+from ..utils.math import norminvcdf
 
 ###############################################################################
 # This code loads sobol coefficients from binary numpy file and allocates
 # contents to static global variables.
 ###############################################################################
 
 dirname = os.path.abspath(os.path.dirname(__file__))
 path = os.path.join(dirname, "sobolcoeff.npz")
 
 with np.load(path, mmap_mode='r') as f:
-    sArr = np.array(f['sa'][0])
-    aArr = np.array(f['sa'][1])
+    s_arr = np.array(f['sa'][0])
+    a_arr = np.array(f['sa'][1])
     m_i = f['c']
 
 ###############################################################################
 
 
 @njit(cache=True)
 def get_gaussian_sobol(num_points, dimension):
@@ -71,16 +71,16 @@
     """ Sobol uniform quasi random points generator based on graycode order.
     This function returns a 2D Numpy array of values where the number of rows
     is the number of draws and the number of columns is the number of
     dimensions of the random values. Each dimension has the same number of
     random draws. Each column of random numbers is ordered so as not to
     correlate, i.e be independent from any other column."""
 
-    global sArr
-    global aArr
+    global s_arr
+    global a_arr
     global m_i
 
     # ll = number of bits needed
     ll = int(np.ceil(np.log(num_points+1)/np.log(2.0)))
 
     # c[i] = index from the right of the first zero bit of i
     c = np.zeros(num_points, dtype=np.int64)
@@ -107,16 +107,16 @@
     for i in range(1, num_points+1):
         x[i] = int(x[i-1]) ^ int(v[c[i-1]])
         points[i-1, 0] = x[i]/(2**32)
 
     # ----- Compute the remaining dimensions -----
     for j in range(1, dimension):
         # read parameters from file
-        s = sArr[j-1]
-        a = aArr[j-1]
+        s = s_arr[j-1]
+        a = a_arr[j-1]
         mm = m_i[j-1]
         m = np.concatenate((np.zeros(1), mm))
 
         # Compute direction numbers V[1] to V[L], scaled by 2**32
         v = np.zeros(ll+1)
         if ll <= s:
             for i in range(1, ll+1):
```

### Comparing `financepy-0.350/financepy/models/sobolcoeff.npz` & `financepy-0.360/financepy/models/sobolcoeff.npz`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/models/student_t_copula.py` & `financepy-0.360/financepy/models/student_t_copula.py`

 * *Files 10% similar despite different names*

```diff
@@ -11,38 +11,38 @@
 ###############################################################################
 
 
 class StudentTCopula():
 
     def default_times(self,
                       issuer_curves,
-                      correlation_matrix,
-                      degreesOfFreedom,
+                      corr_matrix,
+                      degrees_of_freedom,
                       num_trials,
                       seed):
 
         np.random.seed(seed)
         num_credits = len(issuer_curves)
         x = np.random.normal(0.0, 1.0, size=(num_credits, num_trials))
-        c = np.linalg.cholesky(correlation_matrix)
+        c = np.linalg.cholesky(corr_matrix)
         y = np.dot(c, x)
 
         corr_times = np.empty(shape=(num_credits, 2 * num_trials))
 
         for i_trial in range(0, num_trials):
-            chi2 = np.random.chisquare(degreesOfFreedom)
-            c = sqrt(chi2 / degreesOfFreedom)
-            for iCredit in range(0, num_credits):
-                issuer_curve = issuer_curves[iCredit]
-                g = y[iCredit, i_trial] / c
-                u1 = student.cdf(g, degreesOfFreedom)
+            chi2 = np.random.chisquare(degrees_of_freedom)
+            c = sqrt(chi2 / degrees_of_freedom)
+            for i_credit in range(0, num_credits):
+                issuer_curve = issuer_curves[i_credit]
+                g = y[i_credit, i_trial] / c
+                u1 = student.cdf(g, degrees_of_freedom)
                 u2 = 1.0 - u1
-                times = issuer_curve._times
-                values = issuer_curve._values
+                times = issuer_curve.times()
+                values = issuer_curve.values()
                 t1 = uniform_to_default_time(u1, times, values)
                 t2 = uniform_to_default_time(u2, times, values)
-                corr_times[iCredit, i_trial] = t1
-                corr_times[iCredit, i_trial + num_trials] = t2
+                corr_times[i_credit, i_trial] = t1
+                corr_times[i_credit, i_trial + num_trials] = t2
 
         return corr_times
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/models/vasicek_mc.py` & `financepy-0.360/financepy/models/vasicek_mc.py`

 * *Files 22% similar despite different names*

```diff
@@ -50,25 +50,27 @@
     return vr
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def zero_price(r0, a, b, sigma, t):
-    B = (1.0 - exp(-a * t)) / a
-    A = exp((b - sigma * sigma / 2.0 / a / a) *
-            (B - t) - B * B * sigma * sigma / 4.0 / a)
-    zcb = A * exp(-r0 * B)
+    ''' Generate zero price analytically using Vasicek model '''
+    bb = (1.0 - exp(-a * t)) / a
+    aa = exp((b - sigma * sigma / 2.0 / a / a) *
+            (bb - t) - bb * bb * sigma * sigma / 4.0 / a)
+    zcb = aa * exp(-r0 * bb)
     return zcb
 
 ###############################################################################
 
 
 @njit(float64[:](float64, float64, float64, float64, float64, float64, int64))
 def rate_path_mc(r0, a, b, sigma, t, dt, seed):
+    ''' Generate a path of short rates using Vasicek model '''
 
     np.random.seed(seed)
     num_steps = int(t / dt)
     rate_path = np.zeros(num_steps)
     rate_path[0] = r0
     num_paths = 1
 
@@ -87,15 +89,15 @@
 
 ###############################################################################
 
 
 @njit(float64(float64, float64, float64, float64, float64,
               float64, int64, int64), fastmath=True, cache=True)
 def zero_price_mc(r0, a, b, sigma, t, dt, num_paths, seed):
-
+    ''' Generate zero price by Monte Carlo using Vasicek model '''
     np.random.seed(seed)
     num_steps = int(t / dt)
     sigmasqrt_dt = sigma * sqrt(dt)
     zcb = 0.0
     for _ in range(0, num_paths):
         z = np.random.normal(0.0, 1.0, size=num_steps)
         rsum = 0.0
```

### Comparing `financepy-0.350/financepy/models/volatility_fns.py` & `financepy-0.360/financepy/models/volatility_fns.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/products/bonds/bond.py` & `financepy-0.360/financepy/products/bonds/bond.py`

 * *Files 10% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 
 import numpy as np
 from scipy import optimize
 
 from ...utils.date import Date
 from ...utils.error import FinError
 from ...utils.frequency import annual_frequency, FrequencyTypes
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.day_count import DayCount, DayCountTypes
 from ...utils.schedule import Schedule
 from ...utils.calendar import Calendar
 from ...utils.calendar import CalendarTypes
 from ...utils.calendar import BusDayAdjustTypes
 from ...utils.calendar import DateGenRuleTypes
 from ...utils.helpers import label_to_string, check_argument_types
@@ -47,18 +47,18 @@
 ###############################################################################
 
 
 from enum import Enum
 
 
 class YTMCalcType(Enum):
-    ZERO = 0,
-    UK_DMO = 1,
-    US_STREET = 2,
-    US_TREASURY = 3,
+    ZERO = 0
+    UK_DMO = 1
+    US_STREET = 2
+    US_TREASURY = 3
     CFETS = 4  # China Foreign Exchange Trade System
 
 
 ###############################################################################
 
 
 def _f(ytm, *args):
@@ -88,145 +88,149 @@
 
 ###############################################################################
 
 
 class Bond:
     """ Class for fixed coupon bonds and performing related analytics. These
     are bullet bonds which means they have regular coupon payments of a known
-    size that are paid on known dates plus a payment of par at maturity. """
+    size that are paid on known dts plus a payment of par at maturity. """
 
     def __init__(self,
                  issue_dt: Date,
                  maturity_dt: Date,
                  coupon: float,  # Annualised bond coupon
                  freq_type: FrequencyTypes,
                  dc_type: DayCountTypes,
                  ex_div_days: int = 0,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type=BusDayAdjustTypes.FOLLOWING,
                  dg_type=DateGenRuleTypes.BACKWARD):
         """ Create Bond object by providing the issue date, maturity Date,
         coupon frequency, annualised coupon, the accrual convention type, face
         amount and the number of ex-dividend days. A calendar type is used
-        to determine holidays from which coupon dates might be shifted."""
+        to determine holidays from which coupon dts might be shifted."""
 
         check_argument_types(self.__init__, locals())
 
         if issue_dt >= maturity_dt:
             raise FinError("Issue Date must preceded maturity date.")
 
         # If the maturity date falls on the last day of the month we assume
         # that earlier flows also fall on month ends
-        self._end_of_month = False
+        self.end_of_month = False
         if maturity_dt.is_eom():
-            self._end_of_month = True
+            self.end_of_month = True
 
-        self._issue_dt = issue_dt
-        self._maturity_dt = maturity_dt
+        self.issue_dt = issue_dt
+        self.maturity_dt = maturity_dt
 
         if coupon == 0.0:
             raise FinError("Zero coupon bonds must use BondZero class.")
 
         if freq_type == FrequencyTypes.ZERO:
             raise FinError("Zero coupon bonds must use BondZero class.")
 
         if dc_type == dc_type.ZERO:
             raise FinError("Zero coupon bonds must use BondZero class.")
 
-        self._cpn = coupon
-        self._freq_type = freq_type
+        self.cpn = coupon
+        self.freq_type = freq_type
 
-        self._dc_type = dc_type
-        self._freq = annual_frequency(freq_type)
+        self.dc_type = dc_type
+        self.freq = annual_frequency(freq_type)
 
         if ex_div_days > 90:
             raise FinError("Ex dividend days cannot be more than 90"
                            + str(ex_div_days))
 
-        self._ex_div_dt = None
-        self._ex_div_days = ex_div_days
+        self.ex_div_dt = None
+        self.ex_div_days = ex_div_days
 
-        self._par = 100.0  # This is how price is quoted and amount at maturity
-        self._cal_type = cal_type
+        self.par = 100.0  # This is how price is quoted and amount at maturity
+        self.cal_type = cal_type
 
-        self._cpn_dts = []  # can be holidays or weekend
-        self._payment_dts = []  # Actual pay dates are adjusted to bus days
-        self._flow_amounts = []
-
-        self._accrued_interest = None
-        self._accrued_days = 0.0
-        self._alpha = 0.0
+        self.cpn_dts = []  # can be holidays or weekend
+        self.payment_dts = []  # Actual pay dts are adjusted to bus days
+        self.flow_amounts = []
 
-        self._bd_type = bd_type
-        self._dg_type = dg_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
 
         self._calculate_cpn_dts()
         self._calculate_flows()
 
+        self.pcd = None
+        self.ncd = None
+
+        # Private
+        self.accrued_int = None
+        self.accrued_days = 0.0
+        self.alpha = 0.0
+
     ###########################################################################
 
     def _calculate_cpn_dts(self):
-        """ Determine the bond coupon dates. Note that for analytical
+        """ Determine the bond coupon dts. Note that for analytical
         calculations these are not usually adjusted and so may fall on a
         weekend or holiday.
         """
 
         # This should only be called once from init
         # bd_type = BusDayAdjustTypes.FOLLOWING
         # dg_type = DateGenRuleTypes.BACKWARD
 
-        self._cpn_dts = Schedule(self._issue_dt,
-                                 self._maturity_dt,
-                                 self._freq_type,
-                                 CalendarTypes.NONE,
-                                 self._bd_type,
-                                 self._dg_type,
-                                 end_of_month=self._end_of_month).generate()
+        self.cpn_dts = Schedule(self.issue_dt,
+                                self.maturity_dt,
+                                self.freq_type,
+                                CalendarTypes.NONE,
+                                self.bd_type,
+                                self.dg_type,
+                                end_of_month=self.end_of_month).generate()
 
     ###########################################################################
 
     def _calculate_payment_dts(self):
-        """ For the actual payment dates, they are adjusted,
-        and so we then use the calendar payment dates. Although payments are
+        """ For the actual payment dts, they are adjusted,
+        and so we then use the calendar payment dts. Although payments are
         calculated as though coupon periods are the same length, payments that
         fall on a Saturday or Sunday can only be made on the next business day
         """
 
-        # dates are adjusted forward to the next business day
+        # dts are adjusted forward to the next business day
         bus_day_adj_type = BusDayAdjustTypes.FOLLOWING
-        calendar = Calendar(self._cal_type)
+        calendar = Calendar(self.cal_type)
 
         self._calculate_cpn_dts()
 
-        self._payment_dts = []
+        self.payment_dts = []
 
         # Expect at least an issue date and a maturity date - if not - problem
-        if len(self._cpn_dts) < 2:
-            raise FinError("Cannot calculate payment dates with one payment")
+        if len(self.cpn_dts) < 2:
+            raise FinError("Cannot calculate payment dts with one payment")
 
         # I do not adjust the first date as it is the issue date
-        self._payment_dts.append(self._cpn_dts[0])
+        self.payment_dts.append(self.cpn_dts[0])
 
-        for cpn_dt in self._cpn_dts[1:]:
+        for cpn_dt in self.cpn_dts[1:]:
             pmt_dt = calendar.adjust(cpn_dt,
                                      bus_day_adj_type)
 
-            self._payment_dts.append(pmt_dt)
+            self.payment_dts.append(pmt_dt)
 
     ###########################################################################
 
     def _calculate_flows(self):
         """ Determine the bond cash flow payment amounts without principal.
-        There is no adjustment based on the adjusted payment dates. """
+        There is no adjustment based on the adjusted payment dts. """
 
-        self._flow_amounts = [0.0]
+        self.flow_amounts = [0.0]
 
-        for _ in self._cpn_dts[1:]:
-            cpn = self._cpn / self._freq
-            self._flow_amounts.append(cpn)
+        for _ in self.cpn_dts[1:]:
+            cpn = self.cpn / self.freq
+            self.flow_amounts.append(cpn)
 
     ###########################################################################
 
     def dirty_price_from_ytm(self,
                              settle_dt: Date,
                              ytm: float,
                              convention: YTMCalcType = YTMCalcType.UK_DMO):
@@ -241,93 +245,93 @@
         self.accrued_interest(settle_dt, 1.0)
 
         #######################################################################
         # HANDLE EX_DIVIDEND DATES
         #######################################################################
 
         pay_first_cpn = 1.0
-        if settle_dt > self._ex_div_dt:
+        if settle_dt > self.ex_div_dt:
             pay_first_cpn = 0.0
 
         #######################################################################
 
         ytm = np.array(ytm)  # VECTORIZED
         ytm = ytm + 0.000000000012345  # SNEAKY LOW-COST TRICK TO AVOID y=0
 
-        f = annual_frequency(self._freq_type)
-        c = self._cpn
+        f = annual_frequency(self.freq_type)
+        c = self.cpn
 
         if convention == YTMCalcType.ZERO:
             raise FinError("Zero coupon bonds must use BondZero class.")
 
         v = 1.0 / (1.0 + ytm / f)
 
         # n is the number of flows after the next coupon
         n = 0
-        for dt in self._cpn_dts:
+        for dt in self.cpn_dts:
             if dt > settle_dt:
                 n += 1
         n = n - 1
 
         if n < 0:
             raise FinError("No coupons left")
 
         if convention == YTMCalcType.UK_DMO:
             if n == 0:
-                dp = (v ** (self._alpha)) * (1.0 + pay_first_cpn * c / f)
+                dp = (v ** (self.alpha)) * (1.0 + pay_first_cpn * c / f)
             else:
                 term1 = (c / f) * pay_first_cpn
                 term2 = (c / f) * v
                 term3 = (c / f) * v * v * (1.0 - v ** (n - 1)) / (1.0 - v)
                 term4 = (v ** n)
-                dp = (v ** (self._alpha)) * (term1 + term2 + term3 + term4)
-        #                print(term1, term2, term3, term4, v, self._alpha, dp)
+                dp = (v ** (self.alpha)) * (term1 + term2 + term3 + term4)
+        #                print(term1, term2, term3, term4, v, self.alpha, dp)
         elif convention == YTMCalcType.US_TREASURY:
             if n == 0:
-                dp = (v ** (self._alpha)) * (1.0 + c / f)
+                dp = (v ** (self.alpha)) * (1.0 + c / f)
             else:
                 term1 = (c / f) * pay_first_cpn
                 term2 = (c / f) * v
                 term3 = (c / f) * v * v * (1.0 - v ** (n - 1)) / (1.0 - v)
                 term4 = (v ** n)
-                vw = 1.0 / (1.0 + self._alpha * ytm / f)
+                vw = 1.0 / (1.0 + self.alpha * ytm / f)
                 dp = (vw) * (term1 + term2 + term3 + term4)
         elif convention == YTMCalcType.US_STREET:
             if n == 0:
-                vw = 1.0 / (1.0 + self._alpha * ytm / f)
+                vw = 1.0 / (1.0 + self.alpha * ytm / f)
                 dp = vw * (1.0 + c / f)
             else:
                 term1 = (c / f) * pay_first_cpn
                 term2 = (c / f) * v
                 term3 = (c / f) * v * v * (1.0 - v ** (n - 1)) / (1.0 - v)
                 term4 = (v ** n)
-                dp = (v ** (self._alpha)) * (term1 + term2 + term3 + term4)
+                dp = (v ** (self.alpha)) * (term1 + term2 + term3 + term4)
         elif convention == YTMCalcType.CFETS:
             if n == 0:
-                last_year = self._maturity_dt.add_tenor("-12M")
+                last_year = self.maturity_dt.add_tenor("-12M")
 
                 dc = DayCount(DayCountTypes.ACT_365L)
 
                 alpha = (1 - dc.year_frac(last_year,
                                           settle_dt,
-                                          self._maturity_dt,
+                                          self.maturity_dt,
                                           freq_type=FrequencyTypes.ANNUAL)[0])
 
                 vw = 1.0 / (1.0 + alpha * ytm)
                 dp = vw * (1.0 + c / f)
             else:
                 term1 = (c / f) * pay_first_cpn
                 term2 = (c / f) * v
                 term3 = (c / f) * v * v * (1.0 - v ** (n - 1)) / (1.0 - v)
                 term4 = (v ** n)
-                dp = (v ** (self._alpha)) * (term1 + term2 + term3 + term4)
+                dp = (v ** (self.alpha)) * (term1 + term2 + term3 + term4)
         else:
             raise FinError("Unknown yield convention")
 
-        return dp * self._par
+        return dp * self.par
 
     ###########################################################################
 
     def principal(self,
                   settle_dt: Date,
                   ytm: float,
                   face: (float),
@@ -336,16 +340,16 @@
         amount from its discount margin and making assumptions about the
         future Ibor rates. """
 
         dirty_price = self.dirty_price_from_ytm(settle_dt,
                                                 ytm,
                                                 convention)
 
-        principal = dirty_price * face / self._par
-        principal = principal - self._accrued_interest
+        principal = dirty_price * face / self.par
+        principal = principal - self.accrued_int
         return principal
 
     ###########################################################################
 
     def dollar_duration(self,
                         settle_dt: Date,
                         ytm: float,
@@ -366,15 +370,15 @@
                           ytm: float,
                           convention: YTMCalcType = YTMCalcType.UK_DMO):
         """ Calculate the Macauley duration of the bond on a settlement date
         given its yield to maturity. """
 
         dd = self.dollar_duration(settle_dt, ytm, convention)
         fp = self.dirty_price_from_ytm(settle_dt, ytm, convention)
-        md = dd * (1.0 + ytm / self._freq) / fp
+        md = dd * (1.0 + ytm / self.freq) / fp
         return md
 
     ###########################################################################
 
     def modified_duration(self,
                           settle_dt: Date,
                           ytm: float,
@@ -385,15 +389,15 @@
         dd = self.dollar_duration(settle_dt, ytm, convention)
         fp = self.dirty_price_from_ytm(settle_dt, ytm, convention)
         md = dd / fp
         return md
 
     ###########################################################################
 
-    def key_rate_durations(self, 
+    def key_rate_durations(self,
                            settle_dt: Date,
                            ytm: float,
                            key_rate_tenors: list = None,
                            shift: float = None,
                            rates: list = None):
         """
         Calculates the key rate durations for a bond.
@@ -449,16 +453,19 @@
             # Create set of par bonds to be used in BondZeroCurve
             # ytm and coupons are equal
             par_bonds = []
 
             for tenor, cpn in zip(key_rate_tenors, rates):
                 mat_dt = settle_dt.add_years(tenor)
 
-                par_bond = Bond(settle_dt, mat_dt, cpn,
-                                self._freq_type, self._dc_type)
+                par_bond = Bond(settle_dt,
+                                mat_dt,
+                                cpn,
+                                self.freq_type,
+                                self.dc_type)
 
                 par_bonds.append(par_bond)
 
             clean_prices = []
 
             for par_bond, ytm in zip(par_bonds, rates):
                 clean_price = par_bond.clean_price_from_ytm(settle_dt,
@@ -480,16 +487,16 @@
 
             par_bonds = []
 
             for tenor, cpn in zip(key_rate_tenors, rates):
                 mat = settle_dt.add_years(tenor)
 
                 par_bond = Bond(settle_dt, mat, cpn,
-                                self._freq_type, 
-                                self._dc_type)
+                                self.freq_type,
+                                self.dc_type)
 
                 par_bonds.append(par_bond)
 
             clean_prices = []
 
             for par_bond, ytm in zip(par_bonds, rates):
                 clean_price = par_bond.clean_price_from_ytm(settle_dt,
@@ -500,28 +507,28 @@
             par_crv_up = BondZeroCurve(settle_dt,
                                        par_bonds,
                                        clean_prices,
                                        lin_zero_interp)
 
             # calculate the full price of the bond
             # using the discount curve with the key rate shifted up
-            p_up = self.dirty_price_from_discount_curve(
-                settle_dt, par_crv_up)
+            p_up = self.dirty_price_from_discount_curve(settle_dt,
+                                                        par_crv_up)
 
             # create a curve again with the key rate shifted down
             # by twice the shift value.
             rates[ind] -= shift * 2
 
             par_bonds = []
 
             for tenor, cpn in zip(key_rate_tenors, rates):
                 mat = settle_dt.add_years(tenor)
 
                 par_bond = Bond(settle_dt, mat, cpn,
-                                self._freq_type, self._dc_type)
+                                self.freq_type, self.dc_type)
 
                 par_bonds.append(par_bond)
 
             clean_prices = []
 
             for par_bond, ytm in zip(par_bonds, rates):
                 clean_price = par_bond.clean_price_from_ytm(settle_dt,
@@ -556,128 +563,128 @@
         """ Calculate the bond convexity from the yield to maturity. This
         function is vectorised with respect to the yield input. """
 
         dy = 0.0001  # 1 basis point
         p0 = self.dirty_price_from_ytm(settle_dt, ytm - dy, convention)
         p1 = self.dirty_price_from_ytm(settle_dt, ytm, convention)
         p2 = self.dirty_price_from_ytm(settle_dt, ytm + dy, convention)
-        conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self._par
+        conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self.par
         return conv
 
     ###########################################################################
 
     def clean_price_from_ytm(self,
                              settle_dt: Date,
                              ytm: float,
                              convention: YTMCalcType = YTMCalcType.UK_DMO):
         """ Calculate the bond clean price from the yield to maturity. This
         function is vectorised with respect to the yield input. """
 
         dp = self.dirty_price_from_ytm(settle_dt, ytm, convention)
-        accrued = self.accrued_interest(settle_dt, self._par)
-        cp = dp - accrued
+        accrued_int = self.accrued_interest(settle_dt, self.par)
+        cp = dp - accrued_int
         return cp
 
     ###########################################################################
 
     def clean_price_from_discount_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve):
         """ Calculate the clean bond value using some discount curve to
         present-value the bond's cash flows back to the curve anchor date and
         not to the settlement date. """
 
-        self.accrued_interest(settle_dt, self._par)
+        self.accrued_interest(settle_dt, self.par)
+
         dirty_price = self.dirty_price_from_discount_curve(settle_dt,
                                                            discount_curve)
 
-        accrued = self.accrued_interest(settle_dt, self._par)
-        clean_price = dirty_price - accrued
+        clean_price = dirty_price - self.accrued_int
         return clean_price
 
     ###########################################################################
 
     def dirty_price_from_discount_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve):
         """ Calculate the bond price using a provided discount curve to PV the
         bond's cash flows to the settlement date. As such it is effectively a
         forward bond price if the settlement date is after the valuation date.
         """
 
-        if settle_dt < discount_curve._value_dt:
+        if settle_dt < discount_curve.value_dt:
             raise FinError("Bond settles before Discount curve date")
 
-        if settle_dt > self._maturity_dt:
+        if settle_dt > self.maturity_dt:
             raise FinError("Bond settles after it matures.")
 
         self._calc_pcd_ncd(settle_dt)
 
-        cal = Calendar(self._cal_type)
+        cal = Calendar(self.cal_type)
 
-        self._ex_div_dt = cal.add_business_days(self._ncd, -self._ex_div_days)
+        self.ex_div_dt = cal.add_business_days(self.ncd, -self.ex_div_days)
 
         pay_first_cpn = 1.0
-        if settle_dt > self._ex_div_dt:
+        if settle_dt > self.ex_div_dt:
             pay_first_cpn = 0.0
 
         px = 0.0
         df = 1.0
-        dfSettle = discount_curve.df(settle_dt)
+        df_settle_dt = discount_curve.df(settle_dt)
 
-        dt = self._cpn_dts[1]
+        dt = self.cpn_dts[1]
         if dt > settle_dt:
             df = discount_curve.df(dt)
-            flow = self._cpn / self._freq
+            flow = self.cpn / self.freq
             pv = flow * df
             px += pv * pay_first_cpn
 
-        for dt in self._cpn_dts[2:]:
+        for dt in self.cpn_dts[2:]:
 
             # coupons paid on a settlement date are paid to the seller
             if dt > settle_dt:
                 df = discount_curve.df(dt)
-                flow = self._cpn / self._freq
+                flow = self.cpn / self.freq
                 pv = flow * df
                 px += pv
 
         px += df
-        px = px / dfSettle
+        px = px / df_settle_dt
 
-        return px * self._par
+        return px * self.par
 
     ###########################################################################
 
     def current_yield(self, clean_price):
         """ Calculate the current yield of the bond which is the
         coupon divided by the clean price (not the full price)"""
 
-        y = self._cpn * self._par / clean_price
+        y = self.cpn * self.par / clean_price
         return y
 
     ###########################################################################
 
     def yield_to_maturity(self,
                           settle_dt: Date,
                           clean_price: float,
                           convention: YTMCalcType = YTMCalcType.US_TREASURY):
         """ Calculate the bond's yield to maturity by solving the price
         yield relationship using a one-dimensional root solver. """
 
-        if type(clean_price) is float or type(clean_price) is np.float64:
+        if isinstance(clean_price, float) or isinstance(clean_price, np.float64):
             clean_prices = np.array([clean_price])
-        elif type(clean_price) is list or type(clean_price) is np.ndarray:
+        elif isinstance(clean_price, list) or isinstance(clean_price, np.ndarray):
             clean_prices = np.array(clean_price)
         else:
             raise FinError("Unknown type for clean_price "
                            + str(type(clean_price)))
 
         self.accrued_interest(settle_dt, 1.0)
 
-        accrued_amount = self._accrued_interest * self._par
+        accrued_amount = self.accrued_int * self.par
         dirty_prices = (clean_prices + accrued_amount)
         ytms = []
 
         for dirty_price in dirty_prices:
             argtuple = (self, settle_dt, dirty_price, convention)
 
             ytm = optimize.newton(_f,
@@ -696,24 +703,24 @@
             return np.array(ytms)
 
     ###########################################################################
 
     def _calc_pcd_ncd(self,
                       settle_dt: Date):
 
-        num_flows = len(self._cpn_dts)
+        num_flows = len(self.cpn_dts)
 
         if num_flows == 0:
-            raise FinError("Accrued interest - not enough flow dates.")
+            raise FinError("Accrued interest - not enough flow dts.")
 
         for i_flow in range(1, num_flows):
             # coupons paid on a settlement date are paid to the seller
-            if self._cpn_dts[i_flow] > settle_dt:
-                self._pcd = self._cpn_dts[i_flow - 1]
-                self._ncd = self._cpn_dts[i_flow]
+            if self.cpn_dts[i_flow] > settle_dt:
+                self.pcd = self.cpn_dts[i_flow - 1]
+                self.ncd = self.cpn_dts[i_flow]
                 break
 
     ###########################################################################
 
     def accrued_interest(self,
                          settle_dt: Date,
                          face: float = 100.0):
@@ -725,150 +732,149 @@
         days before the coupon date the ex-coupon date is. You can specify the
         calendar to be used in the bond constructor - NONE means only calendar
         days, WEEKEND is only weekends, or you can specify a country calendar
         for business days."""
 
         self._calc_pcd_ncd(settle_dt)
 
-        dc = DayCount(self._dc_type)
-        cal = Calendar(self._cal_type)
+        dc = DayCount(self.dc_type)
+        cal = Calendar(self.cal_type)
 
-        self._ex_div_dt = cal.add_business_days(self._ncd,
-                                                -self._ex_div_days)
+        self.ex_div_dt = cal.add_business_days(self.ncd,
+                                               -1 * self.ex_div_days)
 
-        (acc_factor, num, _) = dc.year_frac(self._pcd,
+        (acc_factor, num, _) = dc.year_frac(self.pcd,
                                             settle_dt,
-                                            self._ncd,
-                                            self._freq_type)
+                                            self.ncd,
+                                            self.freq_type)
 
-        self._alpha = 1.0 - acc_factor * self._freq
+        self.alpha = 1.0 - acc_factor * self.freq
 
-        if settle_dt > self._ex_div_dt:
-            self._accrued_interest = acc_factor - 1.0 / self._freq
+        if settle_dt > self.ex_div_dt:
+            self.accrued_int = acc_factor - 1.0 / self.freq
         else:
-            self._accrued_interest = acc_factor
-
-        self._accrued_interest *= self._cpn * face
+            self.accrued_int = acc_factor
 
-        self._accrued_days = num
+        self.accrued_int *= self.cpn * face
+        self.accrued_days = num
 
-        return self._accrued_interest
+        return self.accrued_int
 
     ###########################################################################
 
     def asset_swap_spread(
             self,
             settle_dt: Date,
             clean_price: float,
             discount_curve: DiscountCurve,
-            swapFloatDayCountConventionType=DayCountTypes.ACT_360,
-            swapFloatFrequencyType=FrequencyTypes.SEMI_ANNUAL,
-            swapFloatCalendarType=CalendarTypes.WEEKEND,
-            swapFloatBusDayAdjustRuleType=BusDayAdjustTypes.FOLLOWING,
-            swapFloatDateGenRuleType=DateGenRuleTypes.BACKWARD):
+            swap_float_day_count_convention_type=DayCountTypes.ACT_360,
+            swap_float_frequency_type=FrequencyTypes.SEMI_ANNUAL,
+            swap_float_calendar_type=CalendarTypes.WEEKEND,
+            swap_float_bus_day_adjust_rule_type=BusDayAdjustTypes.FOLLOWING,
+            swap_float_date_gen_rule_type=DateGenRuleTypes.BACKWARD):
         """ Calculate the par asset swap spread of the bond. The discount curve
         is an Ibor curve that is passed in. This function is vectorised with
         respect to the clean price. """
 
         clean_price = np.array(clean_price)
         self.accrued_interest(settle_dt, 1.0)
-        accrued_amount = self._accrued_interest * self._par
+        accrued_amount = self.accrued_int * self.par
         bond_price = clean_price + accrued_amount
         # Calculate the price of the bond discounted on the Ibor curve
         pv_ibor = 0.0
-        prev_dt = self._pcd
+        prev_dt = self.pcd
 
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
             # coupons paid on a settlement date are paid to the seller
             if dt > settle_dt:
                 df = discount_curve.df(dt)
-                pv_ibor += df * self._cpn / self._freq
+                pv_ibor += df * self.cpn / self.freq
 
         pv_ibor += df
 
         # Calculate the PV01 of the floating leg of the asset swap
         # I assume here that the coupon starts accruing on the settlement date
-        prev_dt = self._pcd
+        prev_dt = self.pcd
         schedule = Schedule(settle_dt,
-                            self._maturity_dt,
-                            swapFloatFrequencyType,
-                            swapFloatCalendarType,
-                            swapFloatBusDayAdjustRuleType,
-                            swapFloatDateGenRuleType)
+                            self.maturity_dt,
+                            swap_float_frequency_type,
+                            swap_float_calendar_type,
+                            swap_float_bus_day_adjust_rule_type,
+                            swap_float_date_gen_rule_type)
 
-        day_count = DayCount(swapFloatDayCountConventionType)
+        day_count = DayCount(swap_float_day_count_convention_type)
 
-        prev_dt = self._pcd
+        prev_dt = self.pcd
         pv01 = 0.0
-        for dt in schedule._adjusted_dts[1:]:
+        for dt in schedule.adjusted_dts[1:]:
             df = discount_curve.df(dt)
             year_frac = day_count.year_frac(prev_dt, dt)[0]
             pv01 = pv01 + year_frac * df
             prev_dt = dt
 
-        asw = (pv_ibor - bond_price / self._par) / pv01
+        asw = (pv_ibor - bond_price / self.par) / pv01
         return asw
 
     ###########################################################################
 
     def dirty_price_from_oas(self,
                              settle_dt: Date,
                              discount_curve: DiscountCurve,
                              oas: float):
         """ Calculate the full price of the bond from its OAS given the bond
         settlement date, a discount curve and the oas as a number. """
 
         self.accrued_interest(settle_dt, 1.0)
-        f = self._freq
-        c = self._cpn
+        f = self.freq
+        c = self.cpn
         df_adjusted = 1.0
 
         pv = 0.0
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
             # coupons paid on a settlement date are paid to the seller
             if dt > settle_dt:
                 t = (dt - settle_dt) / gDaysInYear
 
-                t = np.maximum(t, gSmall)
+                t = np.maximum(t, g_small)
 
                 df = discount_curve.df(dt)
 
                 # determine the Ibor implied zero rate
                 r = f * (np.power(df, -1.0 / t / f) - 1.0)
 
                 # determine the OAS adjusted zero rate
                 df_adjusted = np.power(1.0 + (r + oas) / f, -t * f)
                 pv = pv + (c / f) * df_adjusted
 
         pv = pv + df_adjusted
-        pv *= self._par
+        pv *= self.par
         return pv
 
     ###########################################################################
 
     def option_adjusted_spread(self,
                                settle_dt: Date,
                                clean_price: float,
                                discount_curve: DiscountCurve):
         """ Return OAS for bullet bond given settlement date, clean bond price
         and the discount relative to which the spread is to be computed. """
 
-        if type(clean_price) is float or type(clean_price) is np.float64:
+        if isinstance(clean_price, float) or isinstance(clean_price, np.float64):
             clean_prices = np.array([clean_price])
-        elif type(clean_price) is list or type(clean_price) is np.ndarray:
+        elif isinstance(clean_price, list) or isinstance(clean_price, np.ndarray):
             clean_prices = np.array(clean_price)
         else:
             raise FinError("Unknown type for clean_price "
                            + str(type(clean_price)))
 
         self.accrued_interest(settle_dt, 1.0)
 
-        accrued_amount = self._accrued_interest * self._par
+        accrued_amount = self.accrued_int * self.par
         dirty_prices = clean_prices + accrued_amount
 
         oass = []
 
         for dirty_price in dirty_prices:
             argtuple = (self, settle_dt, dirty_price, discount_curve)
 
@@ -886,38 +892,38 @@
             return oass[0]
         else:
             return np.array(oass)
 
     ###########################################################################
 
     def bond_payments(self, settle_dt: Date, face: (float)):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted coupon payment dts used in
         analytic calculations for the bond. """
 
-        flow = face * self._cpn / self._freq
+        flow = face * self.cpn / self.freq
 
         flow_str = ""
 
-        for dt in self._cpn_dts[1:-1]:
+        for dt in self.cpn_dts[1:-1]:
             # coupons paid on a settlement date are paid to the seller
             if dt > settle_dt:
                 flow_str += ("%12s %12.5f \n" % (dt, flow))
 
         redemption_amount = face + flow
         flow_str += ("%12s %12.5f \n"
-                     % (self._cpn_dts[-1], redemption_amount))
+                     % (self.cpn_dts[-1], redemption_amount))
 
         return flow_str
 
     ###########################################################################
 
     def print_payments(self,
                        settle_dt: Date,
                        face: float = 100.0):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted coupon payment dts used in
         analytic calculations for the bond. """
 
         print(self.bond_payments(settle_dt, face))
 
     ###########################################################################
 
     def dirty_price_from_survival_curve(self,
@@ -929,25 +935,25 @@
         The survival curve treats the coupons as zero recovery payments while
         the recovery fraction of the par amount is paid at default. For the
         defaulting principal we discretize the time steps using the coupon
         payment times. A finer discretization may handle the time value with
         more accuracy. I reduce any error by averaging period start and period
         end payment present values. """
 
-        f = self._freq
-        c = self._cpn
+        f = self.freq
+        c = self.cpn
 
         pv = 0.0
         prev_q = 1.0
         prev_df = 1.0
 
         defaulting_pv_pay_start = 0.0
         defaulting_pv_pay_end = 0.0
 
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
             # coupons paid on a settlement date are paid to the seller
             if dt > settle_dt:
                 df = discount_curve.df(dt)
                 q = survival_curve.survival_prob(dt)
 
                 # Add PV of coupon conditional on surviving to payment date
@@ -963,15 +969,15 @@
                 # Add on PV of principal if default occurs in coupon period
                 prev_q = q
                 prev_df = df
 
         pv = pv + 0.50 * defaulting_pv_pay_start
         pv = pv + 0.50 * defaulting_pv_pay_end
         pv = pv + df * q
-        pv *= self._par
+        pv *= self.par
         return pv
 
     ###########################################################################
 
     def clean_price_from_survival_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve,
@@ -984,15 +990,15 @@
         self.accrued_interest(settle_dt, 1.0)
 
         dirty_price = self.dirty_price_from_survival_curve(settle_dt,
                                                            discount_curve,
                                                            survival_curve,
                                                            recovery_rate)
 
-        clean_price = dirty_price - self._accrued_interest
+        clean_price = dirty_price - self.accrued_int
         return clean_price
 
     ###########################################################################
 
     def calc_ror(self,
                  begin_dt: Date,
                  end_dt: Date,
@@ -1006,24 +1012,24 @@
         coupon payments during the period.
         It returns a tuple which includes a simple rate of return, a compounded
         IRR and the PnL.
         """
         buy_price = self.dirty_price_from_ytm(
             begin_dt, begin_ytm, convention)
         sell_price = self.dirty_price_from_ytm(end_dt, end_ytm, convention)
-        dates_cfs = zip(self._cpn_dts, self._flow_amounts)
+        dts_cfs = zip(self.cpn_dts, self.flow_amounts)
 
         # The coupon or par payments on buying date belong to the buyer. The
         # coupon or par payments on selling date are given to the new buyer.
-        dates_cfs = [(d, c * self._par)
-                     for (d, c) in dates_cfs if (d >= begin_dt) and (d < end_dt)]
+        dts_cfs = [(d, c * self.par)
+                   for (d, c) in dts_cfs if (d >= begin_dt) and (d < end_dt)]
 
-        dates_cfs.append((begin_dt, -buy_price))
-        dates_cfs.append((end_dt, sell_price))
-        times_cfs = [((d - begin_dt) / 365, c) for (d, c) in dates_cfs]
+        dts_cfs.append((begin_dt, -buy_price))
+        dts_cfs.append((end_dt, sell_price))
+        times_cfs = [((d - begin_dt) / 365, c) for (d, c) in dts_cfs]
         pnl = sum(c for (t, c) in times_cfs)
         simple_return = (pnl / buy_price) * 365 / (end_dt - begin_dt)
         brentq_up_lim = 5
         brentq_dn_lim = -0.9999
 
         # in case brentq cannot find the irr root
         if simple_return > brentq_up_lim or simple_return < brentq_dn_lim:
@@ -1040,23 +1046,23 @@
         return simple_return, irr, pnl
 
     ###########################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("ISSUE DATE", self._issue_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("COUPON (%)", self._cpn * 100.0)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("EX_DIV DAYS", self._ex_div_days, "")
+        s += label_to_string("ISSUE DATE", self.issue_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("COUPON (%)", self.cpn * 100.0)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("EX_DIV DAYS", self.ex_div_days, "")
         return s
 
     ###########################################################################
 
     def _print(self):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted coupon payment dts used in
         analytic calculations for the bond. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_annuity.py` & `financepy-0.360/financepy/products/bonds/bond_annuity.py`

 * *Files 12% similar despite different names*

```diff
@@ -30,162 +30,168 @@
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD,
                  dc_type: DayCountTypes = DayCountTypes.ACT_360):
 
         check_argument_types(self.__init__, locals())
 
-        self._maturity_dt = maturity_dt
-        self._cpn = cpn
-        self._freq_type = freq_type
-        self._freq = annual_frequency(freq_type)
+        self.maturity_dt = maturity_dt
+        self.cpn = cpn
+        self.freq_type = freq_type
+        self.freq = annual_frequency(freq_type)
 
         # ISDA Style conventions
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
-        self._dc_type = dc_type
-
-        self._par = 100.0
-
-        self._cpn_dts = []
-        self._settle_dt = Date(1, 1, 1900)
-        self._accrued_interest = None
-        self._accrued_days = 0.0
-        self._alpha = 0.0
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+        self.dc_type = dc_type
+
+        self.par = 100.0
+
+        self.cpn_dts = []
+        self.settle_dt = Date(1, 1, 1900)
+        self.accrued_int = None
+        self.accrued_days = 0.0
+        self.alpha = 0.0
+
+        self.pcd = None
+        self.ncd = None
+        self.flow_amounts = None
 
     ###########################################################################
 
     def clean_price_from_discount_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve):
         """ Calculate the bond price using some discount curve to present-value
         the bond's cash flows. """
 
         dirty_price = self.dirty_price_from_discount_curve(settle_dt,
                                                            discount_curve)
-        accrued = self._accrued_interest * self._par
+        accrued = self.accrued_int* self.par
         clean_price = dirty_price - accrued
         return clean_price
 
     ###########################################################################
 
     def dirty_price_from_discount_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve):
         """ Calculate the bond price using some discount curve to present-value
         the bond's cash flows. """
 
         self.calculate_payments(settle_dt, 1.0)
         pv = 0.0
 
-        num_flows = len(self._cpn_dts)
+        num_flows = len(self.cpn_dts)
 
         for i in range(1, num_flows):
-            dt = self._cpn_dts[i]
+            dt = self.cpn_dts[i]
             df = discount_curve.df(dt)
-            flow = self._flow_amounts[i]
+            flow = self.flow_amounts[i]
             pv = pv + flow * df
 
-        return pv * self._par
+        return pv * self.par
 
     ###########################################################################
 
     def calculate_payments(self,
                            settle_dt: Date,
                            face: (float)):
         ''' Calculate bond payments '''
         # No need to generate flows if settlement date has not changed
-        if settle_dt == self._settle_dt:
+        if settle_dt == self.settle_dt:
             return
 
-        if settle_dt == self._maturity_dt:
+        if settle_dt == self.maturity_dt:
             raise FinError("Settlement date is maturity date.")
 
-        self._settle_dt = settle_dt
+        self.settle_dt = settle_dt
         bd_type = BusDayAdjustTypes.FOLLOWING
         dg_type = DateGenRuleTypes.BACKWARD
 
-        self._cpn_dts = Schedule(settle_dt,
-                                 self._maturity_dt,
-                                 self._freq_type,
-                                 self._cal_type,
+        self.cpn_dts = Schedule(settle_dt,
+                                 self.maturity_dt,
+                                 self.freq_type,
+                                 self.cal_type,
                                  bd_type,
                                  dg_type).generate()
 
-        self._pcd = self._cpn_dts[0]
-        self._ncd = self._cpn_dts[1]
+        self.pcd = self.cpn_dts[0]
+        self.ncd = self.cpn_dts[1]
         self.accrued_interest(settle_dt, 1.0)
 
-        self._flow_amounts = [0.0]
-        basis = DayCount(self._dc_type)
+        self.flow_amounts = [0.0]
+        basis = DayCount(self.dc_type)
 
-        prev_dt = self._pcd
+        prev_dt = self.pcd
 
-        for next_dt in self._cpn_dts[1:]:
+        for next_dt in self.cpn_dts[1:]:
             alpha = basis.year_frac(prev_dt, next_dt)[0]
-            flow = self._cpn * alpha * face
-            self._flow_amounts.append(flow)
+            flow = self.cpn * alpha * face
+            self.flow_amounts.append(flow)
             prev_dt = next_dt
 
     ###########################################################################
 
     def accrued_interest(self,
                          settle_dt: Date,
                          face: (float)):
         """ Calculate the amount of coupon that has accrued between the
         previous coupon date and the settlement date. """
 
-        if settle_dt != self._settle_dt:
+        if settle_dt != self.settle_dt:
             self.calculate_payments(settle_dt, 1.0)
 
-        if len(self._cpn_dts) == 0:
+        if len(self.cpn_dts) == 0:
             raise FinError("Accrued interest - not enough flow dates.")
 
-        dc = DayCount(self._dc_type)
+        dc = DayCount(self.dc_type)
 
-        (acc_factor, num, _) = dc.year_frac(self._pcd,
+        (acc_factor, num, _) = dc.year_frac(self.pcd,
                                             settle_dt,
-                                            self._ncd,
-                                            self._freq)
+                                            self.ncd,
+                                            self.freq)
 
-        self._alpha = 1.0 - acc_factor * self._freq
+        self.alpha = 1.0 - acc_factor * self.freq
 
-        self._accrued_interest = acc_factor * face * self._cpn
-        self._accrued_days = num
-        return self._accrued_interest
+        self.accrual_factor = acc_factor
+        self.accrued_int = acc_factor * face * self.cpn
+        self.accrued_days = num
+
+        return self.accrued_int
 
     ###########################################################################
 
     def print_payments(self,
                        settle_dt: Date,
                        face: (float)):
         """ Print a list of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
 
         self.calculate_payments(settle_dt, face)
 
-        num_flows = len(self._cpn_dts)
+        num_flows = len(self.cpn_dts)
         for i in range(1, num_flows):
-            dt = self._cpn_dts[i]
-            flow = self._flow_amounts[i]
+            dt = self.cpn_dts[i]
+            flow = self.flow_amounts[i]
             print(dt, ",", flow)
 
     ###########################################################################
 
     def __repr__(self):
         """ Print a list of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUS_DAY_RULE", self._bd_type)
-        s += label_to_string("DATE_GEN_RULE", self._dg_type)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUS_DAY_RULE", self.bd_type)
+        s += label_to_string("DATE_GEN_RULE", self.dg_type)
 
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_callable.py` & `financepy-0.360/financepy/products/bonds/bond_callable.py`

 * *Files 5% similar despite different names*

```diff
@@ -58,53 +58,53 @@
                  put_dts: List[Date],
                  put_prices: List[float]):
         """ Create a BondEmbeddedOption object with a maturity date, coupon
         and all the bond inputs. """
 
         check_argument_types(self.__init__, locals())
 
-        self._issue_dt = issue_dt
-        self._maturity_dt = maturity_dt
-        self._cpn = coupon
-        self._freq_type = freq_type
-        self._dc_type = dc_type
+        self.issue_dt = issue_dt
+        self.maturity_dt = maturity_dt
+        self.cpn = coupon
+        self.freq_type = freq_type
+        self.dc_type = dc_type
 
-        ex_div_days = 0
+        self.ex_div_days = 0
 
-        self._bond = Bond(issue_dt,
+        self.bond = Bond(issue_dt,
                           maturity_dt,
                           coupon,
                           freq_type,
                           dc_type,
-                          ex_div_days)
+                          self.ex_div_days)
 
         # Validate call and put schedules
         for dt in call_dts:
-            if dt > self._maturity_dt:
+            if dt > self.maturity_dt:
                 raise FinError("Call date after bond maturity date")
 
         if len(call_dts) > 0:
-            dtprev = call_dts[0]
+            dt_prev = call_dts[0]
             for dt in call_dts[1:]:
-                if dt <= dtprev:
+                if dt <= dt_prev:
                     raise FinError("Call dates not increasing")
                 else:
-                    dtprev = dt
+                    dt_prev = dt
 
         for dt in put_dts:
-            if dt > self._maturity_dt:
+            if dt > self.maturity_dt:
                 raise FinError("Put date after bond maturity date")
 
         if len(put_dts) > 0:
-            dtprev = put_dts[0]
+            dt_prev = put_dts[0]
             for dt in put_dts[1:]:
-                if dt <= dtprev:
+                if dt <= dt_prev:
                     raise FinError("Put dates not increasing")
                 else:
-                    dtprev = dt
+                    dt_prev = dt
 
         for px in call_prices:
             if px < 0.0:
                 raise FinError("Call price must be positive.")
 
         for px in put_prices:
             if px < 0.0:
@@ -112,139 +112,139 @@
 
         if len(call_dts) != len(call_prices):
             raise FinError("Number of call dates and call prices not the same")
 
         if len(put_dts) != len(put_prices):
             raise FinError("Number of put dates and put prices not the same")
 
-        self._call_dts = call_dts
-        self._call_prices = call_prices
-        self._put_dts = put_dts
-        self._put_prices = put_prices
-        self._par = 100.0
-        self._bond._calculate_cpn_dts()
+        self.call_dts = call_dts
+        self.call_prices = call_prices
+        self.put_dts = put_dts
+        self.put_prices = put_prices
+        self.par = 100.0
+        self.bond._calculate_cpn_dts()
 
 ###############################################################################
 
     def value(self,
               settle_dt: Date,
               discount_curve: DiscountCurve,
               model):
         """ Value the bond that settles on the specified date that can have
         both embedded call and put options. This is done using the specified
         model and a discount curve. """
 
         # Generate bond coupon flow schedule
-        cpn = self._bond._cpn/self._bond._freq
+        cpn = self.bond.cpn/self.bond.freq
 
         cpn_times = []
         cpn_amounts = []
 
-        for flow_dt in self._bond._cpn_dts[1:]:
+        for flow_dt in self.bond.cpn_dts[1:]:
             if flow_dt > settle_dt:
                 cpn_time = (flow_dt - settle_dt) / gDaysInYear
                 cpn_times.append(cpn_time)
                 cpn_amounts.append(cpn)
 
         cpn_times = np.array(cpn_times)
         cpn_amounts = np.array(cpn_amounts)
 
         # Generate bond call times and prices
         call_times = []
-        for dt in self._call_dts:
+        for dt in self.call_dts:
             if dt > settle_dt:
                 call_time = (dt - settle_dt) / gDaysInYear
                 call_times.append(call_time)
         call_times = np.array(call_times)
-        call_prices = np.array(self._call_prices)
+        call_prices = np.array(self.call_prices)
 
         # Generate bond put times and prices
         put_times = []
-        for dt in self._put_dts:
+        for dt in self.put_dts:
             if dt > settle_dt:
                 put_time = (dt - settle_dt) / gDaysInYear
                 put_times.append(put_time)
         put_times = np.array(put_times)
-        put_prices = np.array(self._put_prices)
+        put_prices = np.array(self.put_prices)
 
-        maturity_dt = self._bond._maturity_dt
+        maturity_dt = self.bond.maturity_dt
         t_mat = (maturity_dt - settle_dt) / gDaysInYear
         df_times = discount_curve._times
         df_values = discount_curve._dfs
 
-        face_amount = self._par
+        face_amount = self.par
 
         if isinstance(model, HWTree):
 
             """ We need to build the tree out to the bond maturity date. To be
             more precise we only need to go out the the last option date but
             we can do that refinement at a later date. """
 
             model.build_tree(t_mat, df_times, df_values)
             v1 = model.callable_puttable_bond_tree(cpn_times, cpn_amounts,
                                                    call_times, call_prices,
                                                    put_times, put_prices,
                                                    face_amount)
-            model._num_time_steps += 1
+            model.num_time_steps += 1
             model.build_tree(t_mat, df_times, df_values)
             v2 = model.callable_puttable_bond_tree(cpn_times, cpn_amounts,
                                                    call_times, call_prices,
                                                    put_times, put_prices,
                                                    face_amount)
-            model._num_time_steps -= 1
+            model.num_time_steps -= 1
 
-            v_bondwithoption = (v1['bondwithoption'] + v2['bondwithoption'])/2
-            v_bondpure = (v1['bondpure'] + v2['bondpure'])/2
+            v_bond_with_option = (v1['bondwithoption'] + v2['bondwithoption']) / 2
+            v_bond_pure = (v1['bondpure'] + v2['bondpure']) / 2
 
-            return {'bondwithoption': v_bondwithoption, 'bondpure': v_bondpure}
+            return {'bondwithoption': v_bond_with_option, 'bondpure': v_bond_pure}
 
         elif isinstance(model, BKTree):
 
             """ Because we not have a closed form bond price we need to build
             the tree out to the bond maturity which is after option expiry. """
 
             model.build_tree(t_mat, df_times, df_values)
             v1 = model.callable_puttable_bond_tree(cpn_times, cpn_amounts,
                                                    call_times, call_prices,
                                                    put_times, put_prices,
                                                    face_amount)
-            model._num_time_steps += 1
+            model.num_time_steps += 1
             model.build_tree(t_mat, df_times, df_values)
             v2 = model.callable_puttable_bond_tree(cpn_times, cpn_amounts,
                                                    call_times, call_prices,
                                                    put_times, put_prices,
                                                    face_amount)
-            model._num_time_steps -= 1
+            model.num_time_steps -= 1
 
-            v_bondwithoption = (v1['bondwithoption'] + v2['bondwithoption'])/2
-            v_bondpure = (v1['bondpure'] + v2['bondpure'])/2
+            v_bond_with_option = (v1['bondwithoption'] + v2['bondwithoption']) / 2
+            v_bond_pure = (v1['bondpure'] + v2['bondpure']) / 2
 
-            return {'bondwithoption': v_bondwithoption, 'bondpure': v_bondpure}
+            return {'bondwithoption': v_bond_with_option, 'bondpure': v_bond_pure}
         else:
             raise FinError("Unknown model type")
 
 ###############################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("ISSUE DATE", self._issue_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("COUPON", self._cpn)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("EX-DIV DAYS", self._ex_div_days)
-
-        s += label_to_string("NUM CALL DATES", len(self._call_dts))
-        for i in range(0, len(self._call_dts)):
-            s += "%12s %12.6f\n" % (self._call_dts[i], self._call_prices[i])
-
-        s += label_to_string("NUM PUT DATES", len(self._put_dts))
-        for i in range(0, len(self._put_dts)):
-            s += "%12s %12.6f\n" % (self._put_dts[i], self._put_prices[i])
+        s += label_to_string("ISSUE DATE", self.issue_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("COUPON", self.cpn)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("EX-DIV DAYS", self.ex_div_days)
+
+        s += label_to_string("NUM CALL DATES", len(self.call_dts))
+        for i in range(0, len(self.call_dts)):
+            s += "%12s %12.6f\n" % (self.call_dts[i], self.call_prices[i])
+
+        s += label_to_string("NUM PUT DATES", len(self.put_dts))
+        for i in range(0, len(self.put_dts)):
+            s += "%12s %12.6f\n" % (self.put_dts[i], self.put_prices[i])
 
         return s
 
 ###############################################################################
 
     def _print(self):
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_convertible.py` & `financepy-0.360/financepy/products/bonds/bond_convertible.py`

 * *Files 10% similar despite different names*

```diff
@@ -101,33 +101,33 @@
 
     num_levels = num_times
 
     # this is the size of the step
     dt = t_mat / (num_times - 1)
 
     tree_times = np.linspace(0.0, t_mat, num_times)
-    treeDfs = np.zeros(num_times)
+    tree_dfs = np.zeros(num_times)
     for i in range(0, num_times):
         df = _uinterpolate(tree_times[i], df_times, df_values, interp)
-        treeDfs[i] = df
+        tree_dfs[i] = df
 
     h = credit_spread / (1.0 - recovery_rate)
     survival_prob = exp(-h * dt)
 
     # map coupons onto tree but preserve their present value using risky dfs
     tree_flows = np.zeros(num_times)
     num_cpns = len(cpn_times)
     for i in range(0, num_cpns):
         flow_time = cpn_times[i]
         n = int(round(flow_time / dt, 0))
-        treeTime = tree_times[n]
+        tree_time = tree_times[n]
         df_flow = _uinterpolate(flow_time, df_times, df_values, interp)
         df_flow *= exp(-h * flow_time)
-        df_tree = _uinterpolate(treeTime, df_times, df_values, interp)
-        df_tree *= exp(-h * treeTime)
+        df_tree = _uinterpolate(tree_time, df_times, df_values, interp)
+        df_tree *= exp(-h * tree_time)
         tree_flows[n] += cpn_flows[i] * 1.0 * df_flow / df_tree
 
     # map call onto tree - must have no calls at high value
     tree_call_value = np.ones(num_times) * face_amount * 1000.0
     num_calls = len(call_times)
     for i in range(0, num_calls):
         call_time = call_times[i]
@@ -139,117 +139,120 @@
     num_puts = len(put_times)
     for i in range(0, num_puts):
         put_time = put_times[i]
         n = int(round(put_time / dt, 0))
         tree_put_value[n] = put_prices[i]
 
     # map discrete dividend yields onto tree dates when they are made
-    treeDividendYield = np.zeros(num_times)
+    tree_dividend_yld = np.zeros(num_times)
     numDividends = len(dividend_times)
     for i in range(0, numDividends):
         dividend_time = dividend_times[i]
         n = int(round(dividend_time / dt, 0))
-        treeDividendYield[n] = dividend_yields[i]
+        tree_dividend_yld[n] = dividend_yields[i]
 
     # Set up the tree of stock prices using a 2D matrix - half the matrix is
     # unused but this may be a cost worth bearing for simpler code. Review.
-    treeStockValue = np.zeros(shape=(num_times, num_levels))
+    tree_stock_value = np.zeros(shape=(num_times, num_levels))
     e = stock_volatility ** 2 - h
     if e < 0.0:
         raise FinError("Volatility squared minus the hazard rate is negative.")
 
     u = exp(sqrt(e * dt))
     d = 1.0 / u
     u2 = u * u
-    treeStockValue[0, 0] = stock_price
+    tree_stock_value[0, 0] = stock_price
     for i_time in range(1, num_times):
-        s = treeStockValue[i_time - 1, 0] * d
-        treeStockValue[i_time, 0] = s
+        s = tree_stock_value[i_time - 1, 0] * d
+        tree_stock_value[i_time, 0] = s
 
         for i_node in range(1, i_time + 1):
             s = s * u2
-            treeStockValue[i_time, i_node] = s
+            tree_stock_value[i_time, i_node] = s
 
         # we now reduce all stocks by the same yield amount at the same date
-        y = treeDividendYield[i_time]
+        y = tree_dividend_yld[i_time]
         for i_node in range(0, i_time + 1):
-            treeStockValue[i_time, i_node] *= (1.0 - y)
+            tree_stock_value[i_time, i_node] *= (1.0 - y)
 
     # set up the tree of conversion values. Before allowed to convert the
     # conversion value must be set equal to zero
 
-    treeConvertValue = np.zeros(shape=(num_times, num_levels))
+    tree_convert_value = np.zeros(shape=(num_times, num_levels))
     for i_time in range(0, num_times):
         if tree_times[i_time] >= start_convert_time:
             for i_node in range(0, i_time + 1):
-                s = treeStockValue[i_time, i_node]
-                treeConvertValue[i_time, i_node] = s * conv_ratio * 1.0
+                s = tree_stock_value[i_time, i_node]
+                tree_convert_value[i_time, i_node] = s * conv_ratio * 1.0
 
-    #    print_tree(treeConvertValue)
+    #    print_tree(tree_convert_value)
 
-    treeConvBondValue = np.zeros(shape=(num_times, num_levels))
+    tree_convert_bond_value = np.zeros(shape=(num_times, num_levels))
 
     # store probability of up move as a function of time on the tree
-    treeProbsUp = np.zeros(num_times)
-    treeProbsDn = np.zeros(num_times)
+    tree_probs_up = np.zeros(num_times)
+    tree_probs_dn = np.zeros(num_times)
     q = 0.0  # we have discrete dividends paid as dividend yields only
     for i_time in range(1, num_times):
-        a = treeDfs[i_time - 1] / treeDfs[i_time] * exp(-q * dt)
-        treeProbsUp[i_time] = (a - d * survival_prob) / (u - d)
-        treeProbsDn[i_time] = (u * survival_prob - a) / (u - d)
+        a = tree_dfs[i_time - 1] / tree_dfs[i_time] * exp(-q * dt)
+        tree_probs_up[i_time] = (a - d * survival_prob) / (u - d)
+        tree_probs_dn[i_time] = (u * survival_prob - a) / (u - d)
     #        r = log(a)/dt
     #        n_min = r*r / stock_volatility / stock_volatility
 
-    if np.any(treeProbsUp > 1.0):
-        raise FinError("pUp > 1.0. Increase time steps.")
+    if np.any(tree_probs_up > 1.0):
+        raise FinError("p_up > 1.0. Increase time steps.")
 
     ###########################################################################
     # work backwards by first setting values at bond maturity date
     ###########################################################################
 
     flow = tree_flows[num_times - 1]
     bullet_pv = (1.0 + flow) * face_amount
     for i_node in range(0, num_levels):
-        convValue = treeConvertValue[num_times - 1, i_node]
-        treeConvBondValue[num_times - 1, i_node] = max(bullet_pv, convValue)
+        convValue = tree_convert_value[num_times - 1, i_node]
+        tree_convert_bond_value[num_times - 1,
+                                i_node] = max(bullet_pv, convValue)
 
     #  begin backward steps from expiry
     for i_time in range(num_times - 2, -1, -1):
 
-        pUp = treeProbsUp[i_time + 1]
-        pDn = treeProbsDn[i_time + 1]
+        p_up = tree_probs_up[i_time + 1]
+        p_dn = tree_probs_dn[i_time + 1]
         pDef = 1.0 - survival_prob
-        df = treeDfs[i_time + 1] / treeDfs[i_time]
+        df = tree_dfs[i_time + 1] / tree_dfs[i_time]
         call = tree_call_value[i_time]
         put = tree_put_value[i_time]
         flow = tree_flows[i_time]
 
         for i_node in range(0, i_time + 1):
-            futValueUp = treeConvBondValue[i_time + 1, i_node + 1]
-            futValueDn = treeConvBondValue[i_time + 1, i_node]
-            hold = pUp * futValueUp + pDn * futValueDn  # pUp already embeds Q
-            holdPV = df * hold + pDef * df * recovery_rate * face_amount \
+            fut_value_up = tree_convert_bond_value[i_time + 1, i_node + 1]
+            fut_value_dn = tree_convert_bond_value[i_time + 1, i_node]
+            hold = p_up * fut_value_up + p_dn * fut_value_dn  # p_up already embeds Q
+            hold_pv = df * hold + pDef * df * recovery_rate * face_amount \
                 + flow * face_amount
-            conv = treeConvertValue[i_time, i_node]
-            value = min(max(holdPV, conv, put), call)
-            treeConvBondValue[i_time, i_node] = value
+            conv = tree_convert_value[i_time, i_node]
+            value = min(max(hold_pv, conv, put), call)
+            tree_convert_bond_value[i_time, i_node] = value
 
         bullet_pv = df * bullet_pv * survival_prob
         bullet_pv += pDef * df * recovery_rate * face_amount
         bullet_pv += flow * face_amount
 
-    price = treeConvBondValue[0, 0]
-    delta = (treeConvBondValue[1, 1] - treeConvBondValue[1, 0]) / \
-            (treeStockValue[1, 1] - treeStockValue[1, 0])
-    delta_up = (treeConvBondValue[2, 3] - treeConvBondValue[2, 2]) / \
-              (treeStockValue[2, 3] - treeStockValue[2, 2])
-    delta_dn = (treeConvBondValue[2, 2] - treeConvBondValue[2, 1]) / \
-              (treeStockValue[2, 2] - treeStockValue[2, 1])
-    gamma = (delta_up - delta_dn) / (treeStockValue[1, 1] - treeStockValue[1, 0])
-    theta = (treeConvBondValue[2, 2] - treeConvBondValue[0, 0]) / (2.0 * dt)
+    price = tree_convert_bond_value[0, 0]
+    delta = (tree_convert_bond_value[1, 1] - tree_convert_bond_value[1, 0]) / \
+            (tree_stock_value[1, 1] - tree_stock_value[1, 0])
+    delta_up = (tree_convert_bond_value[2, 3] - tree_convert_bond_value[2, 2]) / \
+        (tree_stock_value[2, 3] - tree_stock_value[2, 2])
+    delta_dn = (tree_convert_bond_value[2, 2] - tree_convert_bond_value[2, 1]) / \
+        (tree_stock_value[2, 2] - tree_stock_value[2, 1])
+    gamma = (delta_up - delta_dn) / \
+        (tree_stock_value[1, 1] - tree_stock_value[1, 0])
+    theta = (tree_convert_bond_value[2, 2] -
+             tree_convert_bond_value[0, 0]) / (2.0 * dt)
     results = np.array([price, bullet_pv, delta, gamma, theta])
     return results
 
 
 ###############################################################################
 
 
@@ -280,80 +283,83 @@
         """
 
         check_argument_types(self.__init__, locals())
 
         if start_convert_dt > maturity_dt:
             raise FinError("Start convert date is after bond maturity.")
 
-        self._maturity_dt = maturity_dt
-        self._cpn = coupon
-        self._dc_type = dc_type
-        self._freq = annual_frequency(freq_type)
-        self._freq_type = freq_type
-        self._cal_type = cal_type
-        self._call_dts = call_dts
-        self._call_prices = call_prices
+        self.maturity_dt = maturity_dt
+        self.cpn = coupon
+        self.dc_type = dc_type
+        self.freq = annual_frequency(freq_type)
+        self.freq_type = freq_type
+        self.cal_type = cal_type
+        self.call_dts = call_dts
+        self.call_prices = call_prices
 
-        if len(self._call_dts) != len(self._call_prices):
+        if len(self.call_dts) != len(self.call_prices):
             raise FinError("Call dates and prices not same length.")
 
-        self._put_dts = put_dts
-        self._put_prices = put_prices
+        self.put_dts = put_dts
+        self.put_prices = put_prices
 
-        if len(self._put_dts) != len(self._put_prices):
+        if len(self.put_dts) != len(self.put_prices):
             raise FinError("Put dates and prices not same length.")
 
         if len(put_dts) > 0:
             if put_dts[-1] > maturity_dt:
                 raise FinError("Last put is after bond maturity.")
 
         if len(call_dts) > 0:
             if call_dts[-1] > maturity_dt:
                 raise FinError("Last call is after bond maturity.")
 
-        self._start_convert_dt = start_convert_dt
+        self.start_convert_dt = start_convert_dt
 
         if conversion_ratio < 0.0:
             raise FinError("Conversion ratio is negative.")
 
-        self._conversion_ratio = conversion_ratio
-        self._par = 100.0
+        self.conversion_ratio = conversion_ratio
+        self.par = 100.0
 
-        self._settle_dt = Date(1, 1, 1900)
+        self.settle_dt = Date(1, 1, 1900)
         """ I do not determine cashflow dates as I do not want to require
         users to supply the issue date and without that I do not know how
         far to go back in the cashflow date schedule. """
 
-        self._accrued_interest = None
-        self._accrued_days = 0.0
-        self._alpha = 0.0
+        self.accrued_int = None
+        self.accrued_days = 0.0
+        self.alpha = 0.0
 
     ###########################################################################
 
     def _calculate_cpn_dts(self,
                            settle_dt: Date):
         """ Determine the convertible bond cash flow payment dates. """
 
         # No need to generate flows if settlement date has not changed
-        if settle_dt == self._settle_dt:
+        if settle_dt == self.settle_dt:
             return
 
-        self._settle_dt = settle_dt
+        self.settle_dt = settle_dt
+
         bd_type = BusDayAdjustTypes.NONE
         dg_type = DateGenRuleTypes.BACKWARD
 
-        self._cpn_dts = Schedule(settle_dt,
-                                 self._maturity_dt,
-                                 self._freq_type,
-                                 self._cal_type,
+        self.cpn_dts = Schedule(settle_dt,
+                                 self.maturity_dt,
+                                 self.freq_type,
+                                 self.cal_type,
                                  bd_type,
                                  dg_type).generate()
 
-        self._pcd = self._cpn_dts[0]
-        self._ncd = self._cpn_dts[1]
+        self.pcd = self.cpn_dts[0]
+        self.ncd = self.cpn_dts[1]
+
+        self.accrued_int = None
         self.accrued_interest(settle_dt, 1.0)
 
     ###########################################################################
 
     def value(self,
               settle_dt: Date,
               stock_price: float,
@@ -389,26 +395,26 @@
             stock_price = 1e-10  # Avoid overflows in delta calc
 
         if stock_volatility <= 0.0:
             stock_volatility = 1e-10  # Avoid overflows in delta calc
 
         self._calculate_cpn_dts(settle_dt)
 
-        t_mat = (self._maturity_dt - settle_dt) / gDaysInYear
+        t_mat = (self.maturity_dt - settle_dt) / gDaysInYear
 
         if t_mat <= 0.0:
             raise FinError("Maturity must not be on or before the value date.")
 
         # We include time zero in the coupon times and flows
         cpn_times = [0.0]
         cpn_flows = [0.0]
 
-        cpn = self._cpn / self._freq
+        cpn = self.cpn / self.freq
 
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
             flow_time = (dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
         cpn_times = np.array(cpn_times)
         cpn_flows = np.array(cpn_flows)
 
@@ -416,35 +422,35 @@
             raise FinError("No coupon times can be before the value date.")
 
         if np.any(cpn_times > t_mat):
             raise FinError("No coupon times can be after the maturity date.")
 
         call_times = []
 
-        for dt in self._call_dts:
+        for dt in self.call_dts:
             call_time = (dt - settle_dt) / gDaysInYear
             call_times.append(call_time)
 
         call_times = np.array(call_times)
-        call_prices = np.array(self._call_prices)
+        call_prices = np.array(self.call_prices)
 
         if np.any(call_times < 0.0):
             raise FinError("No call times can be before the value date.")
 
         if np.any(call_times > t_mat):
             raise FinError("No call times can be after the maturity date.")
 
         put_times = []
 
-        for dt in self._put_dts:
+        for dt in self.put_dts:
             put_time = (dt - settle_dt) / gDaysInYear
             put_times.append(put_time)
 
         put_times = np.array(put_times)
-        put_prices = np.array(self._put_prices)
+        put_prices = np.array(self.put_prices)
 
         if np.any(put_times > t_mat):
             raise FinError("No put times can be after the maturity date.")
 
         if np.any(put_times <= 0.0):
             raise FinError("No put times can be on or before value date.")
 
@@ -455,15 +461,15 @@
         for dt in dividend_dts:
             dividend_time = (dt - settle_dt) / gDaysInYear
             dividend_times.append(dividend_time)
         dividend_times = np.array(dividend_times)
         dividend_yields = np.array(dividend_yields)
 
         # If it's before today it starts today
-        tconv = (self._start_convert_dt - settle_dt) / gDaysInYear
+        tconv = (self.start_convert_dt - settle_dt) / gDaysInYear
         tconv = max(tconv, 0.0)
 
         discount_factors = []
         for t in cpn_times:
             df = discount_curve._df(t)
             discount_factors.append(df)
 
@@ -482,44 +488,44 @@
         if test_monotonicity(discount_times) is False:
             raise FinError("Coupon times not monotonic")
 
         if test_monotonicity(dividend_times) is False:
             raise FinError("Coupon times not monotonic")
 
         v1 = _value_convertible(t_mat,
-                                self._par,
+                                self.par,
                                 cpn_times,
                                 cpn_flows,
                                 call_times,
                                 call_prices,
                                 put_times,
                                 put_prices,
-                                self._conversion_ratio,
+                                self.conversion_ratio,
                                 tconv,
                                 # Market inputs
                                 stock_price,
                                 discount_times,
                                 discount_factors,
                                 dividend_times,
                                 dividend_yields,
                                 stock_volatility,
                                 credit_spread,
                                 recovery_rate,
                                 # Tree details
                                 num_steps_per_year)
 
         v2 = _value_convertible(t_mat,
-                                self._par,
+                                self.par,
                                 cpn_times,
                                 cpn_flows,
                                 call_times,
                                 call_prices,
                                 put_times,
                                 put_prices,
-                                self._conversion_ratio,
+                                self.conversion_ratio,
                                 tconv,
                                 # Market inputs
                                 stock_price,
                                 discount_times,
                                 discount_factors,
                                 dividend_times,
                                 dividend_yields,
@@ -546,79 +552,79 @@
     ###########################################################################
 
     def accrued_days(self,
                      settle_dt: Date):
         """ Calculate number days from previous coupon date to settlement."""
         self._calculate_cpn_dts(settle_dt)
 
-        if len(self._cpn_dts) <= 2:
+        if len(self.cpn_dts) <= 2:
             raise FinError("Accrued interest - not enough flow dates.")
 
-        return settle_dt - self._pcd
+        return settle_dt - self.pcd
 
     ###########################################################################
 
     def accrued_interest(self,
                          settle_dt: Date,
                          face: (float)):
         """ Calculate the amount of coupon that has accrued between the
         previous coupon date and the settlement date. """
 
-        if settle_dt != self._settle_dt:
+        if settle_dt != self.settle_dt:
             self._calculate_cpn_dts(settle_dt)
 
-        if len(self._cpn_dts) == 0:
+        if len(self.cpn_dts) == 0:
             raise FinError("Accrued interest - not enough flow dates.")
 
-        dc = DayCount(self._dc_type)
+        dc = DayCount(self.dc_type)
 
-        (acc_factor, num, _) = dc.year_frac(self._pcd,
+        (acc_factor, num, _) = dc.year_frac(self.pcd,
                                             settle_dt,
-                                            self._ncd,
-                                            self._freq)
+                                            self.ncd,
+                                            self.freq)
 
-        self._alpha = 1.0 - acc_factor * self._freq
+        self.alpha = 1.0 - acc_factor * self.freq
 
-        self._accrued = acc_factor * face * self._cpn
-        self._accrued_days = num
-        return self._accrued_interest
+        self.accrued_int = acc_factor * face * self.cpn
+        self.accrued_days = num
+        return self.accrued_int
 
     ###########################################################################
 
     def current_yield(self,
                       clean_price: float):
         """ Calculate the current yield of the bond which is the
         coupon divided by the clean price (not the full price)"""
 
-        y = self._cpn * self._par / clean_price
+        y = self.cpn * self.par / clean_price
         return y
 
     ###########################################################################
 
     def __repr__(self):
         """ Print a list of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("COUPON", self._cpn)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("CONVERSION RATIO", self._conversion_ratio)
-        s += label_to_string("START CONVERT DATE", self._start_convert_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("COUPON", self.cpn)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("CONVERSION RATIO", self.conversion_ratio)
+        s += label_to_string("START CONVERT DATE", self.start_convert_dt)
         s += label_to_string("CALL", "DATES")
 
-        for i in range(0, len(self._call_dts)):
-            s += label_to_string(self._call_dts[i],
-                                 self._call_prices[i])
+        for i in range(0, len(self.call_dts)):
+            s += label_to_string(self.call_dts[i],
+                                 self.call_prices[i])
 
         s += label_to_string("PUT", "DATES")
 
-        for i in range(0, len(self._put_dts)):
-            s += label_to_string(self._put_dts[i],
-                                 self._put_prices[i])
+        for i in range(0, len(self.put_dts)):
+            s += label_to_string(self.put_dts[i],
+                                 self.put_prices[i])
 
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_frn.py` & `financepy-0.360/financepy/products/bonds/bond_frn.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,48 +55,50 @@
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND):
         """ Create FinFloatingRateNote object given its maturity date, its
         quoted margin, coupon frequency, DAY COUNT TYPE. Face is the size of
         the position and par is the notional on which price is quoted. """
 
         check_argument_types(self.__init__, locals())
 
-        self._issue_dt = issue_dt
-        self._maturity_dt = maturity_dt
-        self._quoted_margin = quoted_margin
-        self._freq_type = freq_type
-        self._dc_type = dc_type
-        self._freq = annual_frequency(freq_type)
-        self._cal_type = cal_type
-
-        self._settle_dt = Date(1, 1, 1900)
-        self._accrued_interest = None
-        self._accrued_days = 0.0
-
-        self._cpn_dts = []
-        self._flow_amounts = []
-        self._par = 100.0  # This is how price is quoted
+        self.issue_dt = issue_dt
+        self.maturity_dt = maturity_dt
+        self.quoted_margin = quoted_margin
+        self.freq_type = freq_type
+        self.dc_type = dc_type
+        self.freq = annual_frequency(freq_type)
+        self.cal_type = cal_type
+
+        self.settle_dt = Date(1, 1, 1900)
+        self.accrued = None
+        self.accrued_days = 0.0
+        self.accrual_factor = 0.0
+        self.accrued_int = 0.0
+
+        self.cpn_dts = []
+        self.flow_amounts = []
+        self.par = 100.0  # This is how price is quoted
 
         self._calculate_cpn_dts()
 
     ###########################################################################
 
     def _calculate_cpn_dts(self):
         """ Determine the bond cashflow payment dates. """
 
         # This should only be called once from init
 
         bd_type = BusDayAdjustTypes.NONE
         dg_type = DateGenRuleTypes.BACKWARD
 
-        self._cpn_dts = Schedule(self._issue_dt,
-                                 self._maturity_dt,
-                                 self._freq_type,
-                                 self._cal_type,
-                                 bd_type,
-                                 dg_type).generate()
+        self.cpn_dts = Schedule(self.issue_dt,
+                                self.maturity_dt,
+                                self.freq_type,
+                                self.cal_type,
+                                bd_type,
+                                dg_type).generate()
 
     ###########################################################################
 
     def dirty_price_from_dm(self,
                             settle_dt: Date,
                             next_cpn: float,  # The total reset coupon on NCD
                             current_ibor: float,  # Ibor discount to NCD
@@ -105,43 +107,43 @@
         """ Calculate the full price of the bond from its discount margin (DM)
         using standard model based on assumptions about future Ibor rates. The
         next Ibor payment which has reset is entered, so to is the current
         Ibor rate from settlement to the next coupon date (NCD). Finally, there
         is the level of subsequent future Ibor payments and the discount
         margin. """
 
-        self.accrued_interest(settle_dt, next_cpn, 1.0)
+        day_counter = DayCount(self.dc_type)
 
-        day_counter = DayCount(self._dc_type)
-
-        q = self._quoted_margin
-        num_flows = len(self._cpn_dts)
+        q = self.quoted_margin
+        num_flows = len(self.cpn_dts)
 
         # We discount using Libor over the period from settlement to the ncd
-        (alpha, _, _) = day_counter.year_frac(settle_dt, self._ncd)
+        (alpha, _, _) = day_counter.year_frac(settle_dt, self.ncd)
+
         df = 1.0 / (1.0 + alpha * (current_ibor + dm))
 
         # A full coupon is paid
-        (alpha, _, _) = day_counter.year_frac(self._pcd, self._ncd)
+        (alpha, _, _) = day_counter.year_frac(self.pcd, self.ncd)
         pv = next_cpn * alpha * df
 
         # Now do all subsequent coupons that fall after the ncd
         for i_flow in range(1, num_flows):
 
-            if self._cpn_dts[i_flow] > self._ncd:
-                pcd = self._cpn_dts[i_flow - 1]
-                ncd = self._cpn_dts[i_flow]
+            if self.cpn_dts[i_flow] > self.ncd:
+
+                pcd = self.cpn_dts[i_flow - 1]
+                ncd = self.cpn_dts[i_flow]
                 (alpha, _, _) = day_counter.year_frac(pcd, ncd)
 
                 df = df / (1.0 + alpha * (future_ibor + dm))
                 c = future_ibor + q
                 pv = pv + c * alpha * df
 
         pv += df
-        pv = pv * self._par
+        pv = pv * self.par
         return pv
 
     ###########################################################################
 
     def principal(self,
                   settle_dt: Date,
                   next_cpn: float,
@@ -155,16 +157,16 @@
 
         dirty_price = self.dirty_price_from_dm(settle_dt,
                                                next_cpn,
                                                current_ibor,
                                                future_ibor,
                                                dm)
 
-        accrued = self._accrued_interest
-        principal = dirty_price * face / self._par - accrued
+        self.accrued = self.accrual_factor * next_cpn * 1.0
+        principal = dirty_price * face / self.par - self.accrued
         return principal
 
     ###########################################################################
 
     def dollar_duration(self,
                         settle_dt: Date,
                         next_cpn: float,
@@ -200,15 +202,14 @@
                                future_ibor: float,
                                dm: float):
         """ Calculate the risk or dP/dy of the bond by bumping. """
 
         if dm > 10.0:
             raise FinError("Discount margin exceeds 100000bp")
 
-        self.accrued_interest(settle_dt, next_cpn, 1.0)
         dy = 0.0001
 
         p0 = self.dirty_price_from_dm(settle_dt,
                                       next_cpn,
                                       current_ibor,
                                       future_ibor,
                                       dm + dy)
@@ -241,15 +242,15 @@
 
         fp = self.dirty_price_from_dm(settle_dt,
                                       next_cpn,
                                       current_ibor,
                                       future_ibor,
                                       dm)
 
-        md = dd * (1.0 + (next_cpn + dm) / self._freq) / fp
+        md = dd * (1.0 + (next_cpn + dm) / self.freq) / fp
         return md
 
     ###########################################################################
 
     def modified_duration(self,
                           settle_dt: Date,
                           next_cpn: float,
@@ -337,15 +338,15 @@
 
         p2 = self.dirty_price_from_dm(settle_dt,
                                       next_cpn,
                                       current_ibor + dy,
                                       future_ibor,
                                       dm)
 
-        conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self._par
+        conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self.par
         return conv
 
     ###########################################################################
 
     def clean_price_from_dm(self,
                             settle_dt: Date,
                             next_cpn: float,
@@ -364,37 +365,38 @@
 
         dirty_price = self.dirty_price_from_dm(settle_dt,
                                                next_cpn,
                                                current_ibor,
                                                future_ibor,
                                                dm)
 
-        accrued = self._accrued_interest(settle_dt, next_cpn, 1.0)
-        accrued = accrued * self._par
+        self.accrued_interest(settle_dt, next_cpn)
+
+        self.accrued = self.accrual_factor * next_cpn * self.par
 
-        clean_price = dirty_price - accrued
+        clean_price = dirty_price - self.accrued
         return clean_price
 
     ###########################################################################
 
     def discount_margin(self,
                         settle_dt: Date,
                         next_cpn: float,
                         current_ibor: float,
                         future_ibor: float,
                         clean_price: float):
         """ Calculate the bond's yield to maturity by solving the price
         yield relationship using a one-dimensional root solver. """
 
-        self.accrued_interest(settle_dt, next_cpn, 1.0)
+        self.accrued_interest(settle_dt, next_cpn)
 
-        # Needs to be adjusted to par notional
-        accrued = self._accrued_interest * self._par
+        # Accrued needs to be adjusted to par notional
+        self.accrued = self.accrual_factor * next_cpn * self.par
 
-        dirty_price = clean_price + accrued
+        dirty_price = clean_price + self.accrued
 
         argtuple = (self, settle_dt, next_cpn, current_ibor,
                     future_ibor, dirty_price)
 
         dm = optimize.newton(_f,
                              x0=0.01,  # initial value of 10%
                              fprime=None,
@@ -405,66 +407,66 @@
 
         return dm
 
     ###########################################################################
 
     def accrued_interest(self,
                          settle_dt: Date,
-                         next_cpn: float,
-                         face: (float)):
+                         next_cpn: float):
         """ Calculate the amount of coupon that has accrued between the
         previous coupon date and the settlement date. Ex-dividend dates are
         not handled. Contact me if you need this functionality. """
 
-        num_flows = len(self._cpn_dts)
+        num_flows = len(self.cpn_dts)
 
         if num_flows == 0:
             raise FinError("Accrued interest - not enough flow dates.")
 
-        dc = DayCount(self._dc_type)
+        dc = DayCount(self.dc_type)
 
         for i in range(1, num_flows):
-            if self._cpn_dts[i] > settle_dt:
-                self._pcd = self._cpn_dts[i - 1]
-                self._ncd = self._cpn_dts[i]
+            if self.cpn_dts[i] > settle_dt:
+                self.pcd = self.cpn_dts[i - 1]
+                self.ncd = self.cpn_dts[i]
                 break
 
-        (acc_factor, num, _) = dc.year_frac(self._pcd,
+        (acc_factor, num, _) = dc.year_frac(self.pcd,
                                             settle_dt,
-                                            self._ncd,
-                                            self._freq_type)
+                                            self.ncd,
+                                            self.freq_type)
 
-        self._alpha = 1.0 - acc_factor * self._freq
+        self.alpha = 1.0 - acc_factor * self.freq
+        self.accrual_factor = acc_factor
+        self.accrued_days = num
+        self.accrued_int = acc_factor * next_cpn * 1.0
 
-        self._accrued_interest = acc_factor * face * next_cpn
-        self._accrued_days = num
-        return self._accrued_interest
+        return self.accrued_int
 
     ###########################################################################
 
     def print_payments(self,
                        settle_dt: Date):
         """ Print a list of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
         self._calculate_cpn_dts()
-        for dt in self._cpn_dts[1:-1]:
+        for dt in self.cpn_dts[1:-1]:
             print(dt)
 
-        print(self._cpn_dts[-1])
+        print(self.cpn_dts[-1])
 
     ###########################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("ISSUE DATE", self._issue_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
+        s += label_to_string("ISSUE DATE", self.issue_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
         s += label_to_string("QUOTED MARGIN (bp)",
-                             self._quoted_margin * 10000.0)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
+                             self.quoted_margin * 10000.0)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_future.py` & `financepy-0.360/financepy/products/bonds/bond_future.py`

 * *Files 8% similar despite different names*

```diff
@@ -22,19 +22,19 @@
                  first_delivery_dt: Date,
                  last_delivery_dt: Date,
                  contract_size: int,
                  cpn: float):
 
         check_argument_types(self.__init__, locals())
 
-        self._ticker_name = ticker_name
-        self._first_delivery_dt = first_delivery_dt  # This is the IMM date
-        self._last_delivery_dt = last_delivery_dt
-        self._contract_size = contract_size
-        self._cpn = cpn
+        self.ticker_name = ticker_name
+        self.first_delivery_dt = first_delivery_dt  # This is the IMM date
+        self.last_delivery_dt = last_delivery_dt
+        self.contract_size = contract_size
+        self.cpn = cpn
 
 ###############################################################################
 
     def conversion_factor(self,
                           bond: Bond):
         """ Determine the conversion factor for a specific bond using CME
         convention. To do this we need to know the contract standard coupon and
@@ -42,106 +42,105 @@
         date) to the nearest 3 month multiple and then calculate the bond clean
         price. """
 
         # See
         # https://www.cmegroup.com//trading//interest-rates//us-treasury-futures-conversion-factor-lookup-tables.html
         # for a reference.
 
-        t_mat = (bond._maturity_dt - self._first_delivery_dt) / gDaysInYear
+        t_mat = (bond.maturity_dt - self.first_delivery_dt) / gDaysInYear
         roundedt_matInMonths = int(t_mat * 4.0) * 3
-        new_mat = self._first_delivery_dt.add_months(roundedt_matInMonths)
+        new_mat = self.first_delivery_dt.add_months(roundedt_matInMonths)
         ex_div_days = 0
 
-        issue_dt = Date(new_mat._d, new_mat._m, 2000)
+        issue_dt = Date(new_mat.d, new_mat.m, 2000)
 
-        newBond = Bond(issue_dt,
+        new_bond = Bond(issue_dt,
                        new_mat,
-                       bond._cpn,
-                       bond._freq_type,
-                       bond._dc_type,
+                       bond.cpn,
+                       bond.freq_type,
+                       bond.dc_type,
                        ex_div_days)
 
-        p = newBond.clean_price_from_ytm(self._first_delivery_dt,
-                                         self._cpn)
+        p = new_bond.clean_price_from_ytm(self.first_delivery_dt,
+                                          self.cpn)
 
         # Convention is to round the conversion factor to 4dp
         p = round(p, 4)
         return p
 
 ###############################################################################
 
     def principal_invoice_price(self,
                                 bond: Bond,
                                 futures_price: float):
         """ The principal invoice price as defined by the CME."""
         cf = self.conversion_factor(bond)
-        pip = self._contract_size * (futures_price * cf) / 100.0
+        pip = self.contract_size * (futures_price * cf) / 100.0
         pip = round(pip, 2)
         return pip
 
 ###############################################################################
 
     def total_invoice_amount(self,
                              settle_dt: Date,
                              bond: Bond,
                              futures_price: float):
         ' The total invoice amount paid to take delivery of bond. '
 
-        if bond._accrued_interest is None:
-            bond.calculate_cpn_dts(settle_dt)
-
-        accrued_interest = bond._accrued_interest
+        if bond.accrued_int is None:
+            bond._calculate_cpn_dts(settle_dt)
 
         pip = self.principal_invoice_price(bond, futures_price)
-        accrued = accrued_interest * self._contract_size / 100.0
+        accrued = bond.accrued_int * self.contract_size / 100.0
         tia = pip + accrued
         tia = round(tia, 2)
         return tia
 
 ###############################################################################
 
     def cheapest_to_deliver(self,
                             bonds: list,
                             bond_clean_prices: list,
                             futures_price: float):
         """ Determination of CTD as deliverable bond with the lowest cost to buy
         versus what is received when the bond is delivered. """
-        ctdBond = None
-        ctdNet = -self._contract_size * 100
+        ctd_bond = None
+        ctd_net = -self.contract_size * 100
         for bondCleanPrice, bond in zip(bond_clean_prices, bonds):
-            receiveOnFuture = self.principal_invoice_price(bond, futures_price)
-            payForBond = self._contract_size * bondCleanPrice / 100.0
-            net = receiveOnFuture - payForBond
-            if net > ctdNet:
-                ctdBond = bond
-                ctdNet = net
+            receive_on_future = self.principal_invoice_price(
+                bond, futures_price)
+            pay_for_bond = self.contract_size * bondCleanPrice / 100.0
+            net = receive_on_future - pay_for_bond
+            if net > ctd_net:
+                ctd_bond = bond
+                ctd_net = net
 
-        return ctdBond
+        return ctd_bond
 
 ###############################################################################
 
     def delivery_gain_loss(self,
                            bond: Bond,
                            bond_clean_price: float,
                            futures_price: float):
         """ Determination of what is received when the bond is delivered. """
-        receiveOnFuture = self.principal_invoice_price(bond, futures_price)
-        payForBond = self._contract_size * bond_clean_price / 100.0
-        net = receiveOnFuture - payForBond
-        return net, payForBond, receiveOnFuture
+        receive_on_future = self.principal_invoice_price(bond, futures_price)
+        pay_for_bond = self.contract_size * bond_clean_price / 100.0
+        net = receive_on_future - pay_for_bond
+        return net, pay_for_bond, receive_on_future
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("TICKER NAME", self._ticker_name)
-        s += label_to_string("FIRST DELIVERY DATE", self._first_delivery_dt)
-        s += label_to_string("LAST DELIVERY DATE", self._last_delivery_dt)
-        s += label_to_string("CONTRACT SIZE", self._contract_size)
-        s += label_to_string("COUPON", self._cpn)
+        s += label_to_string("TICKER NAME", self.ticker_name)
+        s += label_to_string("FIRST DELIVERY DATE", self.first_delivery_dt)
+        s += label_to_string("LAST DELIVERY DATE", self.last_delivery_dt)
+        s += label_to_string("CONTRACT SIZE", self.contract_size)
+        s += label_to_string("COUPON", self.cpn)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_market.py` & `financepy-0.360/financepy/products/bonds/bond_market.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/products/bonds/bond_mortgage.py` & `financepy-0.360/financepy/products/bonds/bond_mortgage.py`

 * *Files 8% similar despite different names*

```diff
@@ -42,114 +42,120 @@
         """ Create the mortgage using start and end dates and principal. """
 
         check_argument_types(self.__init__, locals())
 
         if start_dt > end_dt:
             raise FinError("Start Date after End Date")
 
-        self._start_dt = start_dt
-        self._end_dt = end_dt
-        self._principal = principal
-        self._freq_type = freq_type
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
-        self._dc_type = dc_type
+        self.start_dt = start_dt
+        self.end_dt = end_dt
+        self.principal = principal
+        self.freq_type = freq_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+        self.dc_type = dc_type
 
-        self._schedule = Schedule(start_dt,
+        self.schedule = Schedule(start_dt,
                                   end_dt,
-                                  self._freq_type,
-                                  self._cal_type,
-                                  self._bd_type,
-                                  self._dg_type)
+                                  self.freq_type,
+                                  self.cal_type,
+                                  self.bd_type,
+                                  self.dg_type)
+
+        self.mortgage_type = None
+        self.interest_flows = None
+        self.principal_flows = None
+        self.principal_remaining = None
+        self.total_flows = None
 
 ###############################################################################
 
     def repayment_amount(self,
                          zero_rate: float):
         """ Determine monthly repayment amount based on current zero rate. """
 
-        frequency = annual_frequency(self._freq_type)
+        frequency = annual_frequency(self.freq_type)
 
-        num_flows = len(self._schedule._adjusted_dts)
+        num_flows = len(self.schedule.adjusted_dts)
         p = (1.0 + zero_rate/frequency) ** (num_flows-1)
         m = zero_rate * p / (p - 1.0) / frequency
-        m = m * self._principal
+        m = m * self.principal
         return m
 
 ###############################################################################
 
     def generate_flows(self,
                        zero_rate: float,
                        mortgage_type: BondMortgageTypes):
         """ Generate the bond flow amounts. """
 
-        self._mortgage_type = mortgage_type
-        self._interest_flows = [0]
-        self._principal_flows = [0]
-        self._principal_remaining = [self._principal]
-        self._total_flows = [0]
-
-        num_flows = len(self._schedule._adjusted_dts)
-        principal = self._principal
-        frequency = annual_frequency(self._freq_type)
+        self.mortgage_type = mortgage_type
+        self.interest_flows = [0]
+        self.principal_flows = [0]
+        self.principal_remaining = [self.principal]
+        self.total_flows = [0]
+
+        num_flows = len(self.schedule.adjusted_dts)
+        principal = self.principal
+        frequency = annual_frequency(self.freq_type)
 
         if mortgage_type == BondMortgageTypes.REPAYMENT:
             monthly_flow = self.repayment_amount(zero_rate)
         elif mortgage_type == BondMortgageTypes.INTEREST_ONLY:
-            monthly_flow = zero_rate * self._principal / frequency
+            monthly_flow = zero_rate * self.principal / frequency
         else:
             raise FinError("Unknown Mortgage type.")
 
         for _ in range(1, num_flows):
             interest_flow = principal * zero_rate / frequency
             principal_flow = monthly_flow - interest_flow
             principal = principal - principal_flow
-            self._interest_flows.append(interest_flow)
-            self._principal_flows.append(principal_flow)
-            self._principal_remaining.append(principal)
-            self._total_flows.append(monthly_flow)
+            self.interest_flows.append(interest_flow)
+            self.principal_flows.append(principal_flow)
+            self.principal_remaining.append(principal)
+            self.total_flows.append(monthly_flow)
 
 ###############################################################################
 
     def print_leg(self):
-        print("START DATE:", self._start_dt)
-        print("MATURITY DATE:", self._end_dt)
-        print("MORTGAGE TYPE:", self._mortgage_type)
-        print("FREQUENCY:", self._freq_type)
-        print("CALENDAR:", self._cal_type)
-        print("BUSDAYRULE:", self._bd_type)
-        print("DATEGENRULE:", self._dg_type)
+        print("START DATE:", self.start_dt)
+        print("MATURITY DATE:", self.end_dt)
+        print("MORTGAGE TYPE:", self.mortgage_type)
+        print("FREQUENCY:", self.freq_type)
+        print("CALENDAR:", self.cal_type)
+        print("BUSDAYRULE:", self.bd_type)
+        print("DATEGENRULE:", self.dg_type)
 
-        num_flows = len(self._schedule._adjusted_dts)
+        num_flows = len(self.schedule.adjusted_dts)
 
         print("%15s %12s %12s %12s %12s" %
               ("PAYMENT DATE", "INTEREST", "PRINCIPAL",
                "OUTSTANDING", "TOTAL"))
 
         print("")
         for i in range(0, num_flows):
             print("%15s %12.2f %12.2f %12.2f %12.2f" %
-                  (self._schedule._adjusted_dts[i],
-                   self._interest_flows[i],
-                   self._principal_flows[i],
-                   self._principal_remaining[i],
-                   self._total_flows[i]))
+                  (self.schedule.adjusted_dts[i],
+                   self.interest_flows[i],
+                   self.principal_flows[i],
+                   self.principal_remaining[i],
+                   self.total_flows[i]))
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START DATE", self._start_dt)
-        s += label_to_string("MATURITY DATE", self._end_dt)
-        s += label_to_string("MORTGAGE TYPE", self._mortgage_type)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUSDAYRULE", self._bd_type)
-        s += label_to_string("DATEGENRULE", self._dg_type)
+        s += label_to_string("START DATE", self.start_dt)
+        s += label_to_string("MATURITY DATE", self.end_dt)
+        s += label_to_string("MORTGAGE TYPE", self.mortgage_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUSDAYRULE", self.bd_type)
+        s += label_to_string("DATEGENRULE", self.dg_type)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_option.py` & `financepy-0.360/financepy/products/bonds/bond_option.py`

 * *Files 10% similar despite different names*

```diff
@@ -40,45 +40,45 @@
                  bond: Bond,
                  expiry_dt: Date,
                  strike_price: float,
                  option_type: OptionTypes):
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._strike_price = strike_price
-        self._bond = bond
-        self._option_type = option_type
-        self._par = 100.0
+        self.expiry_dt = expiry_dt
+        self.strike_price = strike_price
+        self.bond = bond
+        self.option_type = option_type
+        self.par = 100.0
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               discount_curve: DiscountCurve,
               model):
         """ Value a bond option (option on a bond) using a specified model
         which include the Hull-White, Black-Karasinski and Black-Derman-Toy
         model which are all implemented as short rate tree models. """
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        t_mat = (self._bond._maturity_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        t_mat = (self.bond.maturity_dt - value_dt) / gDaysInYear
 
         df_times = discount_curve._times
         df_values = discount_curve._dfs
 
         # We need all the flows in case the option is American
         # and some occur before expiry
-        flow_dts = self._bond._cpn_dts
-        flow_amounts = self._bond._flow_amounts
+        flow_dts = self.bond.cpn_dts
+        flow_amounts = self.bond.flow_amounts
 
         cpn_times = []
         cpn_flows = []
 
-        num_flows = len(self._bond._cpn_dts)
+        num_flows = len(self.bond.cpn_dts)
 
         # Want the first flow to be the previous coupon date
         # This is needed to calculate accrued correctly
         for i in range(1, num_flows):
             pcd = flow_dts[i-1]
             ncd = flow_dts[i]
             if pcd < value_dt and ncd > value_dt:
@@ -103,43 +103,43 @@
         ##################################################################
 
         cpn_times = np.array(cpn_times)
         cpn_flows = np.array(cpn_flows)
 
         exercise_type = FinExerciseTypes.AMERICAN
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL \
-                or self._option_type == OptionTypes.EUROPEAN_PUT:
+        if self.option_type == OptionTypes.EUROPEAN_CALL \
+                or self.option_type == OptionTypes.EUROPEAN_PUT:
             exercise_type = FinExerciseTypes.EUROPEAN
 
         # This is wasteful if model is Jamshidian but how to do neat design
         model.build_tree(t_mat, df_times, df_values)
 
-        v = model.bond_option(t_exp, self._strike_price, self._par,
+        v = model.bond_option(t_exp, self.strike_price, self.par,
                               cpn_times, cpn_flows, exercise_type)
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL \
-                or self._option_type == OptionTypes.AMERICAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL \
+                or self.option_type == OptionTypes.AMERICAN_CALL:
             return v['call']
-        elif self._option_type == OptionTypes.EUROPEAN_PUT \
-                or self._option_type == OptionTypes.AMERICAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT \
+                or self.option_type == OptionTypes.AMERICAN_PUT:
             return v['put']
         else:
-            print(self._option_type)
+            print(self.option_type)
             raise FinError("Unknown option type.")
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE", self._strike_price)
-        s += label_to_string("OPTION TYPE", self._option_type)
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE", self.strike_price)
+        s += label_to_string("OPTION TYPE", self.option_type)
         s += "Underlying Bond\n"
-        s += str(self._bond)
+        s += str(self.bond)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_portfolio.py` & `financepy-0.360/financepy/products/bonds/bond_portfolio.py`

 * *Files 18% similar despite different names*

```diff
@@ -22,26 +22,26 @@
 #                  bonds: (list),
 #                  bondWeights: (list, np.ndarray)):
 #         """ XXX """
 
 #         check_argument_types(self.__init__, locals())
 
 #         self.calculateFlows()
-#         self._par = 100.0
+#         self.par = 100.0
 
 # ###############################################################################
 
 #     def _calculate_flows(self):
 #         """ Determine the bond cashflow payment amounts without principal """
 
-#         self._flow_amounts = [0.0]
+#         self.flow_amounts = [0.0]
 
-#         for _ in self._cpn_dts[1:]:
-#             cpn = self._cpn / self._freq
-#             self._flow_amounts.append(cpn)
+#         for _ in self.cpn_dts[1:]:
+#             cpn = self.cpn / self.freq
+#             self.flow_amounts.append(cpn)
 
 # ###############################################################################
 
 #     def dollar_duration(self,
 #                         settle_dt: Date,
 #                         ytm: float,
 #                         convention: YTMCalcType = YTMCalcType.UK_DMO):
@@ -61,15 +61,15 @@
 #                           ytm: float,
 #                           convention: YTMCalcType = YTMCalcType.UK_DMO):
 #         """ Calculate the Macauley duration of the bond on a settlement date
 #         given its yield to maturity. """
 
 #         dd = self.dollar_duration(settle_dt, ytm, convention)
 #         fp = self.dirty_price_from_ytm(settle_dt, ytm, convention)
-#         md = dd * (1.0 + ytm / self._freq) / fp
+#         md = dd * (1.0 + ytm / self.freq) / fp
 #         return md
 
 # ###############################################################################
 
 #     def modified_duration(self,
 #                           settle_dt: Date,
 #                           ytm: float,
@@ -91,29 +91,29 @@
 #         """ Calculate the bond convexity from the yield to maturity. This
 #         function is vectorised with respect to the yield input. """
 
 #         dy = 0.0001
 #         p0 = self.dirty_price_from_ytm(settle_dt, ytm - dy, convention)
 #         p1 = self.dirty_price_from_ytm(settle_dt, ytm, convention)
 #         p2 = self.dirty_price_from_ytm(settle_dt, ytm + dy, convention)
-#         conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self._par
+#         conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self.par
 #         return conv
 
 # ###############################################################################
 
 #     def clean_price_from_ytm(self,
 #                              settle_dt: Date,
 #                              ytm: float,
 #                              convention: YTMCalcType = YTMCalcType.UK_DMO):
 #         """ Calculate the bond clean price from the yield to maturity. This
 #         function is vectorised with respect to the yield input. """
 
 #         dirty_price = self.dirty_price_from_ytm(settle_dt, ytm,
 #                                                 convention)
-#         accrued_amount = self._accrued_interest * self._par
+#         accrued_amount = self.accrued_int* self.par
 #         clean_price = dirty_price - accrued_amount
 #         return clean_price
 
 # ###############################################################################
 
 #     def clean_price_from_discount_curve(self,
 #                                         settle_dt: Date,
@@ -136,15 +136,15 @@
 
 # ###############################################################################
 
 #     def current_yield(self, clean_price):
 #         """ Calculate the current yield of the bond which is the
 #         coupon divided by the clean price (not the full price)"""
 
-#         y = self._cpn * self._par / clean_price
+#         y = self.cpn * self.par / clean_price
 #         return y
 
 # ###############################################################################
 
 #     def yield_to_maturity(self,
 #                           settle_dt: Date,
 #                           clean_price: float,
@@ -156,34 +156,34 @@
 # ###############################################################################
 
 #     def accrued_interest(self,
 #                          settle_dt: Date,
 #                          num_ex_dividend_days: int = 0,
 #                          cal_type: CalendarTypes = CalendarTypes.WEEKEND):
 
-#         return self._accrued_interest
+#         return self.accrued_interest
 
 # ###############################################################################
 
 #     def print_payments(self,
 #                        settle_dt: Date,
 #                        face: (float)):
 #         """ Print a list of the unadjusted coupon payment dates used in
 #         analytic calculations for the bond. """
 
-#         flow = self._cpn / self._freq
+#         flow = self.cpn / self.freq
 
-#         for dt in self._cpn_dts[1:-1]:
+#         for dt in self.cpn_dts[1:-1]:
 #             # coupons paid on a settlement date are included
 #             if dt >= settle_dt:
 #                 print("%12s" % dt, " %12.2f " % flow)
 
 #         redemption_amount = face * (1.0 + flow)
 
-#         print("%12s" % self._cpn_dts[-1], " %12.2f " % redemption_amount)
+#         print("%12s" % self.cpn_dts[-1], " %12.2f " % redemption_amount)
 
 # ###############################################################################
 
 #     def dirty_price_from_survival_curve(self,
 #                                         settle_dt: Date,
 #                                         discount_curve: DiscountCurve,
 #                                         survival_curve: DiscountCurve,
@@ -192,25 +192,25 @@
 #         The survival curve treats the coupons as zero recovery payments while
 #         the recovery fraction of the par amount is paid at default. For the
 #         defaulting principal we discretise the time steps using the coupon
 #         payment times. A finer discretisation may handle the time value with
 #         more accuracy. I reduce any error by averaging period start and period
 #         end payment present values. """
 
-#         f = self._freq
-#         c = self._cpn
+#         f = self.freq
+#         c = self.cpn
 
 #         pv = 0.0
 #         prevQ = 1.0
 #         prevDf = 1.0
 
 #         defaultingPrincipalPVPayStart = 0.0
 #         defaultingPrincipalPVPayEnd = 0.0
 
-#         for dt in self._cpn_dts[1:]:
+#         for dt in self.cpn_dts[1:]:
 
 #             # coupons paid on a settlement date are included
 #             if dt >= settle_dt:
 
 #                 df = discount_curve.df(dt)
 #                 q = survival_curve.survival_prob(dt)
 
@@ -226,16 +226,16 @@
 
 #                 # Add on PV of principal if default occurs in coupon period
 #                 prevQ = q
 #                 prevDf = df
 
 #         pv = pv + 0.50 * defaultingPrincipalPVPayStart
 #         pv = pv + 0.50 * defaultingPrincipalPVPayEnd
-#         pv = pv + df * q * self._par
-#         pv *= self._par
+#         pv = pv + df * q * self.par
+#         pv *= self.par
 #         return pv
 
 # ###############################################################################
 
 #     def clean_price_from_survival_curve(self,
 #                                         settle_dt: Date,
 #                                         discount_curve: DiscountCurve,
@@ -248,27 +248,27 @@
 #         self.accrued_interest(settle_dt, 1.0)
 
 #         dirty_price = self.dirty_price_from_survival_curve(settle_dt,
 #                                                            discount_curve,
 #                                                            survival_curve,
 #                                                            recovery_rate)
 
-#         clean_price = dirty_price - self._accrued_interest
+#         clean_price = dirty_price - self.accrued_interest
 #         return clean_price
 
 # ###############################################################################
 
 #     def __repr__(self):
 
 #         s = label_to_string("OBJECT TYPE", type(self).__name__)
-#         s += label_to_string("ISSUE DATE", self._issue_dt)
-#         s += label_to_string("MATURITY DATE", self._maturity_dt)
-#         s += label_to_string("COUPON", self._cpn)
-#         s += label_to_string("FREQUENCY", self._freq_type)
-#         s += label_to_string("DAY COUNT TYPE", self._dc_type)
+#         s += label_to_string("ISSUE DATE", self.issue_dt)
+#         s += label_to_string("MATURITY DATE", self.maturity_dt)
+#         s += label_to_string("COUPON", self.cpn)
+#         s += label_to_string("FREQUENCY", self.freq_type)
+#         s += label_to_string("DAY COUNT TYPE", self.dc_type)
 #         return s
 
 # ###############################################################################
 
 #     def _print(self):
 #         """ Print a list of the unadjusted coupon payment dates used in
 #         analytic calculations for the bond. """
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_yield_curve.py` & `financepy-0.360/financepy/products/bonds/bond_yield_curve.py`

 * *Files 17% similar despite different names*

```diff
@@ -37,147 +37,149 @@
                  bonds: list,
                  ylds: (np.ndarray, list),
                  curve_fit):
         """ Fit the curve to a set of bond yields using the type of curve
         specified. Bounds can be provided if you wish to enforce lower and
         upper limits on the respective model parameters. """
 
-        self._settle_dt = settle_dt
-        self._bonds = bonds
-        self._ylds = np.array(ylds)
-        self._curve_fit = curve_fit
+        self.settle_dt = settle_dt
+        self.bonds = bonds
+        self.ylds = np.array(ylds)
+        self.curve_fit = curve_fit
 
-        fit_type = type(self._curve_fit)
+        fit_type = type(self.curve_fit)
 
-        yearsToMaturities = []
+        years_to_maturities = []
 
         for bond in bonds:
-            years_to_maturity = (bond._maturity_dt - settle_dt)/gDaysInYear
-            yearsToMaturities.append(years_to_maturity)
+            years_to_maturity = (bond.maturity_dt - settle_dt)/gDaysInYear
+            years_to_maturities.append(years_to_maturity)
 
-        self._yearsToMaturity = np.array(yearsToMaturities)
+        self.yearsToMaturity = np.array(years_to_maturities)
 
         if fit_type is CurveFitPolynomial:
 
-            d = curve_fit._power
-            coeffs = np.polyfit(self._yearsToMaturity, self._ylds, deg=d)
-            curve_fit._coeffs = coeffs
+            d = curve_fit.power
+            coeffs = np.polyfit(self.yearsToMaturity, self.ylds, deg=d)
+            curve_fit.coeffs = coeffs
 
         elif fit_type is CurveFitNelsonSiegel:
 
-            xdata = self._yearsToMaturity
-            ydata = self._ylds
+            xdata = self.yearsToMaturity
+            ydata = self.ylds
 
-            popt, pcov = scipy.optimize.curve_fit(curve_fit._interpolated_yield,
-                                   xdata, ydata, bounds=curve_fit._bounds)
-
-            curve_fit._beta_1 = popt[0]
-            curve_fit._beta_2 = popt[1]
-            curve_fit._beta_3 = popt[2]
-            curve_fit._tau = popt[3]
+            popt, pcov = scipy.optimize.curve_fit(curve_fit.interp_yield,
+                                                  xdata,
+                                                  ydata,
+                                                  bounds=curve_fit.bounds)
+
+            curve_fit.beta_1 = popt[0]
+            curve_fit.beta_2 = popt[1]
+            curve_fit.beta_3 = popt[2]
+            curve_fit.tau = popt[3]
 
         elif fit_type is CurveFitNelsonSiegelSvensson:
 
-            xdata = self._yearsToMaturity
-            ydata = self._ylds
+            xdata = self.yearsToMaturity
+            ydata = self.ylds
 
-            popt, pcov = scipy.optimize.curve_fit(curve_fit._interpolated_yield,
-                                   xdata, ydata, bounds=curve_fit._bounds)
+            popt, pcov = scipy.optimize.curve_fit(curve_fit.interp_yield,
+                                   xdata, ydata, bounds=curve_fit.bounds)
 
-            curve_fit._beta_1 = popt[0]
-            curve_fit._beta_2 = popt[1]
-            curve_fit._beta_3 = popt[2]
-            curve_fit._beta_4 = popt[3]
-            curve_fit._tau_1 = popt[4]
-            curve_fit._tau_2 = popt[5]
+            curve_fit.beta_1 = popt[0]
+            curve_fit.beta_2 = popt[1]
+            curve_fit.beta_3 = popt[2]
+            curve_fit.beta_4 = popt[3]
+            curve_fit.tau_1 = popt[4]
+            curve_fit.tau_2 = popt[5]
 
         elif fit_type is CurveFitBSpline:
 
-            xdata = self._yearsToMaturity
-            ydata = self._ylds
+            xdata = self.yearsToMaturity
+            ydata = self.ylds
 
             """ Cubic splines as k=3 """
-            spline = splrep(xdata, ydata, k=curve_fit._power, t=curve_fit._knots)
-            self._curve_fit._spline = spline
+            spline = splrep(xdata, ydata, k=curve_fit.power, t=curve_fit.knots)
+            self.curve_fit.spline = spline
 
         else:
             raise FinError("Unrecognised curve fit type.")
 
 ###############################################################################
 
-    def interpolated_yield(self,
-                           maturity_dt: Date):
+    def interp_yield(self,
+                     maturity_dt: Date):
 
         if isinstance(maturity_dt, Date):
-            t = (maturity_dt - self._settle_dt) / gDaysInYear
+            t = (maturity_dt - self.settle_dt) / gDaysInYear
         elif isinstance(maturity_dt, list):
             t = maturity_dt
         elif isinstance(maturity_dt, np.ndarray):
             t = maturity_dt
-        elif isinstance(maturity_dt, float) or type(maturity_dt) is np.float64:
+        elif isinstance(maturity_dt, float) or isinstance(maturity_dt, np.float64):
             t = maturity_dt
         else:
             raise FinError("Unknown date type.")
 
-        fit = self._curve_fit
+        fit = self.curve_fit
 
         if isinstance(fit, CurveFitPolynomial):
-            yld = fit._interpolated_yield(t)
+            yld = fit.interp_yield(t)
         elif isinstance(fit, CurveFitNelsonSiegel):
-            yld = fit._interpolated_yield(t,
-                                          fit._beta_1,
-                                          fit._beta_2,
-                                          fit._beta_3,
-                                          fit._tau)
+            yld = fit.interp_yield(t,
+                                          fit.beta_1,
+                                          fit.beta_2,
+                                          fit.beta_3,
+                                          fit.tau)
 
         elif isinstance(fit, CurveFitNelsonSiegelSvensson):
-            yld = fit._interpolated_yield(t,
-                                          fit._beta_1,
-                                          fit._beta_2,
-                                          fit._beta_3,
-                                          fit._beta_4,
-                                          fit._tau_1,
-                                          fit._tau_2)
+            yld = fit.interp_yield(t,
+                                          fit.beta_1,
+                                          fit.beta_2,
+                                          fit.beta_3,
+                                          fit.beta_4,
+                                          fit.tau_1,
+                                          fit.tau_2)
 
         elif isinstance(fit, CurveFitBSpline):
-            yld = fit._interpolated_yield(t)
+            yld = fit.interp_yield(t)
 
         return yld
 
 ###############################################################################
 
     def plot(self,
              title):
         """ Display yield curve. """
 
         plt.figure(figsize=(12, 6))
         plt.title(title)
-        bond_ylds_scaled = scale(self._ylds, 100.0)
-        plt.plot(self._yearsToMaturity, bond_ylds_scaled, 'o')
+        bond_ylds_scaled = scale(self.ylds, 100.0)
+        plt.plot(self.yearsToMaturity, bond_ylds_scaled, 'o')
         plt.xlabel('Time to Maturity (years)')
         plt.ylabel('Yield To Maturity (%)')
 
-        tmax = np.max(self._yearsToMaturity)
+        tmax = np.max(self.yearsToMaturity)
         t = np.linspace(0.0, int(tmax+0.5), 100)
 
-        yld = self.interpolated_yield(t)
+        yld = self.interp_yield(t)
         yld = scale(yld, 100.0)
-        plt.plot(t, yld, label=str(self._curve_fit))
+        plt.plot(t, yld, label=str(self.curve_fit))
         plt.legend(loc='lower right')
         plt.ylim((min(yld)-0.3, max(yld)*1.1))
         plt.grid(True)
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("SETTLEMENT DATE", self._settle_dt)
-        s += label_to_string("BOND", self._bonds)
-        s += label_to_string("YIELDS", self._ylds)
-        s += label_to_string("CURVE FIT", self._curve_fit)
+        s += label_to_string("SETTLEMENT DATE", self.settle_dt)
+        s += label_to_string("BOND", self.bonds)
+        s += label_to_string("YIELDS", self.ylds)
+        s += label_to_string("CURVE FIT", self.curve_fit)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_zero.py` & `financepy-0.360/financepy/products/bonds/bond_zero.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import numpy as np
 from scipy import optimize
 
 from ...utils.date import Date
 from ...utils.error import FinError
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.day_count import DayCount, DayCountTypes
 from ...utils.schedule import Schedule
 from ...utils.calendar import Calendar
 from ...utils.calendar import CalendarTypes
 from ...utils.calendar import BusDayAdjustTypes
 from ...utils.calendar import DateGenRuleTypes
 from ...utils.helpers import label_to_string, check_argument_types
@@ -44,15 +44,15 @@
     obj_fn = px - price
     return obj_fn
 
 ###############################################################################
 
 
 class BondZero:
-    """ A zero coupon bond is a bond which doesn't pay any periodic payments.
+    """ A zero cpn bond is a bond which doesn't pay any periodic payments.
     Instead, it is issued at a discount. The entire face value of the bond is
     paid out at maturity. It is issued as a deep discount bond.
 
     There is a special convention for accrued interest in which
 
         Accrued_interest = (par - issue price) * D
 
@@ -68,69 +68,71 @@
         face amount and issue price. """
 
         check_argument_types(self.__init__, locals())
 
         if issue_dt >= maturity_dt:
             raise FinError("Issue Date must preceded maturity date.")
 
-        self._issue_dt = issue_dt
-        self._maturity_dt = maturity_dt
-        self._dc_type = DayCountTypes.ZERO
-        self._issue_price = issue_price  # Price of issue, usually discounted
-        self._par = 100.0  # This is how price is quoted and amount at maturity
-        self._freq_type = FrequencyTypes.ZERO
-        self._cpn_dts = [issue_dt, maturity_dt]
-        self._payment_dts = [issue_dt, maturity_dt]
-        self._flow_amounts = [0.0, 0.0]  # coupon payments are zero
-        self._cal_type = CalendarTypes.WEEKEND
-        self._ex_div_days = 0
-
-        self._accrued_interest = None
-        self._accrued_days = 0.0
-        self._alpha = 0.0
+        self.issue_dt = issue_dt
+        self.maturity_dt = maturity_dt
+        self.dc_type = DayCountTypes.ZERO
+        self.issue_price = issue_price  # Price of issue, usually discounted
+        self.par = 100.0  # This is how price is quoted and amount at maturity
+        self.freq_type = FrequencyTypes.ZERO
+        self.cpn_dts = [issue_dt, maturity_dt]
+        self.payment_dts = [issue_dt, maturity_dt]
+        self.flow_amounts = [0.0, 0.0]  # cpn payments are zero
+        self.cal_type = CalendarTypes.WEEKEND
+        self.ex_div_days = 0
+
+        self.accrued_int = None
+        self.accrued_days = None
+        self.alpha = None
+        self.pcd = None
+        self.ncd = None
 
     ###########################################################################
 
     def dirty_price_from_ytm(self,
                              settle_dt: Date,
                              ytm: float,
                              convention: YTMCalcType = YTMCalcType.ZERO):
         """ Calculate the full price of bond from its yield to maturity. This
         function is vectorised with respect to the yield input. It implements
         a number of standard conventions for calculating the YTM. """
 
         if convention != YTMCalcType.ZERO:
-            raise FinError("Need to use YTMCalcType.ZERO for zero coupon bond")
+            raise FinError("Need to use YTMCalcType.ZERO for zero cpn bond")
 
         self.accrued_interest(settle_dt, 1.0)
 
         ytm = np.array(ytm)  # VECTORIZED
         ytm = ytm + 0.000000000012345  # SNEAKY LOW-COST TRICK TO AVOID y=0
 
-        # n is the number of flows after the next coupon
+        # n is the number of flows after the next cpn
         n = 0
-        for dt in self._cpn_dts:
+        for dt in self.cpn_dts:
             if dt > settle_dt:
                 n += 1
         n = n - 1
 
         if n < 0:
-            raise FinError("No coupons left")
-        # A zero coupon bond has a price equal to the discounted principal
+            raise FinError("No cpns left")
+        # A zero cpn bond has a price equal to the discounted principal
         # assuming an annualised rate raised to the power of years
 
-        dc = DayCount(self._dc_type)
+        dc = DayCount(self.dc_type)
         (acc_factor, _, _) = dc.year_frac(settle_dt,
-                                            self._maturity_dt,
-                                            self._maturity_dt,
+                                            self.maturity_dt,
+                                            self.maturity_dt,
                                             FrequencyTypes.ZERO)
         if acc_factor <= 1:
-            pv = self._par / (1.0 + ytm * acc_factor)
+            pv = self.par / (1.0 + ytm * acc_factor)
         else:
-            pv = self._par / (1.0 + ytm) ** acc_factor
+            pv = self.par / (1.0 + ytm) ** acc_factor
 
         return pv
 
     ###########################################################################
 
     def principal(self,
                   settle_dt: Date,
@@ -140,32 +142,32 @@
         """ Calculate the principal value of the bond based on the face
         amount from its discount margin and making assumptions about the
         future Ibor rates. """
 
         dirty_price = self.dirty_price_from_ytm(settle_dt, ytm,
                                                 convention)
 
-        principal = dirty_price * face / self._par
-        principal = principal - self._accrued_interest
+        principal = dirty_price * face / self.par
+        principal = principal - self.accrued_int
         return principal
 
     ###########################################################################
 
     def dollar_duration(self,
                         settle_dt: Date,
                         ytm: float,
                         convention: YTMCalcType = YTMCalcType.ZERO):
         """ Calculate the risk or dP/dy of the bond by bumping. This is also
         known as the DV01 in Bloomberg. """
 
         dy = 0.0001  # 1 basis point
         p0 = self.dirty_price_from_ytm(settle_dt, ytm - dy, convention)
         p2 = self.dirty_price_from_ytm(settle_dt, ytm + dy, convention)
-        durn = -(p2 - p0) / dy / 2.0
-        return durn
+        d = -(p2 - p0) / dy / 2.0
+        return d
 
     ###########################################################################
 
     def macauley_duration(self,
                           settle_dt: Date,
                           ytm: float,
                           convention: YTMCalcType = YTMCalcType.ZERO):
@@ -200,29 +202,29 @@
         """ Calculate the bond convexity from the yield to maturity. This
         function is vectorised with respect to the yield input. """
 
         dy = 0.0001
         p0 = self.dirty_price_from_ytm(settle_dt, ytm - dy, convention)
         p1 = self.dirty_price_from_ytm(settle_dt, ytm, convention)
         p2 = self.dirty_price_from_ytm(settle_dt, ytm + dy, convention)
-        conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self._par
+        conv = ((p2 + p0) - 2.0 * p1) / dy / dy / p1 / self.par
         return conv
 
     ###########################################################################
 
     def clean_price_from_ytm(self,
                              settle_dt: Date,
                              ytm: float,
                              convention: YTMCalcType = YTMCalcType.ZERO):
         """ Calculate the bond clean price from the yield to maturity. This
         function is vectorised with respect to the yield input. """
 
         dirty_price = self.dirty_price_from_ytm(settle_dt, ytm,
                                                 convention)
-        accrued = self.accrued_interest(settle_dt, self._par)
+        accrued = self.accrued_interest(settle_dt, self.par)
         clean_price = dirty_price - accrued
         return clean_price
 
     ###########################################################################
 
     def clean_price_from_discount_curve(self,
                                         settle_dt: Date,
@@ -230,88 +232,88 @@
         """ Calculate the clean bond value using some discount curve to
         present-value the bond's cash flows back to the curve anchor date and
         not to the settlement date. """
 
         dirty_price = self.dirty_price_from_discount_curve(settle_dt,
                                                            discount_curve)
 
-        accrued = self.accrued_interest(settle_dt, self._par)
+        accrued = self.accrued_interest(settle_dt, self.par)
         clean_price = dirty_price - accrued
         return clean_price
 
     ###########################################################################
 
     def dirty_price_from_discount_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve):
         """ Calculate the bond price using a provided discount curve to PV the
         bond's cash flows to the settlement date. As such it is effectively a
         forward bond price if the settlement date is after the valuation date.
         """
 
-        if settle_dt < discount_curve._value_dt:
+        if settle_dt < discount_curve.value_dt:
             raise FinError("Bond settles before Discount curve date")
 
-        if settle_dt > self._maturity_dt:
+        if settle_dt > self.maturity_dt:
             raise FinError("Bond settles after it matures.")
 
         px = 0.0
         df = 1.0
         df_settle = discount_curve.df(settle_dt, )
 
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
-            # coupons paid on the settlement date are paid to the seller
+            # cpns paid on the settlement date are paid to the seller
             if dt > settle_dt:
                 df = discount_curve.df(dt)
                 flow = 0
                 pv = flow * df
                 px += pv
 
-        px += df * self._par
+        px += df * self.par
         px = px / df_settle
 
-        return px * self._par
+        return px * self.par
 
     ###########################################################################
 
     def current_yield(self, clean_price):
         """
         Calculate the current yield of the bond which is the
-        coupon divided by the clean price (not the full price).
-        The coupon of a zero coupon bond is defined as:
+        cpn divided by the clean price (not the full price).
+        The cpn of a zero cpn bond is defined as:
         (par - issue_price) / tenor
         """
-        dc = DayCount(self._dc_type)
-        tenor, _, _ = dc.year_frac(self._issue_dt,
-                                   self._maturity_dt,
-                                   self._maturity_dt,
+        dc = DayCount(self.dc_type)
+        tenor, _, _ = dc.year_frac(self.issue_dt,
+                                   self.maturity_dt,
+                                   self.maturity_dt,
                                    FrequencyTypes.ZERO)
-        virtual_coupon = (self._par - self._issue_price) / tenor
-        y = virtual_coupon / clean_price
+        virtual_cpn = (self.par - self.issue_price) / tenor
+        y = virtual_cpn / clean_price
         return y
 
     ###########################################################################
 
     def yield_to_maturity(self,
                           settle_dt: Date,
                           clean_price: float,
                           convention: YTMCalcType = YTMCalcType.ZERO):
         """ Calculate the bond's yield to maturity by solving the price
         yield relationship using a one-dimensional root solver. """
 
-        if type(clean_price) is float or type(clean_price) is np.float64:
+        if isinstance(clean_price, float) or isinstance(clean_price, np.float64):
             clean_prices = np.array([clean_price])
-        elif type(clean_price) is list or type(clean_price) is np.ndarray:
+        elif isinstance(clean_price, list) or isinstance(clean_price, np.ndarray):
             clean_prices = np.array(clean_price)
         else:
             raise FinError("Unknown type for clean_price "
                            + str(type(clean_price)))
 
-        accrued_amount = self.accrued_interest(settle_dt, self._par)
+        accrued_amount = self.accrued_interest(settle_dt, self.par)
         dirty_prices = (clean_prices + accrued_amount)
 
         ytms = []
 
         for dirty_price in dirty_prices:
 
             argtuple = (self, settle_dt, dirty_price, convention)
@@ -332,167 +334,167 @@
             return np.array(ytms)
 
     ###########################################################################
 
     def accrued_interest(self,
                          settle_dt: Date,
                          face: (float)):
-        """ Calculate the amount of coupon that has accrued between the
-        previous coupon date and the settlement date. Note that for some day
+        """ Calculate the amount of cpn that has accrued between the
+        previous cpn date and the settlement date. Note that for some day
         count schemes (such as 30E/360) this is not actually the number of days
-        between the previous coupon payment date and settlement date. If the
-        bond trades with ex-coupon dates then you need to supply the number of
-        days before the coupon date the ex-coupon date is. You can specify the
+        between the previous cpn payment date and settlement date. If the
+        bond trades with ex-cpn dates then you need to supply the number of
+        days before the cpn date the ex-cpn date is. You can specify the
         calendar to be used - NONE means only calendar days, WEEKEND is only
         weekends or you can specify a country calendar for business days."""
 
-        num_flows = len(self._cpn_dts)
+        num_flows = len(self.cpn_dts)
 
         if num_flows == 0:
             raise FinError("Accrued interest - not enough flow dates.")
 
         for i_flow in range(1, num_flows):
-            # coupons paid on the settlement date are paid to the seller
-            if self._cpn_dts[i_flow] > settle_dt:
-                self._pcd = self._cpn_dts[i_flow - 1]
-                self._ncd = self._cpn_dts[i_flow]
+            # cpns paid on the settlement date are paid to the seller
+            if self.cpn_dts[i_flow] > settle_dt:
+                self.pcd = self.cpn_dts[i_flow - 1]
+                self.ncd = self.cpn_dts[i_flow]
                 break
 
-        dc = DayCount(self._dc_type)
-        cal = Calendar(self._cal_type)
-        exDividend_dt = cal.add_business_days(
-            self._ncd, -self._ex_div_days)
+        dc = DayCount(self.dc_type)
+        cal = Calendar(self.cal_type)
+        ex_dividend_dt = cal.add_business_days(
+            self.ncd, -self.ex_div_days)
 
-        (acc_factor, num, _) = dc.year_frac(self._pcd,
+        (acc_factor, num, _) = dc.year_frac(self.pcd,
                                             settle_dt,
-                                            self._ncd,
+                                            self.ncd,
                                             FrequencyTypes.ZERO)
 
-        if settle_dt > exDividend_dt:
+        if settle_dt > ex_dividend_dt:
             acc_factor = acc_factor - 1.0
 
-        self._alpha = 1.0 - acc_factor
+        self.alpha = 1.0 - acc_factor
 
-        num = (settle_dt - self._issue_dt)
-        den = (self._maturity_dt - self._issue_dt)
+        num = (settle_dt - self.issue_dt)
+        den = (self.maturity_dt - self.issue_dt)
 
         f = num / den
-        g = ((self._par - self._issue_price)) / self._par
+        g = ((self.par - self.issue_price)) / self.par
 
-        self._accrued_interest = f * g * face
-        self._accrued_days = num
+        self.accrued_int= f * g * face
+        self.accrued_days = num
 
-        return self._accrued_interest
+        return self.accrued_int
 
     ###########################################################################
 
     def asset_swap_spread(
             self,
             settle_dt: Date,
             clean_price: float,
             discount_curve: DiscountCurve,
             swapFloatDayCountConventionType=DayCountTypes.ACT_360,
-            swapFloatFrequencyType=FrequencyTypes.SEMI_ANNUAL,
-            swapFloatCalendarType=CalendarTypes.WEEKEND,
-            swapFloatBusDayAdjustRuleType=BusDayAdjustTypes.FOLLOWING,
+            swap_float_freq_type=FrequencyTypes.SEMI_ANNUAL,
+            swap_float_cal_type=CalendarTypes.WEEKEND,
+            swap_float_bus_day_adjust_rule_type=BusDayAdjustTypes.FOLLOWING,
             swapFloatDateGenRuleType=DateGenRuleTypes.BACKWARD):
         """ Calculate the par asset swap spread of the bond. The discount curve
         is a Ibor curve that is passed in. This function is vectorised with
         respect to the clean price. """
 
         clean_price = np.array(clean_price)
         self.accrued_interest(settle_dt, 1.0)
-        accrued_amount = self._accrued_interest * self._par
+        accrued_amount = self.accrued_int* self.par
         bond_price = clean_price + accrued_amount
         # Calculate the price of the bond discounted on the Ibor curve
-        pvIbor = 0.0
-        prev_dt = self._pcd
+        pv_ibor = 0.0
+        prev_dt = self.pcd
 
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
-            # coupons paid on the settlement date are paid to the seller
+            # cpns paid on the settlement date are paid to the seller
             if dt > settle_dt:
                 df = discount_curve.df(dt)
-                # pvIbor += df * self._cpn / self._freq
+                # pv_ibor += df * self.cpn / self.freq
 
-        pvIbor += df * self._par
+        pv_ibor += df * self.par
 
         # Calculate the PV01 of the floating leg of the asset swap
-        # I assume here that the coupon starts accruing on the settlement date
-        prev_dt = self._pcd
+        # I assume here that the cpn starts accruing on the settlement date
+        prev_dt = self.pcd
         schedule = Schedule(settle_dt,
-                            self._maturity_dt,
-                            swapFloatFrequencyType,
-                            swapFloatCalendarType,
-                            swapFloatBusDayAdjustRuleType,
+                            self.maturity_dt,
+                            swap_float_freq_type,
+                            swap_float_cal_type,
+                            swap_float_bus_day_adjust_rule_type,
                             swapFloatDateGenRuleType)
 
         day_count = DayCount(swapFloatDayCountConventionType)
 
-        prev_dt = self._pcd
+        prev_dt = self.pcd
         pv01 = 0.0
-        for dt in schedule._adjusted_dts[1:]:
+        for dt in schedule.adjusted_dts[1:]:
             df = discount_curve.df(dt)
             year_frac = day_count.year_frac(prev_dt, dt)[0]
             pv01 = pv01 + year_frac * df
             prev_dt = dt
 
-        asw = (pvIbor - bond_price / self._par) / pv01
+        asw = (pv_ibor - bond_price / self.par) / pv01
         return asw
 
     ###########################################################################
 
     def dirty_price_from_oas(self,
                              settle_dt: Date,
                              discount_curve: DiscountCurve,
                              oas: float):
         """ Calculate the full price of the bond from its OAS given the bond
         settlement date, a discount curve and the oas as a number. """
 
         self.accrued_interest(settle_dt, 1.0)
 
         pv = 0.0
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
-            # coupons paid on the settlement date are paid to the seller
+            # cpns paid on the settlement date are paid to the seller
             if dt > settle_dt:
                 t = (dt - settle_dt) / gDaysInYear
 
-                t = np.maximum(t, gSmall)
+                t = np.maximum(t, g_small)
 
                 df = discount_curve.df(dt)
                 # determine the Ibor implied zero rate
                 r = np.power(df, -1.0 / t) - 1.0
                 # determine the OAS adjusted zero rate
                 df_adjusted = np.power(1.0 + (r + oas), -t)
 
-        pv = pv + df_adjusted * self._par
-        pv *= self._par
+        pv = pv + df_adjusted * self.par
+        pv *= self.par
         return pv
 
     ###########################################################################
 
     def option_adjusted_spread(self,
                                settle_dt: Date,
                                clean_price: float,
                                discount_curve: DiscountCurve):
         """ Return OAS for bullet bond given settlement date, clean bond price
         and the discount relative to which the spread is to be computed. """
 
-        if type(clean_price) is float or type(clean_price) is np.float64:
+        if isinstance(clean_price, float) or isinstance(clean_price, np.float64):
             clean_prices = np.array([clean_price])
-        elif type(clean_price) is list or type(clean_price) is np.ndarray:
+        elif isinstance(clean_price, list) or isinstance(clean_price, np.ndarray):
             clean_prices = np.array(clean_price)
         else:
             raise FinError("Unknown type for clean_price "
                            + str(type(clean_price)))
 
         self.accrued_interest(settle_dt, 1.0)
 
-        accrued_amount = self._accrued_interest * self._par
+        accrued_amount = self.accrued_int* self.par
         dirty_prices = clean_prices + accrued_amount
 
         oass = []
 
         for dirty_price in dirty_prices:
             argtuple = (self, settle_dt, dirty_price, discount_curve)
 
@@ -512,99 +514,99 @@
             return np.array(oass)
 
     ###########################################################################
 
     def bond_payments(self,
                       settle_dt: Date,
                       face: (float)):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted cpn payment dates used in
         analytic calculations for the bond. """
         flow_str = ''
         flow_str += ("%12s %12.2f \n"
-                     % (self._cpn_dts[-1], face))
+                     % (self.cpn_dts[-1], face))
 
         return flow_str
 
     ###########################################################################
 
     def print_bond_payments(self,
                             settle_dt: Date,
                             face: (float) = 100.0):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted cpn payment dates used in
         analytic calculations for the bond. """
 
         print(self.bond_payments(settle_dt, face))
 
     ###########################################################################
 
     def dirty_price_from_survival_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve,
                                         survival_curve: DiscountCurve,
                                         recovery_rate: float):
         """ Calculate discounted present value of flows assuming default model.
-        The survival curve treats the coupons as zero recovery payments while
+        The survival curve treats the cpns as zero recovery payments while
         the recovery fraction of the par amount is paid at default. For the
-        defaulting principal we discretize the time steps using the coupon
+        defaulting principal we discretize the time steps using the cpn
         payment times. A finer discretization may handle the time value with
         more accuracy. I reduce any error by averaging period start and period
         end payment present values. """
 
         pv = 0.0
-        prevQ = 1.0
-        prevDf = 1.0
+        prev_q = 1.0
+        prev_df = 1.0
 
-        defaultingPrincipalPVPayStart = 0.0
-        defaultingPrincipalPVPayEnd = 0.0
+        defaulting_principal_pv_pay_start = 0.0
+        defaulting_principal_pv_pay_end = 0.0
 
-        for dt in self._cpn_dts[1:]:
+        for dt in self.cpn_dts[1:]:
 
-            # coupons paid on the settlement date are paid to the seller
+            # cpns paid on the settlement date are paid to the seller
             if dt > settle_dt:
                 df = discount_curve.df(dt)
                 q = survival_curve.survival_prob(dt)
 
-                # Add PV of coupon conditional on surviving to payment date
-                # Any default results in all subsequent coupons being lost
+                # Add PV of cpn conditional on surviving to payment date
+                # Any default results in all subsequent cpns being lost
                 # with zero recovery
 
-                dq = q - prevQ
+                dq = q - prev_q
 
-                defaultingPrincipalPVPayStart += -dq * recovery_rate * prevDf
-                defaultingPrincipalPVPayStart += -dq * recovery_rate * df
+                defaulting_principal_pv_pay_start += -dq * recovery_rate * prev_df
+                defaulting_principal_pv_pay_start += -dq * recovery_rate * df
 
-                # Add on PV of principal if default occurs in coupon period
-                prevQ = q
-                prevDf = df
-
-        pv = pv + 0.50 * defaultingPrincipalPVPayStart
-        pv = pv + 0.50 * defaultingPrincipalPVPayEnd
-        pv = pv + df * q * self._par
-        pv *= self._par
+                # Add on PV of principal if default occurs in cpn period
+                prev_q = q
+                prev_df = df
+
+        pv = pv + 0.50 * defaulting_principal_pv_pay_start
+        pv = pv + 0.50 * defaulting_principal_pv_pay_end
+        pv = pv + df * q * self.par
+        pv *= self.par
         return pv
 
     ###########################################################################
 
     def clean_price_from_survival_curve(self,
                                         settle_dt: Date,
                                         discount_curve: DiscountCurve,
                                         survival_curve: DiscountCurve,
                                         recovery_rate: float):
         """ Calculate clean price value of flows assuming default model.
-        The survival curve treats the coupons as zero recovery payments while
+        The survival curve treats the cpns as zero recovery payments while
         the recovery fraction of the par amount is paid at default. """
 
         self.accrued_interest(settle_dt, 1.0)
 
         dirty_price = self.dirty_price_from_survival_curve(settle_dt,
                                                            discount_curve,
                                                            survival_curve,
                                                            recovery_rate)
 
-        clean_price = dirty_price - self._accrued_interest
+        clean_price = dirty_price - self.accrued_int
         return clean_price
 
     ###########################################################################
 
     def calc_ror(self,
                  begin_dt: Date,
                  end_dt: Date,
@@ -613,29 +615,29 @@
                  convention: YTMCalcType = YTMCalcType.ZERO):
         """ TODO: TIDY THIS UP !!!!!!!!!!!!!!!!!
 
         Calculates the rate of total return (capital return and interest) given
         a BUY YTM and a SELL YTM of this bond.
 
         This function computes the full prices at buying and selling, plus the
-        coupon payments during the period.
+        cpn payments during the period.
 
         It returns a tuple which includes a simple rate of return, a compounded
         IRR and the PnL.
         """
 
         buy_price = self.dirty_price_from_ytm(
             begin_dt, begin_ytm, convention)
         sell_price = self.dirty_price_from_ytm(end_dt, end_ytm, convention)
 
-        dates_cfs = zip(self._cpn_dts, self._flow_amounts)
+        dates_cfs = zip(self.cpn_dts, self.flow_amounts)
 
-        # The coupon or par payments on buying date belong to the buyer.
-        # The coupon or par payments on selling date are given to the new buyer
-        dates_cfs = [(d, c * self._par)
+        # The cpn or par payments on buying date belong to the buyer.
+        # The cpn or par payments on selling date are given to the new buyer
+        dates_cfs = [(d, c * self.par)
                      for (d, c) in dates_cfs if (d >= begin_dt) and (d < end_dt)]
 
         dates_cfs.append((begin_dt, -buy_price))
 
         dates_cfs.append((end_dt, sell_price))
         times_cfs = [((d - begin_dt)/365, c) for (d, c) in dates_cfs]
 
@@ -663,23 +665,23 @@
         return simple_rtn, irr, pnl
 
 ##############################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("ISSUE DATE", self._issue_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("COUPON (%)", 0)
-        s += label_to_string("ISSUE PRICE", self._issue_price)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
+        s += label_to_string("ISSUE DATE", self.issue_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("cpn (%)", 0)
+        s += label_to_string("ISSUE PRICE", self.issue_price)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
         return s
 
     ###########################################################################
 
     def _print(self):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted cpn payment dates used in
         analytic calculations for the bond. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/bonds/bond_zero_curve.py` & `financepy-0.360/financepy/products/bonds/bond_zero_curve.py`

 * *Files 12% similar despite different names*

```diff
@@ -22,20 +22,20 @@
 ###############################################################################
 
 
 def _f(df, *args):
     curve = args[0]
     value_dt = args[1]
     bond = args[2]
-    marketCleanPrice = args[3]
+    mkt_clean_price = args[3]
     num_points = len(curve._times)
     curve._values[num_points - 1] = df
-    bondDiscountPrice = bond.clean_price_from_discount_curve(
+    bond_discount_price = bond.clean_price_from_discount_curve(
         value_dt, curve)
-    obj_fn = bondDiscountPrice - marketCleanPrice
+    obj_fn = bond_discount_price - mkt_clean_price
     return obj_fn
 
 ###############################################################################
 
 
 class BondZeroCurve(DiscountCurve):
     """ Class to do bootstrap exact fitting of the bond zero rate curve. """
@@ -47,48 +47,47 @@
                  interp_type: InterpTypes = InterpTypes.FLAT_FWD_RATES):
         """ Fit a discount curve to a set of bond yields using the type of
         curve specified. """
 
         if len(bonds) != len(clean_prices):
             raise FinError("Num bonds does not equal number of prices.")
 
-        self._settle_dt = value_dt
-        self._value_dt = value_dt
-        self._bonds = bonds
-        self._clean_prices = np.array(clean_prices)
-        self._discount_curve = None
+        self.settle_dt = value_dt
+        self.value_dt = value_dt
+        self.bonds = bonds
+        self.clean_prices = np.array(clean_prices)
+        self.discount_curve = None
         self._interp_type = interp_type
 
         times = []
-        for bond in self._bonds:
-            t_mat = (bond._maturity_dt - self._settle_dt)/gDaysInYear
+        for bond in self.bonds:
+            t_mat = (bond.maturity_dt - self.settle_dt) / gDaysInYear
             times.append(t_mat)
 
         times = np.array(times)
         if test_monotonicity(times) is False:
             raise FinError("Times are not sorted in increasing order")
 
-        self._yearsToMaturity = np.array(times)
-
+        self.yearsToMaturity = np.array(times)
         self._bootstrap_zero_rates()
 
 ###############################################################################
 
     def _bootstrap_zero_rates(self):
 
         self._times = np.array([0.0])
         self._values = np.array([1.0])
         df = 1.0
 
-        for i in range(0, len(self._bonds)):
-            bond = self._bonds[i]
-            maturity_dt = bond._maturity_dt
-            clean_price = self._clean_prices[i]
-            t_mat = (maturity_dt - self._settle_dt) / gDaysInYear
-            argtuple = (self, self._settle_dt, bond, clean_price)
+        for i in range(0, len(self.bonds)):
+            bond = self.bonds[i]
+            maturity_dt = bond.maturity_dt
+            clean_price = self.clean_prices[i]
+            t_mat = (maturity_dt - self.settle_dt) / gDaysInYear
+            argtuple = (self, self.settle_dt, bond, clean_price)
             self._times = np.append(self._times, t_mat)
             self._values = np.append(self._values, df)
 
             optimize.newton(_f, x0=df, fprime=None, args=argtuple,
                             tol=1e-8, maxiter=100, fprime2=None)
 
 ###############################################################################
@@ -142,15 +141,15 @@
     def fwd_rate(self,
                  date1: Date,
                  date2: Date,
                  day_count_type: DayCountTypes):
         """ Calculate the forward rate according to the specified
         day count convention. """
 
-        if date1 < self._value_dt:
+        if date1 < self.value_dt:
             raise FinError("Date1 before curve value date.")
 
         if date2 < date1:
             raise FinError("Date2 must not be before Date1")
 
         day_count = DayCount(day_count_type)
         year_frac = day_count.year_frac(date1, date2)[0]
@@ -166,15 +165,15 @@
         """ Display yield curve. """
 
         plt.figure(figsize=(12, 6))
         plt.title(title)
         plt.xlabel('Time to Maturity (years)')
         plt.ylabel('Zero Rate (%)')
 
-        tmax = np.max(self._yearsToMaturity)
+        tmax = np.max(self.yearsToMaturity)
         t = np.linspace(0.0, int(tmax+0.5), 100)
 
         zero_rate = self.zero_rate(t)
         zero_rate = scale(zero_rate, 100.0)
         plt.plot(t, zero_rate, label="Zero Rate Bootstrap", marker='o')
         plt.legend(loc='lower right')
         plt.ylim((min(zero_rate)-0.3, max(zero_rate)*1.1))
@@ -182,17 +181,17 @@
 
 ###############################################################################
 
     def __repr__(self):
         # TODO
         header = "TIMES,DISCOUNT FACTORS"
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        valueTable = [self._times, self._values]
+        value_table = [self._times, self._values]
         precision = "10.7f"
-        s += table_to_string(header, valueTable, precision)
+        s += table_to_string(header, value_table, precision)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/bonds/curve_fits.py` & `financepy-0.360/financepy/products/bonds/curve_fits.py`

 * *Files 12% similar despite different names*

```diff
@@ -15,79 +15,79 @@
 
 ###############################################################################
 
 
 class CurveFitPolynomial():
 
     def __init__(self, power=3):
-        self._parent_type = FinCurveFitMethod
-        self._power = power
-        self._coeffs = []
+        self.parent_type = FinCurveFitMethod
+        self.power = power
+        self.coeffs = []
 
-    def _interpolated_yield(self, t):
-        yld = np.polyval(self._coeffs, t)
+    def interp_yield(self, t):
+        yld = np.polyval(self.coeffs, t)
         return yld
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("Power", self._power)
+        s += label_to_string("Power", self.power)
 
-        for c in self._coeffs:
+        for c in self.coeffs:
             s += label_to_string("Coefficient", c)
 
         return s
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
 
 ###############################################################################
 
 
 class CurveFitNelsonSiegel():
 
     def __init__(self, tau=None, bounds=[(-1, -1, -1, 0.5), (1, 1, 1, 100)]):
-        self._parent_type = FinCurveFitMethod
-        self._beta_1 = None
-        self._beta_2 = None
-        self._beta_3 = None
-        self._tau = tau
+        self.parent_type = FinCurveFitMethod
+        self.beta_1 = None
+        self.beta_2 = None
+        self.beta_3 = None
+        self.tau = tau
         """ Fairly permissive bounds. Only tau_1 is 1-100 """
-        self._bounds = bounds
+        self.bounds = bounds
 
-    def _interpolated_yield(self, t, beta_1=None, beta_2=None,
-                            beta_3=None, tau=None):
+    def interp_yield(self, t, beta_1=None, beta_2=None,
+                              beta_3=None, tau=None):
 
         t = np.maximum(t, 1e-10)
 
         if beta_1 is None:
-            beta_1 = self._beta_1
+            beta_1 = self.beta_1
 
         if beta_2 is None:
-            beta_2 = self._beta_2
+            beta_2 = self.beta_2
 
         if beta_3 is None:
-            beta_3 = self._beta_3
+            beta_3 = self.beta_3
 
         if tau is None:
-            tau = self._tau
+            tau = self.tau
 
         theta = t / tau
         exp_term = np.exp(-theta)
         yld = beta_1
         yld += beta_2 * (1.0 - exp_term) / theta
         yld += beta_3 * ((1.0 - exp_term) / theta - exp_term)
         return yld
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("beta_1", self._beta_1)
-        s += label_to_string("beta_2", self._beta_2)
-        s += label_to_string("beta_3", self._beta_3)
-        s += label_to_string("Tau", self._tau)
+        s += label_to_string("beta_1", self.beta_1)
+        s += label_to_string("beta_2", self.beta_2)
+        s += label_to_string("beta_3", self.beta_3)
+        s += label_to_string("Tau", self.tau)
         return s
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
 
 ###############################################################################
@@ -96,95 +96,95 @@
 class CurveFitNelsonSiegelSvensson():
 
     def __init__(self, tau_1=None, tau_2=None,
                  bounds=[(0, -1, -1, -1, 0, 1), (1, 1, 1, 1, 10, 100)]):
         """ Create object to store calibration and functional form of NSS
         parametric fit. """
 
-        self._parent_type = FinCurveFitMethod
-        self._beta_1 = None
-        self._beta_2 = None
-        self._beta_3 = None
-        self._beta_4 = None
-        self._tau_1 = tau_1
-        self._tau_2 = tau_2
+        self.parent_type = FinCurveFitMethod
+        self.beta_1 = None
+        self.beta_2 = None
+        self.beta_3 = None
+        self.beta_4 = None
+        self.tau_1 = tau_1
+        self.tau_2 = tau_2
 
         """ I impose some bounds to help ensure a sensible result if
         the user does not provide any bounds. Especially for tau_2. """
-        self._bounds = bounds
+        self.bounds = bounds
 
-    def _interpolated_yield(self, t, beta_1=None, beta_2=None, beta_3=None,
+    def interp_yield(self, t, beta_1=None, beta_2=None, beta_3=None,
                             beta_4=None, tau_1=None, tau_2=None):
 
         # Careful if we get a time zero point
         t = np.maximum(t, 1e-10)
 
         if beta_1 is None:
-            beta_1 = self._beta_1
+            beta_1 = self.beta_1
 
         if beta_2 is None:
-            beta_2 = self._beta_2
+            beta_2 = self.beta_2
 
         if beta_3 is None:
-            beta_3 = self._beta_3
+            beta_3 = self.beta_3
 
         if beta_4 is None:
-            beta_4 = self._beta_4
+            beta_4 = self.beta_4
 
         if tau_1 is None:
-            tau_1 = self._tau_1
+            tau_1 = self.tau_1
 
         if tau_2 is None:
-            tau_2 = self._tau_2
+            tau_2 = self.tau_2
 
         theta1 = t / tau_1
         theta2 = t / tau_2
         exp_term1 = np.exp(-theta1)
         exp_term2 = np.exp(-theta2)
         yld = beta_1
         yld += beta_2 * (1.0 - exp_term1) / theta1
         yld += beta_3 * ((1.0 - exp_term1) / theta1 - exp_term1)
         yld += beta_4 * ((1.0 - exp_term2) / theta2 - exp_term2)
         return yld
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("beta_1", self._beta_1)
-        s += label_to_string("beta_2", self._beta_2)
-        s += label_to_string("beta_3", self._beta_3)
-        s += label_to_string("beta_4", self._beta_3)
-        s += label_to_string("tau_1", self._tau_1)
-        s += label_to_string("tau_2", self._tau_2)
+        s += label_to_string("beta_1", self.beta_1)
+        s += label_to_string("beta_2", self.beta_2)
+        s += label_to_string("beta_3", self.beta_3)
+        s += label_to_string("beta_4", self.beta_3)
+        s += label_to_string("tau_1", self.tau_1)
+        s += label_to_string("tau_2", self.tau_2)
         return s
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
 
 ###############################################################################
 
 
 class CurveFitBSpline():
 
     def __init__(self, power=3, knots=[1, 3, 5, 10]):
-        self._parent_type = FinCurveFitMethod
-        self._power = power
-        self._knots = knots
-        self._spline = None
+        self.parent_type = FinCurveFitMethod
+        self.power = power
+        self.knots = knots
+        self.spline = None
 
-    def _interpolated_yield(self, t):
+    def interp_yield(self, t):
         t = np.maximum(t, 1e-10)
-        yld = splev(t, self._spline)
+        yld = splev(t, self.spline)
         return yld
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("Power", self._power)
-        s += label_to_string("Knots", self._knots)
-        s += label_to_string("Spline", self._spline)
+        s += label_to_string("Power", self.power)
+        s += label_to_string("Knots", self.knots)
+        s += label_to_string("Spline", self.spline)
         return s
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/credit/cds.py` & `financepy-0.360/financepy/products/credit/cds.py`

 * *Files 13% similar despite different names*

```diff
@@ -17,172 +17,172 @@
 from ...utils.global_vars import gDaysInYear
 from ...utils.math import ONE_MILLION
 from ...utils.helpers import label_to_string, table_to_string
 from ...market.curves.interpolator import InterpTypes, _uinterpolate
 
 from ...utils.helpers import check_argument_types
 
-use_flat_hazard_rate_integral = True
-standard_recovery_rate = 0.40
-glob_num_steps_per_year = 25
+USE_FLAT_HAZARD_RATE_INTEGRAL = True
+STANDARD_RECOVERY_RATE = 0.40
+GLOB_NUM_STEPS_PER_YEAR = 25
 
 ###############################################################################
 # TODO: Perform protection leg pv analytically using fact that hazard rate and
 #       interest rates are flat between their combined node points. Right now I
 #       do not find the protection leg PV calculations to be a bottleneck,
 #       especially given the speedup benefits of using NUMBA.
 ###############################################################################
 
 
 @njit(float64[:](float64, float64, float64[:], float64[:], float64[:],
                  float64[:], float64[:], float64[:], int64),
       fastmath=True, cache=True)
 def _risky_pv01_numba(teff,
-                      accrual_factorPCDToNow,
+                      accrual_factor_pcd_to_now,
                       payment_times,
                       year_fracs,
-                      npIborTimes,
-                      npIborValues,
-                      npSurvTimes,
-                      npSurvValues,
+                      np_ibor_times,
+                      np_ibor_values,
+                      np_surv_times,
+                      np_surv_values,
                       pv01_method):
     """ Fast calculation of the risky PV01 of a CDS using NUMBA.
     The output is a numpy array of the full and clean risky PV01."""
 
     method = InterpTypes.FLAT_FWD_RATES.value
 
     if 1 == 0:
         print("===================")
         print("Teff", teff)
-        print("Acc", accrual_factorPCDToNow)
+        print("Acc", accrual_factor_pcd_to_now)
         print("Payments", payment_times)
         print("Alphas", year_fracs)
-        print("QTimes", npSurvTimes)
-        print("QValues", npSurvValues)
+        print("QTimes", np_surv_times)
+        print("QValues", np_surv_values)
 
     cpnAccruedIndicator = 1
 
     # Method 0 : This is the market standard which assumes that the cpn
     # accrued is treated as though on average default occurs roughly midway
     # through a cpn period.
 
     tncd = payment_times[0]
 
     # The first cpn is a special case which needs to be handled carefully
     # taking into account what cpn has already accrued and what has not
-    qeff = _uinterpolate(teff, npSurvTimes, npSurvValues, method)
-    q1 = _uinterpolate(tncd, npSurvTimes, npSurvValues, method)
-    z1 = _uinterpolate(tncd, npIborTimes, npIborValues, method)
+    qeff = _uinterpolate(teff, np_surv_times, np_surv_values, method)
+    q1 = _uinterpolate(tncd, np_surv_times, np_surv_values, method)
+    z1 = _uinterpolate(tncd, np_ibor_times, np_ibor_values, method)
 
     # this is the part of the cpn accrued from previous cpn date to now
-    # accrual_factorPCDToNow = day_count.year_frac(pcd,teff)
+    # accrual_factor_pcd_to_now = day_count.year_frac(pcd,teff)
 
     # reference credit survives to the premium payment date
     full_rpv01 = q1 * z1 * year_fracs[1]
 
     # cpn accrued from previous cpn to today paid in full at default
     # before cpn payment
     full_rpv01 = full_rpv01 + z1 * \
-        (qeff - q1) * accrual_factorPCDToNow * cpnAccruedIndicator
+        (qeff - q1) * accrual_factor_pcd_to_now * cpnAccruedIndicator
 
     # future accrued from now to cpn payment date assuming default roughly
     # midway
     full_rpv01 += 0.5 * z1 * \
-        (qeff - q1) * (year_fracs[1] - accrual_factorPCDToNow) \
+        (qeff - q1) * (year_fracs[1] - accrual_factor_pcd_to_now) \
         * cpnAccruedIndicator
 
     for it in range(1, len(payment_times)):
 
         t2 = payment_times[it]
 
-        q2 = _uinterpolate(t2, npSurvTimes, npSurvValues, method)
-        z2 = _uinterpolate(t2, npIborTimes, npIborValues, method)
+        q2 = _uinterpolate(t2, np_surv_times, np_surv_values, method)
+        z2 = _uinterpolate(t2, np_ibor_times, np_ibor_values, method)
 
         accrual_factor = year_fracs[it]
 
         # full cpn is paid at the end of the current period if survives to
         # payment date
         full_rpv01 += q2 * z2 * accrual_factor
 
         #######################################################################
 
         if cpnAccruedIndicator == 1:
 
-            if use_flat_hazard_rate_integral:
+            if USE_FLAT_HAZARD_RATE_INTEGRAL:
                 # This needs to be updated to handle small h+r
                 tau = accrual_factor
                 h12 = -log(q2 / q1) / tau
                 r12 = -log(z2 / z1) / tau
                 alpha = h12 + r12
-                expTerm = 1.0 - exp(-alpha * tau) - alpha * \
+                exp_term = 1.0 - exp(-alpha * tau) - alpha * \
                     tau * exp(-alpha * tau)
                 d_full_rpv01 = q1 * z1 * h12 * \
-                    expTerm / abs(alpha * alpha + 1e-20)
+                    exp_term / abs(alpha * alpha + 1e-20)
             else:
                 d_full_rpv01 = 0.50 * (q1 - q2) * z2 * accrual_factor
 
             full_rpv01 = full_rpv01 + d_full_rpv01
 
         q1 = q2
 
-    clean_rpv01 = full_rpv01 - accrual_factorPCDToNow
+    clean_rpv01 = full_rpv01 - accrual_factor_pcd_to_now
 
     return np.array([full_rpv01, clean_rpv01])
 
 ###############################################################################
 
 
 @njit(float64(float64, float64, float64[:], float64[:], float64[:], float64[:],
               float64, int64, int64), fastmath=True, cache=True)
-def _protection_leg_pv_numba(teff,
+def _prot_leg_pv_numba(teff,
                              t_mat,
-                             npIborTimes,
-                             npIborValues,
-                             npSurvTimes,
-                             npSurvValues,
+                             np_ibor_times,
+                             np_ibor_values,
+                             np_surv_times,
+                             np_surv_values,
                              contract_recovery_rate,
                              num_steps_per_year,
                              prot_method):
     """ Fast calculation of the CDS protection leg PV using NUMBA to speed up
     the numerical integration over time. """
 
     method = InterpTypes.FLAT_FWD_RATES.value
     dt = 1.0 / num_steps_per_year
     num_steps = int((t_mat-teff) * num_steps_per_year + 0.50)
     dt = (t_mat - teff) / num_steps
 
     t = teff
-    z1 = _uinterpolate(t, npIborTimes, npIborValues, method)
-    q1 = _uinterpolate(t, npSurvTimes, npSurvValues, method)
+    z1 = _uinterpolate(t, np_ibor_times, np_ibor_values, method)
+    q1 = _uinterpolate(t, np_surv_times, np_surv_values, method)
 
     prot_pv = 0.0
     small = 1e-8
 
-    if use_flat_hazard_rate_integral:
+    if USE_FLAT_HAZARD_RATE_INTEGRAL:
 
         for _ in range(0, num_steps):
             t = t + dt
-            z2 = _uinterpolate(t, npIborTimes, npIborValues, method)
-            q2 = _uinterpolate(t, npSurvTimes, npSurvValues, method)
+            z2 = _uinterpolate(t, np_ibor_times, np_ibor_values, method)
+            q2 = _uinterpolate(t, np_surv_times, np_surv_values, method)
             # This needs to be updated to handle small h+r
             h12 = -log(q2 / q1) / dt
             r12 = -log(z2 / z1) / dt
-            expTerm = exp(-(r12 + h12) * dt)
-            dprot_pv = h12 * (1.0 - expTerm) * q1 * z1 / \
+            exp_term = exp(-(r12 + h12) * dt)
+            dprot_pv = h12 * (1.0 - exp_term) * q1 * z1 / \
                 (abs(h12 + r12) + small)
             prot_pv += dprot_pv
             q1 = q2
             z1 = z2
 
     else:
 
         for _ in range(0, num_steps):
             t += dt
-            z2 = _uinterpolate(t, npIborTimes, npIborValues, method)
-            q2 = _uinterpolate(t, npSurvTimes, npSurvValues, method)
+            z2 = _uinterpolate(t, np_ibor_times, np_ibor_values, method)
+            q2 = _uinterpolate(t, np_surv_times, np_surv_values, method)
             dq = q1 - q2
             dprot_pv = 0.5 * (z1 + z2) * dq
             prot_pv += dprot_pv
             q1 = q2
             z1 = z2
 
     prot_pv = prot_pv * (1.0 - contract_recovery_rate)
@@ -198,224 +198,223 @@
     generation and the valuation and risk management of CDS. """
 
     def __init__(self,
                  step_in_dt: Date,  # Date protection starts
                  maturity_dt_or_tenor: (Date, str),  # Date or tenor
                  running_cpn: float,  # Annualised cpn on premium fee leg
                  notional: float = ONE_MILLION,
-                 long_protection: bool = True,
+                 long_protect: bool = True,
                  freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  dc_type: DayCountTypes = DayCountTypes.ACT_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create a CDS from the step-in date, maturity date and cpn """
 
         check_argument_types(self.__init__, locals())
 
-        if type(maturity_dt_or_tenor) == Date:
+        if isinstance(maturity_dt_or_tenor, Date):
             maturity_dt = maturity_dt_or_tenor
         else:
             # To get the next CDS date we move on by the tenor and then roll to
             # the next CDS date after that. We do not holiday adjust it. That
             # is handled in the schedule generation.
             maturity_dt = step_in_dt.add_tenor(maturity_dt_or_tenor)
             maturity_dt = maturity_dt.next_cds_date()
 
         if step_in_dt > maturity_dt:
             raise FinError("Step in date after maturity date")
 
-        self._step_in_dt = step_in_dt
-        self._maturity_dt = maturity_dt
-        self._running_cpn = running_cpn
-        self._notional = notional
-        self._long_protection = long_protection
-        self._dc_type = dc_type
-        self._dg_type = dg_type
-        self._cal_type = cal_type
-        self._freq_type = freq_type
-        self._bd_type = bd_type
+        self.step_in_dt = step_in_dt
+        self.maturity_dt = maturity_dt
+        self.running_cpn = running_cpn
+        self.notional = notional
+        self.long_protect = long_protect
+        self.dc_type = dc_type
+        self.dg_type = dg_type
+        self.cal_type = cal_type
+        self.freq_type = freq_type
+        self.bd_type = bd_type
 
         self._generate_adjusted_cds_payment_dts()
         self._calc_flows()
 
     ###########################################################################
 
     def _generate_adjusted_cds_payment_dts(self):
         """ Generate CDS payment dates which have been holiday adjusted."""
 
-        frequency = annual_frequency(self._freq_type)
-        calendar = Calendar(self._cal_type)
-        start_dt = self._step_in_dt
-
-        self._payment_dts = []
-        self._accrual_start_dts = []
-        self._accrual_end_dts = []
+        frequency = annual_frequency(self.freq_type)
+        calendar = Calendar(self.cal_type)
+        start_dt = self.step_in_dt
+
+        self.payment_dts = []
+        self.accrual_start_dts = []
+        self.accrual_end_dts = []
         num_months = int(12.0 / frequency)
 
         # We generate unadjusted dates - not adjusted for weekends or holidays
         unadjusted_schedule_dts = []
 
-        if self._dg_type == DateGenRuleTypes.BACKWARD:
+        if self.dg_type == DateGenRuleTypes.BACKWARD:
 
             # We start at end date and step backwards
 
-            next_dt = self._maturity_dt
+            next_dt = self.maturity_dt
 
             unadjusted_schedule_dts.append(next_dt)
 
             # the unadjusted dates start at end date and end at previous
             # cpn date
             while next_dt > start_dt:
                 next_dt = next_dt.add_months(-num_months)
                 unadjusted_schedule_dts.append(next_dt)
 
             # now we adjust for holiday using business day adjustment
             # convention specified
             adjusted_dts = []
 
             for date in reversed(unadjusted_schedule_dts):
-                adjusted = calendar.adjust(date, self._bd_type)
+                adjusted = calendar.adjust(date, self.bd_type)
                 adjusted_dts.append(adjusted)
 
 # eg: https://www.cdsmodel.com/assets/cds-model/docs/Standard%20CDS%20Examples.pdf
 # Payment       = [20-MAR-2009, 22-JUN-2009, 21-SEP-2009, 21-DEC-2009, 22-MAR-2010]
 # Accrual Start = [22-DEC-2008, 20-MAR-2009, 22-JUN-2009, 21-SEP-2009, 21-DEC-2009]
 # Accrual End   = [19-MAR-2009, 21-JUN-2009, 20-SEP-2009, 20-DEC-2009, 20-MAR-2010]
 
-        elif self._dg_type == DateGenRuleTypes.FORWARD:
+        elif self.dg_type == DateGenRuleTypes.FORWARD:
 
             # We start at start date and step forwards
 
             next_dt = start_dt
 
             # the unadjusted dates start at start date and end at last date
             # before maturity date
-            while next_dt < self._maturity_dt:
+            while next_dt < self.maturity_dt:
                 unadjusted_schedule_dts.append(next_dt)
                 next_dt = next_dt.add_months(num_months)
 
             # We then append the maturity date
-            unadjusted_schedule_dts.append(self._maturity_dt)
+            unadjusted_schedule_dts.append(self.maturity_dt)
 
             adjusted_dts = []
             for date in unadjusted_schedule_dts:
-                adjusted = calendar.adjust(date, self._bd_type)
+                adjusted = calendar.adjust(date, self.bd_type)
                 adjusted_dts.append(adjusted)
 
     # eg. Date(20, 2, 2009) to Date(20, 3, 2010) with DateGenRuleTypes.FORWARD
     # Payment       = [20-MAY-2009, 20-AUG-2009, 20-NOV-2009, 22-FEB-2010]
     # Accrual Start = [20-FEB-2009, 20-MAY-2009, 20-AUG-2009, 20-NOV-2009]
     # Accrual End   = [19-MAY-2009, 19-AUG-2009, 19-NOV-2009, 20-MAR-2010]
 
         else:
 
-            raise FinError("Unknown DateGenRuleType:"
-                           + str(self._dg_type))
+            raise FinError("Unknown DateGenRuleType:" + str(self.dg_type))
 
         # We only include dates which fall after the CDS start date
-        self._payment_dts = adjusted_dts[1:]
+        self.payment_dts = adjusted_dts[1:]
 
         # Accrual start dates run from previous cpn date to penultimate
         # cpn date
-        self._accrual_start_dts = adjusted_dts[:-1]
+        self.accrual_start_dts = adjusted_dts[:-1]
 
         # Accrual end dates are one day before the start of the next
         # accrual period
-        self._accrual_end_dts = [
-            date.add_days(-1) for date in self._accrual_start_dts[1:]]
+        self.accrual_end_dts = [
+            date.add_days(-1) for date in self.accrual_start_dts[1:]]
 
         # Final accrual end date is the maturity date
-        self._accrual_end_dts.append(self._maturity_dt)
+        self.accrual_end_dts.append(self.maturity_dt)
 
     ###########################################################################
 
     def _calc_flows(self):
         """ Calculate cash flow amounts on premium leg. """
-        day_count = DayCount(self._dc_type)
+        day_count = DayCount(self.dc_type)
 
-        self._accrual_factors = []
-        self._flows = []
+        self.accrual_factors = []
+        self.flows = []
 
-        # self._accrual_factors.append(0.0)
-        # self._flows.append(0.0)
+        # self.accrual_factors.append(0.0)
+        # self.flows.append(0.0)
 
-        for t0, t1 in zip(self._accrual_start_dts, self._accrual_end_dts):
+        for t0, t1 in zip(self.accrual_start_dts, self.accrual_end_dts):
             # Adding a day because `year_frac` is non-inclusive
             # eg. 20th to 22nd should be 3 days
             accrual_factor = day_count.year_frac(t0, t1.add_days(1))[0]
-            flow = accrual_factor * self._running_cpn * self._notional
+            flow = accrual_factor * self.running_cpn * self.notional
 
-            self._accrual_factors.append(accrual_factor)
-            self._flows.append(flow)
+            self.accrual_factors.append(accrual_factor)
+            self.flows.append(flow)
 
     ###########################################################################
 
     def value(self,
               value_dt,
               issuer_curve,
               contract_recovery_rate,
               pv01_method=0,
               prot_method=0,
-              num_steps_per_year=glob_num_steps_per_year):
+              num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR):
         """ Valuation of a CDS contract on a specific valuation date given
         an issuer curve and a contract recovery rate."""
 
         rpv01 = self.risky_pv01(value_dt,
                                 issuer_curve,
                                 pv01_method)
 
-        dirtyRPV01 = rpv01['dirty_rpv01']
+        dirty_rpv01 = rpv01['dirty_rpv01']
         clean_rpv01 = rpv01['clean_rpv01']
 
-        prot_pv = self.protection_leg_pv(value_dt,
+        prot_pv = self.prot_leg_pv(value_dt,
                                          issuer_curve,
                                          contract_recovery_rate,
                                          num_steps_per_year,
                                          prot_method)
 
-        fwdDf = 1.0
+        fwd_df = 1.0
 
-        if self._long_protection:
-            longProt = +1
+        if self.long_protect:
+            long_prot = +1
         else:
-            longProt = -1
+            long_prot = -1
 
-        dirtyPV = fwdDf * longProt * \
-            (prot_pv - self._running_cpn * dirtyRPV01 * self._notional)
-        clean_pv = fwdDf * longProt * \
-            (prot_pv - self._running_cpn * clean_rpv01 * self._notional)
+        dirty_pv = fwd_df * long_prot * \
+            (prot_pv - self.running_cpn * dirty_rpv01 * self.notional)
+        clean_pv = fwd_df * long_prot * \
+            (prot_pv - self.running_cpn * clean_rpv01 * self.notional)
 
-        return {'dirty_pv': dirtyPV, 'clean_pv': clean_pv}
+        return {'dirty_pv': dirty_pv, 'clean_pv': clean_pv}
 
     ###########################################################################
 
     def credit_dv01(self,
                     value_dt,
                     issuer_curve,
                     contract_recovery_rate,
                     pv01_method=0,
                     prot_method=0,
-                    num_steps_per_year=glob_num_steps_per_year):
+                    num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR):
         """ Calculation of the change in the value of the CDS contract for a
         one basis point change in the level of the CDS curve."""
 
         v0 = self.value(value_dt,
                         issuer_curve,
                         contract_recovery_rate,
                         pv01_method,
                         prot_method,
                         num_steps_per_year)
 
         bump = 0.0001  # 1 basis point
 
         # we create a deep copy to avoid state issues
         bumpedIssuerCurve = deepcopy(issuer_curve)
-        for cds in bumpedIssuerCurve._cds_contracts:
-            cds._running_cpn += bump
+        for cds in bumpedIssuerCurve.cds_contracts:
+            cds.running_cpn += bump
 
         bumpedIssuerCurve._build_curve()
 
         v1 = self.value(value_dt,
                         bumpedIssuerCurve,
                         contract_recovery_rate,
                         pv01_method,
@@ -429,15 +428,15 @@
 
     def interest_dv01(self,
                       value_dt: Date,
                       issuer_curve,
                       contract_recovery_rate,
                       pv01_method: int = 0,
                       prot_method: int = 0,
-                      num_steps_per_year=glob_num_steps_per_year):
+                      num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR):
         """ Calculation of the interest DV01 based on a simple bump of
         the discount factors and reconstruction of the CDS curve. """
 
         v0 = self.value(value_dt,
                         issuer_curve,
                         contract_recovery_rate,
                         pv01_method,
@@ -445,37 +444,37 @@
                         num_steps_per_year)
 
         # we create a deep copy to avoid state issues
         new_issuer_curve = deepcopy(issuer_curve)
 
         bump = 0.0001  # 1 basis point
 
-        for depo in new_issuer_curve._libor_curve._usedDeposits:
+        for depo in new_issuer_curve.libor_curve.used_deposits:
 
-            depo._deposit_rate += bump
+            depo.deposit_rate += bump
 
-        for fra in new_issuer_curve._libor_curve._usedFRAs:
+        for fra in new_issuer_curve.libor_curve.used_fras:
 
-            fra._fraRate += bump
+            fra.fra_rate += bump
 
-        for swap in new_issuer_curve._libor_curve._usedSwaps:
+        for swap in new_issuer_curve.libor_curve.used_swaps:
 
-            cpn = swap._fixed_leg._cpn
-            swap._fixed_leg._cpn = cpn + bump
+            cpn = swap.fixed_leg.cpn
+            swap.fixed_leg.cpn = cpn + bump
 
             # Need to regenerate fixed leg payments with bumped cpn
-            # I could call swap._fixed_leg.generate_payments() but it is
+            # I could call swap.fixed_leg.generate_payments() but it is
             # overkill as it has to do all the schedule generation which is
             # not needed as the dates are unchanged
-            num_payments = len(swap._fixed_leg._payments)
+            num_payments = len(swap.fixed_leg.payments)
             for i in range(0, num_payments):
-                old_pmt = swap._fixed_leg._payments[i]
-                swap._fixed_leg._payments[i] = old_pmt * (cpn + bump) / cpn
+                old_pmt = swap.fixed_leg.payments[i]
+                swap.fixed_leg.payments[i] = old_pmt * (cpn + bump) / cpn
 
-        new_issuer_curve._libor_curve._build_curve()
+        new_issuer_curve.libor_curve._build_curve()
         new_issuer_curve._build_curve()
 
         v1 = self.value(value_dt,
                         new_issuer_curve,
                         contract_recovery_rate,
                         pv01_method,
                         prot_method,
@@ -489,326 +488,327 @@
     def cash_settlement_amount(self,
                                value_dt,
                                settle_dt,
                                issuer_curve,
                                contract_recovery_rate,
                                pv01_method=0,
                                prot_method=0,
-                               num_steps_per_year=glob_num_steps_per_year):
+                               num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR):
         """ Value of the contract on the settlement date including accrued
         interest. """
 
         v = self.value(value_dt,
                        issuer_curve,
                        contract_recovery_rate,
                        pv01_method,
                        prot_method,
                        num_steps_per_year)
 
-        libor_curve = issuer_curve._libor_curve
+        libor_curve = issuer_curve.libor_curve
         df = libor_curve.df(settle_dt)
         v = v / df
         return v
 
     ###########################################################################
 
     def clean_price(self,
                     value_dt,
                     issuer_curve,
                     contract_recovery_rate,
                     pv01_method=0,
                     prot_method=0,
-                    num_steps_per_year=glob_num_steps_per_year):
+                    num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR):
         """ Value of the CDS contract excluding accrued interest. """
 
         risky_pv01 = self.risky_pv01(value_dt, issuer_curve, pv01_method)
 
         clean_rpv01 = risky_pv01['clean_rpv01']
 
-        prot_pv = self.protection_leg_pv(value_dt,
+        prot_pv = self.prot_leg_pv(value_dt,
                                          issuer_curve,
                                          contract_recovery_rate,
                                          num_steps_per_year,
                                          prot_method)
 
-        fwdDf = 1.0
+        fwd_df = 1.0
 
-        clean_pv = fwdDf * (prot_pv - self._running_cpn * clean_rpv01
-                           * self._notional)
+        clean_pv = fwd_df * (prot_pv - self.running_cpn * clean_rpv01
+                            * self.notional)
 
-        clean_price = (self._notional - clean_pv) / self._notional * 100.0
+        clean_price = (self.notional - clean_pv) / self.notional * 100.0
 
         return clean_price
 
     ###########################################################################
 
     def accrued_days(self):
         """ Number of days between the previous coupon and the currrent step
         in date. """
 
         # I assume accrued runs to the effective date
-        pcd = self._accrual_start_dts[0]
-        accrued_days = self._step_in_dt - pcd
+        pcd = self.accrual_start_dts[0]
+        accrued_days = self.step_in_dt - pcd
         return accrued_days
 
     ###########################################################################
 
     def accrued_interest(self):
         """ Calculate the amount of accrued interest that has accrued from the
         previous cpn date (PCD) to the step_in_dt of the CDS contract. """
 
-        day_count = DayCount(self._dc_type)
-        pcd = self._accrual_start_dts[0]
-        accrual_factor = day_count.year_frac(pcd, self._step_in_dt)[0]
-        accrued_interest = accrual_factor * self._notional \
-            * self._running_cpn
+        day_count = DayCount(self.dc_type)
+        pcd = self.accrual_start_dts[0]
+        accrual_factor = day_count.year_frac(pcd, self.step_in_dt)[0]
+        accrued_interest = accrual_factor * self.notional \
+            * self.running_cpn
 
-        if self._long_protection:
+        if self.long_protect:
             accrued_interest *= -1.0
 
         return accrued_interest
 
     ###########################################################################
 
-    def protection_leg_pv(self,
+    def prot_leg_pv(self,
                           value_dt,
                           issuer_curve,
-                          contract_recovery_rate=standard_recovery_rate,
-                          num_steps_per_year=glob_num_steps_per_year,
+                          contract_recovery_rate=STANDARD_RECOVERY_RATE,
+                          num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR,
                           prot_method=0):
         """ Calculates the protection leg PV of the CDS by calling into the
         fast NUMBA code that has been defined above. """
 
-        teff = (self._step_in_dt - value_dt) / gDaysInYear
-        t_mat = (self._maturity_dt - value_dt) / gDaysInYear
+        teff = (self.step_in_dt - value_dt) / gDaysInYear
+        t_mat = (self.maturity_dt - value_dt) / gDaysInYear
 
-        libor_curve = issuer_curve._libor_curve
+        libor_curve = issuer_curve.libor_curve
 
-        v = _protection_leg_pv_numba(teff,
+        v = _prot_leg_pv_numba(teff,
                                      t_mat,
                                      libor_curve._times,
                                      libor_curve._dfs,
                                      issuer_curve._times,
                                      issuer_curve._values,
                                      contract_recovery_rate,
                                      num_steps_per_year,
                                      prot_method)
 
-        return v * self._notional
+        return v * self.notional
 
     ###########################################################################
 
     def risky_pv01(self,
                    value_dt,
                    issuer_curve,
                    pv01_method=0):
         """ The risky_pv01 is the present value of a risky one dollar paid on
         the premium leg of a CDS contract. """
 
-        libor_curve = issuer_curve._libor_curve
+        libor_curve = issuer_curve.libor_curve
 
         payment_times = []
-        for date in self._payment_dts:
+        for date in self.payment_dts:
             t = (date - value_dt) / gDaysInYear
 
             if t > 0.0:
                 payment_times.append(t)
 
         # this is the part of the cpn accrued from the previous cpn date
         # to now
-        pcd = self._accrual_start_dts[0]
-        eff = self._step_in_dt
-        day_count = DayCount(self._dc_type)
+        pcd = self.accrual_start_dts[0]
+        eff = self.step_in_dt
+        day_count = DayCount(self.dc_type)
 
-        accrual_factorPCDToNow = day_count.year_frac(pcd, eff)[0]
+        accrual_factor_pcd_to_now = day_count.year_frac(pcd, eff)[0]
 
-        year_fracs = self._accrual_factors
+        year_fracs = self.accrual_factors
         teff = (eff - value_dt) / gDaysInYear
 
-        valueRPV01 = _risky_pv01_numba(teff,
-                                       accrual_factorPCDToNow,
+        value_rpv01 = _risky_pv01_numba(teff,
+                                       accrual_factor_pcd_to_now,
                                        np.array(payment_times),
                                        np.array(year_fracs),
                                        libor_curve._times,
                                        libor_curve._dfs,
                                        issuer_curve._times,
                                        issuer_curve._values,
                                        pv01_method)
 
-        full_rpv01 = valueRPV01[0]
-        clean_rpv01 = valueRPV01[1]
+        full_rpv01 = value_rpv01[0]
+        clean_rpv01 = value_rpv01[1]
 
         return {'dirty_rpv01': full_rpv01, 'clean_rpv01': clean_rpv01}
 
     ###########################################################################
 
     def premium_leg_pv(self,
                        value_dt,
                        issuer_curve,
                        pv01_method=0):
         """ Value of the premium leg of a CDS. """
 
         full_rpv01 = self.risky_pv01(value_dt,
-                                    issuer_curve,
-                                    pv01_method)['dirty_rpv01']
+                                     issuer_curve,
+                                     pv01_method)['dirty_rpv01']
 
-        v = full_rpv01 * self._notional * self._running_cpn
+        v = full_rpv01 * self.notional * self.running_cpn
         return v
 
     ###########################################################################
 
     def par_spread(self,
                    value_dt,
                    issuer_curve,
-                   contract_recovery_rate=standard_recovery_rate,
-                   num_steps_per_year=glob_num_steps_per_year,
+                   contract_recovery_rate=STANDARD_RECOVERY_RATE,
+                   num_steps_per_year=GLOB_NUM_STEPS_PER_YEAR,
                    pv01_method=0,
                    prot_method=0):
         """ Breakeven CDS cpn that would make the value of the CDS contract
         equal to zero. """
 
         clean_rpv01 = self.risky_pv01(value_dt,
-                                     issuer_curve,
-                                     pv01_method)['clean_rpv01']
+                                      issuer_curve,
+                                      pv01_method)['clean_rpv01']
 
-        prot = self.protection_leg_pv(value_dt,
+        prot = self.prot_leg_pv(value_dt,
                                       issuer_curve,
                                       contract_recovery_rate,
                                       num_steps_per_year,
                                       prot_method)
 
         # By convention this is calculated using the clean RPV01
-        spd = prot / clean_rpv01 / self._notional
+        spd = prot / clean_rpv01 / self.notional
         return spd
 
     ###########################################################################
 
     def value_fast_approx(self,
                           value_dt,
                           flat_cont_interest_rate,
                           flat_cds_curve_spread,
-                          curve_recovery=standard_recovery_rate,
-                          contract_recovery_rate=standard_recovery_rate):
+                          curve_recovery=STANDARD_RECOVERY_RATE,
+                          contract_recovery_rate=STANDARD_RECOVERY_RATE):
         """ Implementation of fast valuation of the CDS contract using an
         accurate approximation that avoids curve building. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date must be a Date and not " +
                            str(value_dt))
 
-        t_mat = (self._maturity_dt - value_dt) / gDaysInYear
-        t_eff = (self._step_in_dt - value_dt) / gDaysInYear
+        t_mat = (self.maturity_dt - value_dt) / gDaysInYear
+        t_eff = (self.step_in_dt - value_dt) / gDaysInYear
 
         h = flat_cds_curve_spread / (1.0 - curve_recovery)
         r = flat_cont_interest_rate
-        fwdDf = 1.0
+        fwd_df = 1.0
         bump_size = 0.0001
 
-        if self._long_protection:
-            long_protection = +1
+        if self.long_protect:
+            long_protect = +1
         else:
-            long_protection = -1
+            long_protect = -1
 
         # The sign of he accrued has already been sign adjusted for direction
         accrued = self.accrued_interest()
 
         # This is the clean RPV01 as it treats the PV01 stream as though it
         # pays just the accrued for the time between 0 and the maturity
         # It therefore omits the part that has accrued
 
         w = r + h
         z = np.exp(-w * t_eff) - np.exp(-w * t_mat)
         clean_rpv01 = (z / w) * 365.0 / 360.0
-        prot_pv = h * (1.0 - contract_recovery_rate) * (z / w) * self._notional
-        clean_pv = fwdDf * long_protection * \
-            (prot_pv - self._running_cpn * clean_rpv01 * self._notional)
-        full_pv = clean_pv + fwdDf * accrued
+        prot_pv = h * (1.0 - contract_recovery_rate) * (z / w) * self.notional
+        clean_pv = fwd_df * long_protect * \
+            (prot_pv - self.running_cpn * clean_rpv01 * self.notional)
+        full_pv = clean_pv + fwd_df * accrued
 
         #######################################################################
         # bump CDS spread and calculate
         #######################################################################
 
-        h = (flat_cds_curve_spread + bump_size) / (1.0 - contract_recovery_rate)
+        h = (flat_cds_curve_spread + bump_size) / \
+            (1.0 - contract_recovery_rate)
         r = flat_cont_interest_rate
         w = r + h
         z = np.exp(-w * t_eff) - np.exp(-w * t_mat)
         clean_rpv01 = (z / w) * 365.0 / 360.0
-        prot_pv = h * (1.0 - contract_recovery_rate) * (z / w) * self._notional
-        clean_pv_credit_bumped = fwdDf * long_protection * \
-            (prot_pv - self._running_cpn * clean_rpv01 * self._notional)
+        prot_pv = h * (1.0 - contract_recovery_rate) * (z / w) * self.notional
+        clean_pv_credit_bumped = fwd_df * long_protect * \
+            (prot_pv - self.running_cpn * clean_rpv01 * self.notional)
         full_pv_credit_bumped = clean_pv_credit_bumped \
-            + fwdDf * long_protection * accrued
+            + fwd_df * long_protect * accrued
         credit01 = full_pv_credit_bumped - full_pv
 
         #######################################################################
         # bump Rate and calculate
         #######################################################################
 
         h = flat_cds_curve_spread / (1.0 - contract_recovery_rate)
         r = flat_cont_interest_rate + bump_size
 
         w = r + h
         z = np.exp(-w * t_eff) - np.exp(-w * t_mat)
 
         clean_rpv01 = (z / w) * 365.0 / 360.0
 
-        prot_pv = h * (1.0 - contract_recovery_rate) * (z / w) * self._notional
+        prot_pv = h * (1.0 - contract_recovery_rate) * (z / w) * self.notional
 
-        clean_pv_ir_bumped = fwdDf * long_protection * \
-            (prot_pv - self._running_cpn * clean_rpv01 * self._notional)
+        clean_pv_ir_bumped = fwd_df * long_protect * \
+            (prot_pv - self.running_cpn * clean_rpv01 * self.notional)
 
-        full_pv_ir_bumped = clean_pv_ir_bumped + fwdDf * long_protection * accrued
+        full_pv_ir_bumped = clean_pv_ir_bumped + fwd_df * long_protect * accrued
 
         ir01 = full_pv_ir_bumped - full_pv
 
         return (full_pv, clean_pv, credit01, ir01)
 
     ###########################################################################
 
     def print_payments(self, value_dt, issuer_curve):
         ''' We only print payments after the current valuation date '''
-        num_flows = len(self._payment_dts)
+        num_flows = len(self.payment_dts)
 
         print("PAYMENT_dt      YEAR_FRAC      FLOW           DF       SURV_PROB      NPV")
 
         for it in range(0, num_flows):
-            dt = self._payment_dts[it]
+            dt = self.payment_dts[it]
 
             if dt > value_dt:
-                acc_factor = self._accrual_factors[it]
-                flow = self._flows[it]
+                acc_factor = self.accrual_factors[it]
+                flow = self.flows[it]
                 z = issuer_curve.df(dt)
                 q = issuer_curve.survival_prob(dt)
                 print("%15s %10.6f %12.2f %12.6f %12.6f %12.2f" %
                       (dt, acc_factor, flow, z, q, flow * z * q))
 
     ###########################################################################
 
     def __repr__(self):
         """ print out details of the CDS contract and all the calculated
         cash flows """
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("STEP-IN DATE", self._step_in_dt)
-        s += label_to_string("MATURITY", self._maturity_dt)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("RUN COUPON", self._running_cpn * 10000, "bp\n")
-        s += label_to_string("DAYCOUNT", self._dc_type)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUSDAYRULE", self._bd_type)
-        s += label_to_string("DATEGENRULE", self._dg_type)
+        s += label_to_string("STEP-IN DATE", self.step_in_dt)
+        s += label_to_string("MATURITY", self.maturity_dt)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("RUN COUPON", self.running_cpn * 10000, "bp\n")
+        s += label_to_string("DAYCOUNT", self.dc_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUSDAYRULE", self.bd_type)
+        s += label_to_string("DATEGENRULE", self.dg_type)
         s += label_to_string("ACCRUED DAYS", self.accrued_days())
 
         header = "PAYMENT_dt, YEAR_FRAC, ACCRUAL_START, ACCRUAL_END, FLOW"
         value_table = [
-            self._payment_dts,
-            self._accrual_factors,
-            self._accrual_start_dts,
-            self._accrual_end_dts,
-            self._flows
+            self.payment_dts,
+            self.accrual_factors,
+            self.accrual_start_dts,
+            self.accrual_end_dts,
+            self.flows
         ]
         precision = "12.6f"
 
         s += table_to_string(header, value_table, precision)
 
         return s
```

### Comparing `financepy-0.350/financepy/products/credit/cds_basket.py` & `financepy-0.360/financepy/products/credit/cds_basket.py`

 * *Files 7% similar despite different names*

```diff
@@ -37,44 +37,44 @@
     """ Class to deal with n-to-default CDS baskets. """
 
     def __init__(self,
                  step_in_dt: Date,
                  maturity_dt: Date,
                  notional: float = ONE_MILLION,
                  running_cpn: float = 0.0,
-                 long_protection: bool = True,
+                 long_protect: bool = True,
                  freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  dc_type: DayCountTypes = DayCountTypes.ACT_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
 
         check_argument_types(self.__init__, locals())
 
-        self._step_in_dt = step_in_dt
-        self._maturity_dt = maturity_dt
-        self._notional = notional
-        self._running_cpn = running_cpn / 10000.0
-        self._long_protection = long_protection
-        self._dc_type = dc_type
-        self._dg_type = dg_type
-        self._cal_type = cal_type
-        self._freq_type = freq_type
-        self._bd_type = bd_type
-
-        self._cds_contract = CDS(self._step_in_dt,
-                                 self._maturity_dt,
-                                 self._running_cpn,
+        self.step_in_dt = step_in_dt
+        self.maturity_dt = maturity_dt
+        self.notional = notional
+        self.running_cpn = running_cpn / 10000.0
+        self.long_protect = long_protect
+        self.dc_type = dc_type
+        self.dg_type = dg_type
+        self.cal_type = cal_type
+        self.freq_type = freq_type
+        self.bd_type = bd_type
+
+        self.cds_contract = CDS(self.step_in_dt,
+                                 self.maturity_dt,
+                                 self.running_cpn,
                                  1.0,
-                                 self._long_protection,
-                                 self._freq_type,
-                                 self._dc_type,
-                                 self._cal_type,
-                                 self._bd_type,
-                                 self._dg_type)
+                                 self.long_protect,
+                                 self.freq_type,
+                                 self.dc_type,
+                                 self.cal_type,
+                                 self.bd_type,
+                                 self.dg_type)
 
 ###############################################################################
 
     def value_legs_mc(self,
                       value_dt,
                       n_to_default,
                       default_times,
@@ -82,73 +82,73 @@
                       libor_curve):
         """ Value the legs of the default basket using Monte Carlo. The default
         times are an input so this valuation is not model dependent. """
 
         num_credits = default_times.shape[0]
         num_trials = default_times.shape[1]
 
-        payment_dts = self._cds_contract._payment_dts
+        payment_dts = self.cds_contract.payment_dts
         num_payments = len(payment_dts)
-        day_count = DayCount(self._dc_type)
+        day_count = DayCount(self.dc_type)
 
         avg_acc_factor = 0.0
 
-        rpv01ToTimes = np.zeros(num_payments)
+        rpv01_to_times = np.zeros(num_payments)
 
         for i_time in range(1, num_payments):
 
             t = (payment_dts[i_time] - value_dt) / gDaysInYear
             dt0 = payment_dts[i_time - 1]
             dt1 = payment_dts[i_time]
             accrual_factor = day_count.year_frac(dt0, dt1)[0]
             avg_acc_factor += accrual_factor
-            rpv01ToTimes[i_time] = rpv01ToTimes[i_time - 1] + \
+            rpv01_to_times[i_time] = rpv01_to_times[i_time - 1] + \
                 accrual_factor * libor_curve._df(t)
 
         avg_acc_factor /= num_payments
 
-        t_mat = (self._maturity_dt - value_dt) / gDaysInYear
+        t_mat = (self.maturity_dt - value_dt) / gDaysInYear
 
         rpv01 = 0.0
         prot = 0.0
 
-        assetTau = np.zeros(num_credits)
+        asset_tau = np.zeros(num_credits)
 
         for i_trial in range(0, num_trials):
 
             for i_credit in range(0, num_credits):
 
-                assetTau[i_credit] = default_times[i_credit, i_trial]
+                asset_tau[i_credit] = default_times[i_credit, i_trial]
 
             # ORDER THE DEFAULT TIMES
-            assetTau.sort()
+            asset_tau.sort()
 
             # GET THE Nth DEFAULT TIME
-            minTau = assetTau[n_to_default - 1]
+            min_tau = asset_tau[n_to_default - 1]
 
-            if minTau < t_mat:
+            if min_tau < t_mat:
 
-                num_pmnts_index = int(minTau / avg_acc_factor)
-                rpv01_trial = rpv01ToTimes[num_pmnts_index]
-                rpv01_trial += (minTau - num_pmnts_index * avg_acc_factor)
+                num_payment_amounts_index = int(min_tau / avg_acc_factor)
+                rpv01_trial = rpv01_to_times[num_payment_amounts_index]
+                rpv01_trial += (min_tau - num_payment_amounts_index * avg_acc_factor)
 
                 # DETERMINE IDENTITY OF N-TO-DEFAULT CREDIT IF BASKET NOT HOMO
-                assetIndex = 0
+                asset_index = 0
                 for i_credit in range(0, num_credits):
-                    if minTau == default_times[i_credit, i_trial]:
-                        assetIndex = i_credit
+                    if min_tau == default_times[i_credit, i_trial]:
+                        asset_index = i_credit
                         break
 
-                prot_trial = (1.0 - issuer_curves[assetIndex]._recovery_rate)
-                prot_trial *= libor_curve._df(minTau)
+                prot_trial = (1.0 - issuer_curves[asset_index].recovery_rate)
+                prot_trial *= libor_curve._df(min_tau)
 
             else:
 
-                num_pmnts_index = int(t_mat / avg_acc_factor)
-                rpv01_trial = rpv01ToTimes[-1]
+                num_payment_amounts_index = int(t_mat / avg_acc_factor)
+                rpv01_trial = rpv01_to_times[-1]
                 prot_trial = 0.0
 
             rpv01 += rpv01_trial
             prot += prot_trial
 
         rpv01 = rpv01 / num_trials
         prot = prot / num_trials
@@ -156,81 +156,81 @@
 
 ###############################################################################
 
     def value_gaussian_mc(self,
                           value_dt,
                           n_to_default,
                           issuer_curves,
-                          correlation_matrix,
+                          corr_matrix,
                           libor_curve,
                           num_trials,
                           seed):
         """ Value the default basket using a Gaussian copula model. This
         depends on the issuer discount and correlation matrix. """
 
         num_credits = len(issuer_curves)
 
         if n_to_default > num_credits or n_to_default < 1:
             raise FinError("n_to_default must be 1 to num_credits")
 
         default_times = default_times_gc(issuer_curves,
-                                         correlation_matrix,
+                                         corr_matrix,
                                          num_trials,
                                          seed)
 
         rpv01, prot_pv = self.value_legs_mc(value_dt,
                                             n_to_default,
                                             default_times,
                                             issuer_curves,
                                             libor_curve)
 
         spd = prot_pv / rpv01
-        value = self._notional * (prot_pv - self._running_cpn * rpv01)
+        value = self.notional * (prot_pv - self.running_cpn * rpv01)
 
-        if not self._long_protection:
+        if not self.long_protect:
             value = value * -1.0
 
         return (value, rpv01, spd)
 
 ###############################################################################
 
     def value_student_t_mc(self,
                            value_dt,
                            n_to_default,
                            issuer_curves,
-                           correlation_matrix,
+                           corr_matrix,
                            degrees_of_freedom,
                            libor_curve,
                            num_trials,
                            seed):
         """ Value the default basket using the Student-T copula. """
 
         num_credits = len(issuer_curves)
 
         if n_to_default > num_credits or n_to_default < 1:
             raise FinError("n_to_default must be 1 to num_credits")
 
         model = StudentTCopula()
 
         default_times = model.default_times(issuer_curves,
-                                            correlation_matrix,
+                                            corr_matrix,
                                             degrees_of_freedom,
                                             num_trials,
                                             seed)
 
         rpv01, prot_pv = self.value_legs_mc(value_dt,
                                             n_to_default,
                                             default_times,
                                             issuer_curves,
                                             libor_curve)
 
         spd = prot_pv / rpv01
-        value = self._notional * (prot_pv - self._running_cpn * rpv01)
+        value = self.notional * (prot_pv - self.running_cpn * rpv01)
 
-        if not self._long_protection:
+        if not self.long_protect:
             value = value * -1.0
 
         return (value, rpv01, spd)
 
 ###############################################################################
 
     def value_1f_gaussian_homo(self,
@@ -247,20 +247,20 @@
 
         if num_credits == 0:
             raise FinError("Num Credits is zero")
 
         if n_to_default < 1 or n_to_default > num_credits:
             raise FinError("n_to_default must be 1 to num_credits")
 
-        t_mat = (self._maturity_dt - value_dt) / gDaysInYear
+        t_mat = (self.maturity_dt - value_dt) / gDaysInYear
 
         if t_mat < 0.0:
             raise FinError("Value date is after maturity date")
 
-        payment_dts = self._cds_contract._payment_dts
+        payment_dts = self.cds_contract.payment_dts
         num_times = len(payment_dts)
 
         issuer_surv_probs = np.zeros(num_credits)
         recovery_rates = np.zeros(num_credits)
         basket_times = np.zeros(num_times)
         basket_surv_curve = np.zeros(num_times)
 
@@ -269,73 +269,73 @@
 
         for i_time in range(0, num_times):
 
             t = (payment_dts[i_time] - value_dt) / gDaysInYear
 
             for i_credit in range(0, num_credits):
                 issuer_curve = issuer_curves[i_credit]
-                recovery_rates[i_credit] = issuer_curve._recovery_rate
+                recovery_rates[i_credit] = issuer_curve.recovery_rate
                 issuer_surv_probs[i_credit] = interpolate(
                     t, issuer_curve._times, issuer_curve._values,
                     InterpTypes.FLAT_FWD_RATES.value)
 
             loss_dbn = homog_basket_loss_dbn(issuer_surv_probs,
-                                            recovery_rates,
-                                            beta_vector,
-                                            num_points)
+                                             recovery_rates,
+                                             beta_vector,
+                                             num_points)
 
             basket_surv_curve[i_time] = 1.0
-            for iToDefault in range(n_to_default, num_credits + 1):
-                basket_surv_curve[i_time] -= loss_dbn[iToDefault]
+            for i_to_default in range(n_to_default, num_credits + 1):
+                basket_surv_curve[i_time] -= loss_dbn[i_to_default]
 
             basket_times[i_time] = t
 
         curve_recovery = recovery_rates[0]
-        libor_curve = issuer_curves[0]._libor_curve
+        libor_curve = issuer_curves[0].libor_curve
         basket_curve = CDSCurve(value_dt, [], libor_curve, curve_recovery)
         basket_curve._times = basket_times
         basket_curve._values = basket_surv_curve
 
-        prot_leg_pv = self._cds_contract.protection_leg_pv(
+        prot_leg_pv = self.cds_contract.prot_leg_pv(
             value_dt, basket_curve, curve_recovery)
-        risky_pv01 = self._cds_contract.risky_pv01(
+        risky_pv01 = self.cds_contract.risky_pv01(
             value_dt, basket_curve)['clean_rpv01']
 
         # Long protection
-        mtm = self._notional * (prot_leg_pv - risky_pv01 * self._running_cpn)
+        mtm = self.notional * (prot_leg_pv - risky_pv01 * self.running_cpn)
 
-        if not self._long_protection:
+        if not self.long_protect:
             mtm *= -1.0
 
-        basketOutput = np.zeros(4)
-        basketOutput[0] = mtm
-        basketOutput[1] = risky_pv01 * self._notional * self._running_cpn
-        basketOutput[2] = prot_leg_pv * self._notional
-        basketOutput[3] = prot_leg_pv / risky_pv01
+        basket_output = np.zeros(4)
+        basket_output[0] = mtm
+        basket_output[1] = risky_pv01 * self.notional * self.running_cpn
+        basket_output[2] = prot_leg_pv * self.notional
+        basket_output[3] = prot_leg_pv / risky_pv01
 
-        return basketOutput
+        return basket_output
 
 ###############################################################################
 
     def __repr__(self):
         """ print out details of the CDS contract and all of the calculated
         cash flows """
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("STEP-IN DATE", self._step_in_dt)
-        s += label_to_string("MATURITY", self._maturity_dt)
-        s += label_to_string("NOTIONAL", self._notional)
+        s += label_to_string("STEP-IN DATE", self.step_in_dt)
+        s += label_to_string("MATURITY", self.maturity_dt)
+        s += label_to_string("NOTIONAL", self.notional)
         s += label_to_string("RUNNING COUPON",
-                             self._running_cpn*10000, "bp\n")
-        s += label_to_string("DAYCOUNT", self._dc_type)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUSDAYRULE", self._bd_type)
-        s += label_to_string("DATEGENRULE", self._dg_type)
+                             self.running_cpn*10000, "bp\n")
+        s += label_to_string("DAYCOUNT", self.dc_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUSDAYRULE", self.bd_type)
+        s += label_to_string("DATEGENRULE", self.dg_type)
 
 #       header = "PAYMENT_dt, YEAR_FRAC, FLOW"
-#       valueTable = [self._payment_dts, self._accrual_factors, self._flows]
+#       value_table = [self.payment_dts, self.accrual_factors, self.flows]
 #       precision = "12.6f"
-#       s += tableToString(header, valueTable, precision)
+#       s += tableToString(header, value_table, precision)
 
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/credit/cds_curve.py` & `financepy-0.360/financepy/products/credit/cds_curve.py`

 * *Files 7% similar despite different names*

```diff
@@ -53,59 +53,69 @@
                  interp_method: InterpTypes = InterpTypes.FLAT_FWD_RATES):
         """ Construct a credit curve from a sequence of maturity-ordered CDS
         contracts and a Ibor curve using the same recovery rate and the
         same interpolation method. """
 
         check_argument_types(getattr(self, _func_name(), None), locals())
 
-        if value_dt != libor_curve._value_dt:
+        if value_dt != libor_curve.value_dt:
             raise FinError(
                 "Curve does not have same valuation date as Issuer curve.")
 
-        self._value_dt = value_dt
-        self._cds_contracts = cds_contracts
-        self._recovery_rate = recovery_rate
-        self._libor_curve = libor_curve
-        self._interp_method = interp_method
-        self._built_ok = False
+        self.value_dt = value_dt
+        self.cds_contracts = cds_contracts
+        self.recovery_rate = recovery_rate
+        self.libor_curve = libor_curve
+        self.interp_method = interp_method
+        self.built_ok = False
 
         self._times = []
         self._values = []
 
-        if len(self._cds_contracts) > 0:
+        if len(self.cds_contracts) > 0:
             self._build_curve()
         else:
             pass  # In some cases we allow None to be passed
 
         return
 
 ###############################################################################
 
+    def times(self):
+        return self._times;
+
+###############################################################################
+
+    def values(self):
+        return self._values;
+
+###############################################################################
+
     def _validate(self, cds_contracts):
         """ Ensure that contracts are in increasing maturity. """
 
         if len(cds_contracts) == 0:
             raise FinError("No CDS contracts have been supplied.")
 
-        maturity_dt = cds_contracts[0]._maturity_dt
+        maturity_dt = cds_contracts[0].maturity_dt
 
         for cds in cds_contracts[1:]:
-            if cds._maturity_dt <= maturity_dt:
+            if cds.maturity_dt <= maturity_dt:
                 raise FinError("CDS contracts not in increasing maturity.")
 
-            maturity_dt = cds._maturity_dt
+            maturity_dt = cds.maturity_dt
 
 ###############################################################################
 
     def survival_prob(self, dt):
         """ Extract the survival probability to date dt. This function
         supports vectorisation. """
 
         if isinstance(dt, Date):
-            t = (dt - self._value_dt) / gDaysInYear
+            t = (dt - self.value_dt) / gDaysInYear
         elif isinstance(dt, list):
             t = np.array(dt)
         else:
             t = dt
 
         if np.any(t < 0.0):
             raise FinError("Survival Date before curve anchor date")
@@ -113,64 +123,64 @@
         if isinstance(t, np.ndarray):
             n = len(t)
             qs = np.zeros(n)
             for i in range(0, n):
                 qs[i] = _uinterpolate(t[i],
                                       self._times,
                                       self._values,
-                                      self._interp_method.value)
+                                      self.interp_method.value)
             return qs
         elif isinstance(t, float):
             q = _uinterpolate(t,
                               self._times,
                               self._values,
-                              self._interp_method.value)
+                              self.interp_method.value)
             return q
         else:
             raise FinError("Unknown time type")
 
 ###############################################################################
 
     def df(self, dt):
         """ Extract the discount factor from the underlying Ibor curve. This
         function supports vectorisation. """
 
         if isinstance(dt, Date):
-            t = (dt - self._value_dt) / gDaysInYear
+            t = (dt - self.value_dt) / gDaysInYear
         elif isinstance(dt, list):
             t = np.array(dt)
         else:
             t = dt
 
-        df = self._libor_curve._df(t)
+        df = self.libor_curve._df(t)
 
         return df
 
 ###############################################################################
 
     def _build_curve(self):
         """ Construct the CDS survival curve from a set of CDS contracts """
 
-        self._validate(self._cds_contracts)
-        num_times = len(self._cds_contracts)
+        self._validate(self.cds_contracts)
+        num_times = len(self.cds_contracts)
 
         # we size the vectors to include time zero
         self._times = np.array([0.0])
         self._values = np.array([1.0])
 
         for i in range(0, num_times):
 
-            maturity_dt = self._cds_contracts[i]._maturity_dt
+            maturity_dt = self.cds_contracts[i].maturity_dt
 
             argtuple = (self,
-                        self._value_dt,
-                        self._cds_contracts[i],
-                        self._recovery_rate)
+                        self.value_dt,
+                        self.cds_contracts[i],
+                        self.recovery_rate)
 
-            t_mat = (maturity_dt - self._value_dt) / gDaysInYear
+            t_mat = (maturity_dt - self.value_dt) / gDaysInYear
             q = self._values[i]
 
             self._times = np.append(self._times, t_mat)
             self._values = np.append(self._values, q)
 
             optimize.newton(f, x0=q, fprime=None, args=argtuple,
                             tol=1e-7, maxiter=50, fprime2=None)
@@ -190,15 +200,15 @@
 
 ###############################################################################
 
     def fwd_rate(self, date1, date2, day_count_type):
         """ Calculate the forward rate according between dates date1 and date2
         according to the specified day count convention. """
 
-        if date1 < self._value_dt:
+        if date1 < self.value_dt:
             raise FinError("Date1 before curve value date.")
 
         if date2 < date1:
             raise FinError("Date2 must not be before Date1")
 
         day_count = DayCount(day_count_type)
         year_frac = day_count.year_frac(date1, date2)[0]
```

### Comparing `financepy-0.350/financepy/products/credit/cds_index_option.py` & `financepy-0.360/financepy/products/credit/cds_index_option.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,126 +7,127 @@
 
 
 from ...utils.calendar import CalendarTypes
 from ...utils.calendar import BusDayAdjustTypes, DateGenRuleTypes
 from ...utils.day_count import DayCount, DayCountTypes
 from ...utils.frequency import FrequencyTypes
 from ...utils.global_vars import gDaysInYear
-from ...utils.math import ONE_MILLION, INVROOT2PI, N
+from ...utils.math import ONE_MILLION, INV_ROOT_2_PI, N
 from ...utils.error import FinError
 from ...products.credit.cds_curve import CDSCurve
 from ...products.credit.cds import CDS
 from ...utils.helpers import check_argument_types
 from ...utils.date import Date
 from ...utils.helpers import label_to_string
 
 RPV01_INDEX = 1  # 0 is FULL, 1 is CLEAN
 
 ###############################################################################
 
 
 class CDSIndexOption:
-
     """ Class to manage the pricing and risk management of an option to enter
     into a CDS index. Different pricing algorithms are presented."""
 
     def __init__(self,
                  expiry_dt: Date,
                  maturity_dt: Date,
-                 index_coupon: float,
-                 strike_coupon: float,
+                 index_cpn: float,
+                 strike_cpn: float,
                  notional: float = ONE_MILLION,
-                 long_protection: bool = True,
+                 long_protect: bool = True,
                  freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  dc_type: DayCountTypes = DayCountTypes.ACT_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
-        """ Initialisation of the class object. Note that a large number of the
-        inputs are set to default values in line with the standard contract."""
+        """ Initialisation of the class object. Note that a
+        large number of the inputs are set to default values in line with
+        the standard contract."""
 
         check_argument_types(self.__init__, locals())
 
         if expiry_dt > maturity_dt:
             raise FinError("Expiry date after end date")
 
-        if index_coupon < 0.0:
-            raise FinError("Index coupon is negative")
+        if index_cpn < 0.0:
+            raise FinError("Index cpn is negative")
 
-        if strike_coupon < 0.0:
-            raise FinError("Index Option strike coupon is negative")
+        if strike_cpn < 0.0:
+            raise FinError("Index Option strike cpn is negative")
 
-        self._expiry_dt = expiry_dt
-        self._maturity_dt = maturity_dt
-        self._index_coupon = index_coupon
-        self._strike_coupon = strike_coupon
-        self._notional = notional
-        self._long_protection = long_protection
-
-        self._dc_type = dc_type
-        self._dg_type = dg_type
-        self._cal_type = cal_type
-        self._freq_type = freq_type
-        self._bd_type = bd_type
-
-        self._cds_contract = CDS(self._expiry_dt,
-                                 self._maturity_dt,
-                                 self._index_coupon,
+        self.expiry_dt = expiry_dt
+        self.maturity_dt = maturity_dt
+        self.index_cpn = index_cpn
+        self.strike_cpn = strike_cpn
+        self.notional = notional
+        self.long_protect = long_protect
+
+        self.dc_type = dc_type
+        self.dg_type = dg_type
+        self.cal_type = cal_type
+        self.freq_type = freq_type
+        self.bd_type = bd_type
+
+        self.cds_contract = CDS(self.expiry_dt,
+                                 self.maturity_dt,
+                                 self.index_cpn,
                                  1.0,
-                                 self._long_protection,
-                                 self._freq_type,
-                                 self._dc_type,
-                                 self._cal_type,
-                                 self._bd_type,
-                                 self._dg_type)
+                                 self.long_protect,
+                                 self.freq_type,
+                                 self.dc_type,
+                                 self.cal_type,
+                                 self.bd_type,
+                                 self.dg_type)
 
 ###############################################################################
 
     def value_adjusted_black(self,
-                             value_dt,
-                             index_curve,
-                             index_recovery,
-                             libor_curve,
-                             sigma):
-        """ This approach uses two adjustments to Black's option pricing
+                                             value_dt,
+                                             index_curve,
+                                             index_recovery,
+                                             libor_curve,
+                                             sigma):
+        """ This approach uses two adjustments to black's option pricing
         model to value an option on a CDS index. """
 
-        k = self._strike_coupon
-        c = self._index_coupon
-        time_to_expiry = (self._expiry_dt - value_dt) / gDaysInYear
-        df = libor_curve.df(self._expiry_dt)
-        q_expiry_index = index_curve.survival_prob(time_to_expiry)
+        k = self.strike_cpn
+        c = self.index_cpn
+        time_to_expiry = (self.expiry_dt - value_dt) / gDaysInYear
+        df = libor_curve.df(self.expiry_dt)
+        q_expiry_index = index_curve.survival_prob(
+            time_to_expiry)
 
-        cds = CDS(value_dt, self._maturity_dt, k)
+        cds = CDS(value_dt, self.maturity_dt, k)
         strike_curve = CDSCurve(
             value_dt, [cds], libor_curve, index_recovery)
 #        qExpiryStrike = strike_curve.surv_prob(time_to_expiry)
 
-        strike_rpv01 = self._cds_contract.risky_pv01(
+        strike_rpv01 = self.cds_contract.risky_pv01(
             value_dt, strike_curve)['clean_rpv01']
-        index_rpv01 = self._cds_contract.risky_pv01(
+        index_rpv01 = self.cds_contract.risky_pv01(
             value_dt, index_curve)['clean_rpv01']
 
-        s = self._cds_contract.par_spread(value_dt, index_curve)
+        s = self.cds_contract.par_spread(value_dt, index_curve)
 
         fep = df * (1.0 - q_expiry_index) * (1.0 - index_recovery)
         adj_fwd = s + fep / index_rpv01
         adj_strike = c + (k - c) * strike_rpv01 / index_rpv01 / q_expiry_index
 
         denom = sigma * sqrt(time_to_expiry)
         d1 = log(adj_fwd / adj_strike) + 0.5 * sigma * sigma * time_to_expiry
         d2 = log(adj_fwd / adj_strike) - 0.5 * sigma * sigma * time_to_expiry
         d1 /= denom
         d2 /= denom
 
         v_pay = (adj_fwd * N(d1) - adj_strike * N(d2)) * index_rpv01
         v_rec = (adj_strike * N(-d2) - adj_fwd * N(-d1)) * index_rpv01
 
-        v_pay *= self._notional
-        v_rec *= self._notional
+        v_pay *= self.notional
+        v_rec *= self.notional
 
         return (v_pay, v_rec)
 
 ###############################################################################
 
     def value_anderson(self,
                        value_dt,
@@ -136,47 +137,48 @@
         """ This function values a CDS index option following approach by
         Anderson (2006). This ensures that a no-arbitrage relationship between
         the constituent CDS contract and the CDS index is enforced. It models
         the forward spread as a log-normally distributed quantity and uses the
         credit triangle to compute the forward RPV01. """
 
         num_credits = len(issuer_curves)
-        time_to_expiry = (self._expiry_dt - value_dt) / gDaysInYear
-#        timeToMaturity = (self._maturity_dt - value_dt) / gDaysInYear
+        time_to_expiry = (self.expiry_dt - value_dt) / gDaysInYear
+#        timeToMaturity = (self.maturity_dt - value_dt) / gDaysInYear
         df_to_expiry = issuer_curves[0].df(time_to_expiry)
-        libor_curve = issuer_curves[0]._libor_curve
+        libor_curve = issuer_curves[0].libor_curve
 
-        k = self._strike_coupon
-        c = self._index_coupon
+        k = self.strike_cpn
+        c = self.index_cpn
 
         strike_cds = CDS(
-            self._expiry_dt,
-            self._maturity_dt,
-            self._strike_coupon,
+            self.expiry_dt,
+            self.maturity_dt,
+            self.strike_cpn,
             1.0)
 
         strike_curve = CDSCurve(value_dt, [strike_cds], libor_curve,
-                               index_recovery)
+                                index_recovery)
         strike_rpv01s = strike_cds.risky_pv01(value_dt, strike_curve)
-        q_to_expiry = strike_curve.survival_prob(time_to_expiry)
+        q_to_expiry = strike_curve.survival_prob(
+            time_to_expiry)
         strike_value = (k - c) * strike_rpv01s['clean_rpv01']
         strike_value /= (df_to_expiry * q_to_expiry)
 
         exp_h = 0.0
         h1 = 0.0
         h2 = 0.0
 
         for i_credit in range(0, num_credits):
 
             issuer_curve = issuer_curves[i_credit]
             q = issuer_curve.survival_prob(time_to_expiry)
-            dh1 = (1.0 - issuer_curve._recovery_rate) * (1.0 - q)
+            dh1 = (1.0 - issuer_curve.recovery_rate) * (1.0 - q)
 
-            s = self._cds_contract.par_spread(value_dt, issuer_curve)
-            rpv01 = self._cds_contract.risky_pv01(value_dt, issuer_curve)
+            s = self.cds_contract.par_spread(value_dt, issuer_curve)
+            rpv01 = self.cds_contract.risky_pv01(value_dt, issuer_curve)
             dh2 = (s - c) * rpv01['clean_rpv01'] / (df_to_expiry * q_to_expiry)
 
             h1 = h1 + dh1
             h2 = h2 + dh2
 
         exp_h = (h1 + h2) / num_credits
 
@@ -192,42 +194,42 @@
                                                 sigma,
                                                 c,
                                                 strike_value,
                                                 libor_curve,
                                                 index_recovery)
 
         v = v[1]
-        v_pay = v * self._notional
-        v_rec = v_pay + (strike_value - exp_h) * df_to_expiry * self._notional
+        v_pay = v * self.notional
+        v_rec = v_pay + (strike_value - exp_h) * df_to_expiry * self.notional
         strike_value *= 10000.0
         x *= 10000.0
         exp_h *= 10000.0
         return v_pay, v_rec, strike_value, x, exp_h
 
 ###############################################################################
 
     def _solve_for_x(self,
                      value_dt,
                      sigma,
-                     index_coupon,
+                     index_cpn,
                      index_recovery,
                      libor_curve,
                      exp_h):
         """ Function to solve for the arbitrage free """
         x1 = 0.0
         x2 = 0.9999
         ftol = 1e-8
         j_max = 40
         xacc = 0.000000001
         rtb = 999999
 
-        f = self._calc_obj_func(x1, value_dt, sigma, index_coupon,
+        f = self._calc_obj_func(x1, value_dt, sigma, index_cpn,
                                 index_recovery, libor_curve) - exp_h
 
-        fmid = self._calc_obj_func(x2, value_dt, sigma, index_coupon,
+        fmid = self._calc_obj_func(x2, value_dt, sigma, index_cpn,
                                    index_recovery, libor_curve) - exp_h
 
         if f * fmid >= 0.0:
             raise FinError("Solution not bracketed.")
 
         if f < 0.0:
             rtb = x1
@@ -236,133 +238,137 @@
             rtb = x2
             dx = x1 - x2
 
         for _ in range(0, j_max):
             dx = dx * 0.5
             xmid = rtb + dx
             fmid = self._calc_obj_func(xmid, value_dt, sigma,
-                                       index_coupon,
+                                       index_cpn,
                                        index_recovery, libor_curve) - exp_h
             if fmid <= 0.0:
                 rtb = xmid
             if abs(dx) < xacc or abs(fmid) < ftol:
                 return rtb
 
         return rtb
 
 ###############################################################################
 
     def _calc_obj_func(self,
-                       x,
-                       value_dt,
-                       sigma,
-                       index_coupon, # TODO - do I need this input ?
-                       index_recovery,
-                       libor_curve):
+                                       x,
+                                       value_dt,
+                                       sigma,
+                                       index_cpn,  # TODO - do I need this input ?
+                                       index_recovery,
+                                       libor_curve):
         """ An internal function used in the Anderson valuation. """
 
         # The strike value is not relevant here as we want the zeroth element
         # of the return value
         strike_value = 0.0
 
         values = self._calc_index_payer_option_price(value_dt,
                                                      x,
                                                      sigma,
-                                                     self._index_coupon,
+                                                     self.index_cpn,
                                                      strike_value,
                                                      libor_curve,
                                                      index_recovery)
 
         return values[0]
 
 ###############################################################################
 
     def _calc_index_payer_option_price(self,
                                        value_dt,
                                        x,
                                        sigma,
-                                       index_coupon,
+                                       index_cpn,
                                        strike_value,
                                        libor_curve,
                                        index_recovery):
         """ Calculates the intrinsic value of the index payer swap and the
         value of the index payer option which are both returned in an array.
         """
 
         z = -6.0
         dz = 0.2
         num_z_steps = int(2.0 * abs(z) / dz)
 
-        flow_dts = self._cds_contract._payment_dts
+        flow_dts = self.cds_contract.payment_dts
         num_flows = len(flow_dts)
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        df_to_expiry = libor_curve.df(self._expiry_dt)
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        df_to_expiry = libor_curve.df(self.expiry_dt)
         lgd = 1.0 - index_recovery
 
         fwd_dfs = [1.0] * (num_flows)
         expiry_to_flow_times = [1.0] * (num_flows)
 
         for i_flow in range(0, num_flows):
-            expiry_to_flow_times[i_flow] = (flow_dts[i_flow] - self._expiry_dt) / gDaysInYear
-            fwd_dfs[i_flow] = libor_curve.df(flow_dts[i_flow]) / df_to_expiry
+            expiry_to_flow_times[i_flow] = (
+                flow_dts[i_flow] - self.expiry_dt) / gDaysInYear
+            fwd_dfs[i_flow] = libor_curve.df(
+                flow_dts[i_flow]) / df_to_expiry
 
         int_h = 0.0
         int_max_h = 0.0
 
-        day_count = DayCount(self._dc_type)
+        day_count = DayCount(self.dc_type)
 
-        #  Previous coupon date is last coupon date before valuation date
+        #  Previous cpn date is last cpn date before valuation date
         for dt in flow_dts:
             pcd = dt
             if dt > value_dt:
                 break
 
-        eff = self._expiry_dt
+        eff = self.expiry_dt
         accrual_factor_pcd_to_expiry = day_count.year_frac(pcd, eff)[0]
 
         s0 = exp(-0.5 * sigma * sigma * t_exp)
 
         for _ in range(0, num_z_steps):
             s = x * s0 * exp(sigma * sqrt(t_exp) * z)
             pdf = exp(-(z**2) / 2.0)
             z = z + dz
 
             fwd_rpv01 = 0.0
             for i_flow in range(1, num_flows):
-                acc_factor = self._cds_contract._accrual_factors[i_flow]
-                surv_prob = exp(-s * expiry_to_flow_times[i_flow] / lgd)
-                fwd_rpv01 += acc_factor * surv_prob * fwd_dfs[i_flow]
+                acc_factor = self.cds_contract.accrual_factors[i_flow]
+                surv_prob = exp(-s *
+                                expiry_to_flow_times[i_flow] / lgd)
+                fwd_rpv01 += acc_factor * \
+                    surv_prob * fwd_dfs[i_flow]
 
             fwd_rpv01 += -accrual_factor_pcd_to_expiry
-            h = (s - index_coupon) * fwd_rpv01
+            h = (s - index_cpn) * fwd_rpv01
             maxh = max(h - strike_value, 0.0)
 
             int_h += h * pdf
             int_max_h += maxh * pdf
 
-        int_h *= INVROOT2PI * dz
-        int_max_h *= INVROOT2PI * dz * df_to_expiry
+        int_h *= INV_ROOT_2_PI * dz
+        int_max_h *= INV_ROOT_2_PI * dz * df_to_expiry
         return int_h, int_max_h
 
 ###############################################################################
 
     def __repr__(self):
         """ print out details of the CDS contract and all of the calculated
         cash flows """
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("INDEX COUPON", self._index_coupon*10000, "bp\n")
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("LONG PROTECTION", self._long_protection)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAYCOUNT", self._dc_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUSDAYRULE", self._bd_type)
-        s += label_to_string("DATEGENRULE", self._dg_type)
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("INDEX cpn", self.index_cpn*10000, "bp\n")
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("LONG PROTECTION", self.long_protect)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAYCOUNT", self.dc_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUSDAYRULE", self.bd_type)
+        s += label_to_string("DATEGENRULE", self.dg_type)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/credit/cds_index_portfolio.py` & `financepy-0.360/financepy/products/credit/cds_index_portfolio.py`

 * *Files 3% similar despite different names*

```diff
@@ -33,19 +33,19 @@
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create Fincds_indexPortfolio object. Note that all of the inputs
         have a default value which reflects the CDS market standard. """
 
         check_argument_types(self.__init__, locals())
 
-        self._dc_type = day_count_type
-        self._dg_type = dg_type
-        self._cal_type = cal_type
-        self._freq_type = freq_type
-        self._bd_type = bd_type
+        self.dc_type = day_count_type
+        self.dg_type = dg_type
+        self.cal_type = cal_type
+        self.freq_type = freq_type
+        self.bd_type = bd_type
 
     ###########################################################################
 
     def intrinsic_rpv01(self,
                         value_dt,
                         step_in_dt,
                         maturity_dt,
@@ -58,27 +58,27 @@
         cds_contract = CDS(step_in_dt,
                            maturity_dt,
                            0.0)
 
         intrinsic_rpv01 = 0.0
 
         for m in range(0, num_credits):
-            retValue = cds_contract.risky_pv01(value_dt,
+            ret_value = cds_contract.risky_pv01(value_dt,
                                                issuer_curves[m])
 
-            cleanRPV01 = retValue['clean_rpv01']
+            clean_rpv01 = ret_value['clean_rpv01']
 
-            intrinsic_rpv01 += cleanRPV01
+            intrinsic_rpv01 += clean_rpv01
 
         intrinsic_rpv01 /= num_credits
         return (intrinsic_rpv01)
 
     ###########################################################################
 
-    def intrinsic_protection_leg_pv(self,
+    def intrinsic_prot_leg_pv(self,
                                     value_dt,
                                     step_in_dt,
                                     maturity_dt,
                                     issuer_curves):
         """ Calculation of intrinsic protection leg value of the CDS portfolio
         by taking the average sum the protection legs of each contract. """
 
@@ -89,18 +89,18 @@
         # All contracts have same flows so only need one object
         cds_contract = CDS(step_in_dt,
                            maturity_dt,
                            0.0,
                            1.0)
 
         for m in range(0, num_credits):
-            protectionPV = cds_contract.protection_leg_pv(value_dt,
+            prot_pv = cds_contract.prot_leg_pv(value_dt,
                                                           issuer_curves[m])
 
-            intrinsic_prot_pv += protectionPV
+            intrinsic_prot_pv += prot_pv
 
         intrinsic_prot_pv /= num_credits
         return intrinsic_prot_pv
 
     ###########################################################################
 
     def intrinsic_spread(self,
@@ -108,15 +108,15 @@
                          step_in_dt,
                          maturity_dt,
                          issuer_curves):
         """ Calculation of the intrinsic spread of the CDS portfolio as the one
         which would make the value of the protection legs equal to the value of
         the premium legs if all premium legs paid the same spread. """
 
-        intrinsic_prot_pv = self.intrinsic_protection_leg_pv(value_dt,
+        intrinsic_prot_pv = self.intrinsic_prot_leg_pv(value_dt,
                                                              step_in_dt,
                                                              maturity_dt,
                                                              issuer_curves)
 
         intrinsic_rpv01 = self.intrinsic_rpv01(value_dt,
                                                step_in_dt,
                                                maturity_dt,
@@ -162,21 +162,21 @@
 
         num_credits = len(issuer_curves)
 
         cds_contract = CDS(step_in_dt,
                            maturity_dt,
                            0.0)
 
-        totalSpread = 0.0
+        total_spd = 0.0
 
         for m in range(0, num_credits):
             spread = cds_contract.par_spread(value_dt, issuer_curves[m])
-            totalSpread += spread
+            total_spd += spread
 
-        return totalSpread
+        return total_spd
 
     ###########################################################################
 
     def min_spread(self,
                    value_dt,
                    step_in_dt,
                    maturity_dt,
@@ -252,26 +252,26 @@
         num_credits = len(issuer_curves)
 
         if num_credits < 1:
             raise FinError(
                 "Number of credits in index must be > 1 and not "
                 + str(num_credits))
 
-        libor_curve = issuer_curves[0]._libor_curve
+        libor_curve = issuer_curves[0].libor_curve
         num_index_maturity_points = len(index_cpns)
 
         cds_maturity_dts = []
-        for cds in issuer_curves[0]._cds_contracts:
-            cds_dts = cds._maturity_dt
+        for cds in issuer_curves[0].cds_contracts:
+            cds_dts = cds.maturity_dt
             cds_maturity_dts.append(cds_dts)
 
         num_cds_mat_points = len(cds_maturity_dts)
 
         for issuer_curve in issuer_curves:
-            n = len(issuer_curve._cds_contracts)
+            n = len(issuer_curve.cds_contracts)
             if n != len(cds_maturity_dts):
                 raise FinError(
                     "All issuer discount must be from same cds maturities")
 
         cds_spread_multipliers = [1.0] * num_cds_mat_points
 
         #        spreadDifference = [0.0] * num_cds_mat_points
@@ -281,19 +281,19 @@
         #######################################################################
         # Set up CDS contracts used to build curve
         #######################################################################
 
         curve_cds_contracts = []
 
         for j in range(0, num_cds_mat_points):
-            cds_coupon = 1.0
+            cds_cpn = 1.0
 
             cds_contract = CDS(value_dt,
                                cds_maturity_dts[j],
-                               cds_coupon)
+                               cds_cpn)
 
             curve_cds_contracts.append(cds_contract)
 
         #######################################################################
         # We calibrate the individual CDS discount to fit each index maturity
         #######################################################################
 
@@ -314,37 +314,37 @@
 
                 # This is for the specific index maturity date
                 index_maturity_dt = index_maturity_dts[i_maturity]
                 cds_index = CDS(value_dt, index_maturity_dt, 0.0, 1.0)
 
                 for i_credit in range(0, num_credits):
 
-                    cds_contracts = issuer_curves[i_credit]._cds_contracts
-                    recovery_rate = issuer_curves[i_credit]._recovery_rate
+                    cds_contracts = issuer_curves[i_credit].cds_contracts
+                    recovery_rate = issuer_curves[i_credit].recovery_rate
                     adjusted_cds_contracts = []
 
                     for j in range(0, num_cds_mat_points):
-                        cds_spread = cds_contracts[j]._running_cpn
+                        cds_spread = cds_contracts[j].running_cpn
                         adjusted_cds_spreads[j] = cds_spread * cds_spread_multipliers[j]
-                        curve_cds_contracts[j]._running_cpn = adjusted_cds_spreads[j]
+                        curve_cds_contracts[j].running_cpn = adjusted_cds_spreads[j]
 
                     adjusted_issuer_curve = CDSCurve(value_dt,
                                                      curve_cds_contracts,
                                                      libor_curve,
                                                      recovery_rate)
 
-                    index_protection_pv = cds_index.protection_leg_pv(value_dt,
-                                                                    adjusted_issuer_curve,
-                                                                    index_recovery_rate)
+                    index_prot_pv = cds_index.prot_leg_pv(value_dt,
+                                                          adjusted_issuer_curve,
+                                                          index_recovery_rate)
 
                     clean_rpv01 = cds_index.risky_pv01(value_dt,
-                                                      adjusted_issuer_curve)['clean_rpv01']
+                                                       adjusted_issuer_curve)['clean_rpv01']
 
                     sum_rpv01 += clean_rpv01
-                    sum_prot += index_protection_pv
+                    sum_prot += index_prot_pv
 
                 sum_rpv01 /= num_credits
                 sum_prot /= num_credits
 
                 sum_prem = sum_rpv01 * index_cpns[i_maturity]
 
                 numerator = index_upfronts[i_maturity] + sum_prem
@@ -354,22 +354,22 @@
                 cds_spread_multipliers[i_maturity] *= alpha
 
         # use spread multipliers to build and store adjusted discount
         adjusted_issuer_curves = []
 
         for i_credit in range(0, num_credits):
 
-            recovery_rate = issuer_curves[i_credit]._recovery_rate
+            recovery_rate = issuer_curves[i_credit].recovery_rate
 
             adjusted_cds_contracts = []
             adjusted_spreads = []
 
             for j in range(0, num_cds_mat_points):
 
-                unadjusted_spread = issuer_curves[i_credit]._cds_contracts[j]._running_cpn
+                unadjusted_spread = issuer_curves[i_credit].cds_contracts[j].running_cpn
 
                 adjusted_spread = unadjusted_spread * cds_spread_multipliers[j]
 
                 adjusted_cds_contract = CDS(value_dt,
                                             cds_maturity_dts[j],
                                             adjusted_spread)
 
@@ -409,15 +409,15 @@
             print(index_recovery_rate)
 
         num_credits = len(issuer_curves)
 
         if num_credits < 1:
             raise FinError("Number of credits must be greater than 1")
 
-        libor_curve = issuer_curves[0]._libor_curve
+        libor_curve = issuer_curves[0].libor_curve
         num_index_maturity_points = len(index_cpns)
 
         #        hazardRateMultipliers = [1.0] * numIndexMaturityPoints
 
         adjusted_issuer_curves = []
 
         # making a copy of the issuer discount
@@ -442,78 +442,78 @@
 
                 num_iterations += 1
 
                 if num_iterations > max_iterations:
                     raise FinError("Max Iterations exceeded")
 
                 sum_rpv01 = 0.0
-                sumProt = 0.0
+                sum_prot = 0.0
 
                 for i_credit in range(0, num_credits):
                     q1 = adjusted_issuer_curves[i_credit]._values[i_maturity]
                     q2 = adjusted_issuer_curves[i_credit]._values[i_maturity + 1]
                     q12 = q2 / q1
 
-                    q12NEW = pow(q12, ratio)
-                    q2NEW = q1 * q12NEW
+                    q12_new = pow(q12, ratio)
+                    q2_new = q1 * q12_new
 
-                    adjusted_issuer_curves[i_credit]._values[i_maturity + 1] = q2NEW
+                    adjusted_issuer_curves[i_credit]._values[i_maturity + 1] = q2_new
 
                     #                    if i_maturity == 0 and index_cpns[0] == 0.006:
-                    #                        print(i_credit, q1, q2NEW)
+                    #                        print(i_credit, q1, q2_new)
 
                     index_maturity_dt = index_maturity_dts[i_maturity]
 
                     # the CDS spreads we extract here
                     # should be to the index maturity dates
                     cds_index = CDS(value_dt,
                                     index_maturity_dt,
                                     0,
                                     1.0)
 
-                    indexProtPV = cds_index.protection_leg_pv(value_dt,
+                    index_prot_pv = cds_index.prot_leg_pv(value_dt,
                                                               adjusted_issuer_curves[i_credit],
                                                               index_recovery_rate)
 
-                    rpv01Ret = cds_index.risky_pv01(value_dt,
+                    rpv01_ret = cds_index.risky_pv01(value_dt,
                                                     adjusted_issuer_curves[i_credit])
 
-                    cleanRPV01 = rpv01Ret['clean_rpv01']
+                    clean_rpv01 = rpv01_ret['clean_rpv01']
 
-                    sum_rpv01 += cleanRPV01
-                    sumProt += indexProtPV
+                    sum_rpv01 += clean_rpv01
+                    sum_prot += index_prot_pv
 
                 sum_rpv01 /= num_credits
-                sumProt /= num_credits
+                sum_prot /= num_credits
 
-                spd = sumProt / sum_rpv01
+                spd = sum_prot / sum_rpv01
 
-                sumPrem = sum_rpv01 * index_cpns[i_maturity]
+                sum_prem = sum_rpv01 * index_cpns[i_maturity]
 
-                numerator = index_up_fronts[i_maturity] + sumPrem
-                denominator = sumProt
+                numerator = index_up_fronts[i_maturity] + sum_prem
+                denominator = sum_prot
 
                 ratio = numerator / denominator
                 alpha *= ratio
 
         #                print("Maturity:", i_maturity, "Num:", numerator, "Den:", denominator, "Ratio:", ratio, "Alpha:", alpha)
         #           print("")
 
         return adjusted_issuer_curves
 
     ###########################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAYCOUNT", self._dc_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUSDAYRULE", self._bd_type)
-        s += label_to_string("DATEGENRULE", self._dg_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAYCOUNT", self.dc_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUSDAYRULE", self.bd_type)
+        s += label_to_string("DATEGENRULE", self.dg_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/credit/cds_option.py` & `financepy-0.360/financepy/products/credit/cds_option.py`

 * *Files 5% similar despite different names*

```diff
@@ -43,15 +43,15 @@
     spread agreed today and to be exercised in the future on a specified expiry
     date. The option may or may not cancel if there is a credit event before
     option expiry. This needs to be specified. """
 
     def __init__(self,
                  expiry_dt: Date,
                  maturity_dt: Date,
-                 strike_coupon: float,
+                 strike_cpn: float,
                  notional: float = ONE_MILLION,
                  long_protection: bool = True,
                  knockout_flag: bool = True,
                  freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  dc_type: DayCountTypes = DayCountTypes.ACT_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
@@ -62,93 +62,93 @@
         event before expiry and the payment details of the underlying CDS. """
 
         check_argument_types(self.__init__, locals())
 
         if maturity_dt < expiry_dt:
             raise FinError("Maturity date must be after option expiry date")
 
-        if strike_coupon < 0.0:
+        if strike_cpn < 0.0:
             raise FinError("Strike must be greater than zero")
 
-        self._expiry_dt = expiry_dt
-        self._maturity_dt = maturity_dt
-        self._strike_coupon = strike_coupon
-        self._long_protection = long_protection
-        self._knockout_flag = knockout_flag
-        self._notional = notional
-
-        self._freq_type = freq_type
-        self._dc_type = dc_type
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
+        self.expiry_dt = expiry_dt
+        self.maturity_dt = maturity_dt
+        self.strike_cpn = strike_cpn
+        self.long_protection = long_protection
+        self.knockout_flag = knockout_flag
+        self.notional = notional
+
+        self.freq_type = freq_type
+        self.dc_type = dc_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
 
 ###############################################################################
 
     def value(self,
               value_dt,
               issuer_curve,
               volatility):
         """ Value the CDS option using Black's model with an adjustment for any
         Front End Protection.
         TODO - Should the CDS be created in the init method ? """
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Expiry date is now or in the past")
 
         if volatility < 0.0:
             raise FinError("Volatility must be greater than zero")
 
         # The underlying is a forward starting option that steps in on
         # the expiry date and matures on the expiry date with a coupon
         # set equal to the option spread strike
-        cds = CDS(self._expiry_dt,
-                  self._maturity_dt,
-                  self._strike_coupon,
-                  self._notional,
-                  self._long_protection,
-                  self._freq_type,
-                  self._dc_type,
-                  self._cal_type,
-                  self._bd_type,
-                  self._dg_type)
+        cds = CDS(self.expiry_dt,
+                  self.maturity_dt,
+                  self.strike_cpn,
+                  self.notional,
+                  self.long_protection,
+                  self.freq_type,
+                  self.dc_type,
+                  self.cal_type,
+                  self.bd_type,
+                  self.dg_type)
 
-        strike = self._strike_coupon
+        strike = self.strike_cpn
         forward_spread = cds.par_spread(value_dt, issuer_curve)
         forward_rpv01 = cds.risky_pv01(
             value_dt, issuer_curve)['dirty_rpv01']
 
-        time_to_expiry = (self._expiry_dt - value_dt) / gDaysInYear
-        logMoneyness = log(forward_spread / strike)
+        time_to_expiry = (self.expiry_dt - value_dt) / gDaysInYear
+        log_moneyness = log(forward_spread / strike)
 
-        halfVolSquaredT = 0.5 * volatility * volatility * time_to_expiry
-        volSqrtT = volatility * sqrt(time_to_expiry)
+        half_vol_squared_t = 0.5 * volatility * volatility * time_to_expiry
+        vol_sqrt_t = volatility * sqrt(time_to_expiry)
 
-        d1 = (logMoneyness + halfVolSquaredT) / volSqrtT
-        d2 = (logMoneyness - halfVolSquaredT) / volSqrtT
+        d1 = (log_moneyness + half_vol_squared_t) / vol_sqrt_t
+        d2 = (log_moneyness - half_vol_squared_t) / vol_sqrt_t
 
-        if self._long_protection:
+        if self.long_protection:
             option_value = forward_spread * N(d1) - strike * N(d2)
         else:
             option_value = strike * N(-d2) - forward_spread * N(-d1)
 
         option_value = option_value * forward_rpv01
 
         # If the option does not knock out on a default before expiry then we
         # need to include the cost of protection which is provided between
         # the value date and the expiry date
-        if self._knockout_flag is False and self._long_protection is True:
+        if self.knockout_flag is False and self.long_protection is True:
             df = issuer_curve.getDF(time_to_expiry)
             q = issuer_curve.getSurvProb(time_to_expiry)
-            recovery = issuer_curve._recovery_rate
-            frontEndProtection = df * (1.0 - q) * (1.0 - recovery)
-            option_value += frontEndProtection
+            recovery = issuer_curve.recovery_rate
+            front_end_protection = df * (1.0 - q) * (1.0 - recovery)
+            option_value += front_end_protection
 
         # we return the option price in dollars
-        return option_value * self._notional
+        return option_value * self.notional
 
 ###############################################################################
 
     def implied_volatility(self,
                            value_dt,
                            issuer_curve,
                            option_value):
```

### Comparing `financepy-0.350/financepy/products/credit/cds_tranche.py` & `financepy-0.360/financepy/products/credit/cds_tranche.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 # TODO: Add __repr__ method
 
 from math import sqrt
+
 import numpy as np
 
 from ...models.gauss_copula_onefactor import tranch_surv_prob_gaussian
 from ...models.gauss_copula_onefactor import tranche_surv_prob_adj_binomial
 from ...models.gauss_copula_onefactor import tranche_surv_prob_recursion
 from ...models.gauss_copula_lhp import tr_surv_prob_lhp
 
@@ -30,15 +31,14 @@
 
 ###############################################################################
 
 from enum import Enum
 
 
 class FinLossDistributionBuilder(Enum):
-    ''' Method for constructing loss distributions numerically '''
     RECURSION = 1
     ADJUSTED_BINOMIAL = 2
     GAUSSIAN = 3
     LHP = 4
 
 
 ###############################################################################
@@ -49,69 +49,69 @@
     def __init__(self,
                  step_in_dt: Date,
                  maturity_dt: Date,
                  k1: float,
                  k2: float,
                  notional: float = ONE_MILLION,
                  running_cpn: float = 0.0,
-                 long_protection: bool = True,
+                 long_protect: bool = True,
                  freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  dc_type: DayCountTypes = DayCountTypes.ACT_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
 
         check_argument_types(self.__init__, locals())
 
         if k1 >= k2:
             raise FinError("K1 must be less than K2")
 
-        self._k1 = k1
-        self._k2 = k2
+        self.k1 = k1
+        self.k2 = k2
 
-        self._step_in_dt = step_in_dt
-        self._maturity_dt = maturity_dt
-        self._notional = notional
-        self._running_cpn = running_cpn
-        self._long_protection = long_protection
-        self._dc_type = dc_type
-        self._dg_type = dg_type
-        self._cal_type = cal_type
-        self._freq_type = freq_type
-        self._bd_type = bd_type
+        self.step_in_dt = step_in_dt
+        self.maturity_dt = maturity_dt
+        self.notional = notional
+        self.running_cpn = running_cpn
+        self.long_protect = long_protect
+        self.dc_type = dc_type
+        self.dg_type = dg_type
+        self.cal_type = cal_type
+        self.freq_type = freq_type
+        self.bd_type = bd_type
 
         notional = 1.0
 
-        self._cds_contract = CDS(self._step_in_dt,
-                                 self._maturity_dt,
-                                 self._running_cpn,
+        self.cds_contract = CDS(self.step_in_dt,
+                                 self.maturity_dt,
+                                 self.running_cpn,
                                  notional,
-                                 self._long_protection,
-                                 self._freq_type,
-                                 self._dc_type,
-                                 self._cal_type,
-                                 self._bd_type,
-                                 self._dg_type)
+                                 self.long_protect,
+                                 self.freq_type,
+                                 self.dc_type,
+                                 self.cal_type,
+                                 self.bd_type,
+                                 self.dg_type)
 
     ###########################################################################
 
     def value_bc(self,
                  value_dt,
                  issuer_curves,
                  upfront,
                  running_cpn,
                  corr1,
                  corr2,
                  num_points=50,
                  model=FinLossDistributionBuilder.RECURSION):
 
         num_credits = len(issuer_curves)
-        k1 = self._k1
-        k2 = self._k2
-        t_mat = (self._maturity_dt - value_dt) / gDaysInYear
+        k1 = self.k1
+        k2 = self.k2
+        t_mat = (self.maturity_dt - value_dt) / gDaysInYear
 
         if t_mat < 0.0:
             raise FinError("Value date is after maturity date")
 
         if abs(k1 - k2) < 0.00000001:
             output = np.zeros(4)
             output[0] = 0.0
@@ -123,15 +123,15 @@
         if k1 > k2:
             raise FinError("K1 > K2")
 
         kappa = k2 / (k2 - k1)
 
         recovery_rates = np.zeros(num_credits)
 
-        payment_dts = self._cds_contract._payment_dts
+        payment_dts = self.cds_contract.payment_dts
         num_payments = len(payment_dts)
         num_times = num_payments + 1
 
         beta_1 = sqrt(corr1)
         beta_2 = sqrt(corr2)
         beta_vector1 = np.zeros(num_credits)
         for bb in range(0, num_credits):
@@ -156,19 +156,19 @@
         for i in range(1, num_times):
 
             t = (payment_dts[i-1] - value_dt) / gDaysInYear
 
             for j in range(0, num_credits):
 
                 issuer_curve = issuer_curves[j]
-                vTimes = issuer_curve._times
-                qRow = issuer_curve._values
-                recovery_rates[j] = issuer_curve._recovery_rate
+                v_times = issuer_curve._times
+                q_row = issuer_curve._values
+                recovery_rates[j] = issuer_curve.recovery_rate
                 q_vector[j] = interpolate(
-                    t, vTimes, qRow, InterpTypes.FLAT_FWD_RATES.value)
+                    t, v_times, q_row, InterpTypes.FLAT_FWD_RATES.value)
 
             if model == FinLossDistributionBuilder.RECURSION:
 
                 qt1[i] = tranche_surv_prob_recursion(
                     0.0, k1, num_credits, q_vector, recovery_rates,
                     beta_vector1, num_points)
 
@@ -194,18 +194,18 @@
 
                 qt2[i] = tranch_surv_prob_gaussian(0.0, k2, num_credits,
                                                    q_vector, recovery_rates,
                                                    beta_vector2, num_points)
 
             elif model == FinLossDistributionBuilder.LHP:
 
-                qt1[i] = tr_surv_prob_lhp(0.0, k1, num_credits, 
+                qt1[i] = tr_surv_prob_lhp(0.0, k1, num_credits,
                                           q_vector, recovery_rates, beta_1)
 
-                qt2[i] = tr_surv_prob_lhp(0.0, k2, num_credits, 
+                qt2[i] = tr_surv_prob_lhp(0.0, k2, num_credits,
                                           q_vector, recovery_rates, beta_2)
 
             else:
                 raise FinError(
                     "Unknown model type only full and AdjBinomial allowed")
 
             if qt1[i] > qt1[i - 1]:
@@ -216,32 +216,33 @@
                 raise FinError(
                     "Tranche K2 survival probabilities not decreasing.")
 
             tranche_surv_curve[i] = kappa * qt2[i] + (1.0 - kappa) * qt1[i]
             tranche_times[i] = t
 
         curve_recovery = 0.0  # For tranches only
-        libor_curve = issuer_curves[0]._libor_curve
+        libor_curve = issuer_curves[0].libor_curve
         tranche_curve = CDSCurve(
             value_dt, [], libor_curve, curve_recovery)
         tranche_curve._times = tranche_times
         tranche_curve._values = tranche_surv_curve
 
-        protLegPV = self._cds_contract.protection_leg_pv(
+        prot_leg_pv = self.cds_contract.prot_leg_pv(
             value_dt, tranche_curve, curve_recovery)
-        risky_pv01 = self._cds_contract.risky_pv01(
+        risky_pv01 = self.cds_contract.risky_pv01(
             value_dt, tranche_curve)['clean_rpv01']
 
-        mtm = self._notional * (protLegPV - upfront - risky_pv01 * running_cpn)
+        mtm = self.notional * (prot_leg_pv - upfront -
+                                risky_pv01 * running_cpn)
 
-        if not self._long_protection:
+        if not self.long_protect:
             mtm *= -1.0
 
         tranche_output = np.zeros(4)
         tranche_output[0] = mtm
-        tranche_output[1] = risky_pv01 * self._notional * running_cpn
-        tranche_output[2] = protLegPV * self._notional
-        tranche_output[3] = protLegPV / risky_pv01
+        tranche_output[1] = risky_pv01 * self.notional * running_cpn
+        tranche_output[2] = prot_leg_pv * self.notional
+        tranche_output[3] = prot_leg_pv / risky_pv01
 
         return tranche_output
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/__init__.py` & `financepy-0.360/financepy/products/equity/__init__.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/products/equity/equity_american_option.py` & `financepy-0.360/financepy/products/equity/equity_american_option.py`

 * *Files 9% similar despite different names*

```diff
@@ -38,76 +38,76 @@
 
         if option_type != OptionTypes.EUROPEAN_CALL and \
             option_type != OptionTypes.EUROPEAN_PUT and \
             option_type != OptionTypes.AMERICAN_CALL and \
                 option_type != OptionTypes.AMERICAN_PUT:
             raise FinError("Unknown Option Type" + str(option_type))
 
-        self._expiry_dt = expiry_dt
-        self._strike_price = strike_price
-        self._option_type = option_type
-        self._num_options = num_options
+        self.expiry_dt = expiry_dt
+        self.strike_price = strike_price
+        self.option_type = option_type
+        self.num_options = num_options
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: (np.ndarray, float),
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model: Model):
         """ Valuation of an American option using a CRR tree to take into
         account the value of early exercise. """
 
-        if discount_curve.value_dt() != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve.value_dt() != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if isinstance(model, Model) is False:
             raise FinError("Model is not inherited off type FinModel.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         t_exp = np.maximum(t_exp, 1e-10)
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
         s = stock_price
-        k = self._strike_price
+        k = self.strike_price
 
-        v = model.value(s, t_exp, k, r, q, self._option_type)
-        v = v * self._num_options
+        v = model.value(s, t_exp, k, r, q, self.option_type)
+        v = v * self.num_options
 
         if isinstance(s, float):
             return v
         else:
             return v[0]
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("NUMBER", self._num_options, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("NUMBER", self.num_options, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_asian_option.py` & `financepy-0.360/financepy/products/equity/equity_asian_option.py`

 * *Files 5% similar despite different names*

```diff
@@ -21,15 +21,14 @@
 
 from ...utils.math import N
 
 
 ###############################################################################
 
 class AsianOptionValuationMethods(Enum):
-    ''' Types of Asian Option valuation methods '''
     GEOMETRIC = 1,
     TURNBULL_WAKEMAN = 2,
     CURRAN = 3
 
 ###############################################################################
 
 
@@ -64,15 +63,15 @@
 ###############################################################################
 
 
 @njit(cache=True, fastmath=True)
 def _value_mc_numba(t0,
                     t,
                     tau,
-                    K,
+                    k,
                     n,
                     option_type,
                     stock_price,
                     interest_rate,
                     dividend_yield,
                     volatility,
                     num_paths,
@@ -85,15 +84,15 @@
 
     if t0 < 0.0:  # we are in the averaging period
 
         if accrued_average is None:
             raise FinError(errorStr)
 
         # we adjust the strike to account for the accrued coupon
-        K = (K * tau + accrued_average * t0) / t
+        k = (k * tau + accrued_average * t0) / t
         # the number of options is rescaled also
         multiplier = t / tau
         # there is no pre-averaging time
         t0 = 0.0
         # the number of observations is scaled and floored at 1
         n = int(n * t / tau + 0.5) + 1
 
@@ -129,34 +128,34 @@
             s_1_arithmetic += s_1
             s_2_arithmetic += s_2
 
         s_1_arithmetic /= n
         s_2_arithmetic /= n
 
         if option_type == OptionTypes.EUROPEAN_CALL:
-            payoff_a += max(s_1_arithmetic - K, 0.0)
-            payoff_a += max(s_2_arithmetic - K, 0.0)
+            payoff_a += max(s_1_arithmetic - k, 0.0)
+            payoff_a += max(s_2_arithmetic - k, 0.0)
         elif option_type == OptionTypes.EUROPEAN_PUT:
-            payoff_a += max(K - s_1_arithmetic, 0.0)
-            payoff_a += max(K - s_2_arithmetic, 0.0)
+            payoff_a += max(k - s_1_arithmetic, 0.0)
+            payoff_a += max(k - s_2_arithmetic, 0.0)
         else:
             return None
 
     v_a = payoff_a * np.exp(-interest_rate * t) / num_paths / 2.0
     v_a = v_a * multiplier
     return v_a
 
 ###############################################################################
 
 
 @njit(cache=True, fastmath=True)
 def _value_mc_fast_numba(t0: float,
                          t: float,
                          tau: float,
-                         K: float,
+                         k: float,
                          n: int,
                          option_type: int,
                          stock_price: float,
                          interest_rate: float,
                          dividend_yield: float,
                          volatility: float,
                          num_paths: int,
@@ -174,15 +173,15 @@
 
     if t0 < 0.0:  # we are in the averaging period
 
         if accrued_average is None:
             raise FinError(errorStr)
 
         # we adjust the strike to account for the accrued coupon
-        K = (K * tau + accrued_average * t0) / t
+        k = (k * tau + accrued_average * t0) / t
         # the number of options is rescaled also
         multiplier = t / tau
         # there is no pre-averaging time
         t0 = 0.0
         # the number of observations is scaled and floored at 1
         n = int(n * t / tau + 0.5) + 1
 
@@ -217,19 +216,19 @@
                                        dt - g[ip] * np.sqrt(dt) * volatility)
 
         for ip in range(0, num_paths):
             s_1_arithmetic[ip] += s_1[ip] / n
             s_2_arithmetic[ip] += s_2[ip] / n
 
     if option_type == OptionTypes.EUROPEAN_CALL.value:
-        payoff_a_1 = np.maximum(s_1_arithmetic - K, 0.0)
-        payoff_a_2 = np.maximum(s_2_arithmetic - K, 0.0)
+        payoff_a_1 = np.maximum(s_1_arithmetic - k, 0.0)
+        payoff_a_2 = np.maximum(s_2_arithmetic - k, 0.0)
     elif option_type == OptionTypes.EUROPEAN_PUT.value:
-        payoff_a_1 = np.maximum(K - s_1_arithmetic, 0.0)
-        payoff_a_2 = np.maximum(K - s_2_arithmetic, 0.0)
+        payoff_a_1 = np.maximum(k - s_1_arithmetic, 0.0)
+        payoff_a_2 = np.maximum(k - s_2_arithmetic, 0.0)
     else:
         raise FinError("Unknown option type.")
 
     payoff_a = np.mean(payoff_a_1) + np.mean(payoff_a_2)
     v_a = multiplier * payoff_a * np.exp(- r * t) / 2.0
     return v_a
 
@@ -361,19 +360,19 @@
         number of observations. """
 
         check_argument_types(self.__init__, locals())
 
         if start_averaging_dt > expiry_dt:
             raise FinError("Averaging starts after expiry date")
 
-        self._startAveragingDate = start_averaging_dt
-        self._expiry_dt = expiry_dt
-        self._strike_price = float(strike_price)
-        self._option_type = option_type
-        self._num_observations = num_obs
+        self.start_averaging_date = start_averaging_dt
+        self.expiry_dt = expiry_dt
+        self.strike_price = float(strike_price)
+        self.option_type = option_type
+        self.num_observations = num_obs
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
@@ -391,22 +390,22 @@
         by Curran based on conditioning on the geometric mean price. Just
         choose the corresponding enumerated value to switch between these
         different approaches.
 
         Note that the accrued average is only required if the value date is
         inside the averaging period for the option. """
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option valuation date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option valuation date")
 
         if method == AsianOptionValuationMethods.GEOMETRIC:
             v = self._value_geometric(value_dt,
                                       stock_price,
                                       discount_curve,
@@ -440,32 +439,32 @@
                          dividend_curve, model, accrued_average):
         """ This option valuation is based on paper by Kemna and Vorst 1990. It
         calculates the Geometric Asian option price which is a lower bound on
         the Arithmetic option price. This should not be used as a valuation
         model for the Arithmetic Average option but can be used as a control
         variate for other approaches. """
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after option expiry date.")
 
         # the years to the start of the averaging period
-        t0 = (self._startAveragingDate - value_dt) / gDaysInYear
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        tau = (self._expiry_dt - self._startAveragingDate) / gDaysInYear
+        t0 = (self.start_averaging_date - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        tau = (self.expiry_dt - self.start_averaging_date) / gDaysInYear
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
 #        print("r:", r, "q:", q)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
-        K = self._strike_price
-        n = self._num_observations
-        S0 = stock_price
+        K = self.strike_price
+        n = self.num_observations
+        s0 = stock_price
 
         multiplier = 1.0
 
         if t0 < 0:  # we are in the averaging period
 
             if accrued_average is None:
                 raise FinError(errorStr)
@@ -478,63 +477,63 @@
             t0 = 0.0
             # the number of observations is scaled
             n = n * t_exp / tau
 
         sigSq = volatility ** 2
         meanGeo = (r - q - sigSq / 2.0) * (t0 + (t_exp - t0) / 2.0)
         varGeo = sigSq * (t0 + (t_exp - t0) * (2 * n - 1) / (6 * n))
-        EG = S0 * np.exp(meanGeo + varGeo / 2.0)
+        EG = s0 * np.exp(meanGeo + varGeo / 2.0)
 
         if np.abs(varGeo) < 1e-10:
             raise FinError("Asian option geometric variance is zero.")
 
-        d1 = (meanGeo + np.log(S0 / K) + varGeo) / np.sqrt(varGeo)
+        d1 = (meanGeo + np.log(s0 / K) + varGeo) / np.sqrt(varGeo)
         d2 = d1 - np.sqrt(varGeo)
 
         # the Geometric price is the lower bound
         call_g = np.exp(-r * t_exp) * (EG * N(d1) - K * N(d2))
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             v = call_g
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             put_g = call_g - (EG - K) * np.exp(-r * t_exp)
             v = put_g
         else:
-            raise FinError("Unknown option type " + str(self._option_type))
+            raise FinError("Unknown option type " + str(self.option_type))
 
         v = v * multiplier
         return v
 
 ###############################################################################
 
     def _value_curran(self, value_dt, stock_price, discount_curve,
                       dividend_curve, model, accrued_average):
         """ Valuation of an Asian option using the result by Vorst. """
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after option expiry date.")
 
         # the years to the start of the averaging period
-        t0 = (self._startAveragingDate - value_dt) / gDaysInYear
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        tau = (self._expiry_dt - self._startAveragingDate) / gDaysInYear
+        t0 = (self.start_averaging_date - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        tau = (self.expiry_dt - self.start_averaging_date) / gDaysInYear
 
         multiplier = 1.0
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
-        S0 = stock_price
+        s0 = stock_price
         b = r - q
         sigma2 = volatility**2
-        K = self._strike_price
+        K = self.strike_price
 
-        n = self._num_observations
+        n = self.num_observations
 
         if t0 < 0:  # we are in the averaging period
 
             if accrued_average is None:
                 raise FinError(errorStr)
 
             # we adjust the strike to account for the accrued coupon
@@ -547,26 +546,26 @@
             n = int(n * t_exp / tau + 0.5) + 1
 
         h = (t_exp - t0) / (n - 1)
         u = (1.0 - np.exp(b * h * n)) / (1.0 - np.exp(b * h))
         w = (1.0 - np.exp((2 * b + sigma2) * h * n)) / \
             (1.0 - np.exp((2 * b + sigma2) * h))
 
-        FA = (S0 / n) * np.exp(b * t0) * u
-        EA2 = (S0 * S0 / n / n) * np.exp((2.0 * b + sigma2) * t0)
+        FA = (s0 / n) * np.exp(b * t0) * u
+        EA2 = (s0 * s0 / n / n) * np.exp((2.0 * b + sigma2) * t0)
         EA2 = EA2 * (w + 2.0 / (1.0 - np.exp((b + sigma2) * h)) * (u - w))
         sigmaA = np.sqrt((np.log(EA2) - 2.0 * np.log(FA)) / t_exp)
 
         d1 = (np.log(FA / K) + sigmaA * sigmaA *
               t_exp / 2.0) / (sigmaA*np.sqrt(t_exp))
         d2 = d1 - sigmaA * np.sqrt(t_exp)
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             v = np.exp(-r * t_exp) * (FA * N(d1) - K * N(d2))
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             v = np.exp(-r * t_exp) * (K * N(-d2) - FA * N(-d1))
         else:
             return None
 
         v = v * multiplier
         return v
 
@@ -574,29 +573,29 @@
 
     def _value_turnbull_wakeman(self, value_dt, stock_price, discount_curve,
                                 dividend_curve, model, accrued_average):
         """ Asian option valuation based on paper by Turnbull and Wakeman 1991
         which uses the edgeworth expansion to find the first two moments of the
         arithmetic average. """
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after option expiry date.")
 
-        t0 = (self._startAveragingDate - value_dt) / gDaysInYear
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        tau = (self._expiry_dt - self._startAveragingDate) / gDaysInYear
+        t0 = (self.start_averaging_date - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        tau = (self.expiry_dt - self.start_averaging_date) / gDaysInYear
 
-        K = self._strike_price
+        K = self.strike_price
         multiplier = 1.0
-        n = self._num_observations
+        n = self.num_observations
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
         if t0 < 0:  # we are in the averaging period
 
             if accrued_average is None:
                 raise FinError(errorStr)
 
             # we adjust the strike to account for the accrued coupon
@@ -609,40 +608,40 @@
             n = int(n * t_exp / tau + 0.5) + 1
 
         # need to handle this
         b = r - q
         sigma2 = volatility**2
         a1 = b + sigma2
         a2 = 2 * b + sigma2
-        S0 = stock_price
+        s0 = stock_price
 
         dt = t_exp - t0
 
         if b == 0:
             M1 = 1.0
             M2 = 2.0 * np.exp(sigma2 * t_exp) - 2.0 * \
                 np.exp(sigma2 * t0) * (1.0 + sigma2 * dt)
             M2 = M2 / sigma2 / sigma2 / dt / dt
         else:
-            M1 = S0 * (np.exp(b * t_exp) - np.exp(b * t0)) / (b * dt)
+            M1 = s0 * (np.exp(b * t_exp) - np.exp(b * t0)) / (b * dt)
             M2 = np.exp(a2 * t_exp) / a1 / a2 / dt / dt + \
                 (np.exp(a2 * t0) / b / dt / dt) * (1.0/a2 - np.exp(b*dt) / a1)
-            M2 = 2.0 * M2 * S0 * S0
+            M2 = 2.0 * M2 * s0 * s0
 
         F0 = M1
         sigma2 = (1.0 / t_exp) * np.log(M2 / M1 / M1)
         sigma = np.sqrt(sigma2)
 
         d1 = (np.log(F0 / K) + sigma2 * t_exp / 2) / sigma / np.sqrt(t_exp)
         d2 = d1 - sigma * np.sqrt(t_exp)
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             call = np.exp(-r * t_exp) * (F0 * N(d1) - K * N(d2))
             v = call
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             put = np.exp(-r * t_exp) * (K * N(-d2) - F0 * N(-d1))
             v = put
         else:
             return None
 
         v = v * multiplier
         return v
@@ -659,34 +658,34 @@
                   seed: int,
                   accrued_average: float):
         """ Monte Carlo valuation of the Asian Average option using standard
         Monte Carlo code enhanced by Numba. I have discontinued the use of this
         as it is both slow and has limited variance reduction. """
 
         # Basic validation
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after option expiry date.")
 
-        if value_dt > self._startAveragingDate and accrued_average is None:
+        if value_dt > self.start_averaging_date and accrued_average is None:
             raise FinError(errorStr)
 
         # the years to the start of the averaging period
-        t0 = (self._startAveragingDate - value_dt) / gDaysInYear
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        tau = (self._expiry_dt - self._startAveragingDate) / gDaysInYear
+        t0 = (self.start_averaging_date - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        tau = (self.expiry_dt - self.start_averaging_date) / gDaysInYear
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
-        K = self._strike_price
-        n = self._num_observations
+        K = self.strike_price
+        n = self.num_observations
 
-        v = _value_mc_numba(t0, t_exp, tau, K, n, self._option_type,
+        v = _value_mc_numba(t0, t_exp, tau, K, n, self.option_type,
                             stock_price,
                             r,
                             q,
                             volatility,
                             num_paths,
                             seed,
                             accrued_average)
@@ -704,28 +703,28 @@
                        num_paths,       # Numpaths integer
                        seed,
                        accrued_average):
         """ Monte Carlo valuation of the Asian Average option. This method uses
         a lot of Numpy vectorisation. It is also helped by Numba. """
 
         # the years to the start of the averaging period
-        t0 = (self._startAveragingDate - value_dt) / gDaysInYear
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        tau = (self._expiry_dt - self._startAveragingDate) / gDaysInYear
+        t0 = (self.start_averaging_date - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        tau = (self.expiry_dt - self.start_averaging_date) / gDaysInYear
 
-        K = self._strike_price
-        n = self._num_observations
+        K = self.strike_price
+        n = self.num_observations
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
         v = _value_mc_fast_numba(t0, t_exp, tau,
-                                 K, n, self._option_type.value,
+                                 K, n, self.option_type.value,
                                  stock_price,
                                  r,
                                  q,
                                  volatility,
                                  num_paths,
                                  seed,
                                  accrued_average)
@@ -744,40 +743,40 @@
                  seed: int,
                  accrued_average: float):
         """ Monte Carlo valuation of the Asian Average option using a control
         variate method that improves accuracy and reduces the variance of the
         price. This uses Numpy and Numba. This is the standard MC pricer. """
 
         # the years to the start of the averaging period
-        t0 = (self._startAveragingDate - value_dt) / gDaysInYear
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        tau = (self._expiry_dt - self._startAveragingDate) / gDaysInYear
+        t0 = (self.start_averaging_date - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        tau = (self.expiry_dt - self.start_averaging_date) / gDaysInYear
 
-        K = self._strike_price
-        n = self._num_observations
+        K = self.strike_price
+        n = self.num_observations
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
         # For control variate we price a Geometric average option exactly
         v_g_exact = self._value_geometric(value_dt,
                                           stock_price,
                                           discount_curve,
                                           dividend_curve,
                                           model,
                                           accrued_average)
 
         v = _value_mc_fast_cv_numba(t0,
                                     t_exp,
                                     tau,
                                     K,
                                     n,
-                                    self._option_type,
+                                    self.option_type,
                                     stock_price,
                                     r,
                                     q,
                                     volatility,
                                     num_paths,
                                     seed,
                                     accrued_average,
@@ -785,19 +784,19 @@
 
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START AVERAGING DATE", self._startAveragingDate)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("NUM OBSERVATIONS", self._num_observations, "")
+        s += label_to_string("START AVERAGING DATE", self.start_averaging_date)
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("NUM OBSERVATIONS", self.num_observations, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_barrier_option.py` & `financepy-0.360/financepy/products/equity/equity_barrier_option.py`

 * *Files 9% similar despite different names*

```diff
@@ -35,24 +35,24 @@
                  notional: float = 1.0):
         """ Create the EquityBarrierOption by specifying the expiry date,
         strike price, option type, barrier level, the number of observations
         per year and the notional. """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._strike_price = float(strike_price)
-        self._barrier_level = float(barrier_level)
-        self._num_obs_per_year = int(num_obs_per_year)
+        self.expiry_dt = expiry_dt
+        self.strike_price = float(strike_price)
+        self.barrier_level = float(barrier_level)
+        self.num_obs_per_year = int(num_obs_per_year)
 
         if option_type not in EquityBarrierTypes:
             raise FinError("Option Type " + str(option_type) + " unknown.")
 
-        self._option_type = option_type
-        self._notional = notional
+        self.option_type = option_type
+        self.notional = notional
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: (float, np.ndarray),
               discount_curve: DiscountCurve,
@@ -64,51 +64,51 @@
 
         https://warwick.ac.uk/fac/soc/wbs/subjects/finance/research/wpaperseries/1994/94-54.pdf
         """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve.value_dt() != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve.value_dt() != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
         if isinstance(stock_price, int):
             stock_price = float(stock_price)
 
         if isinstance(stock_price, float):
             stock_prices = [stock_price]
         else:
             stock_prices = stock_price
 
         values = []
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
         if t_exp < 0:
             raise FinError("Option expires before value date.")
 
         values = value_barrier(t_exp,
-                               self._strike_price,
-                               self._barrier_level,
+                               self.strike_price,
+                               self.barrier_level,
                                stock_prices,
-                               discount_curve.cc_rate(self._expiry_dt),
-                               dividend_curve.cc_rate(self._expiry_dt),
-                               model._volatility,
-                               self._option_type.value,
-                               self._num_obs_per_year)
+                               discount_curve.cc_rate(self.expiry_dt),
+                               dividend_curve.cc_rate(self.expiry_dt),
+                               model.volatility,
+                               self.option_type.value,
+                               self.num_obs_per_year)
 
-        values = values * self._notional
+        values = values * self.notional
 
         if isinstance(stock_price, float):
             return values[0]
         else:
             return np.array(values)
 
 ###############################################################################
@@ -236,20 +236,20 @@
 
         return v * notional
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("BARRIER LEVEL", self._barrier_level)
-        s += label_to_string("NUM OBSERVATIONS", self._num_obs_per_year)
-        s += label_to_string("NOTIONAL", self._notional, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("BARRIER LEVEL", self.barrier_level)
+        s += label_to_string("NUM OBSERVATIONS", self.num_obs_per_year)
+        s += label_to_string("NOTIONAL", self.notional, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_basket_option.py` & `financepy-0.360/financepy/products/equity/equity_basket_option.py`

 * *Files 7% similar despite different names*

```diff
@@ -38,52 +38,52 @@
                  num_assets: int):
         """ Define the EquityBasket option by specifying its expiry date,
         its strike price, whether it is a put or call, and the number of
         underlying stocks in the basket. """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._strike_price = float(strike_price)
-        self._option_type = option_type
-        self._num_assets = num_assets
+        self.expiry_dt = expiry_dt
+        self.strike_price = float(strike_price)
+        self.option_type = option_type
+        self.num_assets = num_assets
 
 ###############################################################################
 
     def _validate(self,
                   stock_prices,
                   dividend_yields,
                   volatilities,
                   correlations):
 
-        if len(stock_prices) != self._num_assets:
+        if len(stock_prices) != self.num_assets:
             raise FinError(
-                "Stock prices must have a length " + str(self._num_assets))
+                "Stock prices must have a length " + str(self.num_assets))
 
-        if len(dividend_yields) != self._num_assets:
+        if len(dividend_yields) != self.num_assets:
             raise FinError(
-                "Dividend yields must have a length " + str(self._num_assets))
+                "Dividend yields must have a length " + str(self.num_assets))
 
-        if len(volatilities) != self._num_assets:
+        if len(volatilities) != self.num_assets:
             raise FinError(
-                "Volatilities must have a length " + str(self._num_assets))
+                "Volatilities must have a length " + str(self.num_assets))
 
         if correlations.ndim != 2:
             raise FinError(
                 "Correlation must be a 2D matrix ")
 
-        if correlations.shape[0] != self._num_assets:
+        if correlations.shape[0] != self.num_assets:
             raise FinError(
-                "Correlation cols must have a length " + str(self._num_assets))
+                "Correlation cols must have a length " + str(self.num_assets))
 
-        if correlations.shape[1] != self._num_assets:
+        if correlations.shape[1] != self.num_assets:
             raise FinError(
-                "correlation rows must have a length " + str(self._num_assets))
+                "correlation rows must have a length " + str(self.num_assets))
 
-        for i in range(0, self._num_assets):
+        for i in range(0, self.num_assets):
             if correlations[i, i] != 1.0:
                 raise FinError("Corr matrix must have 1.0 on the diagonal")
 
             for j in range(0, i):
                 if abs(correlations[i, j]) > 1.0:
                     raise FinError("Correlations must be [-1, +1]")
 
@@ -103,78 +103,78 @@
               volatilities: np.ndarray,
               correlations: np.ndarray):
         """ Basket valuation using a moment matching method to approximate the
         effective variance of the underlying basket value. This approach is
         able to handle a full rank correlation structure between the individual
         assets. """
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
         qs = []
         for curve in dividend_curves:
-            q = curve.cc_rate(self._expiry_dt)
+            q = curve.cc_rate(self.expiry_dt)
             qs.append(q)
 
         v = volatilities
         s = stock_prices
 
         self._validate(stock_prices,
                        qs,
                        volatilities,
                        correlations)
 
-        a = np.ones(self._num_assets) * (1.0 / self._num_assets)
+        a = np.ones(self.num_assets) * (1.0 / self.num_assets)
 
-        r = discount_curve.cc_rate(self._expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
 
         smean = 0.0
-        for ia in range(0, self._num_assets):
+        for ia in range(0, self.num_assets):
             smean = smean + s[ia] * a[ia]
 
-        lnS0k = np.log(smean / self._strike_price)
-        sqrtT = np.sqrt(t_exp)
+        ln_s0_k = np.log(smean / self.strike_price)
+        sqrt_t = np.sqrt(t_exp)
 
         # Moment matching - starting with dividend
         qnum = 0.0
         qden = 0.0
-        for ia in range(0, self._num_assets):
+        for ia in range(0, self.num_assets):
             qnum = qnum + a[ia] * s[ia] * np.exp(-qs[ia] * t_exp)
             qden = qden + a[ia] * s[ia]
         qhat = -np.log(qnum / qden) / t_exp
 
         # Moment matching - matching volatility
         vnum = 0.0
-        for ia in range(0, self._num_assets):
+        for ia in range(0, self.num_assets):
             for ja in range(0, ia):
-                rhoSigmaSigma = v[ia] * v[ja] * correlations[ia, ja]
-                expTerm = (qs[ia] + qs[ja] - rhoSigmaSigma) * t_exp
-                vnum = vnum + a[ia] * a[ja] * s[ia] * s[ja] * np.exp(-expTerm)
+                rho_sigma_sigma = v[ia] * v[ja] * correlations[ia, ja]
+                exp_term = (qs[ia] + qs[ja] - rho_sigma_sigma) * t_exp
+                vnum = vnum + a[ia] * a[ja] * s[ia] * s[ja] * np.exp(-exp_term)
 
         vnum *= 2.0
 
-        for ia in range(0, self._num_assets):
-            rhoSigmaSigma = v[ia] ** 2
-            expTerm = (2.0 * qs[ia] - rhoSigmaSigma) * t_exp
-            vnum = vnum + ((a[ia] * s[ia]) ** 2) * np.exp(-expTerm)
+        for ia in range(0, self.num_assets):
+            rho_sigma_sigma = v[ia] ** 2
+            exp_term = (2.0 * qs[ia] - rho_sigma_sigma) * t_exp
+            vnum = vnum + ((a[ia] * s[ia]) ** 2) * np.exp(-exp_term)
 
         vhat2 = np.log(vnum / qnum / qnum) / t_exp
 
-        den = np.sqrt(vhat2) * sqrtT
+        den = np.sqrt(vhat2) * sqrt_t
         mu = r - qhat
-        d1 = (lnS0k + (mu + vhat2 / 2.0) * t_exp) / den
-        d2 = (lnS0k + (mu - vhat2 / 2.0) * t_exp) / den
+        d1 = (ln_s0_k + (mu + vhat2 / 2.0) * t_exp) / den
+        d2 = (ln_s0_k + (mu - vhat2 / 2.0) * t_exp) / den
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             v = smean * np.exp(-qhat * t_exp) * N(d1)
-            v = v - self._strike_price * np.exp(-r * t_exp) * N(d2)
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
-            v = self._strike_price * np.exp(-r * t_exp) * N(-d2)
+            v = v - self.strike_price * np.exp(-r * t_exp) * N(d2)
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            v = self.strike_price * np.exp(-r * t_exp) * N(-d2)
             v = v - smean * np.exp(-qhat * t_exp) * N(-d1)
         else:
             raise FinError("Unknown option type")
 
         return v
 
 ###############################################################################
@@ -192,37 +192,37 @@
         of stock prices assuming a GBM distribution. Cholesky decomposition is
         used to handle a full rank correlation structure between the individual
         assets. The num_paths and seed are pre-set to default values but can be
         overwritten. """
 
         check_argument_types(getattr(self, _func_name(), None), locals())
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
         dividend_yields = []
         for curve in dividend_curves:
-            dq = curve.df(self._expiry_dt)
+            dq = curve.df(self.expiry_dt)
             q = -np.log(dq) / t_exp
             dividend_yields.append(q)
 
         self._validate(stock_prices,
                        dividend_yields,
                        volatilities,
                        corr_matrix)
 
         num_assets = len(stock_prices)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
         mus = r - dividend_yields
-        k = self._strike_price
+        k = self.strike_price
 
         num_time_steps = 2
 
         model = FinGBMProcess()
         np.random.seed(seed)
 
         s_all = model.get_paths_assets(num_assets,
@@ -231,33 +231,33 @@
                                        t_exp,
                                        mus,
                                        stock_prices,
                                        volatilities,
                                        corr_matrix,
                                        seed)
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             payoff = np.maximum(np.mean(s_all, axis=1) - k, 0.0)
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             payoff = np.maximum(k - np.mean(s_all, axis=1), 0.0)
         else:
             raise FinError("Unknown option type.")
 
         payoff = np.mean(payoff)
         v = payoff * np.exp(-r * t_exp)
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("NUM ASSETS", self._num_assets, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("NUM ASSETS", self.num_assets, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_binomial_tree.py` & `financepy-0.360/financepy/products/equity/equity_binomial_tree.py`

 * *Files 1% similar despite different names*

```diff
@@ -101,16 +101,15 @@
                 volatility,
                 num_steps,
                 time_to_expiry,
                 payoff_type,
                 exercise_type,
                 payoff_params):
 
-    if num_steps < 3:
-        num_steps = 3
+    num_steps = max(num_steps, 3)
 
 #        validate_payoff(payoff_type.value,payoff_params)
 
     payoff_typeValue = payoff_type.value
 
     # this is the size of the step
     dt = time_to_expiry / num_steps
@@ -119,28 +118,28 @@
     num_nodes = int(0.5 * (num_steps + 1) * (num_steps + 2))
     stock_values = np.zeros(num_nodes)
     stock_values[0] = stock_price
 
     option_values = np.zeros(num_nodes)
     u = exp(volatility * sqrt(dt))
     d = 1.0 / u
-    sLow = stock_price
+    s_low = stock_price
 
     probs = np.zeros(num_steps)
     period_dfs = np.zeros(num_steps)
 
     # store time independent information for later use in tree
     for i_time in range(0, num_steps):
         a = exp((r - q) * dt)
         probs[i_time] = (a - d) / (u - d)
         period_dfs[i_time] = exp(-r * dt)
 
     for i_time in range(1, num_steps + 1):
-        sLow *= d
-        s = sLow
+        s_low *= d
+        s = s_low
         for i_node in range(0, i_time + 1):
             index = 0.5 * i_time * (i_time + 1)
             stock_values[int(index + i_node)] = s
             s = s * (u * u)
 
     # work backwards by first setting values at expiry date
     index = int(0.5 * num_steps * (num_steps + 1))
@@ -156,18 +155,18 @@
         index = int(0.5 * i_time * (i_time + 1))
 
         for i_node in range(0, i_time + 1):
 
             next_index = int(0.5 * (i_time + 1) * (i_time + 2))
             next_node_dn = next_index + i_node
             next_node_up = next_node_dn + 1
-            vUp = option_values[next_node_up]
-            vDn = option_values[next_node_dn]
-            future_expected_value = probs[i_time] * vUp
-            future_expected_value += (1.0 - probs[i_time]) * vDn
+            v_up = option_values[next_node_up]
+            v_dn = option_values[next_node_dn]
+            future_expected_value = probs[i_time] * v_up
+            future_expected_value += (1.0 - probs[i_time]) * v_dn
             hold_value = period_dfs[i_time] * future_expected_value
 
             if exercise_type == EquityTreeExerciseTypes.EUROPEAN:
                 option_values[index + i_node] = hold_value
             elif exercise_type == EquityTreeExerciseTypes.AMERICAN:
                 s = stock_values[index + i_node]
                 exercise_value = _payoff_value(
@@ -175,17 +174,17 @@
                 option_values[index + i_node] = max(exercise_value, hold_value)
 
     price = option_values[0]
     delta = (option_values[2] - option_values[1]) / \
         (stock_values[2] - stock_values[1])
     delta_up = (option_values[5] - option_values[4]) / \
         (stock_values[5] - stock_values[4])
-    deltaDn = (option_values[4] - option_values[3]) / \
+    delta_dn = (option_values[4] - option_values[3]) / \
         (stock_values[4] - stock_values[3])
-    gamma = (delta_up - deltaDn) / (stock_values[2] - stock_values[1])
+    gamma = (delta_up - delta_dn) / (stock_values[2] - stock_values[1])
     theta = (option_values[4] - option_values[0]) / (2.0 * dt)
     results = np.array([price, delta, gamma, theta])
     return results
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/equity_chooser_option.py` & `financepy-0.360/financepy/products/equity/equity_chooser_option.py`

 * *Files 11% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 
 import numpy as np
 from scipy import optimize
 
 from ...utils.math import M
 from ...utils.global_vars import gDaysInYear
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 from ...utils.error import FinError
 
 from ...products.equity.equity_option import EquityOption
 from ...utils.global_types import OptionTypes
 from ...market.curves.discount_curve_flat import DiscountCurve
 from ...utils.helpers import label_to_string, check_argument_types
 from ...utils.date import Date
@@ -77,73 +77,73 @@
 
         if choose_dt > call_expiry_dt:
             raise FinError("Expiry date must precede call option expiry date")
 
         if choose_dt > put_expiry_dt:
             raise FinError("Expiry date must precede put option expiry date")
 
-        self._chooseDate = choose_dt
-        self._call_expiry_dt = call_expiry_dt
-        self._put_expiry_dt = put_expiry_dt
-        self._call_strike = float(call_strike_price)
-        self._put_strike = float(put_strike_price)
+        self.chooseDate = choose_dt
+        self.call_expiry_dt = call_expiry_dt
+        self.put_expiry_dt = put_expiry_dt
+        self.call_strike = float(call_strike_price)
+        self.put_strike = float(put_strike_price)
 
     ###########################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model):
         """ Value the complex chooser option using an approach by Rubinstein
         (1991). See also Haug page 129 for complex chooser options. """
 
-        if value_dt > self._chooseDate:
+        if value_dt > self.chooseDate:
             raise FinError("Value date after choose date.")
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._call_expiry_dt:
+        if value_dt > self.call_expiry_dt:
             raise FinError("Valuation date after call expiry date.")
 
-        if value_dt > self._put_expiry_dt:
+        if value_dt > self.put_expiry_dt:
             raise FinError("Valuation date after put expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
         DEBUG_MODE = False
 
-        t = (self._chooseDate - value_dt) / gDaysInYear
-        tc = (self._call_expiry_dt - value_dt) / gDaysInYear
-        tp = (self._put_expiry_dt - value_dt) / gDaysInYear
-
-        rt = discount_curve.cc_rate(self._chooseDate)
-        rtc = discount_curve.cc_rate(self._call_expiry_dt)
-        rtp = discount_curve.cc_rate(self._put_expiry_dt)
-
-        q = dividend_curve.cc_rate(self._chooseDate)
-
-        t = max(t, gSmall)
-        tc = max(tc, gSmall)
-        tp = max(tp, gSmall)
+        t = (self.chooseDate - value_dt) / gDaysInYear
+        tc = (self.call_expiry_dt - value_dt) / gDaysInYear
+        tp = (self.put_expiry_dt - value_dt) / gDaysInYear
+
+        rt = discount_curve.cc_rate(self.chooseDate)
+        rtc = discount_curve.cc_rate(self.call_expiry_dt)
+        rtp = discount_curve.cc_rate(self.put_expiry_dt)
+
+        q = dividend_curve.cc_rate(self.chooseDate)
+
+        t = max(t, g_small)
+        tc = max(tc, g_small)
+        tp = max(tp, g_small)
 
-        v = model._volatility
-        v = max(v, gSmall)
+        v = model.volatility
+        v = max(v, g_small)
 
         s0 = stock_price
-        xc = self._call_strike
-        xp = self._put_strike
+        xc = self.call_strike
+        xp = self.put_strike
         bt = rt - q
         btc = rtc - q
         btp = rtp - q
 
         argtuple = (t, tc, tp, rtc, rtp, xc, xp, v, q)
         if DEBUG_MODE:
             print("args", argtuple)
@@ -189,40 +189,40 @@
                  discount_curve: DiscountCurve,
                  dividend_curve: DiscountCurve,
                  model,
                  num_paths: int = 10000,
                  seed: int = 4242):
         """ Value the complex chooser option Monte Carlo. """
 
-        dft = discount_curve.df(self._chooseDate)
-        dftc = discount_curve.df(self._call_expiry_dt)
-        dftp = discount_curve.df(self._put_expiry_dt)
-
-        t = (self._chooseDate - value_dt) / gDaysInYear
-        tc = (self._call_expiry_dt - value_dt) / gDaysInYear
-        tp = (self._put_expiry_dt - value_dt) / gDaysInYear
+        dft = discount_curve.df(self.chooseDate)
+        dftc = discount_curve.df(self.call_expiry_dt)
+        dftp = discount_curve.df(self.put_expiry_dt)
+
+        t = (self.chooseDate - value_dt) / gDaysInYear
+        tc = (self.call_expiry_dt - value_dt) / gDaysInYear
+        tp = (self.put_expiry_dt - value_dt) / gDaysInYear
 
         rt = -np.log(dft) / t
         rtc = -np.log(dftc) / tc
         rtp = -np.log(dftp) / tp
 
         t = max(t, 1e-6)
         tc = max(tc, 1e-6)
         tp = max(tp, 1e-6)
 
-        v = model._volatility
+        v = model.volatility
         v = max(v, 1e-6)
 
         # SHOULD THIS CARE ABOUT TERM STRUCTURE OF Q
-        dq = dividend_curve.df(self._chooseDate)
+        dq = dividend_curve.df(self.chooseDate)
         q = -np.log(dq) / t
 
         #        q = dividend_yield
-        kc = self._call_strike
-        kp = self._put_strike
+        kc = self.call_strike
+        kp = self.put_strike
 
         np.random.seed(seed)
         sqrt_dt = np.sqrt(t)
 
         # Use Antithetic variables
         g = np.random.normal(0.0, 1.0, size=(1, num_paths))
         s = stock_price * np.exp((rt - q - v * v / 2.0) * t)
@@ -248,19 +248,19 @@
         v = payoff * dft / 2.0
         return v
 
     ###########################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("CHOOSER DATE", self._chooseDate)
-        s += label_to_string("CALL EXPIRY DATE", self._call_expiry_dt)
-        s += label_to_string("CALL STRIKE PRICE", self._call_strike)
-        s += label_to_string("PUT EXPIRY DATE", self._put_expiry_dt)
-        s += label_to_string("PUT STRIKE PRICE", self._put_strike, "")
+        s += label_to_string("CHOOSER DATE", self.chooseDate)
+        s += label_to_string("CALL EXPIRY DATE", self.call_expiry_dt)
+        s += label_to_string("CALL STRIKE PRICE", self.call_strike)
+        s += label_to_string("PUT EXPIRY DATE", self.put_expiry_dt)
+        s += label_to_string("PUT STRIKE PRICE", self.put_strike, "")
         return s
 
     ###########################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_cliquet_option.py` & `financepy-0.360/financepy/products/equity/equity_cliquet_option.py`

 * *Files 8% similar despite different names*

```diff
@@ -52,29 +52,33 @@
         if option_type != OptionTypes.EUROPEAN_CALL and \
            option_type != OptionTypes.EUROPEAN_PUT:
             raise FinError("Unknown Option Type" + str(option_type))
 
         if final_expiry_dt < start_dt:
             raise FinError("Expiry date precedes start date")
 
-        self._start_dt = start_dt
-        self._final_expiry_dt = final_expiry_dt
-        self._option_type = option_type
-        self._freq_type = freq_type
-        self._dc_type = day_count_type
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
-
-        self._expiry_dts = Schedule(self._start_dt,
-                                    self._final_expiry_dt,
-                                    self._freq_type,
-                                    self._cal_type,
-                                    self._bd_type,
-                                    self._dg_type).generate()
+        self.start_dt = start_dt
+        self.final_expiry_dt = final_expiry_dt
+        self.option_type = option_type
+        self.freq_type = freq_type
+        self.dc_type = day_count_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+
+        self.v_options = None
+        self._dfs = None
+        self.actual_dts = None
+
+        self.expiry_dts = Schedule(self.start_dt,
+                                    self.final_expiry_dt,
+                                    self.freq_type,
+                                    self.cal_type,
+                                    self.bd_type,
+                                    self.dg_type).generate()
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
@@ -82,102 +86,102 @@
               model: Model):
         """ Value the cliquet option as a sequence of options using the Black-
         Scholes model. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
-        if value_dt > self._final_expiry_dt:
+        if value_dt > self.final_expiry_dt:
             raise FinError("Value date after final expiry date.")
 
         s = stock_price
         v_cliquet = 0.0
 
-        self._v_options = []
+        self.v_options = []
         self._dfs = []
-        self._actualDates = []
+        self.actual_dts = []
 
-        CALL = OptionTypes.EUROPEAN_CALL
-        PUT = OptionTypes.EUROPEAN_PUT
+        call_type = OptionTypes.EUROPEAN_CALL
+        put_type = OptionTypes.EUROPEAN_PUT
 
         if isinstance(model, BlackScholes):
 
-            v = model._volatility
+            v = model.volatility
             v = max(v, 1e-6)
-            tprev = 0.0
+            t_prev = 0.0
 
-            for dt in self._expiry_dts:
+            for dt in self.expiry_dts:
 
                 if dt > value_dt:
 
                     df = discount_curve.df(dt)
                     t_exp = (dt - value_dt) / gDaysInYear
                     r = -np.log(df) / t_exp
 
                     # option life
-                    tau = t_exp - tprev
+                    tau = t_exp - t_prev
 
                     # The deflator is out to the option reset time
-                    dq = dividend_curve._df(tprev)
+                    dq = dividend_curve._df(t_prev)
 
                     # The option dividend is over the option life
                     dqMat = dividend_curve._df(t_exp)
 
                     q = -np.log(dqMat/dq)/tau
 
-                    if self._option_type == CALL:
+                    if self.option_type == call_type:
                         v_fwd_opt = s * dq * \
-                            bs_value(1.0, tau, 1.0, r, q, v, CALL.value)
+                            bs_value(1.0, tau, 1.0, r, q, v, call_type.value)
                         v_cliquet += v_fwd_opt
-                    elif self._option_type == PUT:
+                    elif self.option_type == put_type:
                         v_fwd_opt = s * dq * \
-                            bs_value(1.0, tau, 1.0, r, q, v, PUT.value)
+                            bs_value(1.0, tau, 1.0, r, q, v, put_type.value)
                         v_cliquet += v_fwd_opt
                     else:
                         raise FinError("Unknown option type")
 
 #                    print(dt, r, df, q, v_fwd_opt, v_cliquet)
 
                     self._dfs.append(df)
-                    self._v_options.append(v)
-                    self._actualDates.append(dt)
-                    tprev = t_exp
+                    self.v_options.append(v)
+                    self.actual_dts.append(dt)
+                    t_prev = t_exp
         else:
             raise FinError("Unknown Model Type")
 
         return v_cliquet
 
 ###############################################################################
 
     def print_payments(self):
-        num_options = len(self._v_options)
+        num_options = len(self.v_options)
         for i in range(0, num_options):
-            print(self._actualDates[i], self._dfs[i], self._v_options[i])
+            print(self.actual_dts[i], self._dfs[i], self.v_options[i])
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START DATE", self._start_dt)
-        s += label_to_string("FINAL EXPIRY DATE", self._final_expiry_dt)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("FREQUENCY TYPE", self._freq_type)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("CALENDAR TYPE", self._cal_type)
-        s += label_to_string("BUS DAY ADJUST TYPE", self._bd_type)
+        s += label_to_string("START DATE", self.start_dt)
+        s += label_to_string("FINAL EXPIRY DATE", self.final_expiry_dt)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("FREQUENCY TYPE", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("CALENDAR TYPE", self.cal_type)
+        s += label_to_string("BUS DAY ADJUST TYPE", self.bd_type)
         s += label_to_string("DATE GEN RULE TYPE",
-                             self._dg_type, "")
+                             self.dg_type, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_compound_option.py` & `financepy-0.360/financepy/products/equity/equity_compound_option.py`

 * *Files 22% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 import numpy as np
 from scipy import optimize
 from numba import njit
 
 
 from ...utils.math import N, phi2
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
 from ...utils.global_types import OptionTypes
 
 from ...products.equity.equity_option import EquityOption
 from ...products.equity.equity_vanilla_option import EquityVanillaOption
 from ...market.curves.discount_curve_flat import DiscountCurve
 from ...market.curves.discount_curve_flat import DiscountCurveFlat
@@ -82,42 +82,42 @@
 
     u1 = np.exp(volatility * np.sqrt(dt))
     d1 = 1.0 / u1
     u2 = np.exp(volatility * np.sqrt(dt))
     d2 = 1.0 / u2
 
     probs = np.zeros(num_steps)
-    periodDiscountFactors = np.zeros(num_steps)
+    period_dfs = np.zeros(num_steps)
 
     # store time independent information for later use in tree
     for i_time in range(0, num_steps1):
         a1 = np.exp((r - q) * dt1)
         probs[i_time] = (a1 - d1) / (u1 - d1)
-        periodDiscountFactors[i_time] = np.exp(-r * dt1)
+        period_dfs[i_time] = np.exp(-r * dt1)
 
     for i_time in range(num_steps1, num_steps):
         a2 = np.exp((r - q) * dt2)
         probs[i_time] = (a2 - d2) / (u2 - d2)
-        periodDiscountFactors[i_time] = np.exp(-r * dt2)
+        period_dfs[i_time] = np.exp(-r * dt2)
 
     stock_values = np.zeros(num_nodes)
     stock_values[0] = s
-    sLow = s
+    s_low = s
 
     for i_time in range(1, num_steps1 + 1):
-        sLow *= d1
-        s = sLow
+        s_low *= d1
+        s = s_low
         for i_node in range(0, i_time + 1):
             index = int(0.5 * i_time * (i_time + 1))
             stock_values[index + i_node] = s
             s = s * (u1 * u1)
 
     for i_time in range(num_steps1 + 1, num_steps + 1):
-        sLow *= d2
-        s = sLow
+        s_low *= d2
+        s = s_low
         for i_node in range(0, i_time + 1):
             index = int(0.5 * i_time * (i_time + 1))
             stock_values[index + i_node] = s
             s = s * (u2 * u2)
 
     # work backwards by first setting values at expiry date t2
     index = int(0.5 * num_steps * (num_steps + 1))
@@ -135,19 +135,19 @@
     for i_time in range(num_steps - 1, num_steps1, -1):
         index = int(0.5 * i_time * (i_time + 1))
         for i_node in range(0, i_time + 1):
             s = stock_values[index + i_node]
             next_index = int(0.5 * (i_time + 1) * (i_time + 2))
             next_node_dn = next_index + i_node
             next_node_up = next_index + i_node + 1
-            vUp = option_values[next_node_up]
-            vDn = option_values[next_node_dn]
-            future_exp_val = probs[i_time] * vUp
-            future_exp_val += (1.0 - probs[i_time]) * vDn
-            hold_value = periodDiscountFactors[i_time] * future_exp_val
+            v_up = option_values[next_node_up]
+            v_dn = option_values[next_node_dn]
+            future_exp_val = probs[i_time] * v_up
+            future_exp_val += (1.0 - probs[i_time]) * v_dn
+            hold_value = period_dfs[i_time] * future_exp_val
 
             exercise_value = 0.0  # NUMBA NEEDS HELP TO DETERMINE THE TYPE
 
             if option_type1 == OptionTypes.AMERICAN_CALL:
                 exercise_value = max(s - k2, 0.0)
             elif option_type1 == OptionTypes.AMERICAN_PUT:
                 exercise_value = max(k2 - s, 0.0)
@@ -159,19 +159,19 @@
     index = int(0.5 * i_time * (i_time + 1))
 
     for i_node in range(0, i_time + 1):
         s = stock_values[index + i_node]
         next_index = int(0.5 * (i_time + 1) * (i_time + 2))
         next_node_dn = next_index + i_node
         next_node_up = next_index + i_node + 1
-        vUp = option_values[next_node_up]
-        vDn = option_values[next_node_dn]
-        future_exp_val = probs[i_time] * vUp
-        future_exp_val += (1.0 - probs[i_time]) * vDn
-        hold_value = periodDiscountFactors[i_time] * future_exp_val
+        v_up = option_values[next_node_up]
+        v_dn = option_values[next_node_dn]
+        future_exp_val = probs[i_time] * v_up
+        future_exp_val += (1.0 - probs[i_time]) * v_dn
+        hold_value = period_dfs[i_time] * future_exp_val
 
         if option_type1 == OptionTypes.EUROPEAN_CALL\
            or option_type1 == OptionTypes.AMERICAN_CALL:
             option_values[index + i_node] = max(hold_value - k1, 0.0)
         elif option_type1 == OptionTypes.EUROPEAN_PUT\
                 or option_type1 == OptionTypes.AMERICAN_PUT:
             option_values[index + i_node] = max(k1 - hold_value, 0.0)
@@ -183,19 +183,19 @@
 
         for i_node in range(0, i_time + 1):
 
             s = stock_values[index + i_node]
             next_index = int(0.5 * (i_time + 1) * (i_time + 2))
             next_node_dn = next_index + i_node
             next_node_up = next_index + i_node + 1
-            vUp = option_values[next_node_up]
-            vDn = option_values[next_node_dn]
-            future_exp_val = probs[i_time] * vUp
-            future_exp_val += (1.0 - probs[i_time]) * vDn
-            hold_value = periodDiscountFactors[i_time] * future_exp_val
+            v_up = option_values[next_node_up]
+            v_dn = option_values[next_node_dn]
+            future_exp_val = probs[i_time] * v_up
+            future_exp_val += (1.0 - probs[i_time]) * v_dn
+            hold_value = period_dfs[i_time] * future_exp_val
 
             exercise_value = 0.0  # NUMBA NEEDS HELP TO DETERMINE THE TYPE
 
             if option_type1 == OptionTypes.AMERICAN_CALL:
                 exercise_value = max(hold_value - k1, 0.0)
             elif option_type1 == OptionTypes.AMERICAN_PUT:
                 exercise_value = max(k1 - hold_value, 0.0)
@@ -203,15 +203,15 @@
             option_values[index + i_node] = max(exercise_value, hold_value)
 
     verbose = False
     if verbose:
         print("num_steps1:", num_steps1)
         print("num_steps2:", num_steps2)
         print("u1:", u1, "u2:", u2)
-        print("dfs", periodDiscountFactors)
+        print("dfs", period_dfs)
         print("probs:", probs)
         print("s:", stock_values)
         print("v4:", option_values)
 
     # We calculate all of the important Greeks in one go
     price = option_values[0]
     delta = (option_values[2] - option_values[1]) / \
@@ -231,51 +231,51 @@
 class EquityCompoundOption(EquityOption):
     """ A EquityCompoundOption is a compound option which allows the holder
     to either buy or sell another underlying option on a first expiry date that
     itself expires on a second expiry date. Both strikes are set at trade
     initiation. """
 
     def __init__(self,
-                 cExpiryDate: Date,  # Compound Option expiry date
-                 cOptionType: OptionTypes,  # Compound option type
-                 cStrikePrice: float,  # Compound option strike
-                 uExpiryDate: Date,  # Underlying option expiry date
-                 uOptionType: OptionTypes,  # Underlying option type
-                 uStrikePrice: float):  # Underlying option strike price
+                 c_expiry_dt: Date,  # Compound Option expiry date
+                 c_option_type: OptionTypes,  # Compound option type
+                 c_strike_price: float,  # Compound option strike
+                 u_expiry_dt: Date,  # Underlying option expiry date
+                 u_option_type: OptionTypes,  # Underlying option type
+                 u_strike_price: float):  # Underlying option strike price
         """ Create the EquityCompoundOption by passing in the first and
         second expiry dates as well as the corresponding strike prices and
         option types. """
 
         check_argument_types(self.__init__, locals())
 
-        if cExpiryDate > uExpiryDate:
+        if c_expiry_dt > u_expiry_dt:
             raise FinError(
                 "Compound expiry date must precede underlying expiry date")
 
-        if cOptionType != OptionTypes.EUROPEAN_CALL and \
-                cOptionType != OptionTypes.AMERICAN_CALL and \
-                cOptionType != OptionTypes.EUROPEAN_PUT and \
-                cOptionType != OptionTypes.AMERICAN_PUT:
+        if c_option_type != OptionTypes.EUROPEAN_CALL and \
+                c_option_type != OptionTypes.AMERICAN_CALL and \
+                c_option_type != OptionTypes.EUROPEAN_PUT and \
+                c_option_type != OptionTypes.AMERICAN_PUT:
             raise FinError(
                 "Compound option must be European or American call or put.")
 
-        if uOptionType != OptionTypes.EUROPEAN_CALL and \
-                uOptionType != OptionTypes.AMERICAN_CALL and \
-                uOptionType != OptionTypes.EUROPEAN_PUT and \
-                uOptionType != OptionTypes.AMERICAN_PUT:
+        if u_option_type != OptionTypes.EUROPEAN_CALL and \
+                u_option_type != OptionTypes.AMERICAN_CALL and \
+                u_option_type != OptionTypes.EUROPEAN_PUT and \
+                u_option_type != OptionTypes.AMERICAN_PUT:
             raise FinError(
                 "Underlying Option must be European or American call or put.")
 
-        self._cExpiryDate = cExpiryDate
-        self._cStrikePrice = float(cStrikePrice)
-        self._cOptionType = cOptionType
-
-        self._uExpiryDate = uExpiryDate
-        self._uStrikePrice = float(uStrikePrice)
-        self._uOptionType = uOptionType
+        self.c_expiry_dt = c_expiry_dt
+        self.c_strike_price = float(c_strike_price)
+        self.c_option_type = c_option_type
+
+        self.u_expiry_dt = u_expiry_dt
+        self.u_strike_price = float(u_strike_price)
+        self.u_option_type = u_option_type
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
@@ -286,96 +286,96 @@
         entirely European style. Otherwise use a Tree approach to handle the
         early exercise. Solution by Geske (1977), Hodges and Selby (1987) and
         Rubinstein (1991). See also Haug page 132. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._cExpiryDate:
+        if value_dt > self.c_expiry_dt:
             raise FinError("Valuation date after underlying expiry date.")
 
-        if value_dt > self._uExpiryDate:
+        if value_dt > self.u_expiry_dt:
             raise FinError("Valuation date after compound expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
         # If the option has any American feature then use the tree
-        if self._cOptionType == OptionTypes.AMERICAN_CALL or\
-            self._uOptionType == OptionTypes.AMERICAN_CALL or\
-            self._cOptionType == OptionTypes.AMERICAN_PUT or\
-                self._uOptionType == OptionTypes.AMERICAN_PUT:
+        if self.c_option_type == OptionTypes.AMERICAN_CALL or\
+            self.u_option_type == OptionTypes.AMERICAN_CALL or\
+            self.c_option_type == OptionTypes.AMERICAN_PUT or\
+                self.u_option_type == OptionTypes.AMERICAN_PUT:
 
             v = self._value_tree(value_dt,
                                  stock_price,
                                  discount_curve,
                                  dividend_curve,
                                  model,
                                  num_steps)
 
             return v[0]
 
-        tc = (self._cExpiryDate - value_dt) / gDaysInYear
-        tu = (self._uExpiryDate - value_dt) / gDaysInYear
+        tc = (self.c_expiry_dt - value_dt) / gDaysInYear
+        tu = (self.u_expiry_dt - value_dt) / gDaysInYear
 
         s0 = stock_price
 
-        df = discount_curve.df(self._uExpiryDate)
+        df = discount_curve.df(self.u_expiry_dt)
         ru = -np.log(df)/tu
 
         # CHECK INTEREST RATES AND IF THERE SHOULD BE TWO RU AND RC ?????
-        tc = np.maximum(tc, gSmall)
+        tc = np.maximum(tc, g_small)
         tu = np.maximum(tc, tu)
 
-        dq = dividend_curve.df(self._uExpiryDate)
+        dq = dividend_curve.df(self.u_expiry_dt)
         q = -np.log(dq)/tu
 
-        v = np.maximum(model._volatility, gSmall)
+        v = np.maximum(model.volatility, g_small)
 
-        kc = self._cStrikePrice
-        ku = self._uStrikePrice
+        kc = self.c_strike_price
+        ku = self.u_strike_price
 
         sstar = self._implied_stock_price(s0,
-                                          self._cExpiryDate,
-                                          self._uExpiryDate,
+                                          self.c_expiry_dt,
+                                          self.u_expiry_dt,
                                           kc,
                                           ku,
-                                          self._uOptionType,
+                                          self.u_option_type,
                                           ru, q, model)
 
         a1 = (log(s0 / sstar) + (ru - q + (v**2) / 2.0) * tc) / v / sqrt(tc)
         a2 = a1 - v * sqrt(tc)
         b1 = (log(s0 / ku) + (ru - q + (v**2) / 2.0) * tu) / v / sqrt(tu)
         b2 = b1 - v * sqrt(tu)
 
         dqu = exp(-q * tu)
         dfc = exp(-ru * tc)
         dfu = exp(-ru * tu)
         c = sqrt(tc / tu)
 
         # Taken from Hull Page 532 (6th edition)
 
-        CALL = OptionTypes.EUROPEAN_CALL
-        PUT = OptionTypes.EUROPEAN_PUT
+        call_type = OptionTypes.EUROPEAN_CALL
+        put_type = OptionTypes.EUROPEAN_PUT
 
-        if self._cOptionType == CALL and self._uOptionType == CALL:
+        if self.c_option_type == call_type and self.u_option_type == call_type:
             v = s0 * dqu * phi2(a1, b1, c) - ku * dfu * \
                 phi2(a2, b2, c) - dfc * kc * N(a2)
-        elif self._cOptionType == PUT and self._uOptionType == CALL:
+        elif self.c_option_type == put_type and self.u_option_type == call_type:
             v = ku * dfu * phi2(-a2, b2, -c) - s0 * dqu * \
                 phi2(-a1, b1, -c) + dfc * kc * N(-a2)
-        elif self._cOptionType == CALL and self._uOptionType == PUT:
+        elif self.c_option_type == call_type and self.u_option_type == put_type:
             v = ku * dfu * phi2(-a2, -b2, c) - s0 * dqu * \
                 phi2(-a1, -b1, c) - dfc * kc * N(-a2)
-        elif self._cOptionType == PUT and self._uOptionType == PUT:
+        elif self.c_option_type == put_type and self.u_option_type == put_type:
             v = s0 * dqu * phi2(a1, -b1, -c) - ku * dfu * \
                 phi2(a2, -b2, -c) + dfc * kc * N(a2)
         else:
             raise FinError("Unknown option type")
 
         return v
 
@@ -386,39 +386,39 @@
                     stock_price,
                     discount_curve,
                     dividend_curve,
                     model,
                     num_steps=200):
         """ This function is called if the option has American features. """
 
-        if value_dt > self._cExpiryDate:
+        if value_dt > self.c_expiry_dt:
             raise FinError("Value date is after expiry date.")
 
-        tc = (self._cExpiryDate - value_dt) / gDaysInYear
-        tu = (self._uExpiryDate - value_dt) / gDaysInYear
+        tc = (self.c_expiry_dt - value_dt) / gDaysInYear
+        tu = (self.u_expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._uExpiryDate)
+        df = discount_curve.df(self.u_expiry_dt)
         r = -np.log(df)/tu
 
-        dq = dividend_curve.df(self._uExpiryDate)
+        dq = dividend_curve.df(self.u_expiry_dt)
         q = -np.log(dq)/tu
 
-        r = discount_curve.zero_rate(self._uExpiryDate)
+        r = discount_curve.zero_rate(self.u_expiry_dt)
 
-        volatility = model._volatility
+        volatility = model.volatility
 
         v1 = _value_once(stock_price,
                          r,
                          q,
                          volatility,
                          tc, tu,
-                         self._cOptionType,
-                         self._uOptionType,
-                         self._cStrikePrice,
-                         self._uStrikePrice,
+                         self.c_option_type,
+                         self.u_option_type,
+                         self.c_strike_price,
+                         self.u_strike_price,
                          num_steps)
 
         return v1
 
 ###############################################################################
 
     def _implied_stock_price(self,
@@ -444,20 +444,20 @@
                                 maxiter=50, fprime2=None)
         return sigma
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("CPD EXPIRY DATE", self._cExpiryDate)
-        s += label_to_string("CPD STRIKE PRICE", self._cStrikePrice)
-        s += label_to_string("CPD OPTION TYPE", self._cOptionType)
-        s += label_to_string("UND EXPIRY DATE", self._uExpiryDate)
-        s += label_to_string("UND STRIKE PRICE", self._uStrikePrice)
-        s += label_to_string("UND OPTION TYPE", self._uOptionType)
+        s += label_to_string("CPD EXPIRY DATE", self.c_expiry_dt)
+        s += label_to_string("CPD STRIKE PRICE", self.c_strike_price)
+        s += label_to_string("CPD OPTION TYPE", self.c_option_type)
+        s += label_to_string("UND EXPIRY DATE", self.u_expiry_dt)
+        s += label_to_string("UND STRIKE PRICE", self.u_strike_price)
+        s += label_to_string("UND OPTION TYPE", self.u_option_type)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_digital_option.py` & `financepy-0.360/financepy/products/equity/equity_digital_option.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 
-import numpy as np
 from enum import Enum
+import numpy as np
 
 
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
 from ...utils.global_types import OptionTypes
 from ...products.equity.equity_option import EquityOption
 from ...utils.helpers import label_to_string, check_argument_types
 from ...utils.date import Date
 from ...market.curves.discount_curve import DiscountCurve
 
@@ -47,18 +47,18 @@
         types of underlying - cash or nothing and asset or nothing. """
 
         check_argument_types(self.__init__, locals())
 
         if call_put_type not in [OptionTypes.EUROPEAN_CALL, OptionTypes.EUROPEAN_PUT]:
             raise FinError("Option type must be EUROPEAN CALL or PUT")
 
-        self._expiry_dt = expiry_dt
-        self._barrier = float(barrier)
-        self._call_put_type = call_put_type
-        self._digital_type = digital_type
+        self.expiry_dt = expiry_dt
+        self.barrier = float(barrier)
+        self.call_put_type = call_put_type
+        self.digital_type = digital_type
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               s: (float, np.ndarray),
               discount_curve: DiscountCurve,
@@ -67,60 +67,60 @@
         """ Digital Option valuation using the Black-Scholes model assuming a
         barrier at expiry. Handles both cash-or-nothing and asset-or-nothing
         options."""
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
         t = max(t, 1e-6)
 
         s0 = s
-        X = self._barrier
-        lnS0k = np.log(s0 / X)
-        sqrtT = np.sqrt(t)
+        X = self.barrier
+        ln_s0_k = np.log(s0 / X)
+        sqrt_t = np.sqrt(t)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t
 
-        volatility = model._volatility
+        volatility = model.volatility
 
-        if abs(volatility) < gSmall:
-            volatility = gSmall
+        if abs(volatility) < g_small:
+            volatility = g_small
 
-        d1 = (lnS0k + (r - q + volatility*volatility / 2.0) * t)
-        d1 = d1 / volatility / sqrtT
-        d2 = d1 - volatility * sqrtT
+        d1 = (ln_s0_k + (r - q + volatility*volatility / 2.0) * t)
+        d1 = d1 / volatility / sqrt_t
+        d2 = d1 - volatility * sqrt_t
 
-        if self._digital_type == FinDigitalOptionTypes.CASH_OR_NOTHING:
+        if self.digital_type == FinDigitalOptionTypes.CASH_OR_NOTHING:
 
-            if self._call_put_type == OptionTypes.EUROPEAN_CALL:
+            if self.call_put_type == OptionTypes.EUROPEAN_CALL:
                 v = np.exp(-r * t) * n_vect(d2)
-            elif self._call_put_type == OptionTypes.EUROPEAN_PUT:
+            elif self.call_put_type == OptionTypes.EUROPEAN_PUT:
                 v = np.exp(-r * t) * n_vect(-d2)
 
-        elif self._digital_type == FinDigitalOptionTypes.ASSET_OR_NOTHING:
+        elif self.digital_type == FinDigitalOptionTypes.ASSET_OR_NOTHING:
 
-            if self._call_put_type == OptionTypes.EUROPEAN_CALL:
+            if self.call_put_type == OptionTypes.EUROPEAN_CALL:
                 v = s0 * np.exp(-q * t) * n_vect(d1)
-            elif self._call_put_type == OptionTypes.EUROPEAN_PUT:
+            elif self.call_put_type == OptionTypes.EUROPEAN_PUT:
                 v = s0 * np.exp(-q * t) * n_vect(-d1)
 
         else:
             raise FinError("Unknown underlying type.")
 
         return v
 
@@ -135,60 +135,60 @@
                  num_paths: int = 10000,
                  seed: int = 4242):
         """ Digital Option valuation using the Black-Scholes model and Monte
         Carlo simulation. Product assumes a barrier only at expiry. Monte Carlo
         handles both a cash-or-nothing and an asset-or-nothing option."""
 
         np.random.seed(seed)
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        df = discount_curve.df(self._expiry_dt)
+        t = (self.expiry_dt - value_dt) / gDaysInYear
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t
 
-        volatility = model._volatility
-        K = self._barrier
+        volatility = model.volatility
+        K = self.barrier
         sqrt_dt = np.sqrt(t)
 
         # Use Antithetic variables
         g = np.random.normal(0.0, 1.0, size=(1, num_paths))
         s = stock_price * np.exp((r - q - volatility * volatility / 2.0) * t)
         m = np.exp(g * sqrt_dt * volatility)
 
         s_1 = s * m
         s_2 = s / m
 
-        if self._digital_type == FinDigitalOptionTypes.CASH_OR_NOTHING:
-            if self._call_put_type == OptionTypes.EUROPEAN_CALL:
+        if self.digital_type == FinDigitalOptionTypes.CASH_OR_NOTHING:
+            if self.call_put_type == OptionTypes.EUROPEAN_CALL:
                 payoff_a_1 = np.heaviside(s_1 - K, 0.0)
                 payoff_a_2 = np.heaviside(s_2 - K, 0.0)
-            elif self._call_put_type == OptionTypes.EUROPEAN_PUT:
+            elif self.call_put_type == OptionTypes.EUROPEAN_PUT:
                 payoff_a_1 = np.heaviside(K - s_1, 0.0)
                 payoff_a_2 = np.heaviside(K - s_2, 0.0)
-        elif self._digital_type == FinDigitalOptionTypes.ASSET_OR_NOTHING:
-            if self._call_put_type == OptionTypes.EUROPEAN_CALL:
+        elif self.digital_type == FinDigitalOptionTypes.ASSET_OR_NOTHING:
+            if self.call_put_type == OptionTypes.EUROPEAN_CALL:
                 payoff_a_1 = s_1 * np.heaviside(s_1 - K, 0.0)
                 payoff_a_2 = s_2 * np.heaviside(s_2 - K, 0.0)
-            elif self._call_put_type == OptionTypes.EUROPEAN_PUT:
+            elif self.call_put_type == OptionTypes.EUROPEAN_PUT:
                 payoff_a_1 = s_1 * np.heaviside(K - s_1, 0.0)
                 payoff_a_2 = s_2 * np.heaviside(K - s_2, 0.0)
 
         payoff = np.mean(payoff_a_1) + np.mean(payoff_a_2)
         v = payoff * df / 2.0
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("BARRIER LEVEL", self._barrier)
-        s += label_to_string("CALL-PUT TYPE", self._call_put_type)
-        s += label_to_string("DIGITAL TYPE", self._digital_type, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("BARRIER LEVEL", self.barrier)
+        s += label_to_string("CALL-PUT TYPE", self.call_put_type)
+        s += label_to_string("DIGITAL TYPE", self.digital_type, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_fixed_lookback_option.py` & `financepy-0.360/financepy/products/equity/equity_float_lookback_option.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
 
 
 from ...utils.math import N
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
 from ...utils.date import Date
 
 from ...models.gbm_process_simulator import FinGBMProcess
 from ...products.equity.equity_option import EquityOption
 from ...utils.helpers import label_to_string, check_argument_types
 from ...market.curves.discount_curve import DiscountCurve
@@ -21,174 +21,135 @@
 # TODO: Sobol for Monte Carlo
 # TODO: TIGHTEN UP LIMIT FOR W FROM 100
 # TODO: Vectorise the analytical pricing formula
 ##########################################################################
 
 
 ##########################################################################
-# FIXED STRIKE LOOKBACK CALL PAYS MAX(SMAX-K,0)
-# FIXED STRIKE LOOKBACK PUT PAYS MAX(K-SMIN,0)
+# FLOAT STRIKE LOOKBACK CALL PAYS MAX(S(T)-SMIN,0)
+# FLOAT STRIKE LOOKBACK PUT PAYS MAX(SMAX-S(T),0)
 ##########################################################################
 
 
-class EquityFixedLookbackOption(EquityOption):
-    """ This is an equity option in which the strike of the option is fixed but
-    the value of the stock price used to determine the payoff is the maximum
-    in the case of a call option, and a minimum in the case of a put option."""
+class EquityFloatLookbackOption(EquityOption):
+    """ This is an equity option in which the strike of the option is not fixed
+    but is set at expiry to equal the minimum stock price in the case of a call
+    or the maximum stock price in the case of a put. In other words the buyer
+    of the call gets to buy the asset at the lowest price over the period
+    before expiry while the buyer of the put gets to sell the asset at the
+    highest price before expiry. """
 
     def __init__(self,
                  expiry_dt: Date,
-                 option_type: OptionTypes,
-                 strike_price: float):
-        """ Create the FixedLookbackOption by specifying the expiry date, the
-        option type and the option strike. """
+                 option_type: OptionTypes):
+        """ Create the FloatLookbackOption by specifying the expiry date and
+        the option type. The strike is determined internally as the maximum or
+        minimum of the stock price depending on whether it is a put or a call
+        option. """
 
         check_argument_types(self.__init__, locals())
 
         if option_type != OptionTypes.EUROPEAN_CALL and option_type != OptionTypes.EUROPEAN_PUT:
             raise FinError("Option type must be EUROPEAN_CALL or EUROPEAN_PUT")
 
-        self._expiry_dt = expiry_dt
-        self._option_type = option_type
-        self._strike_price = strike_price
+        self.expiry_dt = expiry_dt
+        self.option_type = option_type
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               volatility: float,
               stock_min_max: float):
-        """ Valuation of the Fixed Lookback option using Black-Scholes using
-        the formulae derived by Conze and Viswanathan (1991). One of the inputs
-        is the minimum of maximum of the stock price since the start of the
-        option depending on whether the option is a call or a put. """
+        """ Valuation of the Floating Lookback option using Black-Scholes using
+        the formulae derived by Goldman, Sosin and Gatto (1979). """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
+        df = discount_curve.df(self.expiry_dt)
 
-        df = discount_curve.df(self._expiry_dt)
-        r = -np.log(df)/t
-
-        dq = dividend_curve.df(self._expiry_dt)
-        q = -np.log(dq)/t
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
         v = volatility
         s0 = stock_price
-        k = self._strike_price
-        s_min = 0.0
-        s_max = 0.0
-
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-            s_max = stock_min_max
-            if s_max < s0:
-                raise FinError("The Smax value must be >= the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
-            s_min = stock_min_max
-            if s_min > s0:
-                raise FinError("The Smin value must be <= the stock price.")
-
-        # There is a risk of an overflow in the limit of q=r which
-        # we remove by adjusting the value of the dividend
-        if abs(r - q) < gSmall:
-            q = r + gSmall
+        smin = 0.0
+        smax = 0.0
+
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
+            smin = stock_min_max
+            if smin > s0:
+                raise FinError(
+                    "Smin must be less than or equal to the stock price.")
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            smax = stock_min_max
+            if smax < s0:
+                raise FinError(
+                    "Smax must be greater than or equal to the stock price.")
+
+        if abs(r - q) < g_small:
+            q = r + g_small
 
-        df = np.exp(-r * t)
         dq = np.exp(-q * t)
+        df = np.exp(-r * t)
         b = r - q
         u = v * v / 2.0 / b
-        w = 2.0 * b / (v * v)
+        w = 2.0 * b / v / v
         expbt = np.exp(b * t)
-        sqrtT = np.sqrt(t)
-
-        # Taken from Hull Page 536 (6th edition) and Haug Page 143
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-
-            if k > s_max:
 
-                d1 = (np.log(s0 / k) + (b + v * v/2.0) * t) / v / sqrtT
-                d2 = d1 - v * sqrtT
+        # Taken from Haug Page 142
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
 
-                if s0 == k:
-                    term = -N(d1 - 2.0 * b * sqrtT / v) + expbt * N(d1)
-                elif s0 < k and w > 100.0:
-                    term = expbt * N(d1)
-                else:
-                    term = -np.power(s0 / k, -w) * N(d1 - 2 * b * sqrtT / v) \
-                        + expbt * N(d1)
-
-                v = s0 * dq * N(d1) - k * df * N(d2) + s0 * df * u * term
+            a1 = (np.log(s0 / smin) + (b + (v**2) / 2.0) * t) / v / np.sqrt(t)
+            a2 = a1 - v * np.sqrt(t)
 
+            if smin == s0:
+                term = N(-a1 + 2.0 * b * np.sqrt(t) / v) - expbt * N(-a1)
+            elif s0 < smin and w < -100:
+                term = - expbt * N(-a1)
             else:
+                term = ((s0 / smin)**(-w)) \
+                    * N(-a1 + 2.0 * b * np.sqrt(t) / v) - expbt * N(-a1)
 
-                e1 = (np.log(s0/s_max) + (r - q + v*v/2) * t) / v / sqrtT
-                e2 = e1 - v * sqrtT
+            v = s0 * dq * N(a1) - smin * df * N(a2) + s0 * df * u * term
 
-                if s0 == s_max:
-                    term = -N(e1 - 2.0 * b * sqrtT / v) + expbt * N(e1)
-                elif s0 < s_max and w > 100.0:
-                    term = expbt * N(e1)
-                else:
-                    term = (-(s0 / s_max)**(-w)) * \
-                        N(e1 - 2.0 * b * sqrtT / v) + expbt * N(e1)
-
-                v = df * (s_max - k) + s0 * dq * N(e1) - \
-                    s_max * df * N(e2) + s0 * df * u * term
-
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
-
-            if k >= s_min:
-
-                f1 = (np.log(s0/s_min) + (b + v * v / 2.0) * t) / v / sqrtT
-                f2 = f1 - v * sqrtT
-
-                if s0 == s_min:
-                    term = N(-f1 + 2.0 * b * sqrtT / v) - expbt * N(-f1)
-                elif s0 > s_min and w < -100.0:
-                    term = -expbt * N(-f1)
-                else:
-                    term = ((s0 / s_min)**(-w)) * N(-f1 + 2.0 * b * sqrtT / v) \
-                        - expbt * N(-f1)
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
 
-                v = df * (k - s_min) - s0 * dq * N(-f1) + \
-                    s_min * df * N(-f2) + s0 * df * u * term
+            b1 = (np.log(s0 / smax) + (b + (v**2) / 2.0) * t) / v / np.sqrt(t)
+            b2 = b1 - v * np.sqrt(t)
 
+            if smax == s0:
+                term = -N(b1 - 2.0 * b * np.sqrt(t) / v) + expbt * N(b1)
+            elif s0 < smax and w > 100:
+                term = expbt * N(b1)
             else:
+                term = (-(s0 / smax)**(-w)) * \
+                    N(b1 - 2.0 * b * np.sqrt(t) / v) + expbt * N(b1)
 
-                d1 = (np.log(s0 / k) + (b + v * v / 2) * t) / v / sqrtT
-                d2 = d1 - v * sqrtT
-
-                if s0 == k:
-                    term = N(-d1 + 2.0 * b * sqrtT / v) - expbt * N(-d1)
-                elif s0 > k and w < -100.0:
-                    term = -expbt * N(-d1)
-                else:
-                    term = ((s0 / k)**(-w)) * N(-d1 + 2.0 * b * sqrtT / v) \
-                        - expbt * N(-d1)
-
-                v = k * df * N(-d2) - s0 * dq * N(-d1) + s0 * df * u * term
+            v = smax * df * N(-b2) - s0 * dq * N(-b1) + s0 * df * u * term
 
         else:
             raise FinError("Unknown lookback option type:" +
-                           str(self._option_type))
+                           str(self.option_type))
 
         return v
 
 ###############################################################################
 
     def value_mc(self,
                  value_dt: Date,
@@ -196,78 +157,71 @@
                  discount_curve: DiscountCurve,
                  dividend_curve: DiscountCurve,
                  volatility: float,
                  stock_min_max: float,
                  num_paths: int = 10000,
                  num_steps_per_year: int = 252,
                  seed: int = 4242):
-        """ Monte Carlo valuation of a fixed strike lookback option using a
+        """ Monte Carlo valuation of a floating strike lookback option using a
         Black-Scholes model that assumes the stock follows a GBM process. """
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        
-        df = discount_curve.df(self._expiry_dt)
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
-
-        mu = r - q
+        t = (self.expiry_dt - value_dt) / gDaysInYear
         num_time_steps = int(t * num_steps_per_year)
 
-        option_type = self._option_type
-        k = self._strike_price
-
-        s_min = 0.0
-        s_max = 0.0
+        df = discount_curve.df(self.expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
+        mu = r - q
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-            s_max = stock_min_max
-            if s_max < stock_price:
-                raise FinError(
-                    "Smax must be greater than or equal to the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
-            s_min = stock_min_max
-            if s_min > stock_price:
+        option_type = self.option_type
+        smin = 0.0
+        smax = 0.0
+
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
+            smin = stock_min_max
+            if smin > stock_price:
                 raise FinError(
                     "Smin must be less than or equal to the stock price.")
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            smax = stock_min_max
+            if smax < stock_price:
+                raise FinError(
+                    "Smax must be greater than or equal to the stock price.")
 
         model = FinGBMProcess()
         s_all = model.get_paths(num_paths,
-                                num_time_steps, t,
-                                mu,
+                                num_time_steps,
+                                t, mu,
                                 stock_price,
-                                volatility,
-                                seed)
+                                volatility, seed)
 
         # Due to antithetics we have doubled the number of paths
         num_paths = 2 * num_paths
         payoff = np.zeros(num_paths)
 
         if option_type == OptionTypes.EUROPEAN_CALL:
-            s_max_vector = np.max(s_all, axis=1)
-            s_maxs = np.ones(num_paths) * s_max
-            payoff = np.maximum(s_max_vector - k, 0.0)
-            payoff = np.maximum(payoff, s_maxs - k)
+            s_min = np.min(s_all, axis=1)
+            s_min = np.minimum(s_min, smin)
+            payoff = np.maximum(s_all[:, -1] - s_min, 0.0)
         elif option_type == OptionTypes.EUROPEAN_PUT:
-            s_min_vector = np.min(s_all, axis=1)
-            s_mins = np.ones(num_paths) * s_min
-            payoff = np.maximum(k - s_min_vector, 0.0)
-            payoff = np.maximum(payoff, k - s_mins)
+            s_max = np.max(s_all, axis=1)
+            s_max = np.maximum(s_max, smax)
+            payoff = np.maximum(s_max - s_all[:, -1], 0.0)
         else:
             raise FinError("Unknown lookback option type:" + str(option_type))
 
         v = payoff.mean() * df
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE", self._option_type, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("OPTION TYPE", self.option_type, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_float_lookback_option.py` & `financepy-0.360/financepy/products/fx/fx_float_lookback_option.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,229 +1,211 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
-
+from enum import Enum
 
 from ...utils.math import N
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
-from ...utils.date import Date
-
 from ...models.gbm_process_simulator import FinGBMProcess
-from ...products.equity.equity_option import EquityOption
-from ...utils.helpers import label_to_string, check_argument_types
-from ...market.curves.discount_curve import DiscountCurve
+from ...products.fx.fx_option import FXOption
+from ...utils.helpers import check_argument_types
+from ...utils.date import Date
 from ...utils.global_types import OptionTypes
+from ...market.curves.discount_curve import DiscountCurve
+
 
 ##########################################################################
 # TODO: Attempt control variate adjustment to monte carlo
 # TODO: Sobol for Monte Carlo
 # TODO: TIGHTEN UP LIMIT FOR W FROM 100
 # TODO: Vectorise the analytical pricing formula
 ##########################################################################
 
 
 ##########################################################################
-# FLOAT STRIKE LOOKBACK CALL PAYS MAX(S(T)-SMIN,0)
-# FLOAT STRIKE LOOKBACK PUT PAYS MAX(SMAX-S(T),0)
+# FLOAT STRIKE LOOKBACK CALL PAYS MAX(S(T)-s_min,0)
+# FLOAT STRIKE LOOKBACK PUT PAYS MAX(s_max-S(T),0)
 ##########################################################################
 
 
-class EquityFloatLookbackOption(EquityOption):
-    """ This is an equity option in which the strike of the option is not fixed
-    but is set at expiry to equal the minimum stock price in the case of a call
-    or the maximum stock price in the case of a put. In other words the buyer
-    of the call gets to buy the asset at the lowest price over the period
-    before expiry while the buyer of the put gets to sell the asset at the
-    highest price before expiry. """
+class FXFloatLookbackOption(FXOption):
+    """ This is an FX option in which the strike of the option is not fixed
+    but is set at expiry to equal the minimum fx rate in the case of a call
+    or the maximum fx rate in the case of a put. """
 
     def __init__(self,
                  expiry_dt: Date,
                  option_type: OptionTypes):
-        """ Create the FloatLookbackOption by specifying the expiry date and
-        the option type. The strike is determined internally as the maximum or
-        minimum of the stock price depending on whether it is a put or a call
-        option. """
+        """ Create the FX Float Look Back Option by specifying the expiry
+        date and the option type. """
 
         check_argument_types(self.__init__, locals())
 
-        if option_type != OptionTypes.EUROPEAN_CALL and option_type != OptionTypes.EUROPEAN_PUT:
-            raise FinError("Option type must be EUROPEAN_CALL or EUROPEAN_PUT")
-
-        self._expiry_dt = expiry_dt
-        self._option_type = option_type
+        self.expiry_dt = expiry_dt
+        self.option_type = option_type
 
-###############################################################################
+    ##########################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
-              discount_curve: DiscountCurve,
-              dividend_curve: DiscountCurve,
+              domestic_curve: DiscountCurve,
+              foreign_curve: DiscountCurve,
               volatility: float,
               stock_min_max: float):
-        """ Valuation of the Floating Lookback option using Black-Scholes using
-        the formulae derived by Goldman, Sosin and Gatto (1979). """
+        """ Valuation of the Floating Lookback option using Black-Scholes
+        using the formulae derived by Goldman, Sosin and Gatto (1979). """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
-                "Discount Curve valuation date not same as option value date")
+                "Domestic Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
-                "Dividend Curve valuation date not same as option value date")
+                "Foreign Curve valuation date not same as option value date")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        df = discount_curve.df(self._expiry_dt)
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        df = domestic_curve._df(t)
+        r = -np.log(df) / t
+
+        dq = foreign_curve._df(t)
+        q = -np.log(dq) / t
 
         v = volatility
         s0 = stock_price
-        smin = 0.0
-        smax = 0.0
+        s_min = 0.0
+        s_max = 0.0
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-            smin = stock_min_max
-            if smin > s0:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
+            s_min = stock_min_max
+            if s_min > s0:
                 raise FinError(
-                    "Smin must be less than or equal to the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
-            smax = stock_min_max
-            if smax < s0:
+                    "s_min must be less than or equal to the stock price.")
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            s_max = stock_min_max
+            if s_max < s0:
                 raise FinError(
-                    "Smax must be greater than or equal to the stock price.")
+                    "s_max must be greater than or equal to the stock price.")
 
-        if abs(r - q) < gSmall:
-            q = r + gSmall
+        if abs(r - q) < g_small:
+            q = r + g_small
 
         dq = np.exp(-q * t)
         df = np.exp(-r * t)
         b = r - q
         u = v * v / 2.0 / b
         w = 2.0 * b / v / v
         expbt = np.exp(b * t)
 
         # Taken from Haug Page 142
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
 
-            a1 = (np.log(s0 / smin) + (b + (v**2) / 2.0) * t) / v / np.sqrt(t)
+            a1 = (np.log(s0 / s_min) + (b + (v ** 2) / 2.0) * t) / v / np.sqrt(t)
             a2 = a1 - v * np.sqrt(t)
 
-            if smin == s0:
+            if s_min == s0:
                 term = N(-a1 + 2.0 * b * np.sqrt(t) / v) - expbt * N(-a1)
-            elif s0 < smin and w < -100:
+            elif s0 < s_min and w < -100:
                 term = - expbt * N(-a1)
             else:
-                term = ((s0 / smin)**(-w)) \
-                    * N(-a1 + 2.0 * b * np.sqrt(t) / v) - expbt * N(-a1)
+                term = ((s0 / s_min) ** (-w)) * N(-a1 + 2.0 *
+                                                 b * np.sqrt(t) / v) - expbt * N(-a1)
 
-            v = s0 * dq * N(a1) - smin * df * N(a2) + s0 * df * u * term
+            v = s0 * dq * N(a1) - s_min * df * N(a2) + s0 * df * u * term
 
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
 
-            b1 = (np.log(s0 / smax) + (b + (v**2) / 2.0) * t) / v / np.sqrt(t)
+            b1 = (np.log(s0 / s_max) + (b + (v ** 2) / 2.0) * t) / v / np.sqrt(t)
             b2 = b1 - v * np.sqrt(t)
 
-            if smax == s0:
+            if s_max == s0:
                 term = -N(b1 - 2.0 * b * np.sqrt(t) / v) + expbt * N(b1)
-            elif s0 < smax and w > 100:
+            elif s0 < s_max and w > 100:
                 term = expbt * N(b1)
             else:
-                term = (-(s0 / smax)**(-w)) * \
+                term = (-(s0 / s_max) ** (-w)) * \
                     N(b1 - 2.0 * b * np.sqrt(t) / v) + expbt * N(b1)
 
-            v = smax * df * N(-b2) - s0 * dq * N(-b1) + s0 * df * u * term
+            v = s_max * df * N(-b2) - s0 * dq * N(-b1) + s0 * df * u * term
 
         else:
             raise FinError("Unknown lookback option type:" +
-                           str(self._option_type))
+                           str(self.option_type))
 
         return v
 
-###############################################################################
+    ##########################################################################
 
     def value_mc(self,
-                 value_dt: Date,
-                 stock_price: float,
-                 discount_curve: DiscountCurve,
-                 dividend_curve: DiscountCurve,
-                 volatility: float,
-                 stock_min_max: float,
-                 num_paths: int = 10000,
-                 num_steps_per_year: int = 252,
-                 seed: int = 4242):
-        """ Monte Carlo valuation of a floating strike lookback option using a
-        Black-Scholes model that assumes the stock follows a GBM process. """
+                 value_dt,
+                 stock_price,
+                 domestic_curve,
+                 foreign_curve,
+                 volatility,
+                 stock_min_max,
+                 num_paths=10000,
+                 num_steps_per_year=252,
+                 seed=4242):
+        ''' Value FX floating lookback option using Monte Carlo '''
+        t = (self.expiry_dt - value_dt) / gDaysInYear
+        df = domestic_curve._df(t)
+        r = -np.log(df) / t
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        num_time_steps = int(t * num_steps_per_year)
+        dq = foreign_curve._df(t)
+        q = -np.log(dq) / t
 
-        df = discount_curve.df(self._expiry_dt)
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        num_time_steps = int(t * num_steps_per_year)
         mu = r - q
 
-        option_type = self._option_type
-        smin = 0.0
-        smax = 0.0
-
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-            smin = stock_min_max
-            if smin > stock_price:
+        option_type = self.option_type
+        s_min = 0.0
+        s_max = 0.0
+
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
+            s_min = stock_min_max
+            if s_min > stock_price:
                 raise FinError(
-                    "Smin must be less than or equal to the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
-            smax = stock_min_max
-            if smax < stock_price:
+                    "s_min must be less than or equal to the stock price.")
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            s_max = stock_min_max
+            if s_max < stock_price:
                 raise FinError(
-                    "Smax must be greater than or equal to the stock price.")
+                    "s_max must be greater than or equal to the stock price.")
 
         model = FinGBMProcess()
         s_all = model.get_paths(num_paths,
                                 num_time_steps,
-                                t, mu,
+                                t,
+                                mu,
                                 stock_price,
-                                volatility, seed)
+                                volatility,
+                                seed)
 
-        # Due to antithetics we have doubled the number of paths
+        # Due to anti-thetics we have doubled the number of paths
         num_paths = 2 * num_paths
         payoff = np.zeros(num_paths)
 
         if option_type == OptionTypes.EUROPEAN_CALL:
-            s_min = np.min(s_all, axis=1)
-            s_min = np.minimum(s_min, smin)
-            payoff = np.maximum(s_all[:, -1] - s_min, 0.0)
+            s_min_vector = np.min(s_all, axis=1)
+            s_min_vector = np.minimum(s_min_vector, s_min)
+            payoff = np.maximum(s_all[:, -1] - s_min_vector, 0.0)
         elif option_type == OptionTypes.EUROPEAN_PUT:
-            s_max = np.max(s_all, axis=1)
-            s_max = np.maximum(s_max, smax)
-            payoff = np.maximum(s_max - s_all[:, -1], 0.0)
+            s_max_vector = np.max(s_all, axis=1)
+            s_max_vector = np.maximum(s_max_vector, s_max)
+            payoff = np.maximum(s_max_vector - s_all[:, -1], 0.0)
         else:
             raise FinError("Unknown lookback option type:" + str(option_type))
 
-        v = payoff.mean() * df
+        v = payoff.mean() * np.exp(-r * t)
         return v
 
-###############################################################################
-
-    def __repr__(self):
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("OPTION TYPE", self._option_type, "")
-        return s
-
-###############################################################################
-
-    def _print(self):
-        """ Simple print function for backward compatibility. """
-        print(self)
-
-###############################################################################
+##########################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/equity_forward.py` & `financepy-0.360/financepy/products/equity/equity_forward.py`

 * *Files 5% similar despite different names*

```diff
@@ -25,107 +25,107 @@
                  notional: float,
                  long_short: FinLongShort = FinLongShort.LONG):
         """ Creates a EquityForward which allows the owner to buy the stock
         at a price agreed today. Need to specify if LONG or SHORT."""
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._forward_price = forward_price
-        self._notional = notional
-        self._long_short = long_short
+        self.expiry_dt = expiry_dt
+        self.forward_price = forward_price
+        self.notional = notional
+        self.long_short = long_short
 
 ###############################################################################
 
     def value(self,
               value_dt,
               stock_price,  # Current stock price
               discount_curve,
               dividend_curve):
         """ Calculate the value of an equity forward contract from the stock
         price and discount and dividend discount. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
         if isinstance(value_dt, Date):
-            t = (self._expiry_dt - value_dt) / gDaysInYear
+            t = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         t = np.maximum(t, 1e-10)
 
-        fwdStockPrice = self.forward(value_dt,
+        fwd_stock_price = self.forward(value_dt,
                                      stock_price,
                                      discount_curve,
                                      dividend_curve)
 
-        discountDF = discount_curve._df(t)
+        discount_df = discount_curve._df(t)
 
-        v = (fwdStockPrice - self._forward_price)
-        v = v * self._notional * discountDF
+        v = (fwd_stock_price - self.forward_price)
+        v = v * self.notional * discount_df
 
-        if self._long_short == FinLongShort.SHORT:
+        if self.long_short == FinLongShort.SHORT:
             v = v * (-1.0)
 
         return v
 
 ###############################################################################
 
     def forward(self,
                 value_dt,
                 stock_price,  # Current stock price
                 discount_curve,
                 dividend_curve):
         """ Calculate the forward price of the equity forward contract. """
 
         if isinstance(value_dt, Date):
-            t = (self._expiry_dt - value_dt) / gDaysInYear
+            t = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("spot_fx_rate must be greater than zero.")
 
         if np.any(t < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         t = np.maximum(t, 1e-10)
 
-        discountDF = discount_curve._df(t)
-        dividendDF = dividend_curve._df(t)
+        discount_df = discount_curve._df(t)
+        dividend_df = dividend_curve._df(t)
 
-        fwdStockPrice = stock_price * dividendDF / discountDF
-        return fwdStockPrice
+        fwd_stock_price = stock_price * dividend_df / discount_df
+        return fwd_stock_price
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("FORWARD PRICE", self._forward_price)
-        s += label_to_string("LONG OR SHORT", self._long_short)
-        s += label_to_string("NOTIONAL", self._notional, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("FORWARD PRICE", self.forward_price)
+        s += label_to_string("LONG OR SHORT", self.long_short)
+        s += label_to_string("NOTIONAL", self.notional, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_index_option.py` & `financepy-0.360/financepy/products/equity/equity_index_option.py`

 * *Files 5% similar despite different names*

```diff
@@ -30,175 +30,185 @@
         """ Create the Equity Index option object by specifying the expiry
         date, the option strike, the option type and the number of options. """
 
         check_argument_types(self.__init__, locals())
 
         if option_type in (OptionTypes.EUROPEAN_CALL, OptionTypes.EUROPEAN_PUT,
                            OptionTypes.AMERICAN_CALL, OptionTypes.AMERICAN_PUT):
-            self._option_type = option_type
-            self._option_type_value = option_type.value
+            self.option_type = option_type
+            self.option_type_value = option_type.value
         else:
             raise FinError("Unknown Option Type")
-        self._expiry_dt = expiry_dt
-        self._strike_price = strike_price
-        self._num_options = num_options
-        self._t_exp = None
+        self.expiry_dt = expiry_dt
+        self.strike_price = strike_price
+        self.num_options = num_options
+        self.t_exp = None
 
 ###############################################################################
 
     def value(self,
               value_dt: Union[Date, list],
               forward_price: float,
               discount_curve: DiscountCurve,
               model: Model,
               ):
         """ Equity Index Option valuation using Black model. """
+
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
-        if isinstance(self._expiry_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        elif isinstance(self._expiry_dt, list):
+
+        if isinstance(self.expiry_dt, Date):
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        elif isinstance(self.expiry_dt, list):
             t_exp = []
-            for expDate in self._expiry_dt:
-                t = (expDate - value_dt) / gDaysInYear
+            for exp_dt in self.expiry_dt:
+                t = (exp_dt - value_dt) / gDaysInYear
             t_exp.append(t)
             t_exp = np.array(t_exp)
         else:
             raise FinError("Valuation date must be Date or list of Date")
-        self._t_exp = t_exp
+
+        self.t_exp = t_exp
+
         if np.any(forward_price <= 0.0):
             raise FinError("Forward price must be greater than zero.")
+
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
+
         t_exp = np.maximum(t_exp, 1e-10)
-        df = discount_curve.df(self._expiry_dt) / \
+
+        df = discount_curve.df(self.expiry_dt) / \
             discount_curve.df(value_dt)
-        k = self._strike_price
+
+        k = self.strike_price
+
         if isinstance(model, Black):
             value = model.value(forward_price, k, t_exp,
-                                df, self._option_type)
+                                df, self.option_type)
         else:
             raise FinError("Unknown Model Type")
-        value = value * self._num_options
+
+        value = value * self.num_options
         return value
 
 ###############################################################################
 
     def delta(self,
               value_dt: Date,
               forward_price: float,
               discount_curve: DiscountCurve,
               model):
         """ Calculate delta of a European/American Index option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
-        self._t_exp = t_exp
+        self.t_exp = t_exp
         if np.any(forward_price <= 0.0):
             raise FinError("Forward price must be greater than zero.")
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
         t_exp = np.maximum(t_exp, 1e-10)
-        df = discount_curve.df(self._expiry_dt) / \
+        df = discount_curve.df(self.expiry_dt) / \
             discount_curve.df(value_dt)
-        k = self._strike_price
+        k = self.strike_price
         if isinstance(model, Black):
             delta = model.delta(forward_price, k, t_exp,
-                                df, self._option_type_value)
+                                df, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
         return delta
 
 ###############################################################################
 
     def gamma(self,
               value_dt: Date,
               forward_price: float,
               discount_curve: DiscountCurve,
               model: Model):
         """ Calculate gamma of a European/American Index option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
         if np.any(forward_price <= 0.0):
             raise FinError("Forward price must be greater than zero.")
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
         t_exp = np.maximum(t_exp, 1e-10)
-        df = discount_curve.df(self._expiry_dt) / \
+        df = discount_curve.df(self.expiry_dt) / \
             discount_curve.df(value_dt)
-        k = self._strike_price
+        k = self.strike_price
         if isinstance(model, Black):
             gamma = model.gamma(forward_price, k, t_exp,
-                                df, self._option_type_value)
+                                df, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
         return gamma
 
 ###############################################################################
 
     def vega(self,
              value_dt: Date,
              forward_price: float,
              discount_curve: DiscountCurve,
              model: Model):
         """ Calculate vega of a European/American Index option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
         if np.any(forward_price <= 0.0):
             raise FinError("Forward price must be greater than zero.")
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
         t_exp = np.maximum(t_exp, 1e-10)
-        df = discount_curve.df(self._expiry_dt) / \
+        df = discount_curve.df(self.expiry_dt) / \
             discount_curve.df(value_dt)
-        k = self._strike_price
+        k = self.strike_price
         if isinstance(model, Black):
             vega = model.vega(forward_price, k, t_exp,
-                              df, self._option_type_value)
+                              df, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
         return vega
 
 ###############################################################################
 
     def theta(self,
               value_dt: Date,
               forward_price: float,
               discount_curve: DiscountCurve,
               model: Model):
         """ Calculate theta of a European/American Index option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
         if np.any(forward_price <= 0.0):
             raise FinError("Forward price must be greater than zero.")
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
         t_exp = np.maximum(t_exp, 1e-10)
-        df = discount_curve.df(self._expiry_dt) / \
+        df = discount_curve.df(self.expiry_dt) / \
             discount_curve.df(value_dt)
-        k = self._strike_price
+        k = self.strike_price
         if isinstance(model, Black):
             theta = model.theta(forward_price, k, t_exp,
-                                df, self._option_type_value)
+                                df, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
         return theta
 
 ###############################################################################
 
     def implied_volatility(self,
@@ -206,38 +216,38 @@
                            forward_price: Union[float, list, np.ndarray],
                            discount_curve: DiscountCurve,
                            model: Model,
                            price: float,
                            ):
         """ Calculate the Black implied volatility of a European/American
         Index option. """
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         if t_exp < 1.0 / 365.0:
             print("Expiry time is too close to zero.")
             return -999
-        df = discount_curve.df(self._expiry_dt) / \
+        df = discount_curve.df(self.expiry_dt) / \
             discount_curve.df(value_dt)
         r = -np.log(df)/t_exp
         if isinstance(model, Black):
             sigma = implied_volatility(
                 forward_price, t_exp, r,
-                self._strike_price, price,
-                self._option_type)
+                self.strike_price, price,
+                self.option_type)
         else:
             raise FinError("Unknown Model Type")
         return sigma
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE VALUE", self._option_type)
-        s += label_to_string("NUMBER", self._num_options, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE VALUE", self.option_type)
+        s += label_to_string("NUMBER", self.num_options, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_model_types.py` & `financepy-0.360/financepy/products/equity/equity_model_types.py`

 * *Files 24% similar despite different names*

```diff
@@ -19,36 +19,36 @@
 # class EquityModelBlackScholes(EquityModel):
 #     def __init__(self,
 #                  volatility: float,
 #                  implementation, parameters):
 
 #         check_argument_types(self.__init__, locals())
 
-#         self._volatility = volatility
-#         self._implementation = implementation
-#         self._parameters = parameters
+#         self.volatility = volatility
+#         self.implementation = implementation
+#         self.parameters = parameters
 
 #     def __repr__(self):
 #         s = label_to_string("OBJECT TYPE", type(self).__name__)
-#         s += label_to_string("VOLATILITY", self._volatility)
-#         s += label_to_string("IMPLEMENTATION", self._implementation)
-#         s += label_to_string("PARAMETERS", self._parameters)
+#         s += label_to_string("VOLATILITY", self.volatility)
+#         s += label_to_string("IMPLEMENTATION", self.implementation)
+#         s += label_to_string("PARAMETERS", self.parameters)
 #         return s
 
 ###############################################################################
 
 
 class EquityModelHeston(EquityModel):
     def __init__(self, volatility, mean_reversion):
-        self._parentType = EquityModel
-        self._volatility = volatility
-        self._mean_reversion = mean_reversion
-        self._implementation = 0
+        self.parentType = EquityModel
+        self.volatility = volatility
+        self.mean_reversion = mean_reversion
+        self.implementation = 0
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VOLATILITY", self._volatility)
-        s += label_to_string("MEAN REVERSION", self._mean_reversion)
-        s += label_to_string("IMPLEMENTATION", self._implementation)
+        s += label_to_string("VOLATILITY", self.volatility)
+        s += label_to_string("MEAN REVERSION", self.mean_reversion)
+        s += label_to_string("IMPLEMENTATION", self.implementation)
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/equity_one_touch_option.py` & `financepy-0.360/financepy/products/equity/equity_one_touch_option.py`

 * *Files 8% similar despite different names*

```diff
@@ -135,18 +135,18 @@
                  barrier_price: float,
                  payment_size: float = 1.0):
         """ Create the one touch option by defining its expiry date and the
         barrier level and a payment size if it is a cash . """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._option_type = option_type
-        self._barrier_price = float(barrier_price)
-        self._payment_size = payment_size
+        self.expiry_dt = expiry_dt
+        self.option_type = option_type
+        self.barrier_price = float(barrier_price)
+        self.payment_size = payment_size
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: (float, np.ndarray),
               discount_curve: DiscountCurve,
@@ -157,39 +157,39 @@
         Handles both cash-or-nothing and asset-or-nothing options."""
 
         DEBUG_MODE = False
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve date not same as option valuation date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve date not same as option valuation date")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
         t = max(t, 1e-6)
 
         s0 = stock_price
-        H = self._barrier_price
-        K = self._payment_size
+        H = self.barrier_price
+        K = self.payment_size
 
-        sqrtT = np.sqrt(t)
+        sqrt_t = np.sqrt(t)
 
-        df = discount_curve.df(self._expiry_dt)
-        r = discount_curve.cc_rate(self._expiry_dt)
-        q = dividend_curve.cc_rate(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        v = model._volatility
+        v = model.volatility
         v = max(v, 1e-6)
 
         # Using notation in Haug page 177
         b = r - q
         mu = (b - v * v / 2.0) / v / v
         lam = np.sqrt(mu * mu + 2.0 * r / v / v)
 
@@ -198,199 +198,199 @@
             print("vol", v)
             print("b", b)
             print("mu", mu)
             print("lam", lam)
 
         # Reference Option Pricing Formulas by Espen Gaarder Haug. Page 176.
 
-        if self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
+        if self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
             # HAUG 1
 
             if np.any(s0 <= H):
                 raise FinError("Stock price is currently below barrier.")
 
             eta = 1.0
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
             A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta
-                                                     * lam * v * sqrtT)
+                                                     * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
             # HAUG 2
 
             if np.any(s0 >= H):
                 raise FinError("Stock price is currently above barrier.")
 
             eta = -1.0
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
             A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta
-                                                     * lam * v * sqrtT)
+                                                     * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
             # HAUG 3
 
             if np.any(s0 <= H):
                 raise FinError("Stock price is currently below barrier.")
 
             eta = 1.0
             K = H
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
             A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta
-                                                     * lam * v * sqrtT)
+                                                     * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
             # HAUG 4
 
             if np.any(s0 >= H):
                 raise FinError("Stock price is currently above barrier.")
 
             eta = -1.0
             K = H
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
             A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta
-                                                     * lam * v * sqrtT)
+                                                     * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
             # HAUG 5
 
             if np.any(s0 <= H):
                 raise FinError("Stock price is currently below barrier.")
 
             eta = +1.0
             phi = -1.0
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 + B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
             # HAUG 6
 
             if np.any(s0 >= H):
                 raise FinError("Stock price is currently above barrier.")
 
             eta = -1.0
             phi = +1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 + B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 7
 
             if np.any(s0 <= H):
                 raise FinError("Stock price is currently below barrier.")
 
             eta = +1.0
             phi = -1.0
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-q*t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 + A4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 8
 
             if np.any(s0 >= H):
                 raise FinError("Stock price is currently above barrier.")
 
             eta = -1.0
             phi = +1.0
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-q*t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 + A4)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
             # HAUG 9
 
             if np.any(s0 <= H):
                 raise FinError("Stock price is currently below barrier.")
 
             eta = +1.0
             phi = +1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 - B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
             # HAUG 10
 
             if np.any(s0 >= H):
                 raise FinError("Stock price is currently above barrier.")
 
             eta = -1.0
             phi = -1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 - B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 11
 
             if np.any(s0 <= H):
                 raise FinError("Stock price is currently below barrier.")
 
             eta = +1.0
             phi = +1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-q*t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 - A4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 12
 
             if np.any(s0 >= H):
                 raise FinError("Stock price is currently above barrier.")
 
             eta = -1.0
             phi = -1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-q*t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 - A4)
             return v
 
         else:
@@ -410,143 +410,143 @@
                  num_steps_per_year: int = 252,
                  seed: int = 4242):
         """ Touch Option valuation using the Black-Scholes model and Monte
         Carlo simulation. Accuracy is not great when compared to the analytical
         result as we only observe the barrier a finite number of times. The
         convergence is slow. """
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t
 
         num_time_steps = int(t * num_steps_per_year) + 1
         dt = t / num_time_steps
 
-        v = model._volatility
+        v = model.volatility
         s0 = stock_price
         mu = r - q
 
         s = get_paths(num_paths, num_time_steps, t, mu, s0, v, seed)
 
-        H = self._barrier_price
-        X = self._payment_size
+        H = self.barrier_price
+        X = self.payment_size
 
         v = 0.0
 
-        if self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
+        if self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
             # HAUG 1
 
             if s0 <= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, r, dt)
             v = v * X
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
             # HAUG 2
 
             if s0 >= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, r, dt)
             v = v * X
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
             # HAUG 3
 
             if s0 <= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, r, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
             # HAUG 4
 
             if s0 >= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, r, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
             # HAUG 5
 
             if s0 <= H:
                 raise FinError("Barrier has  ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, 0.0, dt)
             v = v * X * np.exp(-r*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
             # HAUG 6
 
             if s0 >= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, 0.0, dt)
             v = v * X * np.exp(-r*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 7
 
             if s0 <= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, 0.0, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 8
 
             if s0 >= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, 0.0, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
             # HAUG 9
 
             if s0 <= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = 1.0 - _barrier_pay_one_at_hit_pv_down(s, H, 0.0, dt)
             v = v * X * np.exp(-r*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
             # HAUG 10
 
             if s0 >= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = 1.0 - _barrier_pay_one_at_hit_pv_up(s, H, 0.0, dt)
             v = v * X * np.exp(-r*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 11
 
             if s0 <= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_asset_at_expiry_down_out(s, H)
             v = v * np.exp(-r*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 12
 
             if s0 >= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_asset_at_expiry_up_out(s, H)
             v = v * np.exp(-r*t)
@@ -556,18 +556,18 @@
 
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("BARRIER LEVEL", self._barrier_price)
-        s += label_to_string("PAYMENT SIZE", self._payment_size, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("BARRIER LEVEL", self.barrier_price)
+        s += label_to_string("PAYMENT SIZE", self.payment_size, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_option.py` & `financepy-0.360/financepy/products/equity/equity_option.py`

 * *Files 8% similar despite different names*

```diff
@@ -21,16 +21,16 @@
     BLACKSCHOLES = 1
     ANOTHER = 2
 
 ###############################################################################
 
 
 class EquityOption:
-    """ This class is a parent class for all option classes that require any
-    perturbatory risk. """
+    """ This class is a parent class for all equitu option classes that 
+    require any perturbatory risk. """
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
@@ -46,71 +46,88 @@
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model):
         """ Calculation of option delta by perturbation of stock price and
         revaluation. """
-        v = self.value(value_dt, stock_price, discount_curve,
-                       dividend_curve, model)
+        v = self.value(value_dt,
+                       stock_price,
+                       discount_curve,
+                       dividend_curve,
+                       model)
 
-        vBumped = self.value(value_dt, stock_price + bump,
-                             discount_curve,
-                             dividend_curve,
-                             model)
+        v_bumped = self.value(value_dt,
+                              stock_price + bump,
+                              discount_curve,
+                              dividend_curve,
+                              model)
 
-        delta = (vBumped - v) / bump
+        delta = (v_bumped - v) / bump
         return delta
 
 ###############################################################################
 
     def gamma(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model):
         """ Calculation of option gamma by perturbation of stock price and
         revaluation. """
 
-        v = self.value(value_dt, stock_price, discount_curve,
-                       dividend_curve, model)
+        v = self.value(value_dt,
+                       stock_price,
+                       discount_curve,
+                       dividend_curve,
+                       model)
 
-        vBumpedDn = self.value(value_dt, stock_price - bump,
-                               discount_curve,
-                               dividend_curve, model)
-
-        vBumpedUp = self.value(value_dt, stock_price + bump,
-                               discount_curve,
-                               dividend_curve, model)
+        v_bumped_dn = self.value(value_dt,
+                                 stock_price - bump,
+                                 discount_curve,
+                                 dividend_curve,
+                                 model)
 
-        gamma = (vBumpedUp - 2.0 * v + vBumpedDn) / bump / bump
+        v_bumped_up = self.value(value_dt,
+                                 stock_price + bump,
+                                 discount_curve,
+                                 dividend_curve,
+                                 model)
+
+        gamma = (v_bumped_up - 2.0 * v + v_bumped_dn) / bump / bump
         return gamma
 
 ###############################################################################
 
     def vega(self,
              value_dt: Date,
              stock_price: float,
              discount_curve: DiscountCurve,
              dividend_curve: DiscountCurve,
              model):
         """ Calculation of option vega by perturbing vol and revaluation. """
 
         bump = 0.01
 
-        v = self.value(value_dt, stock_price, discount_curve,
-                       dividend_curve, model)
+        v = self.value(value_dt,
+                       stock_price,
+                       discount_curve,
+                       dividend_curve,
+                       model)
 
-        model = BlackScholes(model._volatility + bump)
+        model = BlackScholes(model.volatility + bump)
 
-        vBumped = self.value(value_dt, stock_price, discount_curve,
-                             dividend_curve, model)
+        v_bumped = self.value(value_dt,
+                              stock_price,
+                              discount_curve,
+                              dividend_curve,
+                              model)
 
-        vega = (vBumped - v)
+        vega = (v_bumped - v)
         return vega
 
 ##############################################################################
 
     def vanna(self,
               value_dt: Date,
               stock_price: float,
@@ -122,15 +139,15 @@
 
         delta = self.delta(value_dt,
                            stock_price,
                            discount_curve,
                            dividend_curve,
                            model)
 
-        model = BlackScholes(model._volatility + bump)
+        model = BlackScholes(model.volatility + bump)
 
         deltaBumped = self.delta(value_dt,
                                  stock_price,
                                  discount_curve,
                                  dividend_curve,
                                  model)
 
@@ -145,52 +162,60 @@
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model):
         """ Calculation of option theta by perturbing value date by one
         calendar date (not a business date) and then doing revaluation and
         calculating the difference divided by dt = 1 / gDaysInYear. """
 
-        v = self.value(value_dt, stock_price,
+        v = self.value(value_dt,
+                       stock_price,
                        discount_curve,
-                       dividend_curve, model)
+                       dividend_curve,
+                       model)
 
         next_dt = value_dt.add_days(1)
 
         # Need to do this carefully. This is a bit hacky.
-        discount_curve._value_dt = next_dt
-        dividend_curve._value_dt = next_dt
+        discount_curve.value_dt = next_dt
+        dividend_curve.value_dt = next_dt
         bump = (next_dt - value_dt) / gDaysInYear
 
-        vBumped = self.value(next_dt, stock_price,
-                             discount_curve,
-                             dividend_curve, model)
+        v_bumped = self.value(next_dt,
+                              stock_price,
+                              discount_curve,
+                              dividend_curve,
+                              model)
 
         # restore valuation dates
-        discount_curve._value_dt = value_dt
-        dividend_curve._value_dt = value_dt
+        discount_curve.value_dt = value_dt
+        dividend_curve.value_dt = value_dt
 
-        theta = (vBumped - v) / bump
+        theta = (v_bumped - v) / bump
         return theta
 
 ###############################################################################
 
     def rho(self,
             value_dt: Date,
             stock_price: float,
             discount_curve: DiscountCurve,
             dividend_curve: DiscountCurve,
             model):
         """ Calculation of option rho by perturbing interest rate and
         revaluation. """
 
-        v = self.value(value_dt, stock_price, discount_curve,
-                       dividend_curve, model)
+        v = self.value(value_dt,
+                       stock_price,
+                       discount_curve,
+                       dividend_curve,
+                       model)
 
-        vBumped = self.value(value_dt,
-                             stock_price,
-                             discount_curve.bump(bump),
-                             dividend_curve, model)
+        v_bumped = self.value(value_dt,
+                              stock_price,
+                              discount_curve.bump(bump),
+                              dividend_curve,
+                              model)
 
-        rho = (vBumped - v) / bump
+        rho = (v_bumped - v) / bump
         return rho
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/equity_rainbow_option.py` & `financepy-0.360/financepy/products/equity/equity_rainbow_option.py`

 * *Files 4% similar despite different names*

```diff
@@ -120,45 +120,45 @@
                  payoff_params: List[float],
                  num_assets: int):
 
         check_argument_types(self.__init__, locals())
 
         self._validate_payoff(payoff_type, payoff_params, num_assets)
 
-        self._expiry_dt = expiry_dt
-        self._payoff_type = payoff_type
-        self._payoff_params = payoff_params
-        self._num_assets = num_assets
+        self.expiry_dt = expiry_dt
+        self.payoff_type = payoff_type
+        self.payoff_params = payoff_params
+        self.num_assets = num_assets
 
 ###############################################################################
 
     def _validate(self,
                   stock_prices,
                   dividend_curves,
                   volatilities,
                   betas):
 
-        if len(stock_prices) != self._num_assets:
+        if len(stock_prices) != self.num_assets:
             raise FinError(
                 "Stock prices must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
-        if len(dividend_curves) != self._num_assets:
+        if len(dividend_curves) != self.num_assets:
             raise FinError(
                 "Dividend discount must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
-        if len(volatilities) != self._num_assets:
+        if len(volatilities) != self.num_assets:
             raise FinError(
                 "Volatilities must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
-        if len(betas) != self._num_assets:
+        if len(betas) != self.num_assets:
             raise FinError("Betas must be a vector of length " +
-                           str(self._num_assets))
+                           str(self.num_assets))
 
 ###############################################################################
 
     def _validate_payoff(self, payoff_type, payoff_params, num_assets):
 
         num_params = 0
 
@@ -199,42 +199,42 @@
               dividend_curves: (list),
               volatilities: np.ndarray,
               corr_matrix: np.ndarray):
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if self._num_assets != 2:
+        if self.num_assets != 2:
             raise FinError("Analytical results for two assets only.")
 
         if corr_matrix.ndim != 2:
             raise FinError("Corr matrix must be of size 2x2")
 
         if corr_matrix.shape[0] != 2:
             raise FinError("Corr matrix must be of size 2x2")
 
         if corr_matrix.shape[1] != 2:
             raise FinError("Corr matrix must be of size 2x2")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
         # Use result by Stulz (1982) given by Haug Page 211
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        r = discount_curve.zero_rate(self._expiry_dt)
+        t = (self.expiry_dt - value_dt) / gDaysInYear
+        r = discount_curve.zero_rate(self.expiry_dt)
 
-        q1 = dividend_curves[0].zero_rate(self._expiry_dt)
-        q2 = dividend_curves[1].zero_rate(self._expiry_dt)
+        q1 = dividend_curves[0].zero_rate(self.expiry_dt)
+        q2 = dividend_curves[1].zero_rate(self.expiry_dt)
 
         dividend_yields = [q1, q2]
 
         self._validate(stock_prices,
                        dividend_yields,
                        volatilities,
                        corr_matrix)
@@ -245,40 +245,40 @@
         rho = corr_matrix[0][1]
         s1 = stock_prices[0]
         s2 = stock_prices[1]
         b1 = r - q1
         b2 = r - q2
         v1 = volatilities[0]
         v2 = volatilities[1]
-        k = self._payoff_params[0]
+        k = self.payoff_params[0]
 
         v = sqrt(v1 * v1 + v2 * v2 - 2 * rho * v1 * v2)
         d = (log(s1 / s2) + (b1 - b2 + v * v / 2) * t) / v / sqrt(t)
         y1 = (log(s1 / k) + (b1 + v1 * v1 / 2) * t) / v1 / sqrt(t)
         y2 = (log(s2 / k) + (b2 + v2 * v2 / 2) * t) / v2 / sqrt(t)
         rho1 = (v1 - rho * v2) / v
         rho2 = (v2 - rho * v1) / v
         dq1 = exp(-q1 * t)
         dq2 = exp(-q2 * t)
         df = exp(-r * t)
 
-        if self._payoff_type == EquityRainbowOptionTypes.CALL_ON_MAXIMUM:
+        if self.payoff_type == EquityRainbowOptionTypes.CALL_ON_MAXIMUM:
             v = s1 * dq1 * M(y1, d, rho1) + s2 * dq2 * M(y2, -d + v * sqrt(t), rho2) \
                 - k * df * \
                 (1.0 - M(-y1 + v1 * sqrt(t), -y2 + v2 * sqrt(t), rho))
-        elif self._payoff_type == EquityRainbowOptionTypes.CALL_ON_MINIMUM:
+        elif self.payoff_type == EquityRainbowOptionTypes.CALL_ON_MINIMUM:
             v = s1 * dq1 * M(y1, -d, -rho1) + s2 * dq2 * M(y2, d - v * sqrt(t), -rho2) \
                 - k * df * M(y1 - v1 * sqrt(t), y2 - v2 * sqrt(t), rho)
-        elif self._payoff_type == EquityRainbowOptionTypes.PUT_ON_MAXIMUM:
+        elif self.payoff_type == EquityRainbowOptionTypes.PUT_ON_MAXIMUM:
             cmax1 = s2 * dq2 + s1 * dq1 * N(d) - s2 * dq2 * N(d - v * sqrt(t))
             cmax2 = s1 * dq1 * M(y1, d, rho1) + s2 * dq2 * M(y2, -d + v * sqrt(t), rho2) \
                 - k * df * \
                 (1.0 - M(-y1 + v1 * sqrt(t), -y2 + v2 * sqrt(t), rho))
             v = k * df - cmax1 + cmax2
-        elif self._payoff_type == EquityRainbowOptionTypes.PUT_ON_MINIMUM:
+        elif self.payoff_type == EquityRainbowOptionTypes.PUT_ON_MINIMUM:
             cmin1 = s1 * dq1 - s1 * dq1 * N(d) + s2 * dq2 * N(d - v * sqrt(t))
             cmin2 = s1 * dq1 * M(y1, -d, -rho1) + s2 * dq2 * M(y2, d - v * sqrt(
                 t), -rho2) - k * df * M(y1 - v1 * sqrt(t), y2 - v2 * sqrt(t), rho)
             v = k * df - cmin1 + cmin2
         else:
             raise FinError("Unsupported Rainbow option type")
 
@@ -297,42 +297,42 @@
                  seed=4242):
 
         self._validate(stock_prices,
                        dividend_curves,
                        volatilities,
                        corr_matrix)
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
         v = value_mc_fast(t,
                           stock_prices,
                           discount_curve,
                           dividend_curves,
                           volatilities,
                           corr_matrix,
-                          self._num_assets,
-                          self._payoff_type,
-                          self._payoff_params,
+                          self.num_assets,
+                          self.payoff_type,
+                          self.payoff_params,
                           num_paths,
                           seed)
 
         return v
 
 ###############################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("PAYOFF TYPE", self._payoff_type)
-        s += label_to_string("PAYOFF PARAMS", self._payoff_params)
-        s += label_to_string("NUM ASSETS TYPE", self._num_assets, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("PAYOFF TYPE", self.payoff_type)
+        s += label_to_string("PAYOFF PARAMS", self.payoff_params)
+        s += label_to_string("NUM ASSETS TYPE", self.num_assets, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_swap.py` & `financepy-0.360/financepy/products/equity/equity_swap.py`

 * *Files 5% similar despite different names*

```diff
@@ -57,121 +57,121 @@
         The start date is contractual and is the same as the settlement date for a new swap.
         It is the date on which interest starts to accrue. The end of the contract is the
         termination date. This is not adjusted for business days. The adjusted termination
         date is called the maturity date. This is calculated. """
 
         check_argument_types(self.__init__, locals())
 
-        if type(term_dt_or_tenor) == Date:
-            self._termination_dt = term_dt_or_tenor
+        if isinstance(term_dt_or_tenor, Date):
+            self.termination_dt = term_dt_or_tenor
         else:
-            self._termination_dt = effective_dt.add_tenor(
+            self.termination_dt = effective_dt.add_tenor(
                 term_dt_or_tenor)
 
         calendar = Calendar(cal_type)
-        self._maturity_dt = calendar.adjust(self._termination_dt,
+        self.maturity_dt = calendar.adjust(self.termination_dt,
                                               bd_type)
 
-        if effective_dt > self._maturity_dt:
+        if effective_dt > self.maturity_dt:
             raise FinError("Start date after maturity date")
 
-        self._effective_dt = effective_dt
+        self.effective_dt = effective_dt
 
         # There is no exchange of principal
-        self._principal = 0.0
+        self.principal = 0.0
 
         rate_leg_type = SwapTypes.PAY
         if eq_leg_type == SwapTypes.PAY:
             rate_leg_type = SwapTypes.RECEIVE
 
-        self._equity_leg = EquitySwapLeg(effective_dt,
-                                         self._maturity_dt,
+        self.equity_leg = EquitySwapLeg(effective_dt,
+                                         self.maturity_dt,
                                          eq_leg_type,
                                          eq_freq_type,
                                          eq_dc_type,
                                          strike,
                                          quantity,
                                          eq_payment_lag,
                                          eq_return_type,
                                          cal_type,
                                          bd_type,
                                          dg_type,
                                          end_of_month)
 
         # Fixed Rate Leg not implemented yet
-        self._rate_leg = SwapFloatLeg(effective_dt,
-                                      self._maturity_dt,
+        self.rate_leg = SwapFloatLeg(effective_dt,
+                                      self.maturity_dt,
                                       rate_leg_type,
                                       rate_spread,
                                       rate_freq_type,
                                       rate_dc_type,
-                                      self._equity_leg._notional,
-                                      self._principal,
+                                      self.equity_leg.notional,
+                                      self.principal,
                                       rate_payment_lag,
                                       cal_type,
                                       bd_type,
                                       dg_type,
                                       end_of_month)
 
     ###########################################################################
 
     def value(self,
               value_dt: Date,
               discount_curve: DiscountCurve,
               index_curve: DiscountCurve = None,
               dividend_curve: DiscountCurve = None,
               current_price: float = None,
-              firstFixingRate=None):
+              first_fixing_rate=None):
         """ Value the Equity swap on a valuation date. """
 
-        self._equity_leg_value = self._equity_leg.value(value_dt,
+        self.equity_leg_value = self.equity_leg.value(value_dt,
                                                         discount_curve,
                                                         index_curve,
                                                         dividend_curve,
                                                         current_price)
         self._fill_rate_notional_array()
 
-        self._rate_leg_value = self._rate_leg.value(value_dt,
+        self.rate_leg_value = self.rate_leg.value(value_dt,
                                                     discount_curve,
                                                     index_curve,
-                                                    firstFixingRate)
+                                                    first_fixing_rate)
 
-        return self._equity_leg_value + self._rate_leg_value
+        return self.equity_leg_value + self.rate_leg_value
 
     ###########################################################################
 
     def _fill_rate_notional_array(self):
         """ In an equity swap, at every equity reset, the notional
         of the contract is updated to reflect the new underlying
         price.
 
         This is a helper function that takes the Equity Notional list
         from Equity Leg and convert it to a Notional array that fits
         the payment schedule defined for the rate leg.
         """
 
         # Assumption: Rate frequency type is a multiple of Equity's
-        eq_freq = annual_frequency(self._equity_leg._freq_type)
-        rate_freq = annual_frequency(self._rate_leg._freq_type)
+        eq_freq = annual_frequency(self.equity_leg.freq_type)
+        rate_freq = annual_frequency(self.rate_leg.freq_type)
 
         multiple = int(rate_freq // eq_freq)
-        isMultiple = int(rate_freq % eq_freq) == 0
+        is_multiple = int(rate_freq % eq_freq) == 0
 
-        if (eq_freq is None or rate_freq is None) or (not isMultiple):
+        if (eq_freq is None or rate_freq is None) or (not is_multiple):
             raise FinError("Invalid frequency type assigned!")
 
-        self._rate_leg._notional_array = []
-        for lastNotional in self._equity_leg._last_notionals:
+        self.rate_leg.notional_array = []
+        for last_notional in self.equity_leg.last_notionals:
             for _ in range(multiple):
-                self._rate_leg._notional_array.append(lastNotional)
+                self.rate_leg.notional_array.append(last_notional)
 
     ###########################################################################
 
     def __repr__(self):
         s = "EQUITY LEG:\n"
-        s += self._equity_leg.__repr__()
+        s += self.equity_leg.__repr__()
         s += "\nRATE LEG:\n"
-        s += self._rate_leg.__repr__()
+        s += self.rate_leg.__repr__()
 
         return s
 
     ###########################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/equity_swap_leg.py` & `financepy-0.360/financepy/products/equity/equity_swap_leg.py`

 * *Files 12% similar despite different names*

```diff
@@ -39,114 +39,123 @@
                  end_of_month: bool = False):
         """ Create the equity leg of a swap contract giving the contract start
         date, its maturity, underlying strike price and quantity, payment
         frequency, day count convention, return type, and other details """
 
         check_argument_types(self.__init__, locals())
 
-        if type(term_dt_or_tenor) == Date:
+        if isinstance(term_dt_or_tenor, Date):
             termination_dt = term_dt_or_tenor
         else:
             termination_dt = effective_dt.add_tenor(term_dt_or_tenor)
 
         calendar = Calendar(cal_type)
-        self._maturity_dt = calendar.adjust(termination_dt,
+        self.maturity_dt = calendar.adjust(termination_dt,
                                             bd_type)
 
-        if effective_dt > self._maturity_dt:
+        if effective_dt > self.maturity_dt:
             raise FinError("Effective date after maturity date")
 
         if quantity < 0:
             # Long/Short is defined by leg_type
             raise FinError("Quantity must be non-negative")
 
         if return_type != ReturnTypes.TOTAL_RETURN:
             raise NotImplementedError("Return Type still not implemented")
 
         # To generate ISDA pmnt schedule properly we can't use these types
         if freq_type in (FrequencyTypes.CONTINUOUS, FrequencyTypes,
                          FrequencyTypes.SIMPLE):
             raise FinError("Cannot generate payment schedule for this frequency!")
 
-        self._effective_dt = effective_dt
-        self._termination_dt = termination_dt
-        self._leg_type = leg_type
-        self._freq_type = freq_type
-        self._payment_lag = payment_lag
-        self._strike = strike
-        self._quantity = quantity
-        self._notional = strike * quantity
-        self._return_type = return_type
-
-        self._dc_type = dc_type
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
-        self._end_of_month = end_of_month
-
-        self._start_accd_dates = []
-        self._end_accd_dates = []
-        self._payment_dts = []
-        self._pmnts = []
-        self._year_fracs = []
-        self._accrued_days = []
-        self._rates = []
+        self.effective_dt = effective_dt
+        self.termination_dt = termination_dt
+        self.leg_type = leg_type
+        self.freq_type = freq_type
+        self.payment_lag = payment_lag
+        self.strike = strike
+        self.quantity = quantity
+        self.notional = strike * quantity
+        self.return_type = return_type
+
+        self.dc_type = dc_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+        self.end_of_month = end_of_month
+
+        self.start_accd_dts = []
+        self.end_accd_dts = []
+        self.payment_dts = []
+        self.payment_amounts = []
+        self.year_fracs = []
+        self.accrued_days = []
+        self.rates = []
+
+        self.fwd_rates = []
+        self.div_fwd_rates = []
+        self.eq_fwd_rates = []
+        self.last_notionals = []
+        self.payment_dfs = []
+        self.payment_pvs = []
+        self.cumulative_pvs = []
+        self.current_price = None
 
         self.generate_payment_dts()
 
 ###############################################################################
 
     def generate_payment_dts(self):
         """ Generate the Equity leg payment dates and accrual factors. Similar
         to swap float leg, payment values can't be generated, as we do not have
         index curve, dividend curve and equity price. """
 
-        schedule = Schedule(self._effective_dt,
-                            self._maturity_dt,
-                            self._freq_type,
-                            self._cal_type,
-                            self._bd_type,
-                            self._dg_type,
-                            end_of_month=self._end_of_month)
+        schedule = Schedule(self.effective_dt,
+                            self.maturity_dt,
+                            self.freq_type,
+                            self.cal_type,
+                            self.bd_type,
+                            self.dg_type,
+                            end_of_month=self.end_of_month)
 
-        scheduleDates = schedule._adjusted_dts
+        schedule_dts = schedule.adjusted_dts
 
-        if len(scheduleDates) < 2:
+        if len(schedule_dts) < 2:
             raise FinError("Schedule has none or only one date")
 
-        self._start_accd_dates = []
-        self._end_accd_dates = []
-        self._payment_dts = []
-        self._year_fracs = []
-        self._accrued_days = []
+        self.start_accd_dts = []
+        self.end_accd_dts = []
+        self.payment_dts = []
+        self.year_fracs = []
+        self.accrued_days = []
 
-        prev_dt = scheduleDates[0]
+        prev_dt = schedule_dts[0]
 
-        day_counter = DayCount(self._dc_type)
-        calendar = Calendar(self._cal_type)
+        day_counter = DayCount(self.dc_type)
+        calendar = Calendar(self.cal_type)
 
-        # All of the lists end up with the same length
-        for next_dt in scheduleDates[1:]:
+        # All the lists end up with the same length
+        for next_dt in schedule_dts[1:]:
 
-            self._start_accd_dates.append(prev_dt)
-            self._end_accd_dates.append(next_dt)
+            self.start_accd_dts.append(prev_dt)
+            self.end_accd_dts.append(next_dt)
 
-            if self._payment_lag == 0:
+            if self.payment_lag == 0:
                 payment_dt = next_dt
             else:
                 payment_dt = calendar.add_business_days(next_dt,
-                                                        self._payment_lag)
+                                                        self.payment_lag)
 
-            self._payment_dts.append(payment_dt)
+            self.payment_dts.append(payment_dt)
 
             (year_frac, num, _) = day_counter.year_frac(prev_dt,
                                                         next_dt)
 
-            self._year_fracs.append(year_frac)
-            self._accrued_days.append(num)
+            self.year_fracs.append(year_frac)
+            self.accrued_days.append(num)
 
             prev_dt = next_dt
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
@@ -158,190 +167,191 @@
         an index curve and an [optional] dividend curve. Discounting is based
         on a supplied discount curve as of the valuation date supplied.
         """
 
         if discount_curve is None:
             raise FinError("Discount curve not provided!")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
         if index_curve is None:
             index_curve = discount_curve
 
         # Assume a naive dividend curve if nothing provided
         if dividend_curve is None:
             dividend_curve = DiscountCurveFlat(value_dt, 0)
 
         # Current price can't be different than strike at effective date
         if current_price is not None:
-            self._current_price = current_price
+            self.current_price = current_price
         else:
-            self._current_price = self._strike
+            self.current_price = self.strike
 
-        self._fwd_rates = []
-        self._div_fwd_rates = []
-        self._eq_fwd_rates = []
-        self._last_notionals = []
-        self._pmnts = []
-        self._pmnt_dfs = []
-        self._pmnt_pvs = []
-        self._cumulative_pvs = []
+        self.fwd_rates = []
+        self.div_fwd_rates = []
+        self.eq_fwd_rates = []
+        self.last_notionals = []
+        self.payment_amounts = []
+        self.payment_dfs = []
+        self.payment_pvs = []
+        self.cumulative_pvs = []
 
-        dfValue = discount_curve.df(value_dt)
+        df_value = discount_curve.df(value_dt)
         leg_pv, eq_term_rate = 0.0, 0.0
-        last_notional = self._notional
-        numPayments = len(self._payment_dts)
+        last_notional = self.notional
+        next_notional = last_notional
+        num_payments = len(self.payment_dts)
 
-        index_basis = index_curve._dc_type
+        index_basis = index_curve.dc_type
         index_day_counter = DayCount(index_basis)
 
-        for iPmnt in range(0, numPayments):
+        for i_pmnt in range(0, num_payments):
 
-            pmntDate = self._payment_dts[iPmnt]
+            payment_dt = self.payment_dts[i_pmnt]
 
-            if pmntDate > value_dt:
+            if payment_dt > value_dt:
 
-                startAccruedDt = self._start_accd_dates[iPmnt]
-                endAccruedDt = self._end_accd_dates[iPmnt]
-                index_alpha = index_day_counter.year_frac(startAccruedDt,
-                                                          endAccruedDt)[0]
+                start_accrued_dt = self.start_accd_dts[i_pmnt]
+                end_accrued_dt = self.end_accd_dts[i_pmnt]
+                index_alpha = index_day_counter.year_frac(start_accrued_dt,
+                                                          end_accrued_dt)[0]
 
-                df_start = index_curve.df(startAccruedDt)
-                df_end = index_curve.df(endAccruedDt)
+                df_start = index_curve.df(start_accrued_dt)
+                df_end = index_curve.df(end_accrued_dt)
                 fwd_rate = (df_start / df_end - 1.0) / index_alpha
 
-                div_start = dividend_curve.df(startAccruedDt)
-                div_end = dividend_curve.df(endAccruedDt)
+                div_start = dividend_curve.df(start_accrued_dt)
+                div_end = dividend_curve.df(end_accrued_dt)
                 div_fwd_rate = (div_start / div_end - 1.0) / index_alpha
 
                 # Equity discount derived from index and div curves
                 eq_fwd_rate = ((df_start / df_end) * (div_start / div_end) - 1) / index_alpha
 
-                self._fwd_rates.append(fwd_rate)
-                self._div_fwd_rates.append(div_fwd_rate)
-                self._eq_fwd_rates.append(eq_fwd_rate)
+                self.fwd_rates.append(fwd_rate)
+                self.div_fwd_rates.append(div_fwd_rate)
+                self.eq_fwd_rates.append(eq_fwd_rate)
 
                 # Iterative update of the term rate
-                eq_term_rate = (1 + eq_fwd_rate * self._year_fracs[iPmnt]) * (1 + eq_term_rate)  - 1
+                eq_term_rate = (1 + eq_fwd_rate * self.year_fracs[i_pmnt]) * (1 + eq_term_rate)  - 1
 
-                next_price = self._current_price * (1 + eq_term_rate)
-                next_notional = next_price * self._quantity
-                pmntAmount = next_notional - last_notional
-
-                df_pmnt = discount_curve.df(pmntDate) / dfValue
-                pmnt_pv = pmntAmount * df_pmnt
-                leg_pv += pmnt_pv
-
-                self._last_notionals.append(last_notional)
-                self._pmnts.append(pmntAmount)
-                self._pmnt_dfs.append(df_pmnt)
-                self._pmnt_pvs.append(pmnt_pv)
-                self._cumulative_pvs.append(leg_pv)
+                next_price = self.current_price * (1 + eq_term_rate)
+                next_notional = next_price * self.quantity
+                payment_amount = next_notional - last_notional
+
+                df_payment = discount_curve.df(payment_dt) / df_value
+                payment_pv = payment_amount * df_payment
+                leg_pv += payment_pv
+
+                self.last_notionals.append(last_notional)
+                self.payment_amounts.append(payment_amount)
+                self.payment_dfs.append(df_payment)
+                self.payment_pvs.append(payment_pv)
+                self.cumulative_pvs.append(leg_pv)
 
             else:
 
-                self._fwd_rates.append(0.0)
-                self._div_fwd_rates.append(0.0)
-                self._eq_fwd_rates.append(0.0)
-                self._last_notionals.append(self._notional)
-                self._pmnts.append(0.0)
-                self._pmnt_dfs.append(0.0)
-                self._pmnt_pvs.append(0.0)
-                self._cumulative_pvs.append(leg_pv)
+                self.fwd_rates.append(0.0)
+                self.div_fwd_rates.append(0.0)
+                self.eq_fwd_rates.append(0.0)
+                self.last_notionals.append(self.notional)
+                self.payment_amounts.append(0.0)
+                self.payment_dfs.append(0.0)
+                self.payment_pvs.append(0.0)
+                self.cumulative_pvs.append(leg_pv)
 
             last_notional = next_notional
 
-        if self._leg_type == SwapTypes.PAY:
+        if self.leg_type == SwapTypes.PAY:
             leg_pv = leg_pv * (-1.0)
 
         return leg_pv
 
 ##########################################################################
 
-    def print_pmnts(self):
+    def print_payment_amounts(self):
         """ Prints the payment dates, accrual factors, discount factors,
         cash amounts, their present value and their cumulative PV using the
         last valuation performed. """
 
-        print("START DATE:", self._effective_dt)
-        print("MATURITY DATE:", self._maturity_dt)
-        print("FREQUENCY:", str(self._freq_type))
-        print("DAY COUNT:", str(self._dc_type))
+        print("START DATE:", self.effective_dt)
+        print("MATURITY DATE:", self.maturity_dt)
+        print("FREQUENCY:", str(self.freq_type))
+        print("DAY COUNT:", str(self.dc_type))
 
-        if len(self._payment_dts) == 0:
+        if len(self.payment_dts) == 0:
             print("Payments Dates not calculated.")
             return
 
         header = ["PAY_NUM", "PAY_dt", "ACCR_START", "ACCR_END", "DAYS",
                   "YEARFRAC"]
 
         rows = []
-        num_flows = len(self._payment_dts)
+        num_flows = len(self.payment_dts)
         for i_flow in range(0, num_flows):
             rows.append([
                 i_flow + 1,
-                self._payment_dts[i_flow],
-                self._start_accd_dates[i_flow],
-                self._end_accd_dates[i_flow],
-                self._accrued_days[i_flow],
-                round(self._year_fracs[i_flow], 4),
+                self.payment_dts[i_flow],
+                self.start_accd_dts[i_flow],
+                self.end_accd_dts[i_flow],
+                self.accrued_days[i_flow],
+                round(self.year_fracs[i_flow], 4),
             ])
 
         table = format_table(header, rows)
         print("\nPAYMENTS SCHEDULE:")
         print(table)
 
 ###############################################################################
 
     def print_valuation(self):
         """ Prints the valuation dates, accrual factors, discount factors,
         cash amounts, their present value and their cumulative PV using the
         last valuation performed. """
 
-        self.print_pmnts()
+        self.print_payment_amounts()
 
-        if len(self._pmnts) == 0:
+        if len(self.payment_amounts) == 0:
             print("Payments not calculated.")
             return
 
         header = ["PAY_NUM", "PAY_dt",  "NOTIONAL",
                   "FWD_RATE", "PMNT", "DF",
                   "PV", "CUM_PV"]
 
         rows = []
-        num_flows = len(self._payment_dts)
+        num_flows = len(self.payment_dts)
         for i_flow in range(0, num_flows):
             rows.append([
                 i_flow + 1,
-                self._payment_dts[i_flow],
-                round(self._last_notionals[i_flow], 0),
-                round(self._eq_fwd_rates[i_flow] * 100.0, 4),
-                round(self._pmnts[i_flow], 2),
-                round(self._pmnt_dfs[i_flow], 4),
-                round(self._pmnt_pvs[i_flow], 2),
-                round(self._cumulative_pvs[i_flow], 2),
+                self.payment_dts[i_flow],
+                round(self.last_notionals[i_flow], 0),
+                round(self.eq_fwd_rates[i_flow] * 100.0, 4),
+                round(self.payment_amounts[i_flow], 2),
+                round(self.payment_dfs[i_flow], 4),
+                round(self.payment_pvs[i_flow], 2),
+                round(self.cumulative_pvs[i_flow], 2),
             ])
 
         table = format_table(header, rows)
         print("\nPAYMENTS VALUATION:")
         print(table)
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EFFECTIVE DATE", self._effective_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("NOTIONAL", self._strike * self._quantity)
-        s += label_to_string("SWAP TYPE", self._leg_type)
-        s += label_to_string("RETURN TYPE", self._return_type)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT", self._dc_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUS DAY ADJUST", self._bd_type)
-        s += label_to_string("DATE GEN TYPE", self._dg_type)
+        s += label_to_string("EFFECTIVE DATE", self.effective_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("NOTIONAL", self.strike * self.quantity)
+        s += label_to_string("SWAP TYPE", self.leg_type)
+        s += label_to_string("RETURN TYPE", self.return_type)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT", self.dc_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUS DAY ADJUST", self.bd_type)
+        s += label_to_string("DATE GEN TYPE", self.dg_type)
         return s
 
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/equity/equity_vanilla_option.py` & `financepy-0.360/financepy/products/equity/equity_vanilla_option.py`

 * *Files 4% similar despite different names*

```diff
@@ -57,15 +57,15 @@
     self = args[0]
     t_exp = args[1]
     s0 = args[2]
     r = args[3]
     q = args[4]
     k = args[5]
 
-    fprime = bs_vega(s0, t_exp, k, r, q, v, self._option_type.value)
+    fprime = bs_vega(s0, t_exp, k, r, q, v, self.option_type.value)
     return fprime
 
 ###############################################################################
 
 
 class EquityVanillaOption():
     """ Class for managing plain vanilla European calls and puts on equities.
@@ -85,62 +85,62 @@
             option_type_value = option_type.value
         elif isinstance(option_type, list):
             option_type_value = []
             for opt in option_type:
                 option_type_value.append(opt.value)
             option_type_value = np.array(option_type_value)
 
-        self._option_type_value = option_type_value
+        self.option_type_value = option_type_value
 
-        self._expiry_dt = expiry_dt
-        self._strike_price = strike_price
-        self._option_type = option_type
-        self._num_options = num_options
-        self._t_exp = None
+        self.expiry_dt = expiry_dt
+        self.strike_price = strike_price
+        self.option_type = option_type
+        self.num_options = num_options
+        self.t_exp = None
 
 ###############################################################################
 
     def intrinsic(self,
                   value_dt: (Date, list),
                   stock_price: (np.ndarray, float),
                   discount_curve: DiscountCurve,
                   dividend_curve: DiscountCurve):
         """ Equity Vanilla Option valuation using Black-Scholes model. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if isinstance(self._expiry_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        elif isinstance(self._expiry_dt, list):
+        if isinstance(self.expiry_dt, Date):
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        elif isinstance(self.expiry_dt, list):
             t_exp = []
-            for expDate in self._expiry_dt:
-                t = (expDate - value_dt) / gDaysInYear
+            for exp_dt in self.expiry_dt:
+                t = (exp_dt - value_dt) / gDaysInYear
             t_exp.append(t)
             t_exp = np.array(t_exp)
         else:
             t_exp = value_dt
 
-        self._t_exp = t_exp
+        self.t_exp = t_exp
 
         s0 = stock_price
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         intrinsic_value = bs_intrinsic(s0, t_exp, k, r, q,
-                                       self._option_type_value)
+                                       self.option_type_value)
 
-        intrinsic_value = intrinsic_value * self._num_options
+        intrinsic_value = intrinsic_value * self.num_options
         return intrinsic_value
 
 ###############################################################################
 
     def value(self,
               value_dt: (Date, list),
               stock_price: (np.ndarray, float),
@@ -148,112 +148,112 @@
               dividend_curve: DiscountCurve,
               model: Model):
         """ Equity Vanilla Option valuation using Black-Scholes model. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if isinstance(self._expiry_dt, list):
-            if any(value_dt > self._expiry_dt):
+        if isinstance(self.expiry_dt, list):
+            if any(value_dt > self.expiry_dt):
                 raise FinError("Valuation date after expiry dates.")
-        elif value_dt > self._expiry_dt:
+        elif value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if discount_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
                 "Discount Curve valuation date not same as option value date")
 
-        if dividend_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
                 "Dividend Curve valuation date not same as option value date")
 
-        if isinstance(self._expiry_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
-        elif isinstance(self._expiry_dt, list):
+        if isinstance(self.expiry_dt, Date):
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
+        elif isinstance(self.expiry_dt, list):
             t_exp = []
-            for expDate in self._expiry_dt:
-                t = (expDate - value_dt) / gDaysInYear
+            for exp_dt in self.expiry_dt:
+                t = (exp_dt - value_dt) / gDaysInYear
             t_exp.append(t)
             t_exp = np.array(t_exp)
         else:
             t_exp = value_dt
 
-        self._t_exp = t_exp
+        self.t_exp = t_exp
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
 
         t_exp = np.maximum(t_exp, 1e-10)
 
         # Extract the discount. Adjust if tvalue date is not same as curve date
         # I decided to put an error message - may reconsider
-        df_expiry = discount_curve.df(self._expiry_dt)
+        df_expiry = discount_curve.df(self.expiry_dt)
         # df_value = discount_curve.df(value_dt)
         # df = df_expiry / df_value
         r = -np.log(df_expiry)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
 
-            v = model._volatility
-            value = bs_value(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            value = bs_value(s0, t_exp, k, r, q, v, self.option_type_value)
 
         else:
             raise FinError("Unknown Model Type")
 
-        value = value * self._num_options
+        value = value * self.num_options
         return value
 
 ###############################################################################
 
     def delta(self,
               value_dt: Date,
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model):
         """ Calculate the analytical delta of a European vanilla option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
-        self._t_exp = t_exp
+        self.t_exp = t_exp
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
 
-            v = model._volatility
-            delta = bs_delta(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            delta = bs_delta(s0, t_exp, k, r, q, v, self.option_type_value)
 
         else:
             raise FinError("Unknown Model Type")
 
         return delta
 
 ###############################################################################
@@ -263,40 +263,40 @@
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model: Model):
         """ Calculate the analytical gamma of a European vanilla option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
 
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
 
-            v = model._volatility
-            gamma = bs_gamma(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            gamma = bs_gamma(s0, t_exp, k, r, q, v, self.option_type_value)
 
         else:
             raise FinError("Unknown Model Type")
 
         return gamma
 
 ###############################################################################
@@ -306,39 +306,39 @@
              stock_price: float,
              discount_curve: DiscountCurve,
              dividend_curve: DiscountCurve,
              model: Model):
         """ Calculate the analytical vega of a European vanilla option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
 
-            v = model._volatility
-            vega = bs_vega(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            vega = bs_vega(s0, t_exp, k, r, q, v, self.option_type_value)
 
         else:
             raise FinError("Unknown Model Type")
 
         return vega
 
 ###############################################################################
@@ -348,38 +348,38 @@
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model: Model):
         """ Calculate the analytical theta of a European vanilla option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
-            v = model._volatility
-            theta = bs_theta(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            theta = bs_theta(s0, t_exp, k, r, q, v, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
 
         return theta
 
 ###############################################################################
 
@@ -388,38 +388,38 @@
             stock_price: float,
             discount_curve: DiscountCurve,
             dividend_curve: DiscountCurve,
             model: Model):
         """ Calculate the analytical rho of a European vanilla option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
-            v = model._volatility
-            rho = bs_rho(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            rho = bs_rho(s0, t_exp, k, r, q, v, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
 
         return rho
 
 ###############################################################################
 
@@ -428,38 +428,38 @@
               stock_price: float,
               discount_curve: DiscountCurve,
               dividend_curve: DiscountCurve,
               model: Model):
         """ Calculate the analytical vanna of a European vanilla option. """
 
         if isinstance(value_dt, Date):
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t_exp = value_dt
 
         if np.any(stock_price <= 0.0):
             raise FinError("Stock price must be greater than zero.")
 
         if np.any(t_exp < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         s0 = stock_price
         t_exp = np.maximum(t_exp, 1e-10)
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
 
         if isinstance(model, BlackScholes):
-            v = model._volatility
-            vanna = bs_vanna(s0, t_exp, k, r, q, v, self._option_type_value)
+            v = model.volatility
+            vanna = bs_vanna(s0, t_exp, k, r, q, v, self.option_type_value)
         else:
             raise FinError("Unknown Model Type")
 
         return vanna
 
 ###############################################################################
 
@@ -468,31 +468,31 @@
                            stock_price: (float, list, np.ndarray),
                            discount_curve: DiscountCurve,
                            dividend_curve: DiscountCurve,
                            price):
         """ Calculate the Black-Scholes implied volatility of a European
         vanilla option. """
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
         if t_exp < 1.0 / 365.0:
             print("Expiry time is too close to zero.")
             return -999
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        k = self._strike_price
+        k = self.strike_price
         s0 = stock_price
 
         sigma = bs_implied_volatility(s0, t_exp, k, r, q, price,
-                                      self._option_type_value)
+                                      self.option_type_value)
 
         return sigma
 
 ###############################################################################
 
     def value_mc_numpy_only(self,
                             value_dt: Date,
@@ -500,28 +500,28 @@
                             discount_curve: DiscountCurve,
                             dividend_curve: DiscountCurve,
                             model: Model,
                             num_paths: int = 10000,
                             seed: int = 4242,
                             use_sobol: int = 0):
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        vol = model._volatility
+        vol = model.volatility
 
         v = _value_mc_numpy_only(stock_price,
                                  t_exp,
-                                 self._strike_price,
-                                 self._option_type.value,
+                                 self.strike_price,
+                                 self.option_type.value,
                                  r,
                                  q,
                                  vol,
                                  num_paths,
                                  seed,
                                  use_sobol)
 
@@ -535,28 +535,28 @@
                             discount_curve: DiscountCurve,
                             dividend_curve: DiscountCurve,
                             model: Model,
                             num_paths: int = 10000,
                             seed: int = 4242,
                             use_sobol: int = 0):
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        vol = model._volatility
+        vol = model.volatility
 
         v = _value_mc_numba_only(stock_price,
                                  t_exp,
-                                 self._strike_price,
-                                 self._option_type_value,
+                                 self.strike_price,
+                                 self.option_type_value,
                                  r,
                                  q,
                                  vol,
                                  num_paths,
                                  seed,
                                  use_sobol)
 
@@ -570,28 +570,28 @@
                                 discount_curve: DiscountCurve,
                                 dividend_curve: DiscountCurve,
                                 model: Model,
                                 num_paths: int = 10000,
                                 seed: int = 4242,
                                 use_sobol: int = 0):
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        vol = model._volatility
+        vol = model.volatility
 
         v = _value_mc_numba_parallel(stock_price,
                                      t_exp,
-                                     self._strike_price,
-                                     self._option_type_value,
+                                     self.strike_price,
+                                     self.option_type_value,
                                      r,
                                      q,
                                      vol,
                                      num_paths,
                                      seed,
                                      use_sobol)
 
@@ -607,28 +607,28 @@
                              discount_curve: DiscountCurve,
                              dividend_curve: DiscountCurve,
                              model: Model,
                              num_paths: int = 10000,
                              seed: int = 4242,
                              use_sobol: int = 0):
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        vol = model._volatility
+        vol = model.volatility
 
         v = _value_mc_numpy_numba(stock_price,
                                   t_exp,
-                                  self._strike_price,
-                                  self._option_type_value,
+                                  self.strike_price,
+                                  self.option_type_value,
                                   r,
                                   q,
                                   vol,
                                   num_paths,
                                   seed,
                                   use_sobol)
 
@@ -642,28 +642,28 @@
                                  discount_curve: DiscountCurve,
                                  dividend_curve: DiscountCurve,
                                  model: Model,
                                  num_paths: int = 10000,
                                  seed: int = 4242,
                                  use_sobol: int = 0):
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        vol = model._volatility
+        vol = model.volatility
 
         v = _value_mc_nonumba_nonumpy(stock_price,
                                       t_exp,
-                                      self._strike_price,
-                                      self._option_type.value,
+                                      self.strike_price,
+                                      self.option_type.value,
                                       r,
                                       q,
                                       vol,
                                       num_paths,
                                       seed,
                                       use_sobol)
 
@@ -679,45 +679,45 @@
                  model: Model,
                  num_paths: int = 10000,
                  seed: int = 4242,
                  use_sobol: int = 0):
         """ Value European style call or put option using Monte Carlo. This is
         mainly for educational purposes. Sobol numbers can be used. """
 
-        t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+        t_exp = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = discount_curve.df(self._expiry_dt)
+        df = discount_curve.df(self.expiry_dt)
         r = -np.log(df)/t_exp
 
-        dq = dividend_curve.df(self._expiry_dt)
+        dq = dividend_curve.df(self.expiry_dt)
         q = -np.log(dq)/t_exp
 
-        vol = model._volatility
+        vol = model.volatility
 
         v = _value_mc_numba_only(stock_price,
                                  t_exp,
-                                 self._strike_price,
-                                 self._option_type_value,
+                                 self.strike_price,
+                                 self.option_type_value,
                                  r,
                                  q,
                                  vol,
                                  num_paths,
                                  seed,
                                  use_sobol)
 
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE PRICE", self._strike_price)
-        s += label_to_string("OPTION TYPE VALUE", self._option_type)
-        s += label_to_string("NUMBER", self._num_options, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE VALUE", self.option_type)
+        s += label_to_string("NUMBER", self.num_options, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/equity/equity_variance_swap.py` & `financepy-0.360/financepy/products/equity/equity_variance_swap.py`

 * *Files 12% similar despite different names*

```diff
@@ -27,75 +27,75 @@
                  strike_variance: float,
                  notional: float = ONE_MILLION,
                  pay_strike_flag: bool = True):
         """ Create variance swap contract. """
 
         check_argument_types(self.__init__, locals())
 
-        if type(maturity_dt_or_tenor) == Date:
+        if isinstance(maturity_dt_or_tenor, Date):
             maturity_dt = maturity_dt_or_tenor
         else:
             maturity_dt = start_dt.add_tenor(maturity_dt_or_tenor)
 
         if start_dt >= maturity_dt:
             raise FinError("Start date after or same as maturity date")
 
-        self._start_dt = start_dt
-        self._maturity_dt = maturity_dt
-        self._strike_variance = strike_variance
-        self._notional = notional
-        self._pay_strike_flag = pay_strike_flag
+        self.start_dt = start_dt
+        self.maturity_dt = maturity_dt
+        self.strike_variance = strike_variance
+        self.notional = notional
+        self.pay_strike_flag = pay_strike_flag
 
         # Replication portfolio is stored
-        self._num_put_options = 0
-        self._num_call_options = 0
-        self._put_wts = []
-        self._put_strikes = []
-        self._call_wts = []
-        self._call_strikes = []
+        self.num_put_options = 0
+        self.num_call_options = 0
+        self.put_wts = []
+        self.put_strikes = []
+        self.call_wts = []
+        self.call_strikes = []
 
 ###############################################################################
 
     def value(self,
               value_dt,
-              realisedVar,
-              fair_strikeVar,
+              realised_var,
+              fair_strike_var,
               libor_curve):
         """ Calculate the value of the variance swap based on the realised
         volatility to the valuation date, the forward looking implied
         volatility to the maturity date using the libor discount curve. """
 
-        t1 = (value_dt - self._start_dt) / gDaysInYear
-        t2 = (self._maturity_dt - self._start_dt) / gDaysInYear
+        t1 = (value_dt - self.start_dt) / gDaysInYear
+        t2 = (self.maturity_dt - self.start_dt) / gDaysInYear
 
-        expectedVariance = t1 * realisedVar/t2
-        expectedVariance += (t2-t1) * fair_strikeVar / t2
+        expected_variance = t1 * realised_var/t2
+        expected_variance += (t2-t1) * fair_strike_var / t2
 
-        payoff = expectedVariance - self._strike_variance
+        payoff = expected_variance - self.strike_variance
 
-        df = libor_curve.df(self._maturity_dt)
-        v = payoff * self._notional * df
+        df = libor_curve.df(self.maturity_dt)
+        v = payoff * self.notional * df
         return v
 
 ###############################################################################
 
     def fair_strike_approx(self,
                            value_dt,
-                           fwdStockPrice,
+                           fwd_stock_price,
                            strikes,
                            volatilities):
         """ This is an approximation of the fair strike variance by Demeterfi
         et al. (1999) which assumes that sigma(K) = sigma(F) - b(K-F)/F where
         F is the forward stock price and sigma(F) is the ATM forward vol. """
 
-        f = fwdStockPrice
+        f = fwd_stock_price
 
         # TODO Linear interpolation - to be revisited
         atm_vol = np.interp(f, strikes, volatilities)
-        t_mat = (self._maturity_dt - value_dt)/gDaysInYear
+        t_mat = (self.maturity_dt - value_dt)/gDaysInYear
 
         """ Calculate the slope of the volatility curve by taking the end
         points in the volatilities and strikes to calculate the gradient."""
 
         dvol = volatilities[-1] - volatilities[0]
         dK = strikes[-1] - strikes[0]
         b = f * dvol / dK
@@ -115,21 +115,21 @@
                     discount_curve,
                     use_forward=True):
         """ Calculate the implied variance according to the volatility surface
         using a static replication methodology with a specially weighted
         portfolio of put and call options across a range of strikes using the
         approximate method set out by Demeterfi et al. 1999. """
 
-        self._num_put_options = num_put_options
-        self._num_call_options = num_call_options
+        self.num_put_options = num_put_options
+        self.num_call_options = num_call_options
 
         call_type = OptionTypes.EUROPEAN_CALL
         put_type = OptionTypes.EUROPEAN_PUT
 
-        t_mat = (self._maturity_dt - value_dt)/gDaysInYear
+        t_mat = (self.maturity_dt - value_dt)/gDaysInYear
 
         df = discount_curve._df(t_mat)
         r = - np.log(df)/t_mat
 
         dq = dividend_curve._df(t_mat)
         q = - np.log(dq)/t_mat
 
@@ -143,84 +143,84 @@
         else:
             sstar = stock_price
 
         """ Replication argument from Demeterfi, Derman, Kamal and Zhou from
         Goldman Sachs Research notes March 1999. See Appendix A. This aim is
         to use calls and puts to approximate the payoff of a log contract """
 
-        minStrike = sstar - (num_put_options+1) * strike_spacing
+        min_strike = sstar - (num_put_options+1) * strike_spacing
 
-        self._put_wts = []
-        self._put_strikes = []
-        self._call_wts = []
-        self._call_strikes = []
+        self.put_wts = []
+        self.put_strikes = []
+        self.call_wts = []
+        self.call_strikes = []
 
         # if the lower strike is < 0 we go to as low as the strike spacing
-        if minStrike < strike_spacing:
+        if min_strike < strike_spacing:
             k = sstar
             klist = [sstar]
             while k >= strike_spacing:
                 k -= strike_spacing
                 klist.append(k)
             put_k = np.array(klist)
-            self._num_put_options = len(put_k) - 1
+            self.num_put_options = len(put_k) - 1
         else:
-            put_k = np.linspace(sstar, minStrike, num_put_options+2)
+            put_k = np.linspace(sstar, min_strike, num_put_options+2)
 
-        self._put_strikes = put_k
+        self.put_strikes = put_k
 
         max_strike = sstar + (num_call_options+1) * strike_spacing
-        callK = np.linspace(sstar, max_strike, num_call_options+2)
+        call_k = np.linspace(sstar, max_strike, num_call_options+2)
 
-        self._call_strikes = callK
+        self.call_strikes = call_k
 
-        optionTotal = 2.0*(r*t_mat - (s0*g/sstar-1.0) - np.log(sstar/s0))/t_mat
+        option_total = 2.0*(r*t_mat - (s0*g/sstar-1.0) - np.log(sstar/s0))/t_mat
 
-        self._call_wts = np.zeros(num_call_options)
-        self._put_wts = np.zeros(num_put_options)
+        self.call_wts = np.zeros(num_call_options)
+        self.put_wts = np.zeros(num_put_options)
 
         def f(x): return (2.0/t_mat)*((x-sstar)/sstar-np.log(x/sstar))
 
         sum_wts = 0.0
-        for n in range(0, self._num_put_options):
+        for n in range(0, self.num_put_options):
             kp = put_k[n+1]
             k = put_k[n]
-            self._put_wts[n] = (f(kp)-f(k))/(k-kp) - sum_wts
-            sum_wts += self._put_wts[n]
+            self.put_wts[n] = (f(kp)-f(k))/(k-kp) - sum_wts
+            sum_wts += self.put_wts[n]
 
         sum_wts = 0.0
-        for n in range(0, self._num_call_options):
-            kp = callK[n+1]
-            k = callK[n]
-            self._call_wts[n] = (f(kp)-f(k))/(kp-k) - sum_wts
-            sum_wts += self._call_wts[n]
+        for n in range(0, self.num_call_options):
+            kp = call_k[n+1]
+            k = call_k[n]
+            self.call_wts[n] = (f(kp)-f(k))/(kp-k) - sum_wts
+            sum_wts += self.call_wts[n]
 
         pi_put = 0.0
         for n in range(0, num_put_options):
             k = put_k[n]
             vol = volatility_curve.volatility(k)
-            opt = EquityVanillaOption(self._maturity_dt, k, put_type)
+            opt = EquityVanillaOption(self.maturity_dt, k, put_type)
             model = BlackScholes(vol)
             v = opt.value(value_dt, s0, discount_curve,
                           dividend_curve, model)
-            pi_put += v * self._put_wts[n]
+            pi_put += v * self.put_wts[n]
 
         pi_call = 0.0
         for n in range(0, num_call_options):
-            k = callK[n]
+            k = call_k[n]
             vol = volatility_curve.volatility(k)
-            opt = EquityVanillaOption(self._maturity_dt, k, call_type)
+            opt = EquityVanillaOption(self.maturity_dt, k, call_type)
             model = BlackScholes(vol)
             v = opt.value(value_dt, s0, discount_curve,
                           dividend_curve, model)
-            pi_call += v * self._call_wts[n]
+            pi_call += v * self.call_wts[n]
 
         pi = pi_call + pi_put
-        optionTotal += g * pi
-        var = optionTotal
+        option_total += g * pi
+        var = option_total
 
         return var
 
 ###############################################################################
 
     def realised_variance(self, closePrices, use_logs=True):
         """ Calculate the realised variance according to market standard
@@ -228,58 +228,58 @@
 
         num_observations = len(closePrices)
 
         for i in range(0, num_observations):
             if closePrices[i] <= 0.0:
                 raise FinError("Stock prices must be greater than zero")
 
-        cumX2 = 0.0
+        cum_x2 = 0.0
 
         if use_logs is True:
             for i in range(1, num_observations):
                 x = np.log(closePrices[i]/closePrices[i-1])
-                cumX2 += x*x
+                cum_x2 += x*x
         else:
             for i in range(1, num_observations):
                 x = (closePrices[i]-closePrices[i-1])/closePrices[i-1]
-                cumX2 += x*x
+                cum_x2 += x*x
 
-        var = cumX2 * 252.0 / num_observations
+        var = cum_x2 * 252.0 / num_observations
         return var
 
 ###############################################################################
 
     def print_weights(self):
         """ Print the list of puts and calls used to replicate the static
         replication component of the variance swap hedge. """
 
-        if self._num_put_options == 0 and self._num_call_options == 0:
+        if self.num_put_options == 0 and self.num_call_options == 0:
             print("No call or put options generated.")
             return
 
         print("TYPE", "STRIKE", "WEIGHT")
-        for n in range(self._num_put_options-1, -1, -1):
-            k = self._put_strikes[n]
-            wt = self._put_wts[n]*self._notional
+        for n in range(self.num_put_options-1, -1, -1):
+            k = self.put_strikes[n]
+            wt = self.put_wts[n]*self.notional
             print("PUT %7.2f %10.3f" % (k, wt))
 
-        for n in range(0, self._num_call_options):
-            k = self._call_strikes[n]
-            wt = self._call_wts[n]*self._notional
+        for n in range(0, self.num_call_options):
+            k = self.call_strikes[n]
+            wt = self.call_wts[n]*self.notional
             print("CALL %7.2f %10.3f" % (k, wt))
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START DATE", self._start_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("STRIKE VARIANCE", self._strike_variance)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("PAY STRIKE FLAG", self._pay_strike_flag, "")
+        s += label_to_string("START DATE", self.start_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("STRIKE VARIANCE", self.strike_variance)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("PAY STRIKE FLAG", self.pay_strike_flag, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/fx/fx_barrier_option.py` & `financepy-0.360/financepy/products/fx/fx_barrier_option.py`

 * *Files 12% similar despite different names*

```diff
@@ -44,215 +44,221 @@
                  notional: float,
                  notional_currency: str):
         """ Create FX Barrier option product. This is an option that cancels if
         the FX rate crosses a barrier during the life of the option. """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._strike_fx_rate = float(strike_fx_rate)
-        self._currency_pair = currency_pair
-        self._barrier_level = float(barrier_level)
-        self._num_obs_per_year = int(num_obs_per_year)
-        self._option_type = option_type
-        self._notional = notional
-        self._notional_currency = notional_currency
+        self.expiry_dt = expiry_dt
+        self.strike_fx_rate = float(strike_fx_rate)
+        self.currency_pair = currency_pair
+        self.barrier_level = float(barrier_level)
+        self.num_obs_per_year = int(num_obs_per_year)
+        self.option_type = option_type
+        self.notional = notional
+        self.notional_currency = notional_currency
 
     ##########################################################################
 
     def value(self,
               value_dt,
               spot_fx_rate,
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ Value FX Barrier Option using Black-Scholes model with closed-form
         analytical models. """
 
         # This prices the option using the formulae given in the paper
         # by Clewlow, Llanos and Strickland December 1994 which can be found at
         # https://warwick.ac.uk/fac/soc/wbs/subjects/finance/research/wpaperseries/1994/94-54.pdf
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as option value date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
                 "Foreign Curve valuation date not same as option value date")
 
-        K = self._strike_fx_rate
-        S0 = spot_fx_rate
-        h = self._barrier_level
-
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        lnS0k = log(float(S0) / K)
-        sqrtT = sqrt(t)
+        K = self.strike_fx_rate
+        s0 = spot_fx_rate
+        h = self.barrier_level
+
+        t = (self.expiry_dt - value_dt) / gDaysInYear
+        ln_s0_k = log(float(s0) / K)
+        sqrt_t = sqrt(t)
 
-        dq = for_discount_curve._df(t)
-        df = dom_discount_curve._df(t)
+        dq = foreign_curve._df(t)
+        df = domestic_curve._df(t)
         r_d = -log(df) / t
         rf = -log(dq) / t
 
-        volatility = model._volatility
-        sigmaRootT = volatility * sqrtT
+        volatility = model.volatility
+        sigma_root_t = volatility * sqrt_t
         v2 = volatility * volatility
         mu = r_d - rf
-        d1 = (lnS0k + (mu + v2 / 2.0) * t) / sigmaRootT
-        d2 = (lnS0k + (mu - v2 / 2.0) * t) / sigmaRootT
+        d1 = (ln_s0_k + (mu + v2 / 2.0) * t) / sigma_root_t
+        d2 = (ln_s0_k + (mu - v2 / 2.0) * t) / sigma_root_t
 
-        c = S0 * dq * N(d1) - K * df * N(d2)
-        p = K * df * N(-d2) - S0 * dq * N(-d1)
+        c = s0 * dq * N(d1) - K * df * N(d2)
+        p = K * df * N(-d2) - s0 * dq * N(-d1)
         #        print("CALL:",c,"PUT:",p)
 
-        if self._option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL and S0 <= h:
+        if self.option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL and s0 <= h:
             return 0.0
-        elif self._option_type == FinFXBarrierTypes.UP_AND_OUT_CALL and S0 >= h:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_OUT_CALL and s0 >= h:
             return 0.0
-        elif self._option_type == FinFXBarrierTypes.UP_AND_OUT_PUT and S0 >= h:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_OUT_PUT and s0 >= h:
             return 0.0
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT and S0 <= h:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT and s0 <= h:
             return 0.0
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL and S0 <= h:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL and s0 <= h:
             return c
-        elif self._option_type == FinFXBarrierTypes.UP_AND_IN_CALL and S0 >= h:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_IN_CALL and s0 >= h:
             return c
-        elif self._option_type == FinFXBarrierTypes.UP_AND_IN_PUT and S0 >= h:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_IN_PUT and s0 >= h:
             return p
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT and S0 <= h:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT and s0 <= h:
             return p
 
-        num_observations = t * self._num_obs_per_year
+        num_observations = t * self.num_obs_per_year
 
         # Correction by Broadie, Glasserman and Kou, Mathematical Finance, 1997
         # Adjusts the barrier for discrete and not continuous observations
         h_adj = h
-        if self._option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL:
+        if self.option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL:
             h_adj = h * exp(-0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL:
             h_adj = h * exp(-0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.UP_AND_IN_CALL:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_IN_CALL:
             h_adj = h * exp(0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.UP_AND_OUT_CALL:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_OUT_CALL:
             h_adj = h * exp(0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.UP_AND_IN_PUT:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_IN_PUT:
             h_adj = h * exp(0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.UP_AND_OUT_PUT:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_OUT_PUT:
             h_adj = h * exp(0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT:
             h_adj = h * exp(-0.5826 * volatility * sqrt(t / num_observations))
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT:
             h_adj = h * exp(-0.5826 * volatility * sqrt(t / num_observations))
         else:
             raise FinError("Unknown barrier option type." +
-                           str(self._option_type))
+                           str(self.option_type))
 
         h = h_adj
 
         if abs(volatility) < 1e-5:
             volatility = 1e-5
 
         ll = (mu + v2 / 2.0) / v2
-        y = log(h * h / (S0 * K)) / sigmaRootT + ll * sigmaRootT
-        x1 = log(S0 / h) / sigmaRootT + ll * sigmaRootT
-        y1 = log(h / S0) / sigmaRootT + ll * sigmaRootT
-        hOverS = h / S0
+        y = log(h * h / (s0 * K)) / sigma_root_t + ll * sigma_root_t
+        x1 = log(s0 / h) / sigma_root_t + ll * sigma_root_t
+        y1 = log(h / s0) / sigma_root_t + ll * sigma_root_t
+        h_over_s = h / s0
 
-        if self._option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL:
+        if self.option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL:
             if h >= K:
-                c_do = S0 * dq * N(x1) - K * df * N(x1 - sigmaRootT) \
-                    - S0 * dq * pow(hOverS, 2.0 * ll) * N(y1) \
-                    + K * df * pow(hOverS, 2.0 * ll - 2.0) * N(y1 - sigmaRootT)
+                c_do = s0 * dq * N(x1) - K * df * N(x1 - sigma_root_t) \
+                    - s0 * dq * pow(h_over_s, 2.0 * ll) * N(y1) \
+                    + K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(y1 - sigma_root_t)
                 price = c_do
             else:
-                c_di = S0 * dq * pow(hOverS, 2.0 * ll) * N(y) \
-                    - K * df * pow(hOverS, 2.0 * ll - 2.0) * N(y - sigmaRootT)
+                c_di = s0 * dq * pow(h_over_s, 2.0 * ll) * N(y) \
+                    - K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(y - sigma_root_t)
                 price = c - c_di
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL:
             if h <= K:
-                c_di = S0 * dq * pow(hOverS, 2.0 * ll) * N(y) \
-                    - K * df * pow(hOverS, 2.0 * ll - 2.0) * N(y - sigmaRootT)
+                c_di = s0 * dq * pow(h_over_s, 2.0 * ll) * N(y) \
+                    - K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(y - sigma_root_t)
                 price = c_di
             else:
-                c_do = S0 * dq * N(x1) \
-                    - K * df * N(x1 - sigmaRootT) \
-                    - S0 * dq * pow(hOverS, 2.0 * ll) * N(y1) \
-                    + K * df * pow(hOverS, 2.0 * ll - 2.0) * N(y1 - sigmaRootT)
+                c_do = s0 * dq * N(x1) \
+                    - K * df * N(x1 - sigma_root_t) \
+                    - s0 * dq * pow(h_over_s, 2.0 * ll) * N(y1) \
+                    + K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(y1 - sigma_root_t)
                 price = c - c_do
-        elif self._option_type == FinFXBarrierTypes.UP_AND_IN_CALL:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_IN_CALL:
             if h >= K:
-                c_ui = S0 * dq * N(x1) - K * df * N(x1 - sigmaRootT) \
-                    - S0 * dq * pow(hOverS, 2.0 * ll) * (N(-y) - N(-y1)) \
-                    + K * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                    (N(-y + sigmaRootT) - N(-y1 + sigmaRootT))
+                c_ui = s0 * dq * N(x1) - K * df * N(x1 - sigma_root_t) \
+                    - s0 * dq * pow(h_over_s, 2.0 * ll) * (N(-y) - N(-y1)) \
+                    + K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    (N(-y + sigma_root_t) - N(-y1 + sigma_root_t))
                 price = c_ui
             else:
                 price = c
-        elif self._option_type == FinFXBarrierTypes.UP_AND_OUT_CALL:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_OUT_CALL:
             if h > K:
-                c_ui = S0 * dq * N(x1) - K * df * N(x1 - sigmaRootT) \
-                    - S0 * dq * pow(hOverS, 2.0 * ll) * (N(-y) - N(-y1)) \
-                    + K * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                    (N(-y + sigmaRootT) - N(-y1 + sigmaRootT))
+                c_ui = s0 * dq * N(x1) - K * df * N(x1 - sigma_root_t) \
+                    - s0 * dq * pow(h_over_s, 2.0 * ll) * (N(-y) - N(-y1)) \
+                    + K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    (N(-y + sigma_root_t) - N(-y1 + sigma_root_t))
                 price = c - c_ui
             else:
                 price = 0.0
-        elif self._option_type == FinFXBarrierTypes.UP_AND_IN_PUT:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_IN_PUT:
             if h > K:
-                p_ui = -S0 * dq * pow(hOverS, 2.0 * ll) * N(-y) \
-                    + K * df * pow(hOverS, 2.0 * ll - 2.0) * N(-y + sigmaRootT)
+                p_ui = -s0 * dq * pow(h_over_s, 2.0 * ll) * N(-y) \
+                    + K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(-y + sigma_root_t)
                 price = p_ui
             else:
-                p_uo = -S0 * dq * N(-x1) \
-                    + K * df * N(-x1 + sigmaRootT) \
-                    + S0 * dq * pow(hOverS, 2.0 * ll) * N(-y1) \
-                       - K * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                    N(-y1 + sigmaRootT)
+                p_uo = -s0 * dq * N(-x1) \
+                    + K * df * N(-x1 + sigma_root_t) \
+                    + s0 * dq * pow(h_over_s, 2.0 * ll) * N(-y1) \
+                       - K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(-y1 + sigma_root_t)
                 price = p - p_uo
-        elif self._option_type == FinFXBarrierTypes.UP_AND_OUT_PUT:
+        elif self.option_type == FinFXBarrierTypes.UP_AND_OUT_PUT:
             if h >= K:
-                p_ui = -S0 * dq * pow(hOverS, 2.0 * ll) * N(-y) \
-                    + K * df * pow(hOverS, 2.0 * ll - 2.0) * N(-y + sigmaRootT)
+                p_ui = -s0 * dq * pow(h_over_s, 2.0 * ll) * N(-y) \
+                    + K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(-y + sigma_root_t)
                 price = p - p_ui
             else:
-                p_uo = -S0 * dq * N(-x1) \
-                    + K * df * N(-x1 + sigmaRootT) \
-                    + S0 * dq * pow(hOverS, 2.0 * ll) * N(-y1) \
-                       - K * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                    N(-y1 + sigmaRootT)
+                p_uo = -s0 * dq * N(-x1) \
+                    + K * df * N(-x1 + sigma_root_t) \
+                    + s0 * dq * pow(h_over_s, 2.0 * ll) * N(-y1) \
+                       - K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    N(-y1 + sigma_root_t)
                 price = p_uo
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT:
             if h >= K:
                 price = 0.0
             else:
-                p_di = -S0 * dq * N(-x1) \
-                    + K * df * N(-x1 + sigmaRootT) \
-                    + S0 * dq * pow(hOverS, 2.0 * ll) * (N(y) - N(y1)) \
-                       - K * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                    (N(y - sigmaRootT) - N(y1 - sigmaRootT))
+                p_di = -s0 * dq * N(-x1) \
+                    + K * df * N(-x1 + sigma_root_t) \
+                    + s0 * dq * pow(h_over_s, 2.0 * ll) * (N(y) - N(y1)) \
+                       - K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    (N(y - sigma_root_t) - N(y1 - sigma_root_t))
                 price = p - p_di
-        elif self._option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT:
+        elif self.option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT:
             if h >= K:
                 price = p
             else:
-                p_di = -S0 * dq * N(-x1) \
-                    + K * df * N(-x1 + sigmaRootT) \
-                    + S0 * dq * pow(hOverS, 2.0 * ll) * (N(y) - N(y1)) \
-                       - K * df * pow(hOverS, 2.0 * ll - 2.0) * \
-                    (N(y - sigmaRootT) - N(y1 - sigmaRootT))
+                p_di = -s0 * dq * N(-x1) \
+                    + K * df * N(-x1 + sigma_root_t) \
+                    + s0 * dq * pow(h_over_s, 2.0 * ll) * (N(y) - N(y1)) \
+                       - K * df * pow(h_over_s, 2.0 * ll - 2.0) * \
+                    (N(y - sigma_root_t) - N(y1 - sigma_root_t))
                 price = p_di
         else:
             raise FinError("Unknown barrier option type." +
-                           str(self._option_type))
+                           str(self.option_type))
 
         return price
 
     ###########################################################################
 
     def value_mc(self,
                  value_dt,
@@ -261,142 +267,146 @@
                  process_type,
                  model_params,
                  num_ann_steps=552,
                  num_paths=5000,
                  seed=4242):
         """ Value the FX Barrier Option using Monte Carlo. """
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
         num_time_steps = int(t * num_ann_steps)
-        K = self._strike_fx_rate
-        B = self._barrier_level
-        S0 = spot_fx_rate
-        option_type = self._option_type
+        K = self.strike_fx_rate
+        B = self.barrier_level
+        s0 = spot_fx_rate
+        option_type = self.option_type
 
         process = FinProcessSimulator()
 
         r_d = dom_interest_rate
 
         #######################################################################
 
-        if option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL and S0 <= B:
+        if option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL and s0 <= B:
             return 0.0
-        elif option_type == FinFXBarrierTypes.UP_AND_OUT_CALL and S0 >= B:
+        elif option_type == FinFXBarrierTypes.UP_AND_OUT_CALL and s0 >= B:
             return 0.0
-        elif option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT and S0 <= B:
+        elif option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT and s0 <= B:
             return 0.0
-        elif option_type == FinFXBarrierTypes.UP_AND_OUT_PUT and S0 >= B:
+        elif option_type == FinFXBarrierTypes.UP_AND_OUT_PUT and s0 >= B:
             return 0.0
 
         #######################################################################
 
         simple_call = False
         simple_put = False
 
-        if option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL and S0 <= B:
+        if option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL and s0 <= B:
             simple_call = True
-        elif option_type == FinFXBarrierTypes.UP_AND_IN_CALL and S0 >= B:
+        elif option_type == FinFXBarrierTypes.UP_AND_IN_CALL and s0 >= B:
             simple_call = True
-        elif option_type == FinFXBarrierTypes.UP_AND_IN_PUT and S0 >= B:
+        elif option_type == FinFXBarrierTypes.UP_AND_IN_PUT and s0 >= B:
             simple_put = True
-        elif option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT and S0 <= B:
+        elif option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT and s0 <= B:
             simple_put = True
 
         if simple_put or simple_call:
             s_all = process.get_process(
                 process_type, t, model_params, 1, num_paths, seed)
 
         if simple_call:
-            sT = s_all[:, -1]
-            c = (np.maximum(sT - K, 0.0)).mean()
+            s_t = s_all[:, -1]
+            c = (np.maximum(s_t - K, 0.0)).mean()
             c = c * exp(-r_d * t)
             return c
 
         if simple_put:
-            sT = s_all[:, -1]
-            p = (np.maximum(K - sT, 0.0)).mean()
+            s_t = s_all[:, -1]
+            p = (np.maximum(K - s_t, 0.0)).mean()
             p = p * exp(-r_d * t)
             return p
 
         # Get full set of paths
         s_all = process.get_process(process_type,
-                                   t,
-                                   model_params,
-                                   num_time_steps,
-                                   num_paths,
-                                   seed)
+                                    t,
+                                    model_params,
+                                    num_time_steps,
+                                    num_paths,
+                                    seed)
 
         (num_paths, num_time_steps) = s_all.shape
 
         if option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL or \
                 option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL or \
                 option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT or \
                 option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT:
 
-            barrierCrossedFromAbove = [False] * num_paths
+            barrier_crossed_from_above = [False] * num_paths
 
             for p in range(0, num_paths):
-                barrierCrossedFromAbove[p] = np.any(s_all[p] <= B)
+                barrier_crossed_from_above[p] = np.any(s_all[p] <= B)
 
         if option_type == FinFXBarrierTypes.UP_AND_IN_CALL or \
                 option_type == FinFXBarrierTypes.UP_AND_OUT_CALL or \
                 option_type == FinFXBarrierTypes.UP_AND_IN_PUT or \
                 option_type == FinFXBarrierTypes.UP_AND_OUT_PUT:
 
-            barrierCrossedFromBelow = [False] * num_paths
+            barrier_crossed_from_below = [False] * num_paths
             for p in range(0, num_paths):
-                barrierCrossedFromBelow[p] = np.any(s_all[p] >= B)
+                barrier_crossed_from_below[p] = np.any(s_all[p] >= B)
 
         payoff = np.zeros(num_paths)
         ones = np.ones(num_paths)
 
         if option_type == FinFXBarrierTypes.DOWN_AND_OUT_CALL:
             payoff = np.maximum(s_all[:, -1] - K, 0.0) * \
-                (ones - barrierCrossedFromAbove)
+                (ones - barrier_crossed_from_above)
         elif option_type == FinFXBarrierTypes.DOWN_AND_IN_CALL:
-            payoff = np.maximum(s_all[:, -1] - K, 0.0) * barrierCrossedFromAbove
+            payoff = np.maximum(s_all[:, -1] - K, 0.0) * \
+                barrier_crossed_from_above
         elif option_type == FinFXBarrierTypes.UP_AND_IN_CALL:
-            payoff = np.maximum(s_all[:, -1] - K, 0.0) * barrierCrossedFromBelow
+            payoff = np.maximum(s_all[:, -1] - K, 0.0) * \
+                barrier_crossed_from_below
         elif option_type == FinFXBarrierTypes.UP_AND_OUT_CALL:
             payoff = np.maximum(s_all[:, -1] - K, 0.0) * \
-                (ones - barrierCrossedFromBelow)
+                (ones - barrier_crossed_from_below)
         elif option_type == FinFXBarrierTypes.UP_AND_IN_PUT:
-            payoff = np.maximum(K - s_all[:, -1], 0.0) * barrierCrossedFromBelow
+            payoff = np.maximum(
+                K - s_all[:, -1], 0.0) * barrier_crossed_from_below
         elif option_type == FinFXBarrierTypes.UP_AND_OUT_PUT:
             payoff = np.maximum(K - s_all[:, -1], 0.0) * \
-                (ones - barrierCrossedFromBelow)
+                (ones - barrier_crossed_from_below)
         elif option_type == FinFXBarrierTypes.DOWN_AND_OUT_PUT:
             payoff = np.maximum(K - s_all[:, -1], 0.0) * \
-                (ones - barrierCrossedFromAbove)
+                (ones - barrier_crossed_from_above)
         elif option_type == FinFXBarrierTypes.DOWN_AND_IN_PUT:
-            payoff = np.maximum(K - s_all[:, -1], 0.0) * barrierCrossedFromAbove
+            payoff = np.maximum(
+                K - s_all[:, -1], 0.0) * barrier_crossed_from_above
         else:
             raise FinError("Unknown barrier option type." +
-                           str(self._option_type))
+                           str(self.option_type))
 
         v = payoff.mean() * exp(-r_d * t)
 
         return v
 
     ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE FX RATE", self._strike_fx_rate)
-        s += label_to_string("CURRENCY PAIR", self._currency_pair)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("BARRIER LEVEL", self._barrier_level)
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE FX RATE", self.strike_fx_rate)
+        s += label_to_string("CURRENCY PAIR", self.currency_pair)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("BARRIER LEVEL", self.barrier_level)
         s += label_to_string("NUM OBSERVATIONS",
-                             self._num_obs_per_year)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("NOTIONAL CURRENCY", self._notional_currency, "")
+                             self.num_obs_per_year)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("NOTIONAL CURRENCY", self.notional_currency, "")
         return s
 
     ###############################################################################
 
     def _print(self):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a lis_t of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_digital_option.py` & `financepy-0.360/financepy/products/fx/fx_digital_option.py`

 * *Files 20% similar despite different names*

```diff
@@ -43,116 +43,115 @@
 
         if delivery_dt < expiry_dt:
             raise FinError("Delivery date must be on or after expiry date.")
 
         if len(currency_pair) != 6:
             raise FinError("Currency pair must be 6 characters.")
 
-        self._expiry_dt = expiry_dt
-        self._delivery_dt = delivery_dt
+        self.expiry_dt = expiry_dt
+        self.delivery_dt = delivery_dt
 
         if np.any(strike_fx_rate < 0.0):
             raise FinError("Negative strike.")
 
-        self._strike_fx_rate = strike_fx_rate
+        self.strike_fx_rate = strike_fx_rate
 
-        self._currency_pair = currency_pair
-        self._forName = self._currency_pair[0:3]
-        self._domName = self._currency_pair[3:6]
+        self.currency_pair = currency_pair
+        self.for_name = self.currency_pair[0:3]
+        self.dom_name = self.currency_pair[3:6]
 
-        if prem_currency != self._domName and prem_currency != self._forName:
+        if prem_currency != self.dom_name and prem_currency != self.for_name:
             raise FinError("Notional currency not in currency pair.")
 
-        self._prem_currency = prem_currency
+        self.prem_currency = prem_currency
 
-        self._notional = notional
+        self.notional = notional
 
         if option_type != OptionTypes.DIGITAL_CALL and\
            option_type != OptionTypes.DIGITAL_PUT:
             raise FinError("Unknown Digital Option Type:" + option_type)
 
-        self._option_type = option_type
-        self._spot_days = spot_days
+        self.option_type = option_type
+        self.spot_days = spot_days
 
 ###############################################################################
 
     def value(self,
               value_dt,
               spot_fx_rate,  # 1 unit of foreign in domestic
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ Valuation of a digital option using Black-Scholes model. This
         allows for 4 cases - first upper barriers that when crossed pay out
         cash (calls) and lower barriers than when crossed from above cause a
         cash payout (puts) PLUS the fact that the cash payment can be in
         domestic or foreign currency. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as valuation date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
                 "Foreign Curve valuation date not same as valuation date")
 
         if isinstance(value_dt, Date):
-            spot_dt = value_dt.add_weekdays(self._spot_days)
-            tdel = (self._delivery_dt - spot_dt) / gDaysInYear
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            spot_dt = value_dt.add_weekdays(self.spot_days)
+            t_del = (self.delivery_dt - spot_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
-            tdel = value_dt
-            t_exp = tdel
+            t_del = value_dt
+            t_exp = t_del
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("spot_fx_rate must be greater than zero.")
 
-        if np.any(tdel < 0.0):
+        if np.any(t_del < 0.0):
             raise FinError("Option time to maturity is less than zero.")
 
-        tdel = np.maximum(tdel, 1e-10)
+        t_del = np.maximum(t_del, 1e-10)
 
-        # TODO RESOLVE TDEL versus TEXP
-        dom_df = dom_discount_curve._df(tdel)
-        for_df = for_discount_curve._df(tdel)
+        # TODO RESOLVE t_del versus TEXP
+        dom_df = domestic_curve._df(t_del)
+        for_df = foreign_curve._df(t_del)
+        r_d = -np.log(dom_df) / t_del
+        r_f = -np.log(for_df) / t_del
 
-        r_d = -np.log(dom_df) / tdel
-        rf = -np.log(for_df) / tdel
+        s0 = spot_fx_rate
+        K = self.strike_fx_rate
 
-        S0 = spot_fx_rate
-        K = self._strike_fx_rate
+        if isinstance(model, BlackScholes):
 
-        if type(model) == BlackScholes:
-
-            volatility = model._volatility
-            lnS0k = np.log(S0 / K)
+            volatility = model.volatility
+            ln_s0_k = np.log(s0 / K)
             den = volatility * np.sqrt(t_exp)
             v2 = volatility * volatility
-            mu = r_d - rf
-            d2 = (lnS0k + (mu - v2 / 2.0) * tdel) / den
+            mu = r_d - r_f
+            d2 = (ln_s0_k + (mu - v2 / 2.0) * t_del) / den
 
-            if self._option_type == OptionTypes.DIGITAL_CALL and \
-                    self._forName == self._prem_currency:
-                v = S0 * np.exp(-rf * tdel) * n_vect(d2)
-            elif self._option_type == OptionTypes.DIGITAL_PUT and \
-                    self._forName == self._prem_currency:
-                v = S0 * np.exp(-rf * tdel) * n_vect(-d2)
-            elif self._option_type == OptionTypes.DIGITAL_CALL and \
-                    self._domName == self._prem_currency:
-                v = np.exp(-r_d * tdel) * n_vect(d2)
-            elif self._option_type == OptionTypes.DIGITAL_PUT and \
-                    self._domName == self._prem_currency:
-                v = np.exp(-r_d * tdel) * n_vect(-d2)
+            if self.option_type == OptionTypes.DIGITAL_CALL and \
+                    self.for_name == self.prem_currency:
+                v = s0 * np.exp(-rf * t_del) * n_vect(d2)
+            elif self.option_type == OptionTypes.DIGITAL_PUT and \
+                    self.for_name == self.prem_currency:
+                v = s0 * np.exp(-rf * t_del) * n_vect(-d2)
+            elif self.option_type == OptionTypes.DIGITAL_CALL and \
+                    self.dom_name == self.prem_currency:
+                v = np.exp(-r_d * t_del) * n_vect(d2)
+            elif self.option_type == OptionTypes.DIGITAL_PUT and \
+                    self.dom_name == self.prem_currency:
+                v = np.exp(-r_d * t_del) * n_vect(-d2)
             else:
                 raise FinError("Unknown option type")
 
-            v = v * self._notional
+            v = v * self.notional
 
         return v
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_double_digital_option.py` & `financepy-0.360/financepy/products/fx/fx_double_digital_option.py`

 * *Files 11% similar despite different names*

```diff
@@ -39,114 +39,114 @@
         check_argument_types(self.__init__, locals())
 
         delivery_dt = expiry_dt.add_weekdays(spot_days)
 
         if delivery_dt < expiry_dt:
             raise FinError("Delivery date must be on or after expiry date.")
 
-        self._expiry_dt = expiry_dt
-        self._delivery_dt = delivery_dt
+        self.expiry_dt = expiry_dt
+        self.delivery_dt = delivery_dt
 
         if np.any(upper_strike < 0.0):
             raise FinError("Negative upper strike.")
 
         if np.any(lower_strike < 0.0):
             raise FinError("Negative lower strike.")
 
-        self._upper_strike = upper_strike
-        self._lower_strike = lower_strike
+        self.upper_strike = upper_strike
+        self.lower_strike = lower_strike
 
         if len(currency_pair) != 6:
             raise FinError("Currency pair must be 6 characters.")
 
-        self._currency_pair = currency_pair
-        self._forName = self._currency_pair[0:3]
-        self._domName = self._currency_pair[3:6]
+        self.currency_pair = currency_pair
+        self.for_name = self.currency_pair[0:3]
+        self.dom_name = self.currency_pair[3:6]
 
-        if prem_currency != self._domName and prem_currency != self._forName:
+        if prem_currency != self.dom_name and prem_currency != self.for_name:
             raise FinError("Notional currency not in currency pair.")
 
-        self._prem_currency = prem_currency
+        self.prem_currency = prem_currency
 
-        self._notional = notional
+        self.notional = notional
 
-        self._spot_days = spot_days
+        self.spot_days = spot_days
 
 ###############################################################################
 
     def value(self,
               value_dt,
               spot_fx_rate,  # 1 unit of foreign in domestic
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ Valuation of a double digital option using Black-Scholes model.
         The option pays out the notional in the premium currency if the
         fx rate is between the upper and lower strike at maturity. The
         valuation is equivalent to the valuation of the difference of
         the value of two digital puts, one with the upper and the other
         with the lower strike """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as valuation date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
                 "Foreign Curve valuation date not same as valuation date")
 
         if isinstance(value_dt, Date):
-            spot_dt = value_dt.add_weekdays(self._spot_days)
-            tdel = (self._delivery_dt - spot_dt) / gDaysInYear
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            spot_dt = value_dt.add_weekdays(self.spot_days)
+            t_del = (self.delivery_dt - spot_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
-            tdel = value_dt
-            t_exp = tdel
+            t_del = value_dt
+            t_exp = t_del
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("spot_fx_rate must be greater than zero.")
 
-        if np.any(tdel < 0.0):
+        if np.any(t_del < 0.0):
             raise FinError("Option time to maturity is less than zero.")
 
-        tdel = np.maximum(tdel, 1e-10)
+        t_del = np.maximum(t_del, 1e-10)
 
-        # TODO RESOLVE TDEL versus TEXP
-        dom_df = dom_discount_curve._df(tdel)
-        for_df = for_discount_curve._df(tdel)
+        # TODO RESOLVE t_del versus TEXP
+        dom_df = domestic_curve._df(t_del)
+        for_df = foreign_curve._df(t_del)
 
-        r_d = -np.log(dom_df) / tdel
-        r_f = -np.log(for_df) / tdel
+        r_d = -np.log(dom_df) / t_del
+        r_f = -np.log(for_df) / t_del
 
-        S0 = spot_fx_rate
-        K1 = self._lower_strike
-        K2 = self._upper_strike
+        s0 = spot_fx_rate
+        K1 = self.lower_strike
+        K2 = self.upper_strike
 
-        if type(model) == BlackScholes:
+        if isinstance(model, BlackScholes):
 
-            volatility = model._volatility
-            lnS0k1 = np.log(S0 / K1)
-            lnS0k2 = np.log(S0 / K2)
+            volatility = model.volatility
+            ln_s0_k1 = np.log(s0 / K1)
+            ln_s0_k2 = np.log(s0 / K2)
             den = volatility * np.sqrt(t_exp)
             v2 = volatility * volatility
             mu = r_d - r_f
-            lower_d2 = (lnS0k1 + (mu - v2 / 2.0) * tdel) / den
-            upper_d2 = (lnS0k2 + (mu - v2 / 2.0) * tdel) / den
+            lower_d2 = (ln_s0_k1 + (mu - v2 / 2.0) * t_del) / den
+            upper_d2 = (ln_s0_k2 + (mu - v2 / 2.0) * t_del) / den
 
-            if self._prem_currency == self._forName:
-                lower_digital = S0 * np.exp(-r_f * tdel) * n_vect(-lower_d2)
-                upper_digital = S0 * np.exp(-r_f * tdel) * n_vect(-upper_d2)
-            elif self._prem_currency == self._domName:
-                lower_digital = np.exp(-r_f * tdel) * n_vect(-lower_d2)
-                upper_digital = np.exp(-r_f * tdel) * n_vect(-upper_d2)
+            if self.prem_currency == self.for_name:
+                lower_digital = s0 * np.exp(-r_f * t_del) * n_vect(-lower_d2)
+                upper_digital = s0 * np.exp(-r_f * t_del) * n_vect(-upper_d2)
+            elif self.prem_currency == self.dom_name:
+                lower_digital = np.exp(-r_f * t_del) * n_vect(-lower_d2)
+                upper_digital = np.exp(-r_f * t_del) * n_vect(-upper_d2)
 
-            v = (upper_digital - lower_digital) * self._notional
+            v = (upper_digital - lower_digital) * self.notional
 
         return v
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_fixed_lookback_option.py` & `financepy-0.360/financepy/products/fx/fx_fixed_lookback_option.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 ##############################################################################
 
 from math import exp, log, sqrt
 import numpy as np
 
 
 from ...utils.math import N
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
 from ...models.gbm_process_simulator import FinGBMProcess
 from ...utils.helpers import check_argument_types
 from ...utils.date import Date
 from ...utils.global_types import OptionTypes
 from ...market.curves.discount_curve import DiscountCurve
 
@@ -36,83 +36,83 @@
                  option_type: OptionTypes,
                  option_strike: float):
         """ Create option with expiry date, option type and the option strike
         """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._option_type = option_type
-        self._option_strike = option_strike
+        self.expiry_dt = expiry_dt
+        self.option_type = option_type
+        self.option_strike = option_strike
 
 ##########################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
-              dom_discount_curve: DiscountCurve,
-              for_discount_curve: DiscountCurve,
+              domestic_curve: DiscountCurve,
+              foreign_curve: DiscountCurve,
               volatility: float,
               stock_min_max: float):
         """ Value FX Fixed Lookback Option using Black Scholes model and
         analytical formulae. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as option value date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
                 "Foreign Curve valuation date not same as option value date")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = dom_discount_curve.df(self._expiry_dt)
+        df = domestic_curve.df(self.expiry_dt)
         r = -np.log(df)/t
 
-        dq = for_discount_curve.df(self._expiry_dt)
+        dq = foreign_curve.df(self.expiry_dt)
         q = -np.log(dq)/t
 
         v = volatility
         s0 = stock_price
-        k = self._option_strike
+        k = self.option_strike
         s_min = 0.0
         s_max = 0.0
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             s_max = stock_min_max
             if s_max < s0:
                 raise FinError(
                     "The Smax value must be >= the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             s_min = stock_min_max
             if s_min > s0:
                 raise FinError(
                     "The s_min value must be <= the stock price.")
 
         # There is a risk of an overflow in the limit of q=r which
         # we remove by adjusting the value of the dividend
-        if abs(r - q) < gSmall:
-            q = r + gSmall
+        if abs(r - q) < g_small:
+            q = r + g_small
 
         df = exp(-r * t)
         dq = exp(-q * t)
         b = r - q
         u = v * v / 2.0 / b
         w = 2.0 * b / v / v
         expbt = exp(b * t)
 
         # Taken from Hull Page 536 (6th edition) and Haug Page 143
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
 
             if k > s_max:
                 d1 = (log(s0/k) + (b+v*v/2.0)*t)/v/sqrt(t)
                 d2 = d1 - v * sqrt(t)
 
                 if s0 == k:
                     term = -N(d1 - 2.0 * b * sqrt(t) / v) + expbt * N(d1)
@@ -135,27 +135,27 @@
                 else:
                     term = (-(s0 / s_max)**(-w)) * \
                         N(e1 - 2.0 * b * sqrt(t) / v) + expbt * N(e1)
 
                 v = df * (s_max - k) + s0 * dq * N(e1) - \
                     s_max * df * N(e2) + s0 * df * u * term
 
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
 
             if k >= s_min:
                 f1 = (log(s0 / s_min) + (b + v * v / 2.0) * t) / v / sqrt(t)
                 f2 = f1 - v * sqrt(t)
 
                 if s0 == s_min:
                     term = N(-f1 + 2.0 * b * sqrt(t) / v) - expbt * N(-f1)
                 elif s0 > s_min and w < -100:
                     term = -expbt * N(-f1)
                 else:
                     term = ((s0 / s_min)**(-w)) * N(-f1 + 2.0 *
-                                                   b * sqrt(t) / v) - expbt * N(-f1)
+                                                    b * sqrt(t) / v) - expbt * N(-f1)
 
                 v = df * (k - s_min) - s0 * dq * N(-f1) + \
                     s_min * df * N(-f2) + s0 * df * u * term
 
             else:
                 d1 = (log(s0 / k) + (b + v * v / 2) * t) / v / sqrt(t)
                 d2 = d1 - v * sqrt(t)
@@ -167,15 +167,15 @@
                     term = ((s0 / k)**(-w)) * N(-d1 + 2.0 *
                                                 b * sqrt(t) / v) - expbt * N(-d1)
 
                 v = k * df * N(-d2) - s0 * dq * N(-d1) + s0 * df * u * term
 
         else:
             raise FinError("Unknown lookback option type:" +
-                           str(self._option_type))
+                           str(self.option_type))
 
         return v
 
 ###############################################################################
 
     def value_mc(self,
                  value_dt: Date,
@@ -185,39 +185,39 @@
                  volatility: float,
                  spot_fx_rate_min_max: float,
                  num_paths: int = 10000,
                  num_steps_per_year: int = 252,
                  seed: int = 4242):
         """ Value FX Fixed Lookback option using Monte Carlo. """
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
         s_0 = spot_fx_rate
 
         df = domestic_curve._df(t)
         r_d = -np.log(df)/t
 
         dq = foreign_curve._df(t)
         r_f = -np.log(dq)/t
 
         mu = r_d - r_f
 
         num_time_steps = int(t * num_steps_per_year)
 
-        option_type = self._option_type
-        k = self._option_strike
+        option_type = self.option_type
+        k = self.option_strike
 
         s_min = 0.0
         s_max = 0.0
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             s_max = spot_fx_rate_min_max
             if s_max < s_0:
                 raise FinError(
                     "Smax must be greater than or equal to the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             s_min = spot_fx_rate_min_max
             if s_min > s_0:
                 raise FinError(
                     "s_min must be less than or equal to the stock price.")
 
         model = FinGBMProcess()
         s_all = model.get_paths(num_paths,
```

### Comparing `financepy-0.350/financepy/products/fx/fx_float_lookback_option.py` & `financepy-0.360/financepy/products/equity/equity_fixed_lookback_option.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,211 +1,275 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
-from enum import Enum
+
 
 from ...utils.math import N
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
-from ...models.gbm_process_simulator import FinGBMProcess
-from ...products.fx.fx_option import FXOption
-from ...utils.helpers import check_argument_types
 from ...utils.date import Date
-from ...utils.global_types import OptionTypes
-from ...market.curves.discount_curve import DiscountCurve
 
+from ...models.gbm_process_simulator import FinGBMProcess
+from ...products.equity.equity_option import EquityOption
+from ...utils.helpers import label_to_string, check_argument_types
+from ...market.curves.discount_curve import DiscountCurve
+from ...utils.global_types import OptionTypes
 
 ##########################################################################
 # TODO: Attempt control variate adjustment to monte carlo
 # TODO: Sobol for Monte Carlo
 # TODO: TIGHTEN UP LIMIT FOR W FROM 100
 # TODO: Vectorise the analytical pricing formula
 ##########################################################################
 
 
 ##########################################################################
-# FLOAT STRIKE LOOKBACK CALL PAYS MAX(S(T)-s_min,0)
-# FLOAT STRIKE LOOKBACK PUT PAYS MAX(s_max-S(T),0)
+# FIXED STRIKE LOOKBACK CALL PAYS MAX(SMAX-K,0)
+# FIXED STRIKE LOOKBACK PUT PAYS MAX(K-SMIN,0)
 ##########################################################################
 
 
-class FXFloatLookbackOption(FXOption):
-    """ This is an FX option in which the strike of the option is not fixed
-    but is set at expiry to equal the minimum fx rate in the case of a call
-    or the maximum fx rate in the case of a put. """
+class EquityFixedLookbackOption(EquityOption):
+    """ This is an equity option in which the strike of the option is fixed but
+    the value of the stock price used to determine the payoff is the maximum
+    in the case of a call option, and a minimum in the case of a put option."""
 
     def __init__(self,
                  expiry_dt: Date,
-                 option_type: OptionTypes):
-        """ Create the FX Float Look Back Option by specifying the expiry
-        date and the option type. """
+                 option_type: OptionTypes,
+                 strike_price: float):
+        """ Create the FixedLookbackOption by specifying the expiry date, the
+        option type and the option strike. """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._option_type = option_type
+        if option_type != OptionTypes.EUROPEAN_CALL and option_type != OptionTypes.EUROPEAN_PUT:
+            raise FinError("Option type must be EUROPEAN_CALL or EUROPEAN_PUT")
+
+        self.expiry_dt = expiry_dt
+        self.option_type = option_type
+        self.strike_price = strike_price
 
-    ##########################################################################
+###############################################################################
 
     def value(self,
               value_dt: Date,
               stock_price: float,
-              domestic_curve: DiscountCurve,
-              foreign_curve: DiscountCurve,
+              discount_curve: DiscountCurve,
+              dividend_curve: DiscountCurve,
               volatility: float,
               stock_min_max: float):
-        """ Valuation of the Floating Lookback option using Black-Scholes
-        using the formulae derived by Goldman, Sosin and Gatto (1979). """
+        """ Valuation of the Fixed Lookback option using Black-Scholes using
+        the formulae derived by Conze and Viswanathan (1991). One of the inputs
+        is the minimum of maximum of the stock price since the start of the
+        option depending on whether the option is a call or a put. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if domestic_curve._value_dt != value_dt:
+        if discount_curve.value_dt != value_dt:
             raise FinError(
-                "Domestic Curve valuation date not same as option value date")
+                "Discount Curve valuation date not same as option value date")
 
-        if foreign_curve._value_dt != value_dt:
+        if dividend_curve.value_dt != value_dt:
             raise FinError(
-                "Foreign Curve valuation date not same as option value date")
+                "Dividend Curve valuation date not same as option value date")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = domestic_curve._df(t)
-        r = -np.log(df) / t
+        df = discount_curve.df(self.expiry_dt)
+        r = -np.log(df)/t
 
-        dq = foreign_curve._df(t)
-        q = -np.log(dq) / t
+        dq = dividend_curve.df(self.expiry_dt)
+        q = -np.log(dq)/t
 
         v = volatility
         s0 = stock_price
+        k = self.strike_price
         s_min = 0.0
         s_max = 0.0
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-            s_min = stock_min_max
-            if s_min > s0:
-                raise FinError(
-                    "s_min must be less than or equal to the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             s_max = stock_min_max
             if s_max < s0:
-                raise FinError(
-                    "s_max must be greater than or equal to the stock price.")
+                raise FinError("The Smax value must be >= the stock price.")
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            s_min = stock_min_max
+            if s_min > s0:
+                raise FinError("The Smin value must be <= the stock price.")
 
-        if abs(r - q) < gSmall:
-            q = r + gSmall
+        # There is a risk of an overflow in the limit of q=r which
+        # we remove by adjusting the value of the dividend
+        if abs(r - q) < g_small:
+            q = r + g_small
 
-        dq = np.exp(-q * t)
         df = np.exp(-r * t)
+        dq = np.exp(-q * t)
         b = r - q
         u = v * v / 2.0 / b
-        w = 2.0 * b / v / v
+        w = 2.0 * b / (v * v)
         expbt = np.exp(b * t)
+        sqrt_t = np.sqrt(t)
+
+        # Taken from Hull Page 536 (6th edition) and Haug Page 143
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
+
+            if k > s_max:
+
+                d1 = (np.log(s0 / k) + (b + v * v/2.0) * t) / v / sqrt_t
+                d2 = d1 - v * sqrt_t
 
-        # Taken from Haug Page 142
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+                if s0 == k:
+                    term = -N(d1 - 2.0 * b * sqrt_t / v) + expbt * N(d1)
+                elif s0 < k and w > 100.0:
+                    term = expbt * N(d1)
+                else:
+                    term = -np.power(s0 / k, -w) * N(d1 - 2 * b * sqrt_t / v) \
+                        + expbt * N(d1)
 
-            a1 = (np.log(s0 / s_min) + (b + (v ** 2) / 2.0) * t) / v / np.sqrt(t)
-            a2 = a1 - v * np.sqrt(t)
+                v = s0 * dq * N(d1) - k * df * N(d2) + s0 * df * u * term
 
-            if s_min == s0:
-                term = N(-a1 + 2.0 * b * np.sqrt(t) / v) - expbt * N(-a1)
-            elif s0 < s_min and w < -100:
-                term = - expbt * N(-a1)
             else:
-                term = ((s0 / s_min) ** (-w)) * N(-a1 + 2.0 *
-                                                 b * np.sqrt(t) / v) - expbt * N(-a1)
 
-            v = s0 * dq * N(a1) - s_min * df * N(a2) + s0 * df * u * term
+                e1 = (np.log(s0/s_max) + (r - q + v*v/2) * t) / v / sqrt_t
+                e2 = e1 - v * sqrt_t
 
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+                if s0 == s_max:
+                    term = -N(e1 - 2.0 * b * sqrt_t / v) + expbt * N(e1)
+                elif s0 < s_max and w > 100.0:
+                    term = expbt * N(e1)
+                else:
+                    term = (-(s0 / s_max)**(-w)) * \
+                        N(e1 - 2.0 * b * sqrt_t / v) + expbt * N(e1)
+
+                v = df * (s_max - k) + s0 * dq * N(e1) - \
+                    s_max * df * N(e2) + s0 * df * u * term
+
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+
+            if k >= s_min:
+
+                f1 = (np.log(s0/s_min) + (b + v * v / 2.0) * t) / v / sqrt_t
+                f2 = f1 - v * sqrt_t
+
+                if s0 == s_min:
+                    term = N(-f1 + 2.0 * b * sqrt_t / v) - expbt * N(-f1)
+                elif s0 > s_min and w < -100.0:
+                    term = -expbt * N(-f1)
+                else:
+                    term = ((s0 / s_min)**(-w)) * N(-f1 + 2.0 * b * sqrt_t / v) \
+                        - expbt * N(-f1)
 
-            b1 = (np.log(s0 / s_max) + (b + (v ** 2) / 2.0) * t) / v / np.sqrt(t)
-            b2 = b1 - v * np.sqrt(t)
+                v = df * (k - s_min) - s0 * dq * N(-f1) + \
+                    s_min * df * N(-f2) + s0 * df * u * term
 
-            if s_max == s0:
-                term = -N(b1 - 2.0 * b * np.sqrt(t) / v) + expbt * N(b1)
-            elif s0 < s_max and w > 100:
-                term = expbt * N(b1)
             else:
-                term = (-(s0 / s_max) ** (-w)) * \
-                    N(b1 - 2.0 * b * np.sqrt(t) / v) + expbt * N(b1)
 
-            v = s_max * df * N(-b2) - s0 * dq * N(-b1) + s0 * df * u * term
+                d1 = (np.log(s0 / k) + (b + v * v / 2) * t) / v / sqrt_t
+                d2 = d1 - v * sqrt_t
+
+                if s0 == k:
+                    term = N(-d1 + 2.0 * b * sqrt_t / v) - expbt * N(-d1)
+                elif s0 > k and w < -100.0:
+                    term = -expbt * N(-d1)
+                else:
+                    term = ((s0 / k)**(-w)) * N(-d1 + 2.0 * b * sqrt_t / v) \
+                        - expbt * N(-d1)
+
+                v = k * df * N(-d2) - s0 * dq * N(-d1) + s0 * df * u * term
 
         else:
             raise FinError("Unknown lookback option type:" +
-                           str(self._option_type))
+                           str(self.option_type))
 
         return v
 
-    ##########################################################################
+###############################################################################
 
     def value_mc(self,
-                 value_dt,
-                 stock_price,
-                 domestic_curve,
-                 foreign_curve,
-                 volatility,
-                 stock_min_max,
-                 num_paths=10000,
-                 num_steps_per_year=252,
-                 seed=4242):
-        ''' Value FX floating lookback option using Monte Carlo '''
-        t = (self._expiry_dt - value_dt) / gDaysInYear
-        df = domestic_curve._df(t)
-        r = -np.log(df) / t
-
-        dq = foreign_curve._df(t)
-        q = -np.log(dq) / t
+                 value_dt: Date,
+                 stock_price: float,
+                 discount_curve: DiscountCurve,
+                 dividend_curve: DiscountCurve,
+                 volatility: float,
+                 stock_min_max: float,
+                 num_paths: int = 10000,
+                 num_steps_per_year: int = 252,
+                 seed: int = 4242):
+        """ Monte Carlo valuation of a fixed strike lookback option using a
+        Black-Scholes model that assumes the stock follows a GBM process. """
+
+        t = (self.expiry_dt - value_dt) / gDaysInYear
+
+        df = discount_curve.df(self.expiry_dt)
+        r = discount_curve.cc_rate(self.expiry_dt)
+        q = dividend_curve.cc_rate(self.expiry_dt)
 
-        num_time_steps = int(t * num_steps_per_year)
         mu = r - q
+        num_time_steps = int(t * num_steps_per_year)
+
+        option_type = self.option_type
+        k = self.strike_price
 
-        option_type = self._option_type
         s_min = 0.0
         s_max = 0.0
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
-            s_min = stock_min_max
-            if s_min > stock_price:
-                raise FinError(
-                    "s_min must be less than or equal to the stock price.")
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             s_max = stock_min_max
             if s_max < stock_price:
                 raise FinError(
-                    "s_max must be greater than or equal to the stock price.")
+                    "Smax must be greater than or equal to the stock price.")
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
+            s_min = stock_min_max
+            if s_min > stock_price:
+                raise FinError(
+                    "Smin must be less than or equal to the stock price.")
 
         model = FinGBMProcess()
         s_all = model.get_paths(num_paths,
-                                num_time_steps,
-                                t,
+                                num_time_steps, t,
                                 mu,
                                 stock_price,
                                 volatility,
                                 seed)
 
-        # Due to anti-thetics we have doubled the number of paths
+        # Due to antithetics we have doubled the number of paths
         num_paths = 2 * num_paths
         payoff = np.zeros(num_paths)
 
         if option_type == OptionTypes.EUROPEAN_CALL:
-            s_min_vector = np.min(s_all, axis=1)
-            s_min_vector = np.minimum(s_min_vector, s_min)
-            payoff = np.maximum(s_all[:, -1] - s_min_vector, 0.0)
-        elif option_type == OptionTypes.EUROPEAN_PUT:
             s_max_vector = np.max(s_all, axis=1)
-            s_max_vector = np.maximum(s_max_vector, s_max)
-            payoff = np.maximum(s_max_vector - s_all[:, -1], 0.0)
+            s_maxs = np.ones(num_paths) * s_max
+            payoff = np.maximum(s_max_vector - k, 0.0)
+            payoff = np.maximum(payoff, s_maxs - k)
+        elif option_type == OptionTypes.EUROPEAN_PUT:
+            s_min_vector = np.min(s_all, axis=1)
+            s_mins = np.ones(num_paths) * s_min
+            payoff = np.maximum(k - s_min_vector, 0.0)
+            payoff = np.maximum(payoff, k - s_mins)
         else:
             raise FinError("Unknown lookback option type:" + str(option_type))
 
-        v = payoff.mean() * np.exp(-r * t)
+        v = payoff.mean() * df
         return v
 
-##########################################################################
+###############################################################################
+
+    def __repr__(self):
+        s = label_to_string("OBJECT TYPE", type(self).__name__)
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("STRIKE PRICE", self.strike_price)
+        s += label_to_string("OPTION TYPE", self.option_type, "")
+        return s
+
+###############################################################################
+
+    def _print(self):
+        """ Simple print function for backward compatibility. """
+        print(self)
+
+###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_forward.py` & `financepy-0.360/financepy/products/inflation/FinInflationBond.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,181 +1,152 @@
-##############################################################################
+###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
-##############################################################################
+###############################################################################
 
-import numpy as np
+###############################################################################
+# ADD Inflation assumption and resulting yield calculation
+# Pricing using inflation curve and discount curve
+###############################################################################
 
 
 from ...utils.date import Date
-from ...utils.global_vars import gDaysInYear
 from ...utils.error import FinError
+from ...utils.frequency import annual_frequency, FrequencyTypes
+from ...utils.calendar import CalendarTypes
+from ...utils.day_count import DayCountTypes
 from ...utils.helpers import label_to_string, check_argument_types
+from ..bonds.bond import Bond, YTMCalcType
 
 ###############################################################################
-# ALL CCY RATES MUST BE IN NUM UNITS OF DOMESTIC PER UNIT OF FOREIGN CURRENCY
-# SO EUR USD = 1.30 MEANS 1.30 DOLLARS PER EURO SO DOLLAR IS THE DOMESTIC AND
-# EUR IS THE FOREIGN CURRENCY
-###############################################################################
 
 
-class FXForward:
-    """ Contract to buy or sell currency at a forward rate decided today. """
+class FinInflationBond(Bond):
+    """ Class for inflation-linked bonds like TIPS and related analytics. These
+    are bonds with coupon and principal adjusted by an index such as the CPI.
+    We inherit from the Bond class. """
 
     def __init__(self,
-                 expiry_dt: Date,
-                 strike_fx_rate: float,  # PRICE OF 1 UNIT OF FOREIGN IN DOM CCY
-                 currency_pair: str,  # FOR DOM
-                 notional: float,
-                 notional_currency: str,  # must be FOR or DOM
-                 spot_days: int = 0):
-        """ Creates a FinFXForward which allows the owner to buy the FOR
-        against the DOM currency at the strike_fx_rate and to pay it in the
-        notional currency. """
-
-        check_argument_types(self.__init__, locals())
-
-        delivery_dt = expiry_dt.add_weekdays(spot_days)
-
-        """ The FX rate is the price in domestic currency ccy2 of a single unit
-        of the foreign currency which is ccy1. For example EURUSD of 1.3 is the
-        price in USD (CCY2) of 1 unit of EUR (CCY1) """
-
-        if delivery_dt < expiry_dt:
-            raise FinError("Delivery date must be on or after expiry date.")
-
-        if len(currency_pair) != 6:
-            raise FinError("Currency pair must be 6 characters.")
-
-        self._expiry_dt = expiry_dt
-        self._delivery_dt = delivery_dt
-        self._strike_fx_rate = strike_fx_rate
-
-        self._currency_pair = currency_pair
-        self._forName = self._currency_pair[0:3]
-        self._domName = self._currency_pair[3:6]
-
-        if notional_currency != self._domName and notional_currency != self._forName:
-            raise FinError("Notional currency not in currency pair.")
-
-        self._notional = notional
-        self._notional_currency = notional_currency
-        self._spot_days = spot_days
-
-###############################################################################
-
-    def value(self,
-              value_dt,
-              spot_fx_rate,  # 1 unit of foreign in domestic
-              dom_discount_curve,
-              for_discount_curve):
-        """ Calculate the value of an FX forward contract where the current
-        FX rate is the spot_fx_rate. """
-
-        if isinstance(value_dt, Date) is False:
-            raise FinError("Valuation date is not a Date")
+                 issue_dt: Date,
+                 maturity_dt: Date,
+                 cpn: float,  # Annualised bond coupon before inflation
+                 freq_type: FrequencyTypes,
+                 dc_type: DayCountTypes,
+                 ex_div_days: int,  # Value of CPI index at bond issue date
+                 base_cpi_value: float,  # CPI value at issue
+                 num_ex_dividend_days: int = 0,
+                 cal_type: CalendarTypes = CalendarTypes.NONE):
+        """ Create FinInflationBond object by providing Maturity, Frequency,
+        coupon, frequency and the accrual convention type. You must also supply
+        the base CPI used for all coupon and principal related calculations.
+        The class inherits from Bond so has many similar functions. The YTM"""
 
-        if value_dt > self._expiry_dt:
-            raise FinError("Valuation date after expiry date.")
+        Bond.__init__(self, issue_dt, maturity_dt, cpn, freq_type,
+                      dc_type, ex_div_days, cal_type)
 
-        if dom_discount_curve._value_dt != value_dt:
-            raise FinError(
-                "Domestic Curve valuation date not same as option value date")
-
-        if for_discount_curve._value_dt != value_dt:
-            raise FinError(
-                "Foreign Curve valuation date not same as option value date")
-
-        if isinstance(value_dt, Date):
-            t = (self._expiry_dt - value_dt) / gDaysInYear
-        else:
-            t = value_dt
-
-        if np.any(spot_fx_rate <= 0.0):
-            raise FinError("spot_fx_rate must be greater than zero.")
-
-        if np.any(t < 0.0):
-            raise FinError("Time to expiry must be positive.")
-
-        t = np.maximum(t, 1e-10)
-
-        newFwdFXRate = self.forward(value_dt,
-                                    spot_fx_rate,
-                                    dom_discount_curve,
-                                    for_discount_curve)
-
-        dom_df = dom_discount_curve._df(t)
-
-        if self._notional_currency == self._domName:
-            self._notional_dom = self._notional
-            self._notional_for = self._notional / self._strike_fx_rate
-        elif self._notional_currency == self._forName:
-            self._notional_dom = self._notional * self._strike_fx_rate
-            self._notional_for = self._notional
-        else:
-            raise FinError("Invalid notional currency.")
-
-        if self._notional_currency == self._forName:
-            v = (newFwdFXRate - self._strike_fx_rate)
-            v = v * self._notional * dom_df
-        elif self._notional_currency == self._domName:
-            v = (newFwdFXRate - self._strike_fx_rate)
-            v = v * self._notional * dom_df * newFwdFXRate
-
-        self._cash_dom = v * self._notional_dom / self._strike_fx_rate
-        self._cash_for = v * self._notional_for / spot_fx_rate
-
-        return {"value": v,
-                "cash_dom": self._cash_dom,
-                "cash_for": self._cash_for,
-                "not_dom": self._notional_dom,
-                "not_for": self._notional_for,
-                "ccy_dom": self._domName,
-                "ccy_for": self._forName}
-
-###############################################################################
-
-    def forward(self,
-                value_dt,
-                spot_fx_rate,  # 1 unit of foreign in domestic
-                dom_discount_curve,
-                for_discount_curve):
-        """ Calculate the FX Forward rate that makes the value of the FX
-        contract equal to zero. """
-
-        if isinstance(value_dt, Date):
-            t = (self._delivery_dt - value_dt) / gDaysInYear
-        else:
-            t = value_dt
-
-        if np.any(spot_fx_rate <= 0.0):
-            raise FinError("spot_fx_rate must be greater than zero.")
-
-        if np.any(t < 0.0):
-            raise FinError("Time to expiry must be positive.")
-
-        t = np.maximum(t, 1e-10)
+        check_argument_types(self.__init__, locals())
 
-        for_df = for_discount_curve._df(t)
-        dom_df = dom_discount_curve._df(t)
+        if issue_dt >= maturity_dt:
+            raise FinError("Issue Date must preceded maturity date.")
 
-        fwdFXRate = spot_fx_rate * for_df / dom_df
-        return fwdFXRate
+        # If the maturity date falls on the last day of the month we assume
+        # that earlier flows also fall on month ends
+        self.end_of_month = False
+        if maturity_dt.is_eom():
+            self.end_of_month = True
+
+        self.issue_dt = issue_dt
+        self.maturity_dt = maturity_dt
+        self.cpn = cpn
+        self.freq_type = freq_type
+        self.dc_type = dc_type
+        self.freq = annual_frequency(freq_type)
+        self.ex_div_days = ex_div_days  # This is the bond holding size
+        self.base_cpi_value = base_cpi_value  # CPI value at issue date of bond
+        self.par = 100.0  # This is how price is quoted
+        self.redemption = 1.0  # Amount paid at maturity
+        self.num_ex_dividend_days = num_ex_dividend_days
+        self.inflation_accrued_int = 0.0
+        self.cal_type = cal_type
+        self.cpn_dts = []
+        self.flow_amounts = []
+
+        self.settle_dt = Date(1, 1, 1900)
+        self.accrued_int= None
+        self.accrued_days = 0.0
+        self.alpha = 0.0
+
+        self._calculate_cpn_dts()
+        self._calculate_flows()
+
+###############################################################################
+
+    def inflation_principal(self,
+                            settle_dt: Date,
+                            face: (float),
+                            ytm: float,
+                            reference_cpi: float,
+                            convention: YTMCalcType):
+        """ Calculate the principal value of the bond based on the face
+        amount and the CPI growth. """
+
+        index_ratio = reference_cpi / self.base_cpi_value
+        dirty_price = self.dirty_price_from_ytm(settle_dt, ytm,
+                                                convention)
+        principal = dirty_price * face / self.par
+        principal = principal - self.accrued_int
+        principal *= index_ratio
+        return principal
+
+###############################################################################
+
+    def flat_price_from_yield_to_maturity(self,
+                                          settle_dt: Date,
+                                          ytm: float,
+                                          last_cpn_cpi: float,
+                                          convention: YTMCalcType):
+        """ Calculate the flat clean price value of the bond based on the clean
+        price amount and the CPI growth to the last coupon date. """
+
+        index_ratio = last_cpn_cpi / self.base_cpi_value
+        clean_price = self.clean_price_from_ytm(
+            settle_dt, ytm, convention)
+        flat_price = clean_price
+        flat_price *= index_ratio
+        return flat_price
+
+###############################################################################
+
+    def inflation_accrued_interest(self, settle_dt: Date,
+                                   face: (float),
+                                   reference_cpi):
+        """ Calculate the amount of coupon that has accrued between the
+        previous coupon date and the settlement date. This is adjusted by the
+        index ratio in line with the CPI growth since the bond base CPI date.
+        We assume no ex-dividend period.
+        """
+
+        self.accrued_interest(settle_dt, face)
+        index_ratio = reference_cpi / self.base_cpi_value
+        self.inflation_accrued_int = self.accrued_int * index_ratio
+        return self.inflation_accrued_int
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("STRIKE FX RATE", self._strike_fx_rate)
-        s += label_to_string("CURRENCY PAIR", self._currency_pair)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("NOTIONAL CCY", self._notional_currency)
-        s += label_to_string("SPOT DAYS", self._spot_days, "")
+        s += label_to_string("ISSUE DATE", self.issue_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("COUPON", self.cpn)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("EX-DIV DAYS", self.ex_div_days)
+        s += label_to_string("BASE CPI VALUE", self.base_cpi_value, "")
         return s
 
 ###############################################################################
 
     def _print(self):
-        """ Simple print function for backward compatibility. """
+        """ Print a list of the unadjusted coupon payment dates used in
+        analytic calculations for the bond. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_mkt_conventions.py` & `financepy-0.360/financepy/products/fx/fx_mkt_conventions.py`

 * *Files 5% similar despite different names*

```diff
@@ -116,20 +116,20 @@
 
     def __init__(self,
                  ccy1,
                  ccy2,
                  rate):
 
         if ccy1 in ccyNames:
-            self._ccy1 = ccy1
+            self.ccy1 = ccy1
         else:
-            raise FinError("Unknown currency code ", ccy1)
+            raise FinError("Unknown currency code:" + ccy1)
 
         if ccy2 in ccyNames:
-            self._ccy2 = ccy2
+            self.ccy2 = ccy2
         else:
-            raise FinError("Unknown currency code ", ccy2)
+            raise FinError("Unknown currency code:" + ccy2)
 
-        self._ccy2 = ccy2
-        self._rate
+        self.ccy2 = ccy2
+        self.rate = None
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_one_touch_option.py` & `financepy-0.360/financepy/products/fx/fx_one_touch_option.py`

 * *Files 9% similar despite different names*

```diff
@@ -137,258 +137,263 @@
                  barrier_rate: float,
                  payment_size: float = 1.0):
         """ Create the one touch option by defining its expiry date and the
         barrier level and a payment size if it is a cash . """
 
         check_argument_types(self.__init__, locals())
 
-        self._expiry_dt = expiry_dt
-        self._option_type = option_type
-        self._barrier_rate = float(barrier_rate)
-        self._payment_size = payment_size
+        self.expiry_dt = expiry_dt
+        self.option_type = option_type
+        self.barrier_rate = float(barrier_rate)
+        self.payment_size = payment_size
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               spot_fx_rate: (float, np.ndarray),
-              dom_discount_curve: DiscountCurve,
-              for_discount_curve: DiscountCurve,
+              domestic_curve: DiscountCurve,
+              foreign_curve: DiscountCurve,
               model):
         """ FX One-Touch Option valuation using the Black-Scholes model
         assuming a continuous (American) barrier from value date to expiry.
         Handles both cash-or-nothing and asset-or-nothing options."""
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError("Domestic Curve date not same as valuation date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError("Foreign Curve date not same as valuation date")
 
         DEBUG_MODE = False
 
         print("USE WITH CAUTION. MORE TESTING REQUIRED.")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
         t = max(t, 1e-6)
 
         s0 = spot_fx_rate
-        H = self._barrier_rate
-        K = self._payment_size
+        H = self.barrier_rate
+        K = self.payment_size
 
-        sqrtT = np.sqrt(t)
+        sqrt_t = np.sqrt(t)
 
-        df = dom_discount_curve.df(self._expiry_dt)
-        r_d = dom_discount_curve.cc_rate(self._expiry_dt)
-        r_f = for_discount_curve.cc_rate(self._expiry_dt)
+        df = domestic_curve.df(self.expiry_dt)
+        r_d = domestic_curve.cc_rate(self.expiry_dt)
+        r_f = foreign_curve.cc_rate(self.expiry_dt)
 
-        v = model._volatility
+        v = model.volatility
         v = max(v, 1e-6)
 
         # Using notation in Haug page 177
         b = r_d - r_f
         mu = (b - v * v / 2.0) / v / v
         lam = np.sqrt(mu * mu + 2.0 * r_d / v / v)
 
         if DEBUG_MODE:
             print("t:", t)
             print("vol", v)
             print("b", b)
             print("mu", mu)
             print("lam", lam)
 
-        if self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
+        if self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
             # HAUG 1
 
             if np.any(s0 <= H):
                 raise FinError("FX Rate is currently below barrier.")
 
             eta = 1.0
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
-            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta * lam * v * sqrtT)
+            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta *
+                                                     z - 2.0 * eta * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
             # HAUG 2
 
             if np.any(s0 >= H):
                 raise FinError("FX Rate is currently above barrier.")
 
             eta = -1.0
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
-            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta * lam * v * sqrtT)
+            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta *
+                                                     z - 2.0 * eta * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
             # HAUG 3
 
             if np.any(s0 <= H):
                 raise FinError("FX Rate is currently below barrier.")
 
             eta = 1.0
             K = H
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
-            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta * lam * v * sqrtT)
+            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta *
+                                                     z - 2.0 * eta * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
             # HAUG 4
 
             if np.any(s0 >= H):
                 raise FinError("FX Rate is currently above barrier.")
 
             eta = -1.0
             K = H
-            z = np.log(H/s0) / v / sqrtT + lam * v * sqrtT
+            z = np.log(H/s0) / v / sqrt_t + lam * v * sqrt_t
             A5_1 = np.power(H/s0, mu + lam) * n_vect(eta * z)
-            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta * z - 2.0 * eta * lam * v * sqrtT)
+            A5_2 = np.power(H/s0, mu - lam) * n_vect(eta *
+                                                     z - 2.0 * eta * lam * v * sqrt_t)
             v = (A5_1 + A5_2) * K
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
             # HAUG 5
 
             if np.any(s0 <= H):
                 raise FinError("FX Rate is currently below barrier.")
 
             eta = +1.0
             phi = -1.0
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 + B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
             # HAUG 6
 
             if np.any(s0 >= H):
                 raise FinError("FX Rate is currently above barrier.")
 
             eta = -1.0
             phi = +1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
-            B4 = K * df * np.power(H/s0, 2.0 * mu) * n_vect(eta * y2 - eta * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
+            B4 = K * df * np.power(H/s0, 2.0 * mu) * \
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 + B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 7
 
             if np.any(s0 <= H):
                 raise FinError("FX Rate is currently below barrier.")
 
             eta = +1.0
             phi = -1.0
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-r_f * t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 + A4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 8
 
             if np.any(s0 >= H):
                 raise FinError("FX Rate is currently above barrier.")
 
             eta = -1.0
             phi = +1.0
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-r_f * t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 + A4)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
             # HAUG 9
 
             if np.any(s0 <= H):
                 raise FinError("FX Rate is currently below barrier.")
 
             eta = +1.0
             phi = +1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 - B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
             # HAUG 10
 
             if np.any(s0 >= H):
                 raise FinError("FX Rate is currently above barrier.")
 
             eta = -1.0
             phi = -1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            B2 = K * df * n_vect(phi * x2 - phi * v * sqrtT)
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            B2 = K * df * n_vect(phi * x2 - phi * v * sqrt_t)
             B4 = K * df * np.power(H/s0, 2.0 * mu) * \
-                n_vect(eta * y2 - eta * v * sqrtT)
+                n_vect(eta * y2 - eta * v * sqrt_t)
             v = (B2 - B4)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 11
 
             if np.any(s0 <= H):
                 raise FinError("FX Rate is currently below barrier.")
 
             eta = +1.0
             phi = +1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-r_f*t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 - A4)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 12
 
             if np.any(s0 >= H):
                 raise FinError("FX Rate is currently above barrier.")
 
             eta = -1.0
             phi = -1.0
 
-            x2 = np.log(s0/H) / v / sqrtT + (mu + 1.0) * v * sqrtT
-            y2 = np.log(H/s0) / v / sqrtT + (mu + 1.0) * v * sqrtT
+            x2 = np.log(s0/H) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
+            y2 = np.log(H/s0) / v / sqrt_t + (mu + 1.0) * v * sqrt_t
             dq = np.exp(-r_f*t)
             A2 = s0 * dq * n_vect(phi * x2)
             A4 = s0 * dq * np.power(H/s0, 2.0*(mu+1.0)) * n_vect(eta * y2)
             v = (A2 - A4)
             return v
 
         else:
@@ -396,173 +401,173 @@
 
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("BARRIER LEVEL", self._barrier_rate)
-        s += label_to_string("PAYMENT SIZE", self._payment_size, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("BARRIER LEVEL", self.barrier_rate)
+        s += label_to_string("PAYMENT SIZE", self.payment_size, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
 
 ###############################################################################
 
     def value_mc(self,
                  value_dt: Date,
                  stock_price: float,
-                 domCurve: DiscountCurve,
-                 forCurve: DiscountCurve,
+                 dom_curve: DiscountCurve,
+                 for_curve: DiscountCurve,
                  model,
                  num_paths: int = 10000,
                  num_steps_per_year: int = 252,
                  seed: int = 4242):
         """ Touch Option valuation using the Black-Scholes model and Monte
         Carlo simulation. Accuracy is not great when compared to the analytical
         result as we only observe the barrier a finite number of times. The
         convergence is slow. """
 
         print("THIS NEEDS TO BE CHECKED")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df_d = domCurve.df(self._expiry_dt)
+        df_d = dom_curve.df(self.expiry_dt)
         r_d = -np.log(df_d)/t
 
-        df_f = forCurve.df(self._expiry_dt)
+        df_f = for_curve.df(self.expiry_dt)
         r_f = -np.log(df_f)/t
 
         num_time_steps = int(t * num_steps_per_year) + 1
         dt = t / num_time_steps
 
-        v = model._volatility
+        v = model.volatility
         s0 = stock_price
         mu = r_d - r_f
 
         s = get_paths(num_paths, num_time_steps, t, mu, s0, v, seed)
 
-        H = self._barrier_rate
-        X = self._payment_size
+        H = self.barrier_rate
+        X = self.payment_size
 
         v = 0.0
 
-        if self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
+        if self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT:
             # HAUG 1
 
             if s0 <= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, r_d, dt)
             v = v * X
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_HIT:
             # HAUG 2
 
             if s0 >= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, r_d, dt)
             v = v * X
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT:
             # HAUG 3
 
             if s0 <= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, r_d, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT:
             # HAUG 4
 
             if s0 >= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, r_d, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY:
             # HAUG 5
 
             if s0 <= H:
                 raise FinError("Barrier has  ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, 0.0, dt)
             v = v * X * np.exp(- r_d * t)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY:
             # HAUG 6
 
             if s0 >= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, 0.0, dt)
             v = v * X * np.exp(- r_d * t)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 7
 
             if s0 <= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_down(s, H, 0.0, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
+        elif self.option_type == TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY:
             # HAUG 8
 
             if s0 >= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_one_at_hit_pv_up(s, H, 0.0, dt) * H
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING:
             # HAUG 9
 
             if s0 <= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = 1.0 - _barrier_pay_one_at_hit_pv_down(s, H, 0.0, dt)
             v = v * X * np.exp(-r_d*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING:
             # HAUG 10
 
             if s0 >= H:
                 raise FinError("Barrier has ALREADY been crossed.")
 
             v = 1.0 - _barrier_pay_one_at_hit_pv_up(s, H, 0.0, dt)
             v = v * X * np.exp(-r_d*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 11
 
             if s0 <= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_asset_at_expiry_down_out(s, H)
             v = v * np.exp(-r_d*t)
             return v
 
-        elif self._option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
+        elif self.option_type == TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING:
             # HAUG 12
 
             if s0 >= H:
                 raise FinError("Stock price is currently below barrier.")
 
             v = _barrier_pay_asset_at_expiry_up_out(s, H)
             v = v * np.exp(-r_d*t)
```

### Comparing `financepy-0.350/financepy/products/fx/fx_rainbow_option.py` & `financepy-0.360/financepy/products/fx/fx_rainbow_option.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
+from enum import Enum
+
 import numpy as np
 from typing import List
 
 from ...utils.date import Date
 from ...utils.math import N, M
 from ...utils.global_vars import gDaysInYear
 from ...utils.error import FinError
 from ...models.gbm_process_simulator import FinGBMProcess
-from ...products.equity.equity_option import EquityOption
-
-from enum import Enum
+from ...products.fx.fx_option import FXOption
 
 from ...utils.helpers import check_argument_types
 
 
 ###############################################################################
 
 
@@ -75,75 +75,75 @@
                   num_assets,
                   payoff_type,
                   payoff_params,
                   num_paths=10000,
                   seed=4242):
 
     np.random.seed(seed)
-    df = discount_curve._df(t)
+    df = discount_curve.df(t)
     r = -np.log(df) / t
     mus = r - dividend_yields
     model = FinGBMProcess()
 
     num_time_steps = 2
     s_all = model.get_paths_assets(num_assets, num_paths, num_time_steps,
-                                  t, mus, stock_prices, volatilities, betas, seed)
+                                   t, mus, stock_prices, volatilities, betas, seed)
 
     payoff = payoff_value(s_all, payoff_type.value, payoff_params)
     payoff = np.mean(payoff)
     v = payoff * np.exp(-r * t)
     return v
 
 ###############################################################################
 
 
-class FXRainbowOption(EquityOption):
+class FXRainbowOption(FXOption):
 
     def __init__(self,
                  expiry_dt: Date,
                  payoff_type: FXRainbowOptionTypes,
                  payoff_params: List[float],
                  num_assets: int):
 
         check_argument_types(self.__init__, locals())
 
         self.validate_payoff(payoff_type, payoff_params, num_assets)
 
-        self._expiry_dt = expiry_dt
-        self._payoff_type = payoff_type
-        self._payoff_params = payoff_params
-        self._num_assets = num_assets
+        self.expiry_dt = expiry_dt
+        self.payoff_type = payoff_type
+        self.payoff_params = payoff_params
+        self.num_assets = num_assets
 
     ###############################################################################
 
     def validate(self,
                  stock_prices,
                  dividend_yields,
                  volatilities,
                  betas):
 
-        if len(stock_prices) != self._num_assets:
+        if len(stock_prices) != self.num_assets:
             raise FinError(
                 "Stock prices must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
-        if len(dividend_yields) != self._num_assets:
+        if len(dividend_yields) != self.num_assets:
             raise FinError(
                 "Dividend yields must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
-        if len(volatilities) != self._num_assets:
+        if len(volatilities) != self.num_assets:
             raise FinError(
                 "Volatilities must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
-        if len(betas) != self._num_assets:
+        if len(betas) != self.num_assets:
             raise FinError(
                 "Betas must be a vector of length "
-                + str(self._num_assets))
+                + str(self.num_assets))
 
     ###############################################################################
 
     def validate_payoff(self, payoff_type, payoff_params, num_assets):
 
         num_params = 0
 
@@ -176,86 +176,86 @@
                 raise FinError("Nth parameter must be 1 to " + str(num_assets))
 
     ###########################################################################
 
     def value(self,
               value_dt,
               stock_prices,
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               volatilities,
               betas):
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as option value date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
                 "Foreign Curve valuation date not same as option value date")
 
-        if self._num_assets != 2:
+        if self.num_assets != 2:
             raise FinError("Analytical results for two assets only.")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Value date after expiry date.")
 
         self.validate(stock_prices,
-                      for_discount_curve,
+                      foreign_curve,
                       volatilities,
                       betas)
 
         # Use result by Stulz (1982) given by Haug Page 211
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        df = dom_discount_curve._df(t)
+        df = domestic_curve.df(t)
         r = -np.log(df) / t
 
-        q1 = for_discount_curve[0]
-        q2 = for_discount_curve[1]
+        q1 = foreign_curve[0]
+        q2 = foreign_curve[1]
         rho = betas[0] ** 2
         s1 = stock_prices[0]
         s2 = stock_prices[1]
         b1 = r - q1
         b2 = r - q2
         v1 = volatilities[0]
         v2 = volatilities[1]
-        k = self._payoff_params[0]
+        k = self.payoff_params[0]
 
         v = np.sqrt(v1 * v1 + v2 * v2 - 2 * rho * v1 * v2)
         d = (np.log(s1 / s2) + (b1 - b2 + v * v / 2) * t) / v / np.sqrt(t)
         y1 = (np.log(s1 / k) + (b1 + v1 * v1 / 2) * t) / v1 / np.sqrt(t)
         y2 = (np.log(s2 / k) + (b2 + v2 * v2 / 2) * t) / v2 / np.sqrt(t)
         rho1 = (v1 - rho * v2) / v
         rho2 = (v2 - rho * v1) / v
         dq1 = np.exp(-q1 * t)
         dq2 = np.exp(-q2 * t)
         df = np.exp(-r * t)
         sqrtt = np.sqrt(t)
 
-        if self._payoff_type == FXRainbowOptionTypes.CALL_ON_MAXIMUM:
+        if self.payoff_type == FXRainbowOptionTypes.CALL_ON_MAXIMUM:
             v = s1 * dq1 * M(y1, d, rho1) + s2 * dq2 * M(y2, -d + v * sqrtt, rho2) \
                 - k * df * \
                 (1.0 - M(-y1 + v1 * np.sqrt(t), -y2 + v2 * sqrtt, rho))
-        elif self._payoff_type == FXRainbowOptionTypes.CALL_ON_MINIMUM:
+        elif self.payoff_type == FXRainbowOptionTypes.CALL_ON_MINIMUM:
             v = s1 * dq1 * M(y1, -d, -rho1) + s2 * dq2 * M(y2, d - v * np.sqrt(t), -rho2) \
                 - k * df * M(y1 - v1 * np.sqrt(t), y2 - v2 * np.sqrt(t), rho)
-        elif self._payoff_type == FXRainbowOptionTypes.PUT_ON_MAXIMUM:
+        elif self.payoff_type == FXRainbowOptionTypes.PUT_ON_MAXIMUM:
             cmax1 = s2 * dq2 + s1 * dq1 * N(d) - s2 * dq2 * N(d - v * sqrtt)
             cmax2 = s1 * dq1 * M(y1, d, rho1) \
                 + s2 * dq2 * M(y2, -d + v * sqrtt, rho2) \
                 - k * df * (1.0 - M(-y1 + v1 * sqrtt, -y2 + v2 * sqrtt, rho))
             v = k * df - cmax1 + cmax2
-        elif self._payoff_type == FXRainbowOptionTypes.PUT_ON_MINIMUM:
+        elif self.payoff_type == FXRainbowOptionTypes.PUT_ON_MINIMUM:
             cmin1 = s1 * dq1 - s1 * dq1 * N(d) + s2 * dq2 * N(d - v * sqrtt)
             cmin2 = s1 * dq1 * M(y1, -d, -rho1) + s2 * dq2 * M(y2, d - v * sqrtt, -rho2) - k * df * M(y1 - v1 * sqrtt, y2 - v2 * sqrtt,
                                                                                                       rho)
             v = k * df - cmin1 + cmin2
         else:
             raise FinError("Unsupported FX Rainbow option type")
 
@@ -278,24 +278,24 @@
                       dividend_yields,
                       volatilities,
                       betas)
 
         if value_dt > expiry_dt:
             raise FinError("Value date after expiry date.")
 
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
         v = value_mc_fast(t,
                           stock_prices,
                           discount_curve,
                           dividend_yields,
                           volatilities,
                           betas,
-                          self._num_assets,
-                          self._payoff_type,
-                          self._payoff_params,
+                          self.num_assets,
+                          self.payoff_type,
+                          self.payoff_params,
                           num_paths,
                           seed)
 
         return v
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/fx/fx_vanilla_option.py` & `financepy-0.360/financepy/products/fx/fx_vanilla_option.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 import numpy as np
 from scipy import optimize
 from numba import njit
 
 from ...utils.date import Date
 from ...utils.math import nprime
-from ...utils.global_vars import gDaysInYear, gSmall
+from ...utils.global_vars import gDaysInYear, g_small
 from ...utils.error import FinError
 from ...utils.global_types import OptionTypes
 #from ...products.fx.FinFXModelTypes import FinFXModel
 #from ...products.fx.FinFXModelTypes import FinFXModelBlackScholes
 #from ...products.fx.FinFXModelTypes import FinFXModelSABR
 from ...products.fx.fx_mkt_conventions import FinFXDeltaMethod
 
@@ -35,24 +35,24 @@
 def f(volatility, *args):
     """ This is the objective function used in the determination of the FX
     Option implied volatility which is computed in the class below. """
 
     self = args[0]
     value_dt = args[1]
     spot_fx_rate = args[2]
-    dom_discount_curve = args[3]
-    for_discount_curve = args[4]
+    domestic_curve = args[3]
+    foreign_curve = args[4]
     price = args[5]
 
     model = BlackScholes(volatility)
 
     vdf = self.value(value_dt,
                      spot_fx_rate,
-                     dom_discount_curve,
-                     for_discount_curve,
+                     domestic_curve,
+                     foreign_curve,
                      model)['v']
 
     obj_fn = vdf - price
 
     return obj_fn
 
 ###############################################################################
@@ -62,23 +62,23 @@
     """ This is the derivative of the objective function with respect to the
     option volatility. It is used to speed up the determination of the FX
     Option implied volatility which is computed in the class below. """
 
     self = args[0]
     value_dt = args[1]
     spot_fx_rate = args[2]
-    dom_discount_curve = args[3]
-    for_discount_curve = args[4]
+    domestic_curve = args[3]
+    foreign_curve = args[4]
 
     model = BlackScholes(volatility)
 
     fprime = self.vega(value_dt,
                        spot_fx_rate,
-                       dom_discount_curve,
-                       for_discount_curve,
+                       domestic_curve,
+                       foreign_curve,
                        model)
 
     return fprime
 
 ###############################################################################
 
 
@@ -111,28 +111,28 @@
 # def g(K, *args):
 #     """ This is the objective function used in the determination of the FX
 #     Option implied strike which is computed in the class below. """
 
 #     self = args[0]
 #     value_dt = args[1]
 #     stock_price = args[2]
-#     dom_discount_curve = args[3]
-#     for_discount_curve = args[4]
+#     domestic_curve = args[3]
+#     foreign_curve = args[4]
 #     delta = args[5]
 #     deltaType = args[6]
 #     volatility = args[7]
 
 #     model = FinFXModelBlackScholes(volatility)
 
-#     self._strike_fx_rate = K
+#     self.strike_fx_rate = K
 
 #     deltaDict = self.delta(value_dt,
 #                            stock_price,
-#                            dom_discount_curve,
-#                            for_discount_curve,
+#                            domestic_curve,
+#                            foreign_curve,
 #                            model)
 
 #     delta_out = deltaDict[deltaType]
 #     obj_fn = delta - delta_out
 #     return obj_fn
 
 # ## THIS IS A HOPEFULLY FASTER VERSION WHICH AVOIDS CALLING DF
@@ -146,15 +146,15 @@
 #     stock_price = args[2]
 #     dom_df = args[3]
 #     for_df = args[4]
 #     delta = args[5]
 #     deltaType = args[6]
 #     volatility = args[7]
 
-#     self._strike_fx_rate = K
+#     self.strike_fx_rate = K
 
 #     deltaDict = self.fast_delta(value_dt,
 #                                stock_price,
 #                                dom_df,
 #                                for_df,
 #                                volatility)
 
@@ -206,179 +206,178 @@
 
         if delivery_dt < expiry_dt:
             raise FinError("Delivery date must be on or after expiry date.")
 
         if len(currency_pair) != 6:
             raise FinError("Currency pair must be 6 characters.")
 
-        self._expiry_dt = expiry_dt
-        self._delivery_dt = delivery_dt
+        self.expiry_dt = expiry_dt
+        self.delivery_dt = delivery_dt
 
         if np.any(strike_fx_rate < 0.0):
             raise FinError("Negative strike.")
 
-        self._strike_fx_rate = strike_fx_rate
+        self.strike_fx_rate = strike_fx_rate
 
-        self._currency_pair = currency_pair
-        self._forName = self._currency_pair[0:3]
-        self._domName = self._currency_pair[3:6]
+        self.currency_pair = currency_pair
+        self.for_name = self.currency_pair[0:3]
+        self.dom_name = self.currency_pair[3:6]
 
-        if prem_currency != self._domName and prem_currency != self._forName:
+        if prem_currency != self.dom_name and prem_currency != self.for_name:
             raise FinError("Premium currency not in currency pair.")
 
-        self._prem_currency = prem_currency
+        self.prem_currency = prem_currency
 
-        self._notional = notional
+        self.notional = notional
 
         if option_type != OptionTypes.EUROPEAN_CALL and \
            option_type != OptionTypes.EUROPEAN_PUT and\
            option_type != OptionTypes.AMERICAN_CALL and \
            option_type != OptionTypes.AMERICAN_PUT:
             raise FinError("Unknown Option Type:" + option_type)
 
-        self._option_type = option_type
-        self._spot_days = spot_days
+        self.option_type = option_type
+        self.spot_days = spot_days
 
 ###############################################################################
 
     def value(self,
               value_dt,
               spot_fx_rate,  # 1 unit of foreign in domestic
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ This function calculates the value of the option using a specified
         model with the resulting value being in domestic i.e. ccy2 terms.
         Recall that Domestic = CCY2 and Foreign = CCY1 and FX rate is in
         price in domestic of one unit of foreign currency. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
+        if value_dt > self.expiry_dt:
             raise FinError("Valuation date after expiry date.")
 
-        if dom_discount_curve._value_dt != value_dt:
+        if domestic_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as valuation date")
 
-        if for_discount_curve._value_dt != value_dt:
+        if foreign_curve.value_dt != value_dt:
             raise FinError(
                 "Foreign Curve valuation date not same as valuation date")
 
         if isinstance(value_dt, Date):
-            spot_dt = value_dt.add_weekdays(self._spot_days)
-            tdel = (self._delivery_dt - spot_dt) / gDaysInYear
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            spot_dt = value_dt.add_weekdays(self.spot_days)
+            t_del = (self.delivery_dt - spot_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
-            tdel = value_dt
-            t_exp = tdel
+            t_del = value_dt
+            t_exp = t_del
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("spot_fx_rate must be greater than zero.")
 
-        if tdel < 0.0:
+        if t_del < 0.0:
             raise FinError("Time to expiry must be positive.")
 
-        tdel = np.maximum(tdel, 1e-10)
+        t_del = np.maximum(t_del, 1e-10)
 
-        # TODO RESOLVE TDEL versus TEXP
-        dom_df = dom_discount_curve._df(tdel)
-        for_df = for_discount_curve._df(tdel)
+        # TODO RESOLVE t_del versus TEXP
+        dom_df = domestic_curve._df(t_del)
+        for_df = foreign_curve._df(t_del)
 
-        r_d = -np.log(dom_df) / tdel
-        r_f = -np.log(for_df) / tdel
+        r_d = -np.log(dom_df) / t_del
+        r_f = -np.log(for_df) / t_del
 
         s0 = spot_fx_rate
-        k = self._strike_fx_rate
-        f0t = s0 * np.exp((r_d-r_f)*tdel)
+        k = self.strike_fx_rate
+        f0t = s0 * np.exp((r_d-r_f)*t_del)
 
-        if type(model) == BlackScholes or \
-           type(model) == SABR:
+        if isinstance(model, BlackScholes) or isinstance(model, SABR):
 
-            if type(model) == BlackScholes:
-                volatility = model._volatility
-            elif type(model) == SABR:
-
-                params_list = np.array([model._alpha,
-                                        model._beta,
-                                        model._rho,
-                                        model._nu])
+            if isinstance(model, BlackScholes):
+                volatility = model.volatility
+            elif isinstance(model, SABR):
 
-                volatility = vol_function_sabr(params_list, f0t, k, tdel)
+                params_list = np.array([model.alpha,
+                                        model.beta,
+                                        model.rho,
+                                        model.nu])
+
+                volatility = vol_function_sabr(params_list, f0t, k, t_del)
 
             if np.any(volatility < 0.0):
                 raise FinError("Volatility should not be negative.")
 
             v = np.maximum(volatility, 1e-10)
 
-            if self._option_type == OptionTypes.EUROPEAN_CALL:
+            if self.option_type == OptionTypes.EUROPEAN_CALL:
 
                 vdf = bs_value(s0, t_exp, k, r_d, r_f, v,
                                OptionTypes.EUROPEAN_CALL.value)
 
-            elif self._option_type == OptionTypes.EUROPEAN_PUT:
+            elif self.option_type == OptionTypes.EUROPEAN_PUT:
 
                 vdf = bs_value(s0, t_exp, k, r_d, r_f, v,
                                OptionTypes.EUROPEAN_PUT.value)
 
-            elif self._option_type == OptionTypes.AMERICAN_CALL:
+            elif self.option_type == OptionTypes.AMERICAN_CALL:
 
                 num_steps_per_year = 100
 
                 vdf = crr_tree_val_avg(s0, r_d, r_f, volatility,
                                        num_steps_per_year,
                                        t_exp, OptionTypes.AMERICAN_CALL.value,
                                        k)['value']
 
-            elif self._option_type == OptionTypes.AMERICAN_PUT:
+            elif self.option_type == OptionTypes.AMERICAN_PUT:
 
                 num_steps_per_year = 100
 
                 vdf = crr_tree_val_avg(s0, r_d, r_f, volatility,
                                        num_steps_per_year,
                                        t_exp, OptionTypes.AMERICAN_PUT.value,
                                        k)['value']
             else:
                 raise FinError("Unknown option type")
 
         # The option value v is in domestic currency terms but the value of
         # the option may be quoted in either currency terms and so we calculate
         # these
 
-        if self._prem_currency == self._domName:
-            notional_dom = self._notional
-            notional_for = self._notional / self._strike_fx_rate
-        elif self._prem_currency == self._forName:
-            notional_dom = self._notional * self._strike_fx_rate
-            notional_for = self._notional
+        if self.prem_currency == self.dom_name:
+            notional_dom = self.notional
+            notional_for = self.notional / self.strike_fx_rate
+        elif self.prem_currency == self.for_name:
+            notional_dom = self.notional * self.strike_fx_rate
+            notional_for = self.notional
         else:
             raise FinError("Invalid notional currency.")
 
         vdf = vdf
         pips_dom = vdf
-        pips_for = vdf / (spot_fx_rate * self._strike_fx_rate)
+        pips_for = vdf / (spot_fx_rate * self.strike_fx_rate)
 
-        cash_dom = vdf * notional_dom / self._strike_fx_rate
+        cash_dom = vdf * notional_dom / self.strike_fx_rate
         cash_for = vdf * notional_for / spot_fx_rate
 
-        pct_dom = vdf / self._strike_fx_rate
+        pct_dom = vdf / self.strike_fx_rate
         pct_for = vdf / spot_fx_rate
 
         return {'v': vdf,
                 "cash_dom": cash_dom,
                 "cash_for": cash_for,
                 "pips_dom": pips_dom,
                 "pips_for": pips_for,
                 "pct_dom": pct_dom,
                 "pct_for": pct_for,
                 "not_dom": notional_dom,
                 "not_for": notional_for,
-                "ccy_dom": self._domName,
-                "ccy_for": self._forName}
+                "ccy_dom": self.dom_name,
+                "ccy_for": self.for_name}
 
 ###############################################################################
 
     def delta_bump(self,
                    value_dt,
                    spot_fx_rate,
                    ccy1DiscountCurve,
@@ -393,83 +392,83 @@
         v = self.value(
             value_dt,
             spot_fx_rate,
             ccy1DiscountCurve,
             ccy2DiscountCurve,
             model)
 
-        vBumped = self.value(
+        v_bumped = self.value(
             value_dt,
             spot_fx_rate + bump,
             ccy1DiscountCurve,
             ccy2DiscountCurve,
             model)
 
-        if type(vBumped) is dict:
-            delta = (vBumped['value'] - v['value']) / bump
+        if type(v_bumped) is dict:
+            delta = (v_bumped['value'] - v['value']) / bump
         else:
-            delta = (vBumped - v) / bump
+            delta = (v_bumped - v) / bump
 
         return delta
 
 ###############################################################################
 
     def delta(self,
               value_dt,
               spot_fx_rate,
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ Calculation of the FX Option delta. There are several definitions
         of delta and so we are required to return a dictionary of values. The
         definitions can be found on Page 44 of Foreign Exchange Option Pricing
         by Iain Clark, published by Wiley Finance. """
 
         if isinstance(value_dt, Date):
-            spot_dt = value_dt.add_weekdays(self._spot_days)
-            tdel = (self._delivery_dt - spot_dt) / gDaysInYear
-            t_exp = (self._expiry_dt - value_dt) / gDaysInYear
+            spot_dt = value_dt.add_weekdays(self.spot_days)
+            t_del = (self.delivery_dt - spot_dt) / gDaysInYear
+            t_exp = (self.expiry_dt - value_dt) / gDaysInYear
         else:
-            tdel = value_dt
-            t_exp = tdel
+            t_del = value_dt
+            t_exp = t_del
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("Spot FX Rate must be greater than zero.")
 
-        if np.any(tdel < 0.0):
+        if np.any(t_del < 0.0):
             raise FinError("Time to expiry must be positive.")
 
-        tdel = np.maximum(tdel, 1e-10)
+        t_del = np.maximum(t_del, 1e-10)
 
-        dom_df = dom_discount_curve._df(tdel)
-        r_d = -np.log(dom_df)/tdel
+        dom_df = domestic_curve._df(t_del)
+        r_d = -np.log(dom_df)/t_del
 
-        for_df = for_discount_curve._df(tdel)
-        r_f = -np.log(for_df)/tdel
+        for_df = foreign_curve._df(t_del)
+        r_f = -np.log(for_df)/t_del
 
-        S0 = spot_fx_rate
-        K = self._strike_fx_rate
+        s0 = spot_fx_rate
+        K = self.strike_fx_rate
 
-        if type(model) == BlackScholes:
+        if isinstance(model, BlackScholes):
 
-            v = model._volatility
+            v = model.volatility
 
             if np.any(v < 0.0):
                 raise FinError("Volatility should not be negative.")
 
-            v = np.maximum(v, gSmall)
+            v = np.maximum(v, g_small)
 
             pips_spot_delta = bs_delta(
-                S0, t_exp, K, r_d, r_f, v, self._option_type.value)
-            pips_fwd_delta = pips_spot_delta * np.exp(r_f*tdel)
-            vpctf = bs_value(S0, t_exp, K, r_d, r_f, v,
-                             self._option_type.value) / S0
+                s0, t_exp, K, r_d, r_f, v, self.option_type.value)
+            pips_fwd_delta = pips_spot_delta * np.exp(r_f*t_del)
+            vpctf = bs_value(s0, t_exp, K, r_d, r_f, v,
+                             self.option_type.value) / s0
             pct_spot_delta_prem_adj = pips_spot_delta - vpctf
             pct_fwd_delta_prem_adj = np.exp(
-                r_f*tdel) * (pips_spot_delta - vpctf)
+                r_f*t_del) * (pips_spot_delta - vpctf)
 
         return {"pips_spot_delta": pips_spot_delta,
                 "pips_fwd_delta": pips_fwd_delta,
                 "pct_spot_delta_prem_adj": pct_spot_delta_prem_adj,
                 "pct_fwd_delta_prem_adj": pct_fwd_delta_prem_adj}
 
 ###############################################################################
@@ -480,204 +479,204 @@
                    rd,
                    rf,
                    vol):
         """ Calculation of the FX Option delta. Used in the determination of
         the volatility surface. Avoids discount curve interpolation so it
         should be slightly faster than the full calculation of delta. """
 
-#        spot_dt = value_dt.add_weekdays(self._spot_days)
-#        tdel = (self._delivery_dt - value_dt) / gDaysInYear
-#        tdel = np.maximum(tdel, gSmall)
-
-#        r_d = -np.log(dom_df)/tdel
-#         r_f = -np.log(for_df)/tdel
-        k = self._strike_fx_rate
+#        spot_dt = value_dt.add_weekdays(self.spot_days)
+#        t_del = (self.delivery_dt - value_dt) / gDaysInYear
+#        t_del = np.maximum(t_del, g_small)
+
+#        r_d = -np.log(dom_df)/t_del
+#         r_f = -np.log(for_df)/t_del
+        k = self.strike_fx_rate
 
 #        print("FAST DELTA IN OPTION CLASS", s,t,k,rd,rf,vol)
 
         pips_spot_delta = bs_delta(s, t, k, rd, rf, vol,
-                                   self._option_type.value)
+                                   self.option_type.value)
         pips_fwd_delta = pips_spot_delta * np.exp(rf*t)
 
-        vpctf = bs_value(s, t, k, rd, rf, vol, self._option_type.value) / s
+        vpctf = bs_value(s, t, k, rd, rf, vol, self.option_type.value) / s
 
         pct_spot_delta_prem_adj = pips_spot_delta - vpctf
         pct_fwd_delta_prem_adj = np.exp(rf*t) * (pips_spot_delta - vpctf)
 
         return {"pips_spot_delta": pips_spot_delta,
                 "pips_fwd_delta": pips_fwd_delta,
                 "pct_spot_delta_prem_adj": pct_spot_delta_prem_adj,
                 "pct_fwd_delta_prem_adj": pct_fwd_delta_prem_adj}
 
 ###############################################################################
 
     def gamma(self,
               value_dt,
               spot_fx_rate,  # value of a unit of foreign in domestic currency
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ This function calculates the FX Option Gamma using the spot delta.
         """
 
         if isinstance(value_dt, Date):
-            t = (self._expiry_dt - value_dt) / gDaysInYear
+            t = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t = value_dt
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("FX Rate must be greater than zero.")
 
         if np.any(t < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         t = np.maximum(t, 1e-10)
 
-        dom_df = dom_discount_curve.df(t)
+        dom_df = domestic_curve._df(t)
         r_d = -np.log(dom_df)/t
 
-        for_df = for_discount_curve.df(t)
+        for_df = foreign_curve._df(t)
         r_f = -np.log(for_df)/t
 
-        K = self._strike_fx_rate
-        S0 = spot_fx_rate
+        K = self.strike_fx_rate
+        s0 = spot_fx_rate
 
-        if type(model) == BlackScholes:
+        if isinstance(model, BlackScholes):
 
-            volatility = model._volatility
+            volatility = model.volatility
 
             if np.any(volatility) < 0.0:
                 raise FinError("Volatility should not be negative.")
 
             volatility = np.maximum(volatility, 1e-10)
 
-            lnS0k = np.log(S0 / K)
-            sqrtT = np.sqrt(t)
-            den = volatility * sqrtT
+            ln_s0_k = np.log(s0 / K)
+            sqrt_t = np.sqrt(t)
+            den = volatility * sqrt_t
             mu = r_d - r_f
             v2 = volatility * volatility
-            d1 = (lnS0k + (mu + v2 / 2.0) * t) / den
+            d1 = (ln_s0_k + (mu + v2 / 2.0) * t) / den
             gamma = np.exp(-r_f * t) * nprime(d1)
-            gamma = gamma / S0 / den
+            gamma = gamma / s0 / den
         else:
             raise FinError("Unknown Model Type")
 
         return gamma
 
 ###############################################################################
 
     def vega(self,
              value_dt,
              spot_fx_rate,  # value of a unit of foreign in domestic currency
-             dom_discount_curve,
-             for_discount_curve,
+             domestic_curve,
+             foreign_curve,
              model):
         """ This function calculates the FX Option Vega using the spot delta.
         """
 
         if isinstance(value_dt, Date):
-            t = (self._expiry_dt - value_dt) / gDaysInYear
+            t = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t = value_dt
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("Spot FX Rate must be greater than zero.")
 
         if np.any(t < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         t = np.maximum(t, 1e-10)
 
-        dom_df = dom_discount_curve._df(t)
+        dom_df = domestic_curve._df(t)
         r_d = -np.log(dom_df)/t
 
-        for_df = for_discount_curve._df(t)
+        for_df = foreign_curve._df(t)
         r_f = -np.log(for_df)/t
 
-        K = self._strike_fx_rate
-        S0 = spot_fx_rate
+        K = self.strike_fx_rate
+        s0 = spot_fx_rate
 
-        if type(model) == BlackScholes:
+        if isinstance(model, BlackScholes):
 
-            volatility = model._volatility
+            volatility = model.volatility
 
             if np.any(volatility) < 0.0:
                 raise FinError("Volatility should not be negative.")
 
             volatility = np.maximum(volatility, 1e-10)
 
-            lnS0k = np.log(S0/K)
-            sqrtT = np.sqrt(t)
-            den = volatility * sqrtT
+            ln_s0_k = np.log(s0/K)
+            sqrt_t = np.sqrt(t)
+            den = volatility * sqrt_t
             mu = r_d - r_f
             v2 = volatility * volatility
-            d1 = (lnS0k + (mu + v2 / 2.0) * t) / den
-            vega = S0 * sqrtT * np.exp(-r_f * t) * nprime(d1)
+            d1 = (ln_s0_k + (mu + v2 / 2.0) * t) / den
+            vega = s0 * sqrt_t * np.exp(-r_f * t) * nprime(d1)
         else:
             raise FinError("Unknown Model type")
 
         return vega
 
 ###############################################################################
 
     def theta(self,
               value_dt,
               spot_fx_rate,  # value of a unit of foreign in domestic currency
-              dom_discount_curve,
-              for_discount_curve,
+              domestic_curve,
+              foreign_curve,
               model):
         """ This function calculates the time decay of the FX option. """
 
         if isinstance(value_dt, Date):
-            t = (self._expiry_dt - value_dt) / gDaysInYear
+            t = (self.expiry_dt - value_dt) / gDaysInYear
         else:
             t = value_dt
 
         if np.any(spot_fx_rate <= 0.0):
             raise FinError("Spot FX Rate must be greater than zero.")
 
         if np.any(t < 0.0):
             raise FinError("Time to expiry must be positive.")
 
         t = np.maximum(t, 1e-10)
 
-        dom_df = dom_discount_curve._df(t)
+        dom_df = domestic_curve._df(t)
         r_d = -np.log(dom_df)/t
 
-        for_df = for_discount_curve._df(t)
+        for_df = foreign_curve._df(t)
         r_f = -np.log(for_df)/t
 
-        K = self._strike_fx_rate
-        S0 = spot_fx_rate
+        K = self.strike_fx_rate
+        s0 = spot_fx_rate
 
-        if type(model) == BlackScholes:
+        if isinstance(model, BlackScholes):
 
-            vol = model._volatility
+            vol = model.volatility
 
             if np.any(vol) < 0.0:
                 raise FinError("Volatility should not be negative.")
 
             vol = np.maximum(vol, 1e-10)
 
-            lnS0k = np.log(S0/K)
-            sqrtT = np.sqrt(t)
-            den = vol * sqrtT
+            ln_s0_k = np.log(s0/K)
+            sqrt_t = np.sqrt(t)
+            den = vol * sqrt_t
             mu = r_d - r_f
             v2 = vol * vol
-            d1 = (lnS0k + (mu + v2 / 2.0) * t) / den
-            d2 = (lnS0k + (mu - v2 / 2.0) * t) / den
+            d1 = (ln_s0_k + (mu + v2 / 2.0) * t) / den
+            d2 = (ln_s0_k + (mu - v2 / 2.0) * t) / den
 
-            if self._option_type == OptionTypes.EUROPEAN_CALL:
-                v = - S0 * np.exp(-r_f * t) * nprime(d1) * vol / 2.0 / sqrtT
-                v = v + r_f * S0 * np.exp(-r_f * t) * N(d1)
+            if self.option_type == OptionTypes.EUROPEAN_CALL:
+                v = - s0 * np.exp(-r_f * t) * nprime(d1) * vol / 2.0 / sqrt_t
+                v = v + r_f * s0 * np.exp(-r_f * t) * N(d1)
                 v = v - r_d * K * np.exp(-r_d * t) * N(d2)
-            elif self._option_type == OptionTypes.EUROPEAN_PUT:
-                v = - S0 * np.exp(-r_f * t) * nprime(d1) * vol / 2.0 / sqrtT
+            elif self.option_type == OptionTypes.EUROPEAN_PUT:
+                v = - s0 * np.exp(-r_f * t) * nprime(d1) * vol / 2.0 / sqrt_t
                 v = v + r_d * K * np.exp(-r_d * t) * N(-d2)
-                v = v - r_f * S0 * np.exp(-r_f * t) * N(-d1)
+                v = v - r_f * s0 * np.exp(-r_f * t) * N(-d1)
             else:
                 raise FinError("Unknown option type")
 
         else:
             raise FinError("Unknown Model Type")
 
         return v
@@ -702,75 +701,75 @@
         return sigma
 
 ###############################################################################
 
     def value_mc(self,
                  value_dt,
                  spot_fx_rate,
-                 dom_discount_curve,
-                 for_discount_curve,
+                 domestic_curve,
+                 foreign_curve,
                  model,
                  num_paths=10000,
                  seed=4242):
         """ Calculate the value of an FX Option using Monte Carlo methods.
         This function can be used to validate the risk measures calculated
         above or used as the starting code for a model exotic FX product that
         cannot be priced analytically. This function uses Numpy vectorisation
         for speed of execution."""
 
         if isinstance(model, BlackScholes):
-            volatility = model._volatility
+            volatility = model.volatility
         else:
             raise FinError("Model Type invalid")
 
         np.random.seed(seed)
-        t = (self._expiry_dt - value_dt) / gDaysInYear
+        t = (self.expiry_dt - value_dt) / gDaysInYear
 
-        dom_Df = dom_discount_curve.df(self._expiry_dt)
-        for_Df = for_discount_curve.df(self._expiry_dt)
+        dom_Df = domestic_curve.df(self.expiry_dt)
+        for_Df = foreign_curve.df(self.expiry_dt)
 
         r_d = -np.log(dom_Df)/t
         r_f = -np.log(for_Df)/t
 
         mu = r_d - r_f
         v2 = volatility**2
-        K = self._strike_fx_rate
+        K = self.strike_fx_rate
         sqrt_dt = np.sqrt(t)
 
         # Use Antithetic variables
         g = np.random.normal(0.0, 1.0, size=(1, num_paths))
         s = spot_fx_rate * np.exp((mu - v2 / 2.0) * t)
         m = np.exp(g * sqrt_dt * volatility)
         s_1 = s * m
         s_2 = s / m
 
-        if self._option_type == OptionTypes.EUROPEAN_CALL:
+        if self.option_type == OptionTypes.EUROPEAN_CALL:
             payoff_a_1 = np.maximum(s_1 - K, 0.0)
             payoff_a_2 = np.maximum(s_2 - K, 0.0)
-        elif self._option_type == OptionTypes.EUROPEAN_PUT:
+        elif self.option_type == OptionTypes.EUROPEAN_PUT:
             payoff_a_1 = np.maximum(K - s_1, 0.0)
             payoff_a_2 = np.maximum(K - s_2, 0.0)
         else:
             raise FinError("Unknown option type.")
 
         payoff = np.mean(payoff_a_1) + np.mean(payoff_a_2)
         v = payoff * np.exp(-r_d * t) / 2.0
         return v
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("EXPIRY DATE", self._expiry_dt)
-        s += label_to_string("CURRENCY PAIR", self._currency_pair)
-        s += label_to_string("PREMIUM CCY", self._prem_currency)
-        s += label_to_string("STRIKE FX RATE", self._strike_fx_rate)
-        s += label_to_string("OPTION TYPE", self._option_type)
-        s += label_to_string("SPOT DAYS", self._spot_days)
-        s += label_to_string("NOTIONAL", self._notional, "")
+        s += label_to_string("EXPIRY DATE", self.expiry_dt)
+        s += label_to_string("CURRENCY PAIR", self.currency_pair)
+        s += label_to_string("PREMIUM CCY", self.prem_currency)
+        s += label_to_string("STRIKE FX RATE", self.strike_fx_rate)
+        s += label_to_string("OPTION TYPE", self.option_type)
+        s += label_to_string("SPOT DAYS", self.spot_days)
+        s += label_to_string("NOTIONAL", self.notional, "")
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
         print(self)
```

### Comparing `financepy-0.350/financepy/products/fx/fx_variance_swap.py` & `financepy-0.360/financepy/products/fx/fx_variance_swap.py`

 * *Files 12% similar despite different names*

```diff
@@ -34,77 +34,77 @@
             maturity_dt = maturity_dt_or_tenor
         else:
             maturity_dt = effective_dt.add_tenor(maturity_dt_or_tenor)
 
         if effective_dt >= maturity_dt:
             raise FinError("Start date after or same as maturity date")
 
-        self._effective_dt = effective_dt
-        self._maturity_dt = maturity_dt
-        self._strike_variance = strike_variance
-        self._notional = notional
-        self._payStrike = pay_strike_flag
+        self.effective_dt = effective_dt
+        self.maturity_dt = maturity_dt
+        self.strike_variance = strike_variance
+        self.notional = notional
+        self.payStrike = pay_strike_flag
 
         # Replication portfolio is stored
-        self._num_put_options = 0
-        self._num_call_options = 0
-        self._putWts = []
-        self._put_strikes = []
-        self._callWts = []
-        self._call_strikes = []
+        self.num_put_options = 0
+        self.num_call_options = 0
+        self.put_wts = []
+        self.put_strikes = []
+        self.call_wts = []
+        self.call_strikes = []
 
 ###############################################################################
 
     def value(self,
               value_dt,
-              realisedVar,
-              fair_strikeVar,
+              realised_var,
+              fair_strike_var,
               libor_curve):
         """ Calculate the value of the variance swap based on the realised
         volatility to the valuation date, the forward looking implied
         volatility to the maturity date using the libor discount curve. """
 
         if isinstance(value_dt, Date) is False:
             raise FinError("Valuation date is not a Date")
 
-        if value_dt > self._expiry_dt:
-            raise FinError("Valuation date after expiry date.")
+        if value_dt > self.maturity_dt:
+            raise FinError("Valuation date after maturity date.")
 
-        if libor_curve._value_dt != value_dt:
+        if libor_curve.value_dt != value_dt:
             raise FinError(
                 "Domestic Curve valuation date not same as option value date")
 
-        t1 = (value_dt - self._effective_dt) / gDaysInYear
-        t2 = (self._maturity_dt - self._effective_dt) / gDaysInYear
+        t1 = (value_dt - self.effective_dt) / gDaysInYear
+        t2 = (self.maturity_dt - self.effective_dt) / gDaysInYear
 
-        expectedVariance = t1 * realisedVar/t2
-        expectedVariance += (t2-t1) * fair_strikeVar / t2
+        expected_var = t1 * realised_var/t2
+        expected_var += (t2-t1) * fair_strike_var / t2
 
-        payoff = expectedVariance - self._strike_variance
+        payoff = expected_var - self.strike_variance
 
-        df = libor_curve.df(self._maturity_dt)
-        v = payoff * self._notional * df
+        df = libor_curve.df(self.maturity_dt)
+        v = payoff * self.notional * df
         return v
 
 ###############################################################################
 
     def fair_strike_approx(self,
                            value_dt,
-                           fwdStockPrice,
+                           fwd_stock_price,
                            strikes,
                            volatilities):
         """ This is an approximation of the fair strike variance by Demeterfi
         et al. (1999) which assumes that sigma(K) = sigma(F) - b(K-F)/F where
         F is the forward stock price and sigma(F) is the ATM forward vol. """
 
-        f = fwdStockPrice
+        f = fwd_stock_price
 
         # TODO Linear interpolation - to be revisited
         atm_vol = np.interp(f, strikes, volatilities)
-        t_mat = (self._maturity_dt - value_dt)/gDaysInYear
+        t_mat = (self.maturity_dt - value_dt)/gDaysInYear
 
         """ Calculate the slope of the volatility curve by taking the end
         points in the volatilities and strikes to calculate the gradient."""
 
         dvol = volatilities[-1] - volatilities[0]
         dK = strikes[-1] - strikes[0]
         b = f * dvol / dK
@@ -124,21 +124,21 @@
                     discount_curve,
                     use_forward=True):
         """ Calculate the implied variance according to the volatility surface
         using a static replication methodology with a specially weighted
         portfolio of put and call options across a range of strikes using the
         approximate method set out by Demeterfi et al. 1999. """
 
-        self._num_put_options = num_put_options
-        self._num_call_options = num_call_options
+        self.num_put_options = num_put_options
+        self.num_call_options = num_call_options
 
         call_type = OptionTypes.EUROPEAN_CALL
         put_type = OptionTypes.EUROPEAN_PUT
 
-        t_mat = (self._maturity_dt - value_dt)/gDaysInYear
+        t_mat = (self.maturity_dt - value_dt)/gDaysInYear
 
         df = discount_curve.df(t_mat)
         r = - np.log(df)/t_mat
 
         dq = dividend_curve.df(t_mat)
         q = - np.log(dq)/t_mat
 
@@ -152,126 +152,128 @@
         else:
             sstar = stock_price
 
         """ Replication argument from Demeterfi, Derman, Kamal and Zhou from
         Goldman Sachs Research notes March 1999. See Appendix A. This aim is
         to use calls and puts to approximate the payoff of a log contract """
 
-        minStrike = sstar - (num_put_options+1) * strike_spacing
+        min_strike = sstar - (num_put_options+1) * strike_spacing
 
-        self._putWts = []
-        self._put_strikes = []
-        self._callWts = []
-        self._call_strikes = []
+        self.put_wts = []
+        self.put_strikes = []
+        self.call_wts = []
+        self.call_strikes = []
 
         # if the lower strike is < 0 we go to as low as the strike spacing
-        if minStrike < strike_spacing:
+        if min_strike < strike_spacing:
             k = sstar
             klist = [sstar]
             while k >= strike_spacing:
                 k -= strike_spacing
                 klist.append(k)
-            putK = np.array(klist)
-            self._num_put_options = len(putK) - 1
+            put_k = np.array(klist)
+            self.num_put_options = len(put_k) - 1
         else:
-            putK = np.linspace(sstar, minStrike, num_put_options+2)
+            put_k = np.linspace(sstar, min_strike, num_put_options+2)
 
-        self._put_strikes = putK
+        self.put_strikes = put_k
 
-        maxStrike = sstar + (num_call_options+1) * strike_spacing
-        callK = np.linspace(sstar, maxStrike, num_call_options+2)
+        max_strike = sstar + (num_call_options+1) * strike_spacing
+        call_k = np.linspace(sstar, max_strike, num_call_options+2)
 
-        self._call_strikes = callK
+        self.call_strikes = call_k
 
-        optionTotal = 2.0*(r*t_mat - (s0*g/sstar-1.0) - np.log(sstar/s0))/t_mat
+        option_total = 2.0*(r*t_mat - (s0*g/sstar-1.0) -
+                            np.log(sstar/s0))/t_mat
 
-        self._callWts = np.zeros(num_call_options)
-        self._putWts = np.zeros(num_put_options)
+        self.call_wts = np.zeros(num_call_options)
+        self.put_wts = np.zeros(num_put_options)
 
         def f(x): return (2.0/t_mat)*((x-sstar)/sstar-np.log(x/sstar))
 
-        sumWts = 0.0
-        for n in range(0, self._num_put_options):
-            kp = putK[n+1]
-            k = putK[n]
-            self._putWts[n] = (f(kp)-f(k))/(k-kp) - sumWts
-            sumWts += self._putWts[n]
-
-        sumWts = 0.0
-        for n in range(0, self._num_call_options):
-            kp = callK[n+1]
-            k = callK[n]
-            self._callWts[n] = (f(kp)-f(k))/(kp-k) - sumWts
-            sumWts += self._callWts[n]
+        sum_wts = 0.0
+        for n in range(0, self.num_put_options):
+            kp = put_k[n+1]
+            k = put_k[n]
+            self.put_wts[n] = (f(kp)-f(k))/(k-kp) - sum_wts
+            sum_wts += self.put_wts[n]
+
+        sum_wts = 0.0
+        for n in range(0, self.num_call_options):
+            kp = call_k[n+1]
+            k = call_k[n]
+            self.call_wts[n] = (f(kp)-f(k))/(kp-k) - sum_wts
+            sum_wts += self.call_wts[n]
 
-        piPut = 0.0
+        pi_put = 0.0
         for n in range(0, num_put_options):
-            k = putK[n]
+            k = put_k[n]
             vol = volatility_curve.volatility(k)
-            opt = FXVanillaOption(self._maturity_dt, k, put_type)
+            opt = FXVanillaOption(self.maturity_dt, k, put_type)
             model = BlackScholes(vol)
             v = opt.value(value_dt, s0, discount_curve,
                           dividend_curve, model)
-            piPut += v * self._putWts[n]
+            pi_put += v * self.put_wts[n]
 
-        piCall = 0.0
+        pi_call = 0.0
         for n in range(0, num_call_options):
-            k = callK[n]
+            k = call_k[n]
             vol = volatility_curve.volatility(k)
-            opt = FXVanillaOption(self._maturity_dt, k, call_type)
+            opt = FXVanillaOption(self.maturity_dt, k, call_type)
             model = BlackScholes(vol)
             v = opt.value(value_dt, s0, discount_curve,
                           dividend_curve, model)
-            piCall += v * self._callWts[n]
+            pi_call += v * self.call_wts[n]
 
-        pi = piCall + piPut
-        optionTotal += g * pi
-        var = optionTotal
+        pi = pi_call + pi_put
+        option_total += g * pi
+        var = option_total
 
         return var
 
 ###############################################################################
 
-    def realised_variance(self, closePrices, use_logs=True):
+    def realised_variance(self, close_prices, use_logs=True):
         """ Calculate the realised variance according to market standard
         calculations which can either use log or percentage returns."""
 
-        num_observations = len(closePrices)
+        num_observations = len(close_prices)
 
         for i in range(0, num_observations):
-            if closePrices[i] <= 0.0:
+            if close_prices[i] <= 0.0:
                 raise FinError("Stock prices must be greater than zero")
 
-        cumX2 = 0.0
+        cum_x2 = 0.0
 
         if use_logs is True:
             for i in range(1, num_observations):
-                x = np.log(closePrices[i]/closePrices[i-1])
-                cumX2 += x*x
+                x = np.log(close_prices[i]/close_prices[i-1])
+                cum_x2 += x*x
         else:
             for i in range(1, num_observations):
-                x = (closePrices[i]-closePrices[i-1])/closePrices[i-1]
-                cumX2 += x*x
+                x = (close_prices[i]-close_prices[i-1])/close_prices[i-1]
+                cum_x2 += x*x
 
-        var = cumX2 * 252.0 / num_observations
+        var = cum_x2 * 252.0 / num_observations
         return var
 
 
 ###############################################################################
 
+
     def print_strikes(self):
 
-        if self._num_put_options == 0 and self._num_call_options == 0:
+        if self.num_put_options == 0 and self.num_call_options == 0:
             return
 
         print("TYPE", "STRIKE", "WEIGHT")
-        for n in range(0, self._num_put_options):
-            k = self._put_strikes[n]
-            wt = self._putWts[n]*self._notional
+        for n in range(0, self.num_put_options):
+            k = self.put_strikes[n]
+            wt = self.put_wts[n]*self.notional
             print("PUT %7.2f %10.3f" % (k, wt))
 
-        for n in range(0, self._num_call_options):
-            k = self._call_strikes[n]
-            wt = self._callWts[n]*self._notional
+        for n in range(0, self.num_call_options):
+            k = self.call_strikes[n]
+            wt = self.call_wts[n]*self.notional
             print("CALL %7.2f %10.3f" % (k, wt))
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/inflation/FinInflationIndexCurve.py` & `financepy-0.360/financepy/products/inflation/FinInflationIndexCurve.py`

 * *Files 12% similar despite different names*

```diff
@@ -24,92 +24,91 @@
     https://www.treasury.gov/about/organizational-structure/offices/Domestic-Finance/Documents/tips-presentation.pdf
 
     """
 
 ###############################################################################
 
     def __init__(self,
-                 index_dates: list,
+                 index_dts: list,
                  index_values: (list, np.ndarray),
                  lag_in_months: int = 3):
 
         check_argument_types(self.__init__, locals())
 
         # Validate curve
-        if len(index_dates) == 0:
+        if len(index_dts) == 0:
             raise FinError("Dates has zero length")
 
-        if len(index_dates) != len(index_values):
+        if len(index_dts) != len(index_values):
             raise FinError("Dates and Values are not the same length")
 
         if lag_in_months < 0:
             raise FinError("Lag must be positive.")
 
-        self._index_dates = np.array(index_dates)
-        self._index_values = np.array(index_values)
-        self._lag_in_months = lag_in_months
-        self._base_date = index_dates[0]
+        self.index_dts = np.array(index_dts)
+        self.index_values = np.array(index_values)
+        self.lag_in_months = lag_in_months
+        self.base_dt = index_dts[0]
+        self.index_times = times_from_dates(index_dts, self.base_dt)
 
-        self._indexTimes = times_from_dates(index_dates, self._base_date)
-
-        if test_monotonicity(self._indexTimes) is False:
+        if test_monotonicity(self.index_times) is False:
             raise FinError("Times or dates are not sorted in increasing order")
 
 ###############################################################################
 
     def index_value(self, dt: Date):
         """ Calculate index value by interpolating the CPI curve """
 
-        lagMonthsAgoDt = dt.add_months(-self._lag_in_months)
+        lagMonthsAgoDt = dt.add_months(-self.lag_in_months)
 
-        cpiFirstDate = Date(1, lagMonthsAgoDt._m, lagMonthsAgoDt._y)
-        cpiSecondDate = cpiFirstDate.add_months(1)
+        cpi_first_dt = Date(1, lagMonthsAgoDt.m, lagMonthsAgoDt.y)
+        cpi_second_dt = cpi_first_dt.add_months(1)
 
-        cpiFirstTime = (cpiFirstDate - self._base_date) / gDaysInYear
-        cpiSecondTime = (cpiSecondDate - self._base_date) / gDaysInYear
+        cpi_first_time = (cpi_first_dt - self.base_dt) / gDaysInYear
+        cpi_second_time = (cpi_second_dt - self.base_dt) / gDaysInYear
 
-        cpiFirstValue = np.interp(cpiFirstTime,
-                                  self._indexTimes,
-                                  self._index_values)
-
-        cpiSecondValue = np.interp(cpiSecondTime,
-                                   self._indexTimes,
-                                   self._index_values)
-
-        d = dt._d
-        m = dt._m
-        y = dt._y
-        numDays = days_in_month(m, y)
-        v = cpiFirstValue + (d - 1) * (cpiSecondValue -
-                                       cpiFirstValue) / numDays
+        cpi_first_value = np.interp(cpi_first_time,
+                                  self.index_times,
+                                  self.index_values)
+
+        cpi_second_value = np.interp(cpi_second_time,
+                                   self.index_times,
+                                   self.index_values)
+
+        d = dt.d
+        m = dt.m
+        y = dt.y
+        num_days = days_in_month(m, y)
+        v = cpi_first_value + (d - 1) * (cpi_second_value -
+                                       cpi_first_value) / num_days
         return v
 
 ###############################################################################
 
     def index_ratio(self, dt: Date):
         """ Calculate index value by interpolating the CPI curve """
 
         vt = self.index_value(dt)
-        v0 = self.index_value(self._base_date)
+        v0 = self.index_value(self.base_dt)
         index_ratio = vt / v0
         return index_ratio
 
 ###############################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("BASE DATE", self._base_date)
-        s += label_to_string("INDEX LAG", self._lag_in_months)
+        s += label_to_string("BASE DATE", self.base_dt)
+        s += label_to_string("INDEX LAG", self.lag_in_months)
 
         s += label_to_string("DATES", "ZERO RATES")
-        num_points = len(self._index_values)
+        num_points = len(self.index_values)
         for i in range(0, num_points):
-            s += label_to_string("%12s" % self._index_dates[i],
-                                 "%10.7f" % self._index_values[i])
+            s += label_to_string("%12s" % self.index_dts[i],
+                                 "%10.7f" % self.index_values[i])
 
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Simple print function for backward compatibility. """
```

### Comparing `financepy-0.350/financepy/products/inflation/FinInflationSwap.py` & `financepy-0.360/financepy/products/inflation/FinInflationSwap.py`

 * *Files 10% similar despite different names*

```diff
@@ -39,112 +39,112 @@
     assumed that the fixing date and the settlement date are the same date.
     This should be amended later. """
 
     def __init__(self,
                  start_dt: Date,  # The date the FRA starts to accrue
                  # End of the Ibor rate period
                  maturity_dt_or_tenor: (Date, str),
-                 fraRate: float,  # The fixed contractual FRA rate
+                 fra_rate: float,  # The fixed contractual FRA rate
                  day_count_type: DayCountTypes,  # For interest period
                  notional: float = 100.0,
-                 payFixedRate: bool = True,  # True if the FRA rate is being paid
+                 pay_fixed_rate: bool = True,  # True if the FRA rate is being paid
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.MODIFIED_FOLLOWING):
         """ Create a Forward Rate Agreeement object. """
 
         print("DO NOT USE")
         raise FinError("DO NOT USE")
 
         check_argument_types(self.__init__, locals())
 
-        self._cal_type = cal_type
-        self._bd_type = bd_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
 
         if type(maturity_dt_or_tenor) == Date:
             maturity_dt = maturity_dt_or_tenor
         else:
             maturity_dt = start_dt.add_tenor(maturity_dt_or_tenor)
-            calendar = Calendar(self._cal_type)
+            calendar = Calendar(self.cal_type)
             maturity_dt = calendar.adjust(maturity_dt,
-                                            self._bd_type)
+                                            self.bd_type)
 
         if start_dt > maturity_dt:
             raise FinError("Settlement date after maturity date")
 
-        self._start_dt = start_dt
-        self._maturity_dt = maturity_dt
-        self._fraRate = fraRate
-        self._payFixedRate = payFixedRate
-        self._dc_type = day_count_type
-        self._notional = notional
+        self.start_dt = start_dt
+        self.maturity_dt = maturity_dt
+        self.fra_rate = fra_rate
+        self.pay_fixed_rate = pay_fixed_rate
+        self.dc_type = day_count_type
+        self.notional = notional
 
     ###########################################################################
 
     def value(self, value_dt, libor_curve):
         """ Determine mark to market value of a FRA contract based on the
         market FRA rate. The same curve is used for calculating the forward
         Ibor and for doing discounting on the expected forward payment. """
 
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        df1 = libor_curve.df(self._start_dt)
-        df2 = libor_curve.df(self._maturity_dt)
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        df1 = libor_curve.df(self.start_dt)
+        df2 = libor_curve.df(self.maturity_dt)
         libor_fwd = (df1 / df2 - 1.0) / acc_factor
-        v = acc_factor * (libor_fwd - self._fraRate) * df2
+        v = acc_factor * (libor_fwd - self.fra_rate) * df2
 
 #        print(df1, df2, acc_factor, libor_fwd, v)
         # Forward value the FRA to the value date
         df_to_value_dt = libor_curve.df(value_dt)
-        v = v * self._notional / df_to_value_dt
+        v = v * self.notional / df_to_value_dt
 
-        if self._payFixedRate:
+        if self.pay_fixed_rate:
             v *= -1.0
         return v
 
     ##########################################################################
 
     def maturity_df(self, libor_curve):
         """ Determine the maturity date discount factor needed to refit
         the FRA given the libor curve anbd the contract FRA rate. """
 
-        dc = DayCount(self._dc_type)
-        df1 = libor_curve.df(self._start_dt)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        df2 = df1 / (1.0 + acc_factor * self._fraRate)
+        dc = DayCount(self.dc_type)
+        df1 = libor_curve.df(self.start_dt)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        df2 = df1 / (1.0 + acc_factor * self.fra_rate)
         return df2
 
     ###########################################################################
 
     def print_payments(self, value_dt):
         """ Determine the value of the Deposit given a Ibor curve. """
 
-        flow_settle = self._notional
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        flow_maturity = (1.0 + acc_factor * self._fraRate) * self._notional
-
-        if self._payFixedRate is True:
-            print(self._start_dt, -flow_settle)
-            print(self._maturity_dt, flow_maturity)
+        flow_settle = self.notional
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        flow_maturity = (1.0 + acc_factor * self.fra_rate) * self.notional
+
+        if self.pay_fixed_rate is True:
+            print(self.start_dt, -flow_settle)
+            print(self.maturity_dt, flow_maturity)
         else:
-            print(self._start_dt, flow_settle)
-            print(self._maturity_dt, -flow_maturity)
+            print(self.start_dt, flow_settle)
+            print(self.maturity_dt, -flow_maturity)
 
     ##########################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START ACCD DATE", self._start_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("FRA RATE", self._fraRate)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("PAY FIXED RATE", self._payFixedRate)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("BUS DAY ADJUST TYPE", self._bd_type)
-        s += label_to_string("CALENDAR", self._cal_type)
+        s += label_to_string("START ACCD DATE", self.start_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("FRA RATE", self.fra_rate)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("PAY FIXED RATE", self.pay_fixed_rate)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("BUS DAY ADJUST TYPE", self.bd_type)
+        s += label_to_string("CALENDAR", self.cal_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         print(self)
```

### Comparing `financepy-0.350/financepy/products/inflation/FinInflationSwapCurve.py` & `financepy-0.360/financepy/products/inflation/FinInflationSwapCurve.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,44 +9,44 @@
 from ...utils.date import Date
 from ...utils.helpers import label_to_string
 from ...utils.helpers import check_argument_types, _func_name
 from ...utils.global_vars import gDaysInYear
 from ...market.curves.interpolator import InterpTypes
 from ...market.curves.discount_curve import DiscountCurve
 
-swaptol = 1e-8
+SWAP_TOL = 1e-10
 
 ##############################################################################
 # TODO: CHANGE times to df_times
 ##############################################################################
 
 
 def _f(df, *args):
     """ Root search objective function for swaps """
     curve = args[0]
     value_dt = args[1]
     swap = args[2]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
     v_swap = swap.value(value_dt, curve, curve, None, 1.0)
-    v_swap /= swap._notional
+    v_swap /= swap.notional
     return v_swap
 
 ###############################################################################
 
 
 def _g(df, *args):
     """ Root search objective function for swaps """
     curve = args[0]
     value_dt = args[1]
     fra = args[2]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
     v_fra = fra.value(value_dt, curve)
-    v_fra /= fra._notional
+    v_fra /= fra.notional
     return v_fra
 
 ###############################################################################
 
 
 class InflationSwapCurve(DiscountCurve):
     """ Constructs a discount curve as implied by the prices of Ibor
@@ -55,19 +55,19 @@
     curve date. Typically it is the date on which an amount of 1 unit paid
     has a present value of 1. This class inherits from FinDiscountCurve
     and so it has all of the methods that that class has.
 
     There are two main curve-building approaches:
 
     1) The first uses a bootstrap that interpolates swap rates linearly for
-    coupon dates that fall between the swap maturity dates. With this, we can
+    cpn dates that fall between the swap maturity dates. With this, we can
     solve for the discount factors iteratively without need of a solver. This
     will give us a set of discount factors on the grid dates that refit the
     market exactly. However, when extracting discount factors, we will then
-    assume flat forward rates between these coupon dates. There is no
+    assume flat forward rates between these cpn dates. There is no
     contradiction as it is as though we had been quoted a swap curve with all
     of the market swap rates, and with an additional set as though the market
     quoted swap rates at a higher frequency than the market.
 
     2) The second uses a bootstrap that uses only the swap rates provided but
     which also assumes that forwards are flat between these swap maturity
     dates. This approach is non-linear and so requires a solver. Consequently
@@ -84,34 +84,34 @@
                  ibor_swaps: list,
                  interp_type: InterpTypes = InterpTypes.FLAT_FWD_RATES,
                  check_refit: bool = False):  # Set to True to test it works
         """ Create an instance of a Ibor curve given a valuation date and
         a set of ibor deposits, ibor FRAs and ibor_swaps. Some of these may
         be left None and the algorithm will just use what is provided. An
         interpolation method has also to be provided. The default is to use a
-        linear interpolation for swap rates on coupon dates and to then assume
-        flat forwards between these coupon dates.
+        linear interpolation for swap rates on cpn dates and to then assume
+        flat forwards between these cpn dates.
 
         The curve will assign a discount factor of 1.0 to the valuation date.
         """
         raise FinError("DO NOT USE")
 
         check_argument_types(getattr(self, _func_name(), None), locals())
 
-        self._value_dt = value_dt
-        self._validate_inputs(ibor_deposits, ibor_fras, ibor_swaps)
+        self.value_dt = value_dt
+        self.validate_inputs(ibor_deposits, ibor_fras, ibor_swaps)
         self._interp_type = interp_type
-        self._check_refit = check_refit
-        self._build_curve()
+        self.check_refit = check_refit
+        self.build_curve()
 
 ###############################################################################
 
     def _build_curve(self):
         """ Build curve based on interpolation. """
-        self._build_curve_using_solver()
+        self.build_curve_using_solver()
 
 ###############################################################################
 
     def _validate_inputs(self,
                          ibor_deposits,
                          ibor_fras,
                          ibor_swaps):
@@ -123,121 +123,121 @@
 
         if num_depos + num_fras + num_swaps == 0:
             raise FinError("No calibration instruments.")
 
         # Validation of the inputs.
         if num_depos > 0:
             for depo in ibor_deposits:
-                startDt = depo._start_dt
-                if startDt < self._value_dt:
+                start_dt = depo.start_dt
+                if start_dt < self.value_dt:
                     raise FinError("First deposit starts before value date.")
 
             for depo in ibor_deposits:
-                startDt = depo._start_dt
-                endDt = depo._maturity_dt
-                if startDt >= endDt:
+                start_dt = depo.start_dt
+                end_dt = depo.maturity_dt
+                if start_dt >= end_dt:
                     raise FinError("First deposit ends on or before it begins")
 
         # Ensure order of depos
         if num_depos > 1:
-            prev_dt = ibor_deposits[0]._maturity_dt
+            prev_dt = ibor_deposits[0].maturity_dt
 
             for depo in ibor_deposits[1:]:
-                next_dt = depo._maturity_dt
+                next_dt = depo.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Deposits must be in increasing maturity")
                 prev_dt = next_dt
 
         # Ensure that valuation date is on or after first deposit start date
         if num_depos > 1:
-            if ibor_deposits[0]._start_dt > self._value_dt:
+            if ibor_deposits[0].start_dt > self.value_dt:
                 raise FinError(
                     "Valuation date must not be before first deposit settles.")
 
         if num_fras > 0:
             for fra in ibor_fras:
-                startDt = fra._start_dt
-                if startDt <= self._value_dt:
+                start_dt = fra.start_dt
+                if start_dt <= self.value_dt:
                     raise FinError("FRAs starts before valuation date")
 
         if num_fras > 1:
-            prev_dt = ibor_fras[0]._maturity_dt
+            prev_dt = ibor_fras[0].maturity_dt
             for fra in ibor_fras[1:]:
-                next_dt = fra._maturity_dt
+                next_dt = fra.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("FRAs must be in increasing maturity")
                 prev_dt = next_dt
 
         if num_swaps > 0:
             for swap in ibor_swaps:
-                startDt = swap._start_dt
-                if startDt < self._value_dt:
+                start_dt = swap.start_dt
+                if start_dt < self.value_dt:
                     raise FinError("Swaps starts before valuation date.")
 
         if num_swaps > 1:
 
             # Swaps must all start on the same date for the bootstrap
-            startDt = ibor_swaps[0]._start_dt
+            start_dt = ibor_swaps[0].start_dt
             for swap in ibor_swaps[1:]:
-                nextStartDt = swap._start_dt
-                if nextStartDt != startDt:
+                next_start_dt = swap.start_dt
+                if next_start_dt != start_dt:
                     raise FinError("Swaps must all have same start date.")
 
             # Swaps must be increasing in tenor/maturity
-            prev_dt = ibor_swaps[0]._maturity_dt
+            prev_dt = ibor_swaps[0].maturity_dt
             for swap in ibor_swaps[1:]:
-                next_dt = swap._maturity_dt
+                next_dt = swap.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Swaps must be in increasing maturity")
                 prev_dt = next_dt
 
             # Swaps must have same cash flows for bootstrap to work
-            longestSwap = ibor_swaps[-1]
-            longestSwapCpnDates = longestSwap._adjusted_fixed_dts
+            longest_swap = ibor_swaps[-1]
+            longest_swap_cpn_dts = longest_swap.adjusted_fixed_dts
             for swap in ibor_swaps[0:-1]:
-                swapCpnDates = swap._adjusted_fixed_dts
-                num_flows = len(swapCpnDates)
+                swap_cpn_dts = swap.adjusted_fixed_dts
+                num_flows = len(swap_cpn_dts)
                 for i_flow in range(0, num_flows):
-                    if swapCpnDates[i_flow] != longestSwapCpnDates[i_flow]:
+                    if swap_cpn_dts[i_flow] != longest_swap_cpn_dts[i_flow]:
                         raise FinError(
-                            "Swap coupons are not on the same date grid.")
+                            "Swap cpns are not on the same date grid.")
 
         #######################################################################
         # Now we have ensure they are in order check for overlaps and the like
         #######################################################################
 
-        lastDeposit_maturityDate = Date(1, 1, 1900)
-        firstFRAMaturityDate = Date(1, 1, 1900)
-        lastFRAMaturityDate = Date(1, 1, 1900)
+        last_deposit_maturity_dt = Date(1, 1, 1900)
+        first_fra_maturity_dt = Date(1, 1, 1900)
+        last_fra_maturity_dt = Date(1, 1, 1900)
 
         if num_depos > 0:
-            lastDeposit_maturityDate = ibor_deposits[-1]._maturity_dt
+            last_deposit_maturity_dt = ibor_deposits[-1].maturity_dt
 
         if num_fras > 0:
-            firstFRAMaturityDate = ibor_fras[0]._maturity_dt
-            lastFRAMaturityDate = ibor_fras[-1]._maturity_dt
+            first_fra_maturity_dt = ibor_fras[0].maturity_dt
+            last_fra_maturity_dt = ibor_fras[-1].maturity_dt
 
         if num_swaps > 0:
-            first_swap_maturity_dt = ibor_swaps[0]._maturity_dt
+            first_swap_maturity_dt = ibor_swaps[0].maturity_dt
 
         if num_depos > 0 and num_fras > 0:
-            if firstFRAMaturityDate <= lastDeposit_maturityDate:
-                print("FRA Maturity Date:", firstFRAMaturityDate)
-                print("Last Deposit Date:", lastDeposit_maturityDate)
+            if first_fra_maturity_dt <= last_deposit_maturity_dt:
+                print("FRA Maturity Date:", first_fra_maturity_dt)
+                print("Last Deposit Date:", last_deposit_maturity_dt)
                 raise FinError("First FRA must end after last Deposit")
 
         if num_fras > 0 and num_swaps > 0:
-            if first_swap_maturity_dt <= lastFRAMaturityDate:
+            if first_swap_maturity_dt <= last_fra_maturity_dt:
                 raise FinError("First Swap must mature after last FRA")
 
         # Now determine which instruments are used
-        self._usedDeposits = ibor_deposits
-        self._usedFRAs = ibor_fras
-        self._usedSwaps = ibor_swaps
-        self._dc_type = None
+        self.used_deposits = ibor_deposits
+        self.used_fras = ibor_fras
+        self.used_swaps = ibor_swaps
+        self.dc_type = None
 
 ###############################################################################
 
     def _build_curve_using_solver(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the non-linear slower method that allows the user to choose a number
         of interpolation approaches between the swap rates and other rates. It
@@ -248,61 +248,61 @@
 
         # time zero is now.
         t_mat = 0.0
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
 
-        for depo in self._usedDeposits:
-            df_settle = self.df(depo._start_dt)
-            df_mat = depo._maturity_df() * df_settle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+        for depo in self.used_deposits:
+            df_settle = self.df(depo.start_dt)
+            df_mat = depo.maturity_df() * df_settle
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
         oldt_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < oldt_mat and t_mat > oldt_mat:
                 df_mat = fra.maturity_df(self)
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
             else:
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
 
-                argtuple = (self, self._value_dt, fra)
+                argtuple = (self, self.value_dt, fra)
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                        args=argtuple, tol=swaptol,
-                                        maxiter=50, fprime2=None)
+                                         args=argtuple, tol=SWAP_TOL,
+                                         maxiter=50, fprime2=None)
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # I use the lastPaymentDate in case a date has been adjusted fwd
             # over a holiday as the maturity date is usually not adjusted CHECK
-            maturity_dt = swap._lastPaymentDate
-            t_mat = (maturity_dt - self._value_dt) / gDaysInYear
+            maturity_dt = swap.lastPaymentDate
+            t_mat = (maturity_dt - self.value_dt) / gDaysInYear
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
-            argtuple = (self, self._value_dt, swap)
+            argtuple = (self, self.value_dt, swap)
 
             df_mat = optimize.newton(_f, x0=df_mat, fprime=None, args=argtuple,
-                                    tol=swaptol, maxiter=50, fprime2=None,
-                                    full_output=False)
+                                     tol=SWAP_TOL, maxiter=50, fprime2=None,
+                                     full_output=False)
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self.check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
     def _build_curve_linear_swap_rate_interpolation(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the linear swap rate method that is fast and exact as it does not
         require the use of a solver. It is also market standard. """
@@ -312,195 +312,195 @@
 
         # time zero is now.
         t_mat = 0.0
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
 
-        for depo in self._usedDeposits:
-            df_settle = self.df(depo._start_dt)
-            df_mat = depo._maturity_df() * df_settle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+        for depo in self.used_deposits:
+            df_settle = self.df(depo.start_dt)
+            df_mat = depo.maturity_df() * df_settle
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
         oldt_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < oldt_mat and t_mat > oldt_mat:
                 df_mat = fra.maturity_df(self)
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
             else:
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
 
-                argtuple = (self, self._value_dt, fra)
+                argtuple = (self, self.value_dt, fra)
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                        args=argtuple, tol=swaptol,
-                                        maxiter=50, fprime2=None)
+                                         args=argtuple, tol=SWAP_TOL,
+                                         maxiter=50, fprime2=None)
 
-        if len(self._usedSwaps) == 0:
-            if self._check_refit is True:
-                self._check_refits(1e-10, swaptol, 1e-5)
+        if len(self.used_swaps) == 0:
+            if self.check_refit is True:
+                self.check_refits(1e-10, SWAP_TOL, 1e-5)
             return
 
 #        print("CURVE SO FAR")
 #        print(self._times)
 #        print(self._dfs)
 
         #######################################################################
         # ADD SWAPS TO CURVE
         #######################################################################
 
         # Find where the FRAs and Depos go up to as this bit of curve is done
-        foundStart = False
-        lastDate = self._value_dt
-        if len(self._usedDeposits) != 0:
-            lastDate = self._usedDeposits[-1]._maturity_dt
+        found_start = False
+        last_dt = self.value_dt
+        if len(self.used_deposits) != 0:
+            last_dt = self.used_deposits[-1].maturity_dt
 
-        if len(self._usedFRAs) != 0:
-            lastDate = self._usedFRAs[-1]._maturity_dt
+        if len(self.used_fras) != 0:
+            last_dt = self.used_fras[-1].maturity_dt
 
         # We use the longest swap assuming it has a superset of ALL of the
         # swap flow dates used in the curve construction
-        longestSwap = self._usedSwaps[-1]
-        couponDates = longestSwap._adjusted_fixed_dts
-        num_flows = len(couponDates)
+        longest_swap = self.used_swaps[-1]
+        cpn_dts = longest_swap.adjusted_fixed_dts
+        num_flows = len(cpn_dts)
 
-        # Find where first coupon without discount factor starts
+        # Find where first cpn without discount factor starts
         start_index = 0
         for i in range(0, num_flows):
-            if couponDates[i] > lastDate:
+            if cpn_dts[i] > last_dt:
                 start_index = i
-                foundStart = True
+                found_start = True
                 break
 
-        if foundStart is False:
+        if found_start is False:
             raise FinError("Found start is false. Swaps payments inside FRAs")
 
         swap_rates = []
         swap_times = []
 
-        # I use the last coupon date for the swap rate interpolation as this
+        # I use the last cpn date for the swap rate interpolation as this
         # may be different from the maturity date due to a holiday adjustment
-        # and the swap rates need to align with the coupon payment dates
-        for swap in self._usedSwaps:
-            swap_rate = swap._fixed_coupon
-            maturity_dt = swap._adjusted_fixed_dts[-1]
-            tswap = (maturity_dt - self._value_dt) / gDaysInYear
+        # and the swap rates need to align with the cpn payment dates
+        for swap in self.used_swaps:
+            swap_rate = swap.fixed_cpn
+            maturity_dt = swap.adjusted_fixed_dts[-1]
+            tswap = (maturity_dt - self.value_dt) / gDaysInYear
             swap_times.append(tswap)
             swap_rates.append(swap_rate)
 
-        interpolatedSwapRates = [0.0]
-        interpolatedswap_times = [0.0]
+        interpolated_swap_rates = [0.0]
+        interpolated_swap_times = [0.0]
 
-        for dt in couponDates[1:]:
-            swapTime = (dt - self._value_dt) / gDaysInYear
-            swap_rate = np.interp(swapTime, swap_times, swap_rates)
-            interpolatedSwapRates.append(swap_rate)
-            interpolatedswap_times.append(swapTime)
+        for dt in cpn_dts[1:]:
+            swap_years = (dt - self.value_dt) / gDaysInYear
+            swap_rate = np.interp(swap_years, swap_times, swap_rates)
+            interpolated_swap_rates.append(swap_rate)
+            interpolated_swap_times.append(swap_years)
 
         # Do I need this line ?
-        interpolatedSwapRates[0] = interpolatedSwapRates[1]
+        interpolated_swap_rates[0] = interpolated_swap_rates[1]
 
-#        print("Interpolated swap times:", interpolatedswap_times)
-#        print("Interpolated swap rates:", interpolatedSwapRates)
+#        print("Interpolated swap times:", interpolated_swap_times)
+#        print("Interpolated swap rates:", interpolated_swap_rates)
 
-        accrual_factors = longestSwap._fixed_year_fracs
+        accrual_factors = longest_swap.fixed_year_fracs
 
         acc = 0.0
         df = 1.0
         pv01 = 0.0
-        df_settle = self.df(longestSwap._start_dt)
+        df_settle = self.df(longest_swap.start_dt)
 #        print("SETTLE", df_settle)
 
         for i in range(1, start_index):
-            dt = couponDates[i]
+            dt = cpn_dts[i]
             df = self.df(dt)
             acc = accrual_factors[i-1]
             pv01 += acc * df
 #            print("BEFORE", i, dt, df, acc, pv01)
 
         for i in range(start_index, num_flows):
 
-            dt = couponDates[i]
-            t_mat = (dt - self._value_dt) / gDaysInYear
-            swap_rate = interpolatedSwapRates[i]
+            dt = cpn_dts[i]
+            t_mat = (dt - self.value_dt) / gDaysInYear
+            swap_rate = interpolated_swap_rates[i]
             acc = accrual_factors[i-1]
-            pv01End = (acc * swap_rate + 1.0)
+            pv01_end = (acc * swap_rate + 1.0)
 
-            df_mat = (df_settle - swap_rate * pv01) / pv01End
+            df_mat = (df_settle - swap_rate * pv01) / pv01_end
 
 #            print("IN: %12s %12.10f %12.10f %12.10f %12.10f OUT: %14.12f" %
-#                  (dt, swap_rate, acc, pv01, pv01End, df_mat))
+#                  (dt, swap_rate, acc, pv01, pv01_end, df_mat))
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
             pv01 += acc * df_mat
 
 #        print(self._times)
 #        print(self._dfs)
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self.check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
-    def _check_refits(self, depoTol, fraTol, swapTol):
+    def _check_refits(self, depo_tol, fra_tol, swap_tol):
         """ Ensure that the Ibor curve refits the calibration instruments. """
-        for depo in self._usedDeposits:
-            v = depo.value(self._value_dt, self) / depo._notional
-            if abs(v - 1.0) > depoTol:
+        for depo in self.used_deposits:
+            v = depo.value(self.value_dt, self) / depo.notional
+            if abs(v - 1.0) > depo_tol:
                 print("Value", v)
                 raise FinError("Deposit not repriced.")
 
-        for fra in self._usedFRAs:
-            v = fra.value(self._value_dt, self) / fra._notional
-            if abs(v) > fraTol:
+        for fra in self.used_fras:
+            v = fra.value(self.value_dt, self) / fra.notional
+            if abs(v) > fra_tol:
                 print("Value", v)
                 raise FinError("FRA not repriced.")
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # We value it as of the start date of the swap
-            v = swap.value(swap._start_dt, self, self, None, principal=0.0)
-            v = v / swap._notional
-#            print("REFIT SWAP VALUATION:", swap._adjustedMaturityDate, v)
-            if abs(v) > swapTol:
-                print("Swap with maturity " + str(swap._maturity_dt)
+            v = swap.value(swap.start_dt, self, self, None, principal=0.0)
+            v = v / swap.notional
+#            print("REFIT SWAP VALUATION:", swap.adjustedMaturityDate, v)
+            if abs(v) > swap_tol:
+                print("Swap with maturity " + str(swap.maturity_dt)
                       + " Not Repriced. Has Value", v)
                 swap.print_fixed_leg_pv()
                 swap.print_float_leg_pv()
                 raise FinError("Swap not repriced.")
 
 ###############################################################################
 
     def __repr__(self):
         """ Print out the details of the Ibor curve. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUATION DATE", self._value_dt)
+        s += label_to_string("VALUATION DATE", self.value_dt)
 
-        for depo in self._usedDeposits:
+        for depo in self.used_deposits:
             s += label_to_string("DEPOSIT", "")
             s += depo.__repr__()
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
             s += label_to_string("FRA", "")
             s += fra.__repr__()
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             s += label_to_string("SWAP", "")
             s += swap.__repr__()
 
         num_points = len(self._times)
 
         s += label_to_string("INTERP TYPE", self._interp_type)
```

### Comparing `financepy-0.350/financepy/products/rates/callable_swap.py` & `financepy-0.360/financepy/products/rates/callable_swap.py`

 * *Files 12% similar despite different names*

```diff
@@ -48,32 +48,32 @@
 #     EUROPEAN = 1
 #     BERMUDAN = 2
 
 # ###############################################################################
 
 
 # class IborBermudanSwaption
-#     """ Class for fixed coupon bonds with embedded call or put optionality. """
+#     """ Class for fixed cpn bonds with embedded call or put optionality. """
 
 #     def __init__(self,
 #                  exercise_dt,
 #                  exercise_type,
 #                  maturity_dt,
 #                  swaptionType,
-#                  fixed_coupon,
+#                  fixed_cpn,
 #                  fixed_freq_type,
 #                  fixed_dc_type,
 #                  notional=ONE_MILLION,
 #                  float_freq_type=FrequencyTypes.QUARTERLY,
 #                  float_dc_type=DayCountTypes.THIRTY_E_360,
 #                  cal_type=CalendarTypes.WEEKEND,
 #                  bd_type=BusDayAdjustTypes.FOLLOWING,
 #                  dg_type=DateGenRuleTypes.BACKWARD):
 #         """ Create a Bermudan swaption contract. This is an option to enter
-#         into a swap at a fixed coupon on all of the fixed leg coupon dates
+#         into a swap at a fixed cpn on all of the fixed leg cpn dates
 #         until the exercise date. """
 
 #         if exercise_dt > maturity_dt:
 #             raise FinError("Exercise date must be before swap maturity date")
 
 #         if exercise_type not in FinSwaptionExerciseTypes:
 #             raise FinError("Exercise type must be a FinSwaptionExerciseTypes")
@@ -107,121 +107,121 @@
 #                 str(bd_type))
 
 #         if dg_type not in DateGenRuleTypes:
 #             raise FinError(
 #                 "Unknown Date Gen Rule type " +
 #                 str(dg_type))
 
-#         self._exercise_dt = exercise_dt
-#         self._maturity_dt = maturity_dt
-#         self._fixed_coupon = fixed_coupon
-#         self._fixed_freq_type = fixed_freq_type
-#         self._fixed_dc_type = fixed_dc_type
-#         self._notional = notional
-#         self._float_freq_type = float_freq_type
-#         self._float_dc_type = float_dc_type
-
-#         self._cal_type = cal_type
-#         self._bd_type = bd_type
-#         self._dg_type = dg_type
-
-#         self._pv01 = None
-#         self._fwd_swap_rate = None
-#         self._forward_df = None
-#         self._underlying_swap = None
+#         self.exercise_dt = exercise_dt
+#         self.maturity_dt = maturity_dt
+#         self.fixed_cpn = fixed_cpn
+#         self.fixed_freq_type = fixed_freq_type
+#         self.fixed_dc_type = fixed_dc_type
+#         self.notional = notional
+#         self.float_freq_type = float_freq_type
+#         self.float_dc_type = float_dc_type
+
+#         self.cal_type = cal_type
+#         self.bd_type = bd_type
+#         self.dg_type = dg_type
+
+#         self.pv01 = None
+#         self.fwd_swap_rate = None
+#         self.forward_df = None
+#         self.underlying_swap = None
 
 # ###############################################################################
 
 #     def value(self,
 #               value_dt,
 #               discount_curve,
 #               model):
 #         """ Value the bermuda swaption. This is done using the specified
 #         model and a discount curve. """
 
 #         float_spread = 0.0
-#         payFixedFlag = True
+#         pay_fixedFlag = True
 
 #         # The underlying is a swap in which we pay the fixed amount
-#         swap = IborSwap(self._exercise_dt,
-#                             self._maturity_dt,
-#                             self._fixed_coupon,
-#                             self._fixed_freq_type,
-#                             self._fixed_dc_type,
-#                             self._notional,
+#         swap = IborSwap(self.exercise_dt,
+#                             self.maturity_dt,
+#                             self.fixed_cpn,
+#                             self.fixed_freq_type,
+#                             self.fixed_dc_type,
+#                             self.notional,
 #                             float_spread,
-#                             self._float_freq_type,
-#                             self._float_dc_type,
-#                             payFixedFlag,
-#                             self._cal_type,
-#                             self._bd_type,
-#                             self._dg_type)
+#                             self.float_freq_type,
+#                             self.float_dc_type,
+#                             pay_fixedFlag,
+#                             self.cal_type,
+#                             self.bd_type,
+#                             self.dg_type)
 
 #         swap.generate_flows()
 #         cpn_times = []
 #         cpn_amounts = []
 
-#         for i_flow in range(1, len(self._swap._adjusted_fixed_dts)):
-#             flow_dt= swap._adjusted_fixed_dts[i_flow]
+#         for i_flow in range(1, len(self.swap.adjusted_fixed_dts)):
+#             flow_dt= swap.adjusted_fixed_dts[i_flow]
 #             cpn_time = (flow_dt - settle_dt) / gDaysInYear
-#             cpn_flow = swap._fixedFlows[i_flow-1] / self._notional
+#             cpn_flow = swap.fixed_flows[i_flow-1] / self.notional
 #             cpn_times.append(cpn_time)
 #             cpn_amounts.append(cpn_flow)
 
 #         cpn_times = np.array(cpn_times)
 #         cpn_amounts = np.array(cpn_amounts)
 
 #         # Generate bond call times and prices
 #         call_times = []
-#         for dt in self._call_dts:
+#         for dt in self.call_dts:
 #             call_time = (dt - settle_dt) / gDaysInYear
 #             call_times.append(call_time)
 #         call_times = np.array(call_times)
-#         call_prices = np.array(self._call_prices)
+#         call_prices = np.array(self.call_prices)
 
 #         # Generate bond put times and prices
-#         if self._swaptionType == IborSwaptionType.PAY:
+#         if self.swaptionType == IborSwaptionType.PAY:
 #             call_price = 100.0
 #             putPrice = 1e10
 #         else:
 #             call_price = 1e10
 #             putPrice = 100.0
 
 #         put_times = []
-#         for put_dt in swap._adjusted_fixed_dts[1:]:
-#             if put_dt <= self._exercise_dt:
+#         for put_dt in swap.adjusted_fixed_dts[1:]:
+#             if put_dt <= self.exercise_dt:
 #                 put_time = (put_dt - settle_dt) / gDaysInYear
 #                 put_times.append(put_time)
 
 #         put_times = np.array(put_times)
-#         put_prices = np.array(self._put_prices)
+#         put_prices = np.array(self.put_prices)
 
-#         maturity_dt = self._bond._maturity_dt
+#         maturity_dt = self.bond.maturity_dt
 #         t_mat = (maturity_dt - settle_dt) / gDaysInYear
 #         df_times = discount_curve._times
 #         df_values = discount_curve._values
 
-#         face = self._bond._face
+#         face = self.bond.face
 
 #         if type(model) is HWTree:
 
 #             """ We need to build the tree out to the bond maturity date. To be
 #             more precise we only need to go out the the last option date but
 #             we can do that refinement at a later date. """
 
 #             model.buildTree(t_mat, df_times, df_values)
 #             v1 = model.callableputtable_bond_Tree(cpn_times, cpn_amounts,
 #                                                  call_times, call_prices,
 #                                                  put_times, put_prices, face)
-#             model._num_time_steps += 1
+#             model.num_time_steps += 1
 #             model.buildTree(t_mat, df_times, df_values)
 #             v2 = model.callableputtable_bond_Tree(cpn_times, cpn_amounts,
 #                                                  call_times, call_prices,
 #                                                  put_times, put_prices, face)
-#             model._num_time_steps -= 1
+#             model.num_time_steps -= 1
 
 #             v_bondwithoption = (v1['bondwithoption'] + v2['bondwithoption'])/2
 #             v_bondpure = (v1['bondpure'] + v2['bondpure'])/2
 
 #             return {'bondwithoption': v_bondwithoption, 'bondpure': v_bondpure}
 
 #         elif type(model) == BKTree:
@@ -230,49 +230,49 @@
 #             the tree out to the bond maturity which is after option expiry. """
 
 #             model.buildTree(t_mat, df_times, df_values)
 #             v1 = model.callableputtable_bond_Tree(cpn_times, cpn_amounts,
 #                                                  call_times, call_prices,
 #                                                  put_times, put_prices,
 #                                                  face)
-#             model._num_time_steps += 1
+#             model.num_time_steps += 1
 #             model.buildTree(t_mat, df_times, df_values)
 #             v2 = model.callableputtable_bond_Tree(cpn_times, cpn_amounts,
 #                                                  call_times, call_prices,
 #                                                  put_times, put_prices,
 #                                                  face)
-#             model._num_time_steps -= 1
+#             model.num_time_steps -= 1
 
 #             v_bondwithoption = (v1['bondwithoption'] + v2['bondwithoption'])/2
 #             v_bondpure = (v1['bondpure'] + v2['bondpure'])/2
 
 #             return {'bondwithoption': v_bondwithoption, 'bondpure': v_bondpure}
 #         else:
 #             raise FinError("Unknown model type")
 
 # ###############################################################################
 
 #     def __repr__(self):
 
-#         s = label_to_string("MATURITY DATE", self._maturity_dt)
-#         s += label_to_string("EXERCISE DATE", self._exercise_dt)
-#         s += label_to_string("COUPON", self._cpn)
-#         s += label_to_string("FREQUENCY", self._freq_type)
-#         s += label_to_string("DAY COUNT TYPE", self._dc_type)
-#         s += label_to_string("FACE AMOUNT", self._face)
-#         s += label_to_string("CONVERSION RATIO", self._conversion_ratio)
-#         s += label_to_string("START CONVERT DATE", self._start_convert_dt)
-
-#         for i in range(0, len(self._call_dts)):
-#             s += label_to_string("CALL DATE AND PRICE", self._call_dts[i],
-#                                self._call_prices[i])
-
-#         for i in range(0, len(self._put_dts)):
-#             s += label_to_string("PUT DATE AND PRICE", self._put_dts[i],
-#                                self._put_prices[i])
+#         s = label_to_string("MATURITY DATE", self.maturity_dt)
+#         s += label_to_string("EXERCISE DATE", self.exercise_dt)
+#         s += label_to_string("cpn", self.cpn)
+#         s += label_to_string("FREQUENCY", self.freq_type)
+#         s += label_to_string("DAY COUNT TYPE", self.dc_type)
+#         s += label_to_string("FACE AMOUNT", self.face)
+#         s += label_to_string("CONVERSION RATIO", self.conversion_ratio)
+#         s += label_to_string("START CONVERT DATE", self.start_convert_dt)
+
+#         for i in range(0, len(self.call_dts)):
+#             s += label_to_string("CALL DATE AND PRICE", self.call_dts[i],
+#                                self.call_prices[i])
+
+#         for i in range(0, len(self.put_dts)):
+#             s += label_to_string("PUT DATE AND PRICE", self.put_dts[i],
+#                                self.put_prices[i])
 
 #         return s
 
 # ###############################################################################
 
 #     def print(self):
 #         print(self)
```

### Comparing `financepy-0.350/financepy/products/rates/dual_curve.py` & `financepy-0.360/financepy/products/rates/dual_curve.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
+import copy
+
 import numpy as np
 from scipy import optimize
-import copy
 
 from ...utils.error import FinError
 from ...utils.date import Date
 from ...utils.helpers import label_to_string
 from ...utils.helpers import check_argument_types, _func_name
 from ...utils.global_vars import gDaysInYear
 from ...market.curves.interpolator import InterpTypes, Interpolator
 from ...market.curves.discount_curve import DiscountCurve
 from ...products.rates.ibor_deposit import IborDeposit
 from ...products.rates.ibor_fra import IborFRA
 from ...products.rates.ibor_swap import IborSwap
 
-swaptol = 1e-10
+SWAP_TOL = 1e-10
 
 ###############################################################################
 # TODO: CHANGE times to df_times
 ###############################################################################
 
 
 def _f(df, *args):
@@ -34,15 +35,15 @@
     num_points = len(index_curve._times)
     index_curve._dfs[num_points - 1] = df
 
     # For discount that need a fit function, we fit it now
     index_curve._interpolator.fit(index_curve._times, index_curve._dfs)
     v_swap = swap.value(value_dt, discount_curve, index_curve, None)
 
-    notional = swap._fixed_leg._notional
+    notional = swap.fixed_leg.notional
     v_swap /= notional
     return v_swap
 
 ###############################################################################
 
 
 def _g(df, *args):
@@ -54,15 +55,15 @@
     fra = args[3]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
 
     # For discount that need a fit function, we fit it now
     curve._interpolator.fit(curve._times, curve._dfs)
     v_fra = fra.value(value_dt, discount_curve, curve)
-    v_fra /= fra._notional
+    v_fra /= fra.notional
     return v_fra
 
 ###############################################################################
 
 
 class IborDualCurve(DiscountCurve):
     """ Constructs an index curve as implied by the prices of Ibor
@@ -79,27 +80,27 @@
                  ibor_swaps: list,
                  interp_type: InterpTypes = InterpTypes.FLAT_FWD_RATES,
                  check_refit: bool = False):  # Set to True to test it works
         """ Create an instance of a Ibor curve given a valuation date and
         a set of ibor deposits, ibor FRAs and ibor_swaps. Some of these may
         be left None and the algorithm will just use what is provided. An
         interpolation method has also to be provided. The default is to use a
-        linear interpolation for swap rates on coupon dates and to then assume
-        flat forwards between these coupon dates.
+        linear interpolation for swap rates on cpn dates and to then assume
+        flat forwards between these cpn dates.
 
         The curve will assign a discount factor of 1.0 to the valuation date.
         """
 
         check_argument_types(getattr(self, _func_name(), None), locals())
 
-        self._value_dt = value_dt
-        self._discount_curve = discount_curve
+        self.value_dt = value_dt
+        self.discount_curve = discount_curve
         self._validate_inputs(ibor_deposits, ibor_fras, ibor_swaps)
         self._interp_type = interp_type
-        self._check_refit = check_refit
+        self.check_refit = check_refit
         self._build_curve()
 
 ###############################################################################
 
     def _build_curve(self):
         """ Build curve based on interpolation. """
 
@@ -113,178 +114,178 @@
                          ibor_swaps):
         """ Validate the inputs for each of the Ibor products. """
 
         num_depos = len(ibor_deposits)
         num_fras = len(ibor_fras)
         num_swaps = len(ibor_swaps)
 
-        depo_start_dt = self._value_dt
-        swap_start_dt = self._value_dt
+        depo_start_dt = self.value_dt
+        swap_start_dt = self.value_dt
 
         if num_depos + num_fras + num_swaps == 0:
             raise FinError("No calibration instruments.")
 
         # Validation of the inputs.
         if num_depos > 0:
 
-            depo_start_dt = ibor_deposits[0]._start_dt
+            depo_start_dt = ibor_deposits[0].start_dt
 
             for depo in ibor_deposits:
 
                 if isinstance(depo, IborDeposit) is False:
                     raise FinError("Deposit is not of type IborDeposit")
 
-                start_dt = depo._start_dt
+                start_dt = depo.start_dt
 
-                if start_dt < self._value_dt:
+                if start_dt < self.value_dt:
                     raise FinError("First deposit starts before value date.")
 
                 if start_dt < depo_start_dt:
                     depo_start_dt = start_dt
 
             for depo in ibor_deposits:
-                start_dt = depo._start_dt
-                endDt = depo._maturity_dt
-                if start_dt >= endDt:
+                start_dt = depo.start_dt
+                end_dt = depo.maturity_dt
+                if start_dt >= end_dt:
                     raise FinError("First deposit ends on or before it begins")
 
         # Ensure order of depos
         if num_depos > 1:
 
-            prev_dt = ibor_deposits[0]._maturity_dt
+            prev_dt = ibor_deposits[0].maturity_dt
             for depo in ibor_deposits[1:]:
-                next_dt = depo._maturity_dt
+                next_dt = depo.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Deposits must be in increasing maturity")
                 prev_dt = next_dt
 
         # REMOVED THIS AS WE WANT TO ANCHOR CURVE AT VALUATION DATE
         # USE A SYNTHETIC DEPOSIT TO BRIDGE GAP FROM VALUE DATE TO SETTLEMENT DATE
         # Ensure that valuation date is on or after first deposit start date
         # if num_depos > 1:
-        #    if ibor_deposits[0]._effective_dt > self._value_dt:
+        #    if ibor_deposits[0].effective_dt > self.value_dt:
         #        raise FinError("Valuation date must not be before first deposit settles.")
 
         if num_fras > 0:
             for fra in ibor_fras:
                 if isinstance(fra, IborFRA) is False:
                     raise FinError("FRA is not of type IborFRA")
 
-                start_dt = fra._start_dt
-                if start_dt <= self._value_dt:
+                start_dt = fra.start_dt
+                if start_dt <= self.value_dt:
                     raise FinError("FRAs starts before valuation date")
 
         if num_fras > 1:
-            prev_dt = ibor_fras[0]._maturity_dt
+            prev_dt = ibor_fras[0].maturity_dt
             for fra in ibor_fras[1:]:
-                next_dt = fra._maturity_dt
+                next_dt = fra.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("FRAs must be in increasing maturity")
                 prev_dt = next_dt
 
         if num_swaps > 0:
 
-            swap_start_dt = ibor_swaps[0]._effective_dt
+            swap_start_dt = ibor_swaps[0].effective_dt
 
             for swap in ibor_swaps:
 
                 if isinstance(swap, IborSwap) is False:
                     raise FinError("Swap is not of type IborSwap")
 
-                start_dt = swap._effective_dt
-                if start_dt < self._value_dt:
+                start_dt = swap.effective_dt
+                if start_dt < self.value_dt:
                     raise FinError("Swaps starts before valuation date.")
 
-                if swap._effective_dt < swap_start_dt:
-                    swap_start_dt = swap._effective_dt
+                if swap.effective_dt < swap_start_dt:
+                    swap_start_dt = swap.effective_dt
 
         if num_swaps > 1:
 
             # Swaps must all start on the same date for the bootstrap
-            start_dt = ibor_swaps[0]._effective_dt
+            start_dt = ibor_swaps[0].effective_dt
             for swap in ibor_swaps[1:]:
-                next_start_dt = swap._effective_dt
+                next_start_dt = swap.effective_dt
                 if next_start_dt != start_dt:
                     raise FinError("Swaps must all have same start date.")
 
             # Swaps must be increasing in tenor/maturity
-            prev_dt = ibor_swaps[0]._maturity_dt
+            prev_dt = ibor_swaps[0].maturity_dt
             for swap in ibor_swaps[1:]:
-                next_dt = swap._maturity_dt
+                next_dt = swap.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Swaps must be in increasing maturity")
                 prev_dt = next_dt
 
             # Swaps must have same cash flows for bootstrap to work
-            longestSwap = ibor_swaps[-1]
-            longestSwapCpnDates = longestSwap._fixed_leg._payment_dts
+            longest_swap = ibor_swaps[-1]
+            longest_swap_cpn_dts = longest_swap.fixed_leg.payment_dts
             for swap in ibor_swaps[0:-1]:
-                swapCpnDates = swap._fixed_leg._payment_dts
-                num_flows = len(swapCpnDates)
+                swap_cpn_dts = swap.fixed_leg.payment_dts
+                num_flows = len(swap_cpn_dts)
                 for i_flow in range(0, num_flows):
-                    if swapCpnDates[i_flow] != longestSwapCpnDates[i_flow]:
+                    if swap_cpn_dts[i_flow] != longest_swap_cpn_dts[i_flow]:
                         raise FinError(
-                            "Swap coupons are not on the same date grid.")
+                            "Swap cpns are not on the same date grid.")
 
         #######################################################################
         # Now we have ensure they are in order check for overlaps and the like
         #######################################################################
 
-        lastDeposit_maturityDate = Date(1, 1, 1900)
-        firstFRAMaturityDate = Date(1, 1, 1900)
-        lastFRAMaturityDate = Date(1, 1, 1900)
+        last_deposit_maturity_dt = Date(1, 1, 1900)
+        first_fra_maturity_dt = Date(1, 1, 1900)
+        last_fra_maturity_dt = Date(1, 1, 1900)
 
         if num_depos > 0:
-            lastDeposit_maturityDate = ibor_deposits[-1]._maturity_dt
+            last_deposit_maturity_dt = ibor_deposits[-1].maturity_dt
 
         if num_fras > 0:
-            firstFRAMaturityDate = ibor_fras[0]._maturity_dt
-            lastFRAMaturityDate = ibor_fras[-1]._maturity_dt
+            first_fra_maturity_dt = ibor_fras[0].maturity_dt
+            last_fra_maturity_dt = ibor_fras[-1].maturity_dt
 
         if num_swaps > 0:
-            first_swap_maturity_dt = ibor_swaps[0]._maturity_dt
+            first_swap_maturity_dt = ibor_swaps[0].maturity_dt
 
         if num_depos > 0 and num_fras > 0:
-            if firstFRAMaturityDate <= lastDeposit_maturityDate:
-                print("FRA Maturity Date:", firstFRAMaturityDate)
-                print("Last Deposit Date:", lastDeposit_maturityDate)
+            if first_fra_maturity_dt <= last_deposit_maturity_dt:
+                print("FRA Maturity Date:", first_fra_maturity_dt)
+                print("Last Deposit Date:", last_deposit_maturity_dt)
                 raise FinError("First FRA must end after last Deposit")
 
         if num_fras > 0 and num_swaps > 0:
-            if first_swap_maturity_dt <= lastFRAMaturityDate:
+            if first_swap_maturity_dt <= last_fra_maturity_dt:
                 raise FinError("First Swap must mature after last FRA")
 
         # If both depos and swaps start after T, we need a rate to get them to
         # the first deposit. So we create a synthetic deposit rate contract.
 
-        if swap_start_dt > self._value_dt:
+        if swap_start_dt > self.value_dt:
 
             if num_depos == 0:
                 raise FinError("Need a deposit rate to pin down short end.")
 
-            if depo_start_dt > self._value_dt:
-                firstDepo = ibor_deposits[0]
-                if firstDepo._start_dt > self._value_dt:
+            if depo_start_dt > self.value_dt:
+                first_depo = ibor_deposits[0]
+                if first_depo.start_dt > self.value_dt:
                     print("Inserting synthetic deposit")
-                    syntheticDeposit = copy.deepcopy(firstDepo)
-                    syntheticDeposit._start_dt = self._value_dt
-                    syntheticDeposit._maturity_dt = firstDepo._start_dt
-                    ibor_deposits.insert(0, syntheticDeposit)
+                    synthetic_deposit = copy.deepcopy(first_depo)
+                    synthetic_deposit.start_dt = self.value_dt
+                    synthetic_deposit.maturity_dt = first_depo.start_dt
+                    ibor_deposits.insert(0, synthetic_deposit)
                     num_depos += 1
 
         # Now determine which instruments are used
-        self._usedDeposits = ibor_deposits
-        self._usedFRAs = ibor_fras
-        self._usedSwaps = ibor_swaps
+        self.used_deposits = ibor_deposits
+        self.used_fras = ibor_fras
+        self.used_swaps = ibor_swaps
 
         # Need the floating leg basis for the curve
-        if len(self._usedSwaps) > 0:
-            self._dc_type = ibor_swaps[0]._float_leg._dc_type
+        if len(self.used_swaps) > 0:
+            self.dc_type = ibor_swaps[0].float_leg.dc_type
         else:
-            self._dc_type = None
+            self.dc_type = None
 
 ###############################################################################
 
     def _build_curve_using_1d_solver(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the non-linear slower method that allows the user to choose a number
         of interpolation approaches between the swap rates and other rates. It
@@ -300,63 +301,63 @@
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
         self._interpolator.fit(self._times, self._dfs)
 
         # A deposit is not margined and not indexed to Libor so should
         # probably not be used to build an indexed Libor curve from
-        for depo in self._usedDeposits:
+        for depo in self.used_deposits:
 
-            df_settle = self.df(depo._start_dt)
+            df_settle = self.df(depo.start_dt)
             df_mat = depo._maturity_df() * df_settle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
         oldt_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < oldt_mat and t_mat > oldt_mat:
                 df_mat = fra.maturity_df(self)
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
             else:
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
-                argtuple = (self._discount_curve, self,
-                            self._value_dt, fra)
+                argtuple = (self.discount_curve, self,
+                            self.value_dt, fra)
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                        args=argtuple, tol=swaptol,
-                                        maxiter=50, fprime2=None)
+                                         args=argtuple, tol=SWAP_TOL,
+                                         maxiter=50, fprime2=None)
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # I use the lastPaymentDate in case a date has been adjusted fwd
             # over a holiday as the maturity date is usually not adjusted CHECK
-            maturity_dt = swap._fixed_leg._payment_dts[-1]
-            t_mat = (maturity_dt - self._value_dt) / gDaysInYear
+            maturity_dt = swap.fixed_leg.payment_dts[-1]
+            t_mat = (maturity_dt - self.value_dt) / gDaysInYear
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
-            argtuple = (self._discount_curve, self, self._value_dt, swap)
+            argtuple = (self.discount_curve, self, self.value_dt, swap)
 
             df_mat = optimize.newton(_f, x0=df_mat, fprime=None, args=argtuple,
-                                    tol=swaptol, maxiter=50, fprime2=None,
-                                    full_output=False)
+                                     tol=SWAP_TOL, maxiter=50, fprime2=None,
+                                     full_output=False)
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self._check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
     # def _build_curve_linear_swap_rate_interpolation(self):
     #     """ Construct the discount curve using a bootstrap approach. This is
     #     the linear swap rate method that is fast and exact as it does not
     #     require the use of a solver. It is also market standard. """
@@ -369,184 +370,184 @@
     #     # time zero is now.
     #     t_mat = 0.0
     #     df_mat = 1.0
     #     self._times = np.append(self._times, 0.0)
     #     self._dfs = np.append(self._dfs, df_mat)
     #     self._interpolator.fit(self._times, self._dfs)
 
-    #     for depo in self._usedDeposits:
-    #         df_settle = self.df(depo._effective_dt)
-    #         df_mat = depo._maturity_df() * df_settle
-    #         t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+    #     for depo in self.used_deposits:
+    #         df_settle = self.df(depo.effective_dt)
+    #         df_mat = depo.maturity_df() * df_settle
+    #         t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
     #         self._times = np.append(self._times, t_mat)
     #         self._dfs = np.append(self._dfs, df_mat)
     #         self._interpolator.fit(self._times, self._dfs)
 
     #     oldt_mat = t_mat
 
-    #     for fra in self._usedFRAs:
+    #     for fra in self.used_fras:
 
-    #         t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-    #         t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+    #         t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+    #         t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
     #         # if both dates are after the previous FRA/FUT then need to
     #         # solve for 2 discount factors simultaneously using root search
 
     #         if t_set < oldt_mat and t_mat > oldt_mat:
     #             df_mat = fra.maturity_df(self)
     #             self._times = np.append(self._times, t_mat)
     #             self._dfs = np.append(self._dfs, df_mat)
     #             self._interpolator.fit(self._times, self._dfs)
     #         else:
     #             self._times = np.append(self._times, t_mat)
     #             self._dfs = np.append(self._dfs, df_mat)
     #             self._interpolator.fit(self._times, self._dfs)
 
-    #             argtuple = (self._discount_curve, self, self._value_dt, fra)
+    #             argtuple = (self.discount_curve, self, self.value_dt, fra)
     #             df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-    #                                     args=argtuple, tol=swaptol,
+    #                                     args=argtuple, tol=swap_tol,
     #                                     maxiter=50, fprime2=None)
 
-    #     if len(self._usedSwaps) == 0:
-    #         if self._check_refit is True:
-    #             self._check_refits(1e-10, swaptol, 1e-5)
+    #     if len(self.used_swaps) == 0:
+    #         if self.check_refit is True:
+    #             self.check_refits(1e-10, swap_tol, 1e-5)
     #         return
 
     #     #######################################################################
     #     # ADD SWAPS TO CURVE
     #     #######################################################################
 
     #     # Find where the FRAs and Depos go up to as this bit of curve is done
-    #     foundStart = False
-    #     lastDate = self._value_dt
-    #     if len(self._usedDeposits) != 0:
-    #         lastDate = self._usedDeposits[-1]._maturity_dt
+    #     found_start = False
+    #     last_dt = self.value_dt
+    #     if len(self.used_deposits) != 0:
+    #         last_dt = self.used_deposits[-1].maturity_dt
 
-    #     if len(self._usedFRAs) != 0:
-    #         lastDate = self._usedFRAs[-1]._maturity_dt
+    #     if len(self.used_fras) != 0:
+    #         last_dt = self.used_fras[-1].maturity_dt
 
     #     # We use the longest swap assuming it has a superset of ALL of the
     #     # swap flow dates used in the curve construction
-    #     longestSwap = self._usedSwaps[-1]
-    #     cpn_dts = longestSwap._adjusted_fixed_dts
+    #     longest_swap = self.used_swaps[-1]
+    #     cpn_dts = longest_swap.adjusted_fixed_dts
     #     num_flows = len(cpn_dts)
 
-    #     # Find where first coupon without discount factor starts
+    #     # Find where first cpn without discount factor starts
     #     start_index = 0
     #     for i in range(0, num_flows):
-    #         if cpn_dts[i] > lastDate:
+    #         if cpn_dts[i] > last_dt:
     #             start_index = i
-    #             foundStart = True
+    #             found_start = True
     #             break
 
-    #     if foundStart is False:
+    #     if found_start is False:
     #         raise FinError("Found start is false. Swaps payments inside FRAs")
 
     #     swap_rates = []
     #     swap_times = []
 
-    #     # I use the last coupon date for the swap rate interpolation as this
+    #     # I use the last cpn date for the swap rate interpolation as this
     #     # may be different from the maturity date due to a holiday adjustment
-    #     # and the swap rates need to align with the coupon payment dates
-    #     for swap in self._usedSwaps:
-    #         swap_rate = swap._fixed_coupon
-    #         maturity_dt = swap._adjusted_fixed_dts[-1]
-    #         tswap = (maturity_dt - self._value_dt) / gDaysInYear
+    #     # and the swap rates need to align with the cpn payment dates
+    #     for swap in self.used_swaps:
+    #         swap_rate = swap.fixed_cpn
+    #         maturity_dt = swap.adjusted_fixed_dts[-1]
+    #         tswap = (maturity_dt - self.value_dt) / gDaysInYear
     #         swap_times.append(tswap)
     #         swap_rates.append(swap_rate)
 
     #     interpolatedSwapRates = [0.0]
     #     interpolatedswap_times = [0.0]
 
     #     for dt in cpn_dts[1:]:
-    #         swapTime = (dt - self._value_dt) / gDaysInYear
-    #         swap_rate = np.interp(swapTime, swap_times, swap_rates)
+    #         swap_years = (dt - self.value_dt) / gDaysInYear
+    #         swap_rate = np.interp(swap_years, swap_times, swap_rates)
     #         interpolatedSwapRates.append(swap_rate)
-    #         interpolatedswap_times.append(swapTime)
+    #         interpolatedswap_times.append(swap_years)
 
     #     # Do I need this line ?
     #     interpolatedSwapRates[0] = interpolatedSwapRates[1]
 
-    #     accrual_factors = longestSwap._fixedYearFracs
+    #     accrual_factors = longest_swap.fixedYearFracs
 
     #     acc = 0.0
     #     df = 1.0
     #     pv01 = 0.0
-    #     df_settle = self.df(longestSwap._effective_dt)
+    #     df_settle = self.df(longest_swap.effective_dt)
 
     #     for i in range(1, start_index):
     #         dt = cpn_dts[i]
     #         df = self.df(dt)
     #         acc = accrual_factors[i-1]
     #         pv01 += acc * df
 
     #     for i in range(start_index, num_flows):
 
     #         dt = cpn_dts[i]
-    #         t_mat = (dt - self._value_dt) / gDaysInYear
+    #         t_mat = (dt - self.value_dt) / gDaysInYear
     #         swap_rate = interpolatedSwapRates[i]
     #         acc = accrual_factors[i-1]
-    #         pv01End = (acc * swap_rate + 1.0)
-    #         df_mat = (df_settle - swap_rate * pv01) / pv01End
+    #         pv01_end = (acc * swap_rate + 1.0)
+    #         df_mat = (df_settle - swap_rate * pv01) / pv01_end
 
     #         self._times = np.append(self._times, t_mat)
     #         self._dfs = np.append(self._dfs, df_mat)
     #         self._interpolator.fit(self._times, self._dfs)
 
     #         pv01 += acc * df_mat
 
-    #     if self._check_refit is True:
-    #         self._check_refits(1e-10, swaptol, 1e-5)
+    #     if self.check_refit is True:
+    #         self.check_refits(1e-10, swap_tol, 1e-5)
 
 ###############################################################################
 
-    def _check_refits(self, depoTol, fraTol, swapTol):
+    def _check_refits(self, depo_tol, fra_tol, swap_tol):
         """ Ensure that the Ibor curve refits the calibration instruments. """
-        for depo in self._usedDeposits:
-            v = depo.value(self._value_dt, self) / depo._notional
-            if abs(v - 1.0) > depoTol:
+        for depo in self.used_deposits:
+            v = depo.value(self.value_dt, self) / depo.notional
+            if abs(v - 1.0) > depo_tol:
                 print("Value", v)
                 raise FinError("Deposit not repriced.")
 
-        for fra in self._usedFRAs:
-            v = fra.value(self._value_dt,
-                          self._discount_curve, self) / fra._notional
-            if abs(v) > fraTol:
+        for fra in self.used_fras:
+            v = fra.value(self.value_dt,
+                          self.discount_curve, self) / fra.notional
+            if abs(v) > fra_tol:
                 print("Value", v)
                 raise FinError("FRA not repriced.")
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # We value it as of the start date of the swap
-            v = swap.value(swap._effective_dt, self._discount_curve,
+            v = swap.value(swap.effective_dt, self.discount_curve,
                            self, None)
-            v = v / swap._fixed_leg._notional
-            if abs(v) > swapTol:
-                print("Swap with maturity " + str(swap._maturity_dt)
+            v = v / swap.fixed_leg.notional
+            if abs(v) > swap_tol:
+                print("Swap with maturity " + str(swap.maturity_dt)
                       + " Not Repriced. Has Value", v)
                 swap.print_fixed_leg_pv()
                 swap.print_float_leg_pv()
                 raise FinError("Swap not repriced.")
 
 ###############################################################################
 
     def __repr__(self):
         """ Print out the details of the Ibor curve. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUATION DATE", self._value_dt)
+        s += label_to_string("VALUATION DATE", self.value_dt)
 
-        for depo in self._usedDeposits:
+        for depo in self.used_deposits:
             s += label_to_string("DEPOSIT", "")
             s += depo.__repr__()
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
             s += label_to_string("FRA", "")
             s += fra.__repr__()
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             s += label_to_string("SWAP", "")
             s += swap.__repr__()
 
         num_points = len(self._times)
 
         s += label_to_string("INTERP TYPE", self._interp_type)
         s += label_to_string("GRID TIMES", "GRID DFS")
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_basis_swap.py` & `financepy-0.360/financepy/products/rates/ois_basis_swap.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,35 +14,36 @@
 from ...market.curves.discount_curve import DiscountCurve
 
 from .swap_float_leg import SwapFloatLeg
 
 ###############################################################################
 
 
-class IborBasisSwap:
-    """ Class for managing an Ibor-Ibor basis swap contract. This is a
+class OISBasisSwap:
+    """ Class for managing an Ibor-OIS basis swap contract. This is a
     contract in which a floating leg with one LIBOR tenor is exchanged for a
-    floating leg payment in a different LIBOR tenor. There is no exchange of
+    floating leg payment of an overnight index swap. There is no exchange of
     par. The contract is entered into at zero initial cost. The contract lasts
-    from an effective date to a specified maturity date.
+    from a start date to a specified maturity date.
 
     The value of the contract is the NPV of the two coupon streams. Discounting
-    is done on a supplied discount curve which can be different from the two
-    index discount from which the implied index rates are extracted. """
+    is done on a supplied discount curve which is separate from the discount
+    from which the implied index rates are extracted. """
 
     def __init__(self,
                  effective_dt: Date,  # Date interest starts to accrue
                  term_dt_or_tenor: (Date, str),  # Date contract ends
-                 leg1Type: SwapTypes,
-                 leg1FreqType: FrequencyTypes = FrequencyTypes.QUARTERLY,
-                 leg1DayCountType: DayCountTypes = DayCountTypes.THIRTY_E_360,
-                 leg1Spread: float = 0.0,
-                 leg2FreqType: FrequencyTypes = FrequencyTypes.QUARTERLY,
-                 leg2DayCountType: DayCountTypes = DayCountTypes.THIRTY_E_360,
-                 leg2Spread: float = 0.0,
+                 ibor_type: SwapTypes,
+                 ibor_freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
+                 ibor_day_count_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
+                 ibor_spread: float = 0.0,
+                 ois_freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
+                 ois_day_count_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
+                 ois_spread: float = 0.0,
+                 ois_payment_lag: int = 0,
                  notional: float = ONE_MILLION,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create a Ibor basis swap contract giving the contract start
         date, its maturity, frequency and day counts on the two floating
         legs and notional. The floating leg parameters have default
@@ -50,123 +51,106 @@
         and is the same as the settlement date for a new swap. It is the date
         on which interest starts to accrue. The end of the contract is the
         termination date. This is not adjusted for business days. The adjusted
         termination date is called the maturity date. This is calculated. """
 
         check_argument_types(self.__init__, locals())
 
-        if type(term_dt_or_tenor) == Date:
-            self._termination_dt = term_dt_or_tenor
+        if isinstance(term_dt_or_tenor, Date):
+            self.termination_dt = term_dt_or_tenor
         else:
-            self._termination_dt = effective_dt.add_tenor(
+            self.termination_dt = effective_dt.add_tenor(
                 term_dt_or_tenor)
 
         calendar = Calendar(cal_type)
-        self._maturity_dt = calendar.adjust(self._termination_dt,
-                                              bd_type)
+        self.maturity_dt = calendar.adjust(self.termination_dt,
+                                           bd_type)
 
-        if effective_dt > self._maturity_dt:
+        if effective_dt > self.maturity_dt:
             raise FinError("Start date after maturity date")
 
-        leg2Type = SwapTypes.PAY
-        if leg1Type == SwapTypes.PAY:
-            leg2Type = SwapTypes.RECEIVE
+        ois_type = SwapTypes.PAY
+        if ibor_type == SwapTypes.PAY:
+            ois_type = SwapTypes.RECEIVE
 
-        payment_lag = 0
         principal = 0.0
 
-        self._floatLeg1 = SwapFloatLeg(effective_dt,
-                                       self._termination_dt,
-                                       leg1Type,
-                                       leg1Spread,
-                                       leg1FreqType,
-                                       leg1DayCountType,
-                                       notional,
-                                       principal,
-                                       payment_lag,
-                                       cal_type,
-                                       bd_type,
-                                       dg_type)
-
-        self._floatLeg2 = SwapFloatLeg(effective_dt,
-                                       self._termination_dt,
-                                       leg2Type,
-                                       leg2Spread,
-                                       leg2FreqType,
-                                       leg2DayCountType,
-                                       notional,
-                                       principal,
-                                       payment_lag,
-                                       cal_type,
-                                       bd_type,
-                                       dg_type)
+        self.float_ibor_leg = SwapFloatLeg(effective_dt,
+                                           self.termination_dt,
+                                           ibor_type,
+                                           ibor_spread,
+                                           ibor_freq_type,
+                                           ibor_day_count_type,
+                                           notional,
+                                           principal,
+                                           0,
+                                           cal_type,
+                                           bd_type,
+                                           dg_type)
+
+        self.float_ois_leg = SwapFloatLeg(effective_dt,
+                                          self.termination_dt,
+                                          ois_type,
+                                          ois_spread,
+                                          ois_freq_type,
+                                          ois_day_count_type,
+                                          notional,
+                                          principal,
+                                          ois_payment_lag,
+                                          cal_type,
+                                          bd_type,
+                                          dg_type)
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               discount_curve: DiscountCurve,
-              index_curveLeg1: DiscountCurve = None,
-              index_curveLeg2: DiscountCurve = None,
-              firstFixingRateLeg1=None,
-              firstFixingRateLeg2=None):
+              index_ibor_curve: DiscountCurve = None,
+              index_ois_curve: DiscountCurve = None,
+              first_fixing_rate_leg_1=None,
+              first_fixing_rate_leg_2=None):
         """ Value the interest rate swap on a value date given a single Ibor
         discount curve and an index curve for the Ibors on each swap leg. """
 
-        if index_curveLeg1 is None:
-            index_curveLeg1 = discount_curve
+        if index_ibor_curve is None:
+            index_ibor_curve = discount_curve
 
-        if index_curveLeg2 is None:
-            index_curveLeg2 = discount_curve
+        if index_ois_curve is None:
+            index_ois_curve = discount_curve
 
-        floatLeg1Value = self._floatLeg1.value(value_dt,
-                                               discount_curve,
-                                               index_curveLeg1,
-                                               firstFixingRateLeg1)
-
-        floatLeg2Value = self._floatLeg2.value(value_dt,
-                                               discount_curve,
-                                               index_curveLeg2,
-                                               firstFixingRateLeg2)
+        float_ibor_leg_value = self.float_ibor_leg.value(value_dt,
+                                                         discount_curve,
+                                                         index_ibor_curve,
+                                                         first_fixing_rate_leg_1)
+
+        float_ois_leg_value = self.float_ois_leg.value(value_dt,
+                                                       discount_curve,
+                                                       index_ois_curve,
+                                                       first_fixing_rate_leg_2)
 
-        value = floatLeg1Value + floatLeg2Value
+        value = float_ibor_leg_value + float_ois_leg_value
         return value
 
 ###############################################################################
 
-    def print_float_leg_1_pv(self):
-        """ Prints the fixed leg amounts without any valuation details. Shows
-        the dates and sizes of the promised fixed leg flows. """
-
-        self._floatLeg1.print_valuation()
-
-###############################################################################
-
-    def print_float_leg_2_pv(self):
-        """ Prints the fixed leg amounts without any valuation details. Shows
-        the dates and sizes of the promised fixed leg flows. """
-
-        self._floatLeg2.print_valuation()
-
-###############################################################################
-
     def print_payments(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._floatLeg1.print_payments()
-        self._floatLeg2.print_payments()
+        self.float_ibor_leg.print_payments()
+        self.float_ois_leg.print_payments()
 
 ##########################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += self._floatLeg1.__repr__()
+        s += self.float_ibor_leg._repr__()
         s += "\n"
-        s += self._floatLeg2.__repr__()
+        s += self.float_ois_leg._repr__()
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Print a list of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_cap_floor.py` & `financepy-0.360/financepy/products/rates/ibor_cap_floor.py`

 * *Files 24% similar despite different names*

```diff
@@ -61,303 +61,303 @@
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Initialise IborCapFloor object. """
 
         check_argument_types(self.__init__, locals())
 
-        self._cal_type = cal_type
-        self._bd_type = bd_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
 
         if type(maturity_dt_or_tenor) == Date:
             maturity_dt = maturity_dt_or_tenor
         else:
             maturity_dt = start_dt.add_tenor(maturity_dt_or_tenor)
-            calendar = Calendar(self._cal_type)
+            calendar = Calendar(self.cal_type)
             maturity_dt = calendar.adjust(maturity_dt,
-                                            self._bd_type)
+                                            self.bd_type)
 
         if start_dt > maturity_dt:
             raise FinError("Start date must be before maturity date")
 
-        self._start_dt = start_dt
-        self._maturity_dt = maturity_dt
-        self._option_type = option_type
-        self._strike_rate = strike_rate
-        self._last_fixing = last_fixing
-        self._freq_type = freq_type
-        self._dc_type = dc_type
-        self._notional = notional
-        self._dg_type = dg_type
-
-        self._cap_floor_let_values = []
-        self._cap_floor_let_alphas = []
-        self._cap_floor_let_fwd_rates = []
-        self._cap_floor_let_intrinsic = []
-        self._cap_floor_let_dfs = []
-        self._cap_floor_pv = []
+        self.start_dt = start_dt
+        self.maturity_dt = maturity_dt
+        self.option_type = option_type
+        self.strike_rate = strike_rate
+        self.last_fixing = last_fixing
+        self.freq_type = freq_type
+        self.dc_type = dc_type
+        self.notional = notional
+        self.dg_type = dg_type
+
+        self.cap_floor_let_values = []
+        self.cap_floor_let_alphas = []
+        self.cap_floor_let_fwd_rates = []
+        self.cap_floor_let_intrinsic = []
+        self.cap_floor_let_dfs = []
+        self.cap_floor_pv = []
 
-        self._value_dt = None
-        self._day_counter = None
+        self.value_dt = None
+        self.day_counter = None
 
 ###############################################################################
 
     def _generate_dts(self):
 
-        schedule = Schedule(self._start_dt,
-                            self._maturity_dt,
-                            self._freq_type,
-                            self._cal_type,
-                            self._bd_type,
-                            self._dg_type)
+        schedule = Schedule(self.start_dt,
+                            self.maturity_dt,
+                            self.freq_type,
+                            self.cal_type,
+                            self.bd_type,
+                            self.dg_type)
 
-        self._capFloorLetDates = schedule._adjusted_dts
+        self.capFloorLetDates = schedule.adjusted_dts
 
 ##########################################################################
 
     def value(self, value_dt, libor_curve, model):
         """ Value the cap or floor using the chosen model which specifies
         the volatility of the Ibor rate to the cap start date. """
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
         self._generate_dts()
 
-        self._day_counter = DayCount(self._dc_type)
-        num_options = len(self._capFloorLetDates)
-        strike_rate = self._strike_rate
+        self.day_counter = DayCount(self.dc_type)
+        num_options = len(self.capFloorLetDates)
+        strike_rate = self.strike_rate
 
         if strike_rate < 0.0:
             raise FinError("Strike < 0.0")
 
         if num_options <= 1:
             raise FinError("Number of options in capfloor equals 1")
 
-        self._cap_floor_let_values = [0]
-        self._cap_floor_let_alphas = [0]
-        self._cap_floor_let_fwd_rates = [0]
-        self._cap_floor_let_intrinsic = [0]
-        self._cap_floor_let_dfs = [1.00]
-        self._cap_floor_pv = [0.0]
+        self.cap_floor_let_values = [0]
+        self.cap_floor_let_alphas = [0]
+        self.cap_floor_let_fwd_rates = [0]
+        self.cap_floor_let_intrinsic = [0]
+        self.cap_floor_let_dfs = [1.00]
+        self.cap_floor_pv = [0.0]
 
         cap_floor_value = 0.0
         cap_floor_let_value = 0.0
         # Value the first caplet or floorlet with known payoff
 
-        start_dt = self._start_dt
-        end_dt = self._capFloorLetDates[1]
+        start_dt = self.start_dt
+        end_dt = self.capFloorLetDates[1]
 
-        if self._last_fixing is None:
+        if self.last_fixing is None:
             fwd_rate = libor_curve.fwd_rate(start_dt, end_dt,
-                                            self._dc_type)
+                                            self.dc_type)
         else:
-            fwd_rate = self._last_fixing
+            fwd_rate = self.last_fixing
 
-        alpha = self._day_counter.year_frac(start_dt, end_dt)[0]
+        alpha = self.day_counter.year_frac(start_dt, end_dt)[0]
         df = libor_curve.df(end_dt)
 
-        if self._option_type == FinCapFloorTypes.CAP:
+        if self.option_type == FinCapFloorTypes.CAP:
             cap_floor_let_value = df * alpha * max(fwd_rate - strike_rate, 0.0)
-        elif self._option_type == FinCapFloorTypes.FLOOR:
+        elif self.option_type == FinCapFloorTypes.FLOOR:
             cap_floor_let_value = df * alpha * max(strike_rate - fwd_rate, 0.0)
 
-        cap_floor_let_value *= self._notional
+        cap_floor_let_value *= self.notional
         cap_floor_value += cap_floor_let_value
 
-        self._cap_floor_let_fwd_rates.append(fwd_rate)
-        self._cap_floor_let_values.append(cap_floor_let_value)
-        self._cap_floor_let_alphas.append(alpha)
-        self._cap_floor_let_intrinsic.append(cap_floor_let_value)
-        self._cap_floor_let_dfs.append(df)
-        self._cap_floor_pv.append(cap_floor_value)
+        self.cap_floor_let_fwd_rates.append(fwd_rate)
+        self.cap_floor_let_values.append(cap_floor_let_value)
+        self.cap_floor_let_alphas.append(alpha)
+        self.cap_floor_let_intrinsic.append(cap_floor_let_value)
+        self.cap_floor_let_dfs.append(df)
+        self.cap_floor_pv.append(cap_floor_value)
 
         for i in range(2, num_options):
 
-            start_dt = self._capFloorLetDates[i - 1]
-            end_dt = self._capFloorLetDates[i]
-            alpha = self._day_counter.year_frac(start_dt, end_dt)[0]
+            start_dt = self.capFloorLetDates[i - 1]
+            end_dt = self.capFloorLetDates[i]
+            alpha = self.day_counter.year_frac(start_dt, end_dt)[0]
 
             df = libor_curve.df(end_dt)
             fwd_rate = libor_curve.fwd_rate(start_dt, end_dt,
-                                            self._dc_type)
+                                            self.dc_type)
 
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 intrinsic_value = df * alpha * max(fwd_rate - strike_rate, 0.0)
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 intrinsic_value = df * alpha * max(strike_rate - fwd_rate, 0.0)
 
-            intrinsic_value *= self._notional
+            intrinsic_value *= self.notional
 
             cap_floor_let_value = self.value_caplet_floor_let(value_dt,
                                                            start_dt,
                                                            end_dt,
                                                            libor_curve,
                                                            model)
 
             cap_floor_value += cap_floor_let_value
 
-            self._cap_floor_let_fwd_rates.append(fwd_rate)
-            self._cap_floor_let_values.append(cap_floor_let_value)
-            self._cap_floor_let_alphas.append(alpha)
-            self._cap_floor_let_intrinsic.append(intrinsic_value)
-            self._cap_floor_let_dfs.append(df)
-            self._cap_floor_pv.append(cap_floor_value)
+            self.cap_floor_let_fwd_rates.append(fwd_rate)
+            self.cap_floor_let_values.append(cap_floor_let_value)
+            self.cap_floor_let_alphas.append(alpha)
+            self.cap_floor_let_intrinsic.append(intrinsic_value)
+            self.cap_floor_let_dfs.append(df)
+            self.cap_floor_pv.append(cap_floor_value)
 
         return cap_floor_value
 
 ###############################################################################
 
     def value_caplet_floor_let(self,
                                value_dt,
                                caplet_start_dt,
                                caplet_end_dt,
                                libor_curve,
                                model):
         """ Value the caplet or floorlet using a specific model. """
 
-        t_exp = (caplet_start_dt - self._start_dt) / gDaysInYear
+        t_exp = (caplet_start_dt - self.start_dt) / gDaysInYear
 
-        alpha = self._day_counter.year_frac(caplet_start_dt,
+        alpha = self.day_counter.year_frac(caplet_start_dt,
                                             caplet_end_dt)[0]
 
         f = libor_curve.fwd_rate(caplet_start_dt, caplet_end_dt,
-                                 self._dc_type)
+                                 self.dc_type)
 
-        k = self._strike_rate
+        k = self.strike_rate
         df = libor_curve.df(caplet_end_dt)
 
         if k == 0.0:
             k = 1e-10
 
         if isinstance(model, Black):
 
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_CALL)
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, BlackShifted):
 
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_CALL)
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, Bachelier):
 
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_CALL)
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, SABR):
 
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_CALL)
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, SABRShifted):
 
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_CALL)
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 cap_floor_let_value = model.value(f, k, t_exp, df,
                                                   OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, HWTree):
 
             t_mat = (caplet_end_dt - value_dt) / gDaysInYear
-            alpha = self._day_counter.year_frac(caplet_start_dt,
+            alpha = self.day_counter.year_frac(caplet_start_dt,
                                                 caplet_end_dt)[0]
-            strike_price = 1.0/(1.0 + alpha * self._strike_rate)
-            notional_adj = (1.0 + self._strike_rate * alpha)
+            strike_price = 1.0/(1.0 + alpha * self.strike_rate)
+            notional_adj = (1.0 + self.strike_rate * alpha)
             face_amount = 1.0
             df_times = libor_curve._times
             df_values = libor_curve._dfs
 
             v = model.option_on_zcb(t_exp, t_mat, strike_price, face_amount,
                                     df_times, df_values)
 
             # we divide by alpha to offset the multiplication above
-            if self._option_type == FinCapFloorTypes.CAP:
+            if self.option_type == FinCapFloorTypes.CAP:
                 cap_floor_let_value = v['put'] * notional_adj / alpha
-            elif self._option_type == FinCapFloorTypes.FLOOR:
+            elif self.option_type == FinCapFloorTypes.FLOOR:
                 cap_floor_let_value = v['call'] * notional_adj / alpha
 
         else:
             raise FinError("Unknown model type " + str(model))
 
-        cap_floor_let_value *= (self._notional * alpha)
+        cap_floor_let_value *= (self.notional * alpha)
 
         return cap_floor_let_value
 
 ###############################################################################
 
     def print_leg(self):
         """ Prints the cap floor payment amounts. """
 
-        print("START DATE:", self._start_dt)
-        print("MATURITY DATE:", self._maturity_dt)
-        print("OPTION TYPE", str(self._option_type))
-        print("STRIKE (%):", self._strike_rate * 100)
-        print("FREQUENCY:", str(self._freq_type))
-        print("DAY COUNT:", str(self._dc_type))
-        print("VALUATION DATE", self._value_dt)
+        print("START DATE:", self.start_dt)
+        print("MATURITY DATE:", self.maturity_dt)
+        print("OPTION TYPE", str(self.option_type))
+        print("STRIKE (%):", self.strike_rate * 100)
+        print("FREQUENCY:", str(self.freq_type))
+        print("DAY COUNT:", str(self.dc_type))
+        print("VALUATION DATE", self.value_dt)
 
-        if len(self._cap_floor_let_values) == 0:
+        if len(self.cap_floor_let_values) == 0:
             print("Caplets not calculated.")
             return
 
-        if self._option_type == FinCapFloorTypes.CAP:
+        if self.option_type == FinCapFloorTypes.CAP:
             header = "PAYMENT_dt     YEAR_FRAC   FWD_RATE    INTRINSIC      "
             header += "     DF    CAPLET_PV       CUM_PV"
-        elif self._option_type == FinCapFloorTypes.FLOOR:
+        elif self.option_type == FinCapFloorTypes.FLOOR:
             header = "PAYMENT_dt     YEAR_FRAC   FWD_RATE    INTRINSIC      "
             header += "     DF    FLRLET_PV       CUM_PV"
 
         print(header)
 
         i_flow = 0
 
-        for payment_dt in self._capFloorLetDates[i_flow:]:
+        for payment_dt in self.capFloorLetDates[i_flow:]:
             if i_flow == 0:
                 print("%15s %10s %9s %12s %12.6f %12s %12s" %
                       (payment_dt, "-", "-", "-",
-                       self._cap_floor_let_dfs[i_flow], "-", "-"))
+                       self.cap_floor_let_dfs[i_flow], "-", "-"))
             else:
                 print("%15s %10.7f %9.5f %12.2f %12.6f %12.2f %12.2f" %
                       (payment_dt,
-                       self._cap_floor_let_alphas[i_flow],
-                       self._cap_floor_let_fwd_rates[i_flow]*100,
-                       self._cap_floor_let_intrinsic[i_flow],
-                       self._cap_floor_let_dfs[i_flow],
-                       self._cap_floor_let_values[i_flow],
-                       self._cap_floor_pv[i_flow]))
+                       self.cap_floor_let_alphas[i_flow],
+                       self.cap_floor_let_fwd_rates[i_flow]*100,
+                       self.cap_floor_let_intrinsic[i_flow],
+                       self.cap_floor_let_dfs[i_flow],
+                       self.cap_floor_let_values[i_flow],
+                       self.cap_floor_pv[i_flow]))
 
             i_flow += 1
 
 ###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START DATE", self._start_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("STRIKE COUPON", self._strike_rate * 100)
-        s += label_to_string("OPTION TYPE", str(self._option_type))
-        s += label_to_string("FREQUENCY", str(self._freq_type))
-        s += label_to_string("DAY COUNT", str(self._dc_type), "")
+        s += label_to_string("START DATE", self.start_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("STRIKE COUPON", self.strike_rate * 100)
+        s += label_to_string("OPTION TYPE", str(self.option_type))
+        s += label_to_string("FREQUENCY", str(self.freq_type))
+        s += label_to_string("DAY COUNT", str(self.dc_type), "")
         return s
 
 ###############################################################################
 
     def _print(self):
         print(self)
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_conventions.py` & `financepy-0.360/financepy/products/rates/ibor_conventions.py`

 * *Files 20% similar despite different names*

```diff
@@ -11,22 +11,22 @@
 
 ##########################################################################
 
 
 class IborConventions():
 
     def __init__(self,
-                 currencyName: str,
-                 indexName: str = "LIBOR"):
+                 currency_name: str,
+                 index_name: str = "LIBOR"):
 
-        if currencyName == "USD" and indexName == "LIBOR":
-            self._spotLag = 2
-            self._dc_type = DayCountTypes.THIRTY_E_360_ISDA
-            self._cal_type = CalendarTypes.TARGET
-        elif currencyName == "EUR" and indexName == "EURIBOR":
-            self._spotLag = 2
-            self._dc_type = DayCountTypes.THIRTY_E_360_ISDA
-            self._cal_type = CalendarTypes.TARGET
+        if currency_name == "USD" and index_name == "LIBOR":
+            self.spot_lag = 2
+            self.dc_type = DayCountTypes.THIRTY_E_360_ISDA
+            self.cal_type = CalendarTypes.TARGET
+        elif currency_name == "EUR" and index_name == "EURIBOR":
+            self.spot_lag = 2
+            self.dc_type = DayCountTypes.THIRTY_E_360_ISDA
+            self.cal_type = CalendarTypes.TARGET
         else:
             pass
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_deposit.py` & `financepy-0.360/financepy/products/rates/ibor_deposit.py`

 * *Files 5% similar despite different names*

```diff
@@ -49,94 +49,96 @@
         date and the calendar and business day adjustment method are applied if
         the maturity date fall on a holiday. Note that in order to calculate
         the start date you add the spot business days to the trade date
         which usually today. """
 
         check_argument_types(self.__init__, locals())
 
-        self._cal_type = cal_type
-        self._bd_type = bd_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
 
         if type(maturity_dt_or_tenor) == Date:
             maturity_dt = maturity_dt_or_tenor
         else:
             maturity_dt = start_dt.add_tenor(maturity_dt_or_tenor)
 
-        calendar = Calendar(self._cal_type)
+        calendar = Calendar(self.cal_type)
 
         maturity_dt = calendar.adjust(maturity_dt,
-                                        self._bd_type)
+                                      self.bd_type)
+
         if start_dt > maturity_dt:
             raise FinError("Start date cannot be after maturity date")
 
-        self._start_dt = start_dt
-        self._maturity_dt = maturity_dt
-        self._deposit_rate = deposit_rate
-        self._dc_type = dc_type
-        self._notional = notional
+        self.start_dt = start_dt
+        self.maturity_dt = maturity_dt
+        self.deposit_rate = deposit_rate
+        self.dc_type = dc_type
+        self.notional = notional
 
     ###########################################################################
 
+
     def _maturity_df(self):
         """ Returns the maturity date discount factor that would allow the
         Libor curve to reprice the contractual market deposit rate. Note that
         this is a forward discount factor that starts on settlement date."""
 
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        df = 1.0 / (1.0 + acc_factor * self._deposit_rate)
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        df = 1.0 / (1.0 + acc_factor * self.deposit_rate)
         return df
 
     ###########################################################################
 
     def value(self,
               value_dt: Date,
               libor_curve):
         """ Determine the value of an existing Libor Deposit contract given a
         valuation date and a Libor curve. This is simply the PV of the future
         repayment plus interest discounted on the current Libor curve. """
 
-        if value_dt > self._maturity_dt:
+        if value_dt > self.maturity_dt:
             raise FinError("Start date after maturity date")
 
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        df_settle = libor_curve.df(self._start_dt)
-        df_maturity = libor_curve.df(self._maturity_dt)
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        df_settle = libor_curve.df(self.start_dt)
+        df_maturity = libor_curve.df(self.maturity_dt)
 
-        value = (1.0 + acc_factor * self._deposit_rate) * self._notional
+        value = (1.0 + acc_factor * self.deposit_rate) * self.notional
 
         # Need to take into account spot days being zero so depo settling fwd
         value = value * df_maturity / df_settle
 
         return value
 
     ###########################################################################
 
     def print_payments(self,
                        value_dt: Date):
         """ Print the date and size of the future repayment. """
 
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        flow = (1.0 + acc_factor * self._deposit_rate) * self._notional
-        print(self._maturity_dt, flow)
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        flow = (1.0 + acc_factor * self.deposit_rate) * self.notional
+        print(self.maturity_dt, flow)
 
     ###########################################################################
 
     def __repr__(self):
         """ Print the contractual details of the Libor deposit. """
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START DATE", self._start_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("DEPOSIT RATE", self._deposit_rate)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUS DAY ADJUST TYPE", self._bd_type)
+        s += label_to_string("START DATE", self.start_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("DEPOSIT RATE", self.deposit_rate)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUS DAY ADJUST TYPE", self.bd_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         print(self)
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_fra.py` & `financepy-0.360/financepy/products/rates/ibor_fra.py`

 * *Files 12% similar despite different names*

```diff
@@ -43,44 +43,44 @@
     The valuation below incorporates a dual curve approach.
     """
 
     def __init__(self,
                  start_dt: Date,  # The date the FRA starts to accrue
                  # End of the Ibor rate period
                  maturity_dt_or_tenor: (Date, str),
-                 fraRate: float,  # The fixed contractual FRA rate
+                 fra_rate: float,  # The fixed contractual FRA rate
                  dc_type: DayCountTypes,  # For interest period
                  notional: float = 100.0,
-                 payFixedRate: bool = True,  # True if the FRA rate is being paid
+                 pay_fixed_rate: bool = True,  # True if the FRA rate is being paid
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.MODIFIED_FOLLOWING):
         """ Create a Forward Rate Agreement object. """
 
         check_argument_types(self.__init__, locals())
 
-        self._cal_type = cal_type
-        self._bd_type = bd_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
 
-        if type(maturity_dt_or_tenor) == Date:
+        if isinstance(maturity_dt_or_tenor, Date):
             maturity_dt = maturity_dt_or_tenor
         else:
             maturity_dt = start_dt.add_tenor(maturity_dt_or_tenor)
-            calendar = Calendar(self._cal_type)
+            calendar = Calendar(self.cal_type)
             maturity_dt = calendar.adjust(maturity_dt,
-                                            self._bd_type)
+                                            self.bd_type)
 
         if start_dt > maturity_dt:
             raise FinError("Settlement date after maturity date")
 
-        self._start_dt = start_dt
-        self._maturity_dt = maturity_dt
-        self._fra_rate = fraRate
-        self._pay_fixed_rate = payFixedRate
-        self._dc_type = dc_type
-        self._notional = notional
+        self.start_dt = start_dt
+        self.maturity_dt = maturity_dt
+        self.fra_rate = fra_rate
+        self.pay_fixed_rate = pay_fixed_rate
+        self.dc_type = dc_type
+        self.notional = notional
 
     ###########################################################################
 
     def value(self,
               value_dt: Date,
               discount_curve: DiscountCurve,
               index_curve: DiscountCurve = None):
@@ -88,75 +88,75 @@
         market FRA rate. We allow the pricing to have a different curve for
         the Libor index and the discounting of promised cash flows. """
 
         if index_curve is None:
             index_curve = discount_curve
 
         # Get the Libor index from the index curve
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        dfIndex1 = index_curve.df(self._start_dt)
-        dfIndex2 = index_curve.df(self._maturity_dt)
-        liborFwd = (dfIndex1 / dfIndex2 - 1.0) / acc_factor
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        df_index1 = index_curve.df(self.start_dt)
+        df_index2 = index_curve.df(self.maturity_dt)
+        libor_fwd = (df_index1 / df_index2 - 1.0) / acc_factor
 
         # Get the discount factor from a discount curve
-        dfDiscount2 = discount_curve.df(self._maturity_dt)
+        df_mat = discount_curve.df(self.maturity_dt)
 
-        v = acc_factor * (liborFwd - self._fra_rate) * dfDiscount2
+        v = acc_factor * (libor_fwd - self.fra_rate) * df_mat
 
         # Forward value the FRA to the value date
-        df_to_value_dt = discount_curve.df(value_dt)
-        v = v * self._notional / df_to_value_dt
+        df_value = discount_curve.df(value_dt)
+        v = v * self.notional / df_value
 
-        if self._pay_fixed_rate is True:
+        if self.pay_fixed_rate is True:
             v *= -1.0
         return v
 
     ##########################################################################
 
     def maturity_df(self, index_curve):
         """ Determine the maturity date index discount factor needed to refit
         the market FRA rate. In a dual-curve world, this is not the discount
         rate discount factor but the index curve discount factor. """
 
-        dc = DayCount(self._dc_type)
-        df1 = index_curve.df(self._start_dt)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        df2 = df1 / (1.0 + acc_factor * self._fra_rate)
+        dc = DayCount(self.dc_type)
+        df1 = index_curve.df(self.start_dt)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        df2 = df1 / (1.0 + acc_factor * self.fra_rate)
         return df2
 
     ###########################################################################
 
     def print_payments(self, value_dt):
         """ Determine the value of the Deposit given a Ibor curve. """
 
-        flow_settle = self._notional
-        dc = DayCount(self._dc_type)
-        acc_factor = dc.year_frac(self._start_dt, self._maturity_dt)[0]
-        flow_maturity = (1.0 + acc_factor * self._fra_rate) * self._notional
-
-        if self._pay_fixed_rate is True:
-            print(self._start_dt, -flow_settle)
-            print(self._maturity_dt, flow_maturity)
+        flow_settle = self.notional
+        dc = DayCount(self.dc_type)
+        acc_factor = dc.year_frac(self.start_dt, self.maturity_dt)[0]
+        flow_maturity = (1.0 + acc_factor * self.fra_rate) * self.notional
+
+        if self.pay_fixed_rate is True:
+            print(self.start_dt, -flow_settle)
+            print(self.maturity_dt, flow_maturity)
         else:
-            print(self._start_dt, flow_settle)
-            print(self._maturity_dt, -flow_maturity)
+            print(self.start_dt, flow_settle)
+            print(self.maturity_dt, -flow_maturity)
 
     ##########################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START ACCD DATE", self._start_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("FRA RATE", self._fra_rate)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("PAY FIXED RATE", self._pay_fixed_rate)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("BUS DAY ADJUST TYPE", self._bd_type)
-        s += label_to_string("CALENDAR", self._cal_type)
+        s += label_to_string("START ACCD DATE", self.start_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("FRA RATE", self.fra_rate)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("PAY FIXED RATE", self.pay_fixed_rate)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("BUS DAY ADJUST TYPE", self.bd_type)
+        s += label_to_string("CALENDAR", self.cal_type)
         return s
 
     ###########################################################################
 
     def _print(self):
         print(self)
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_future.py` & `financepy-0.360/financepy/products/rates/ibor_future.py`

 * *Files 4% similar despite different names*

```diff
@@ -41,49 +41,49 @@
 
         if future_number < 1:
             raise FinError("Future number must be 1 or more")
 
         if futureTenor != "3M" and futureTenor != "3m":
             raise FinError("Only 3M IMM futures handled currently.")
 
-        self._delivery_dt = today_dt.next_imm_date()
+        self.delivery_dt = today_dt.next_imm_date()
 
         for iFut in range(0, future_number - 1):
-            self._delivery_dt = self._delivery_dt.next_imm_date()
+            self.delivery_dt = self.delivery_dt.next_imm_date()
 
-        self._end_of_interest_period = self._delivery_dt.next_imm_date()
+        self.end_of_interest_period = self.delivery_dt.next_imm_date()
 
-        self._last_trading_dt = self._delivery_dt.add_days(-2)
-        self._dc_type = dc_type
-        self._contract_size = contract_size
+        self.last_trading_dt = self.delivery_dt.add_days(-2)
+        self.dc_type = dc_type
+        self.contract_size = contract_size
 
 ###############################################################################
 
     def to_fra(self, futures_price, convexity):
         """ Convert the futures contract to a IborFRA object so it can be
         used to boostrap a Ibor curve. For this we need to adjust the futures
         rate using the convexity correction. """
 
         fra_rate = self.fra_rate(futures_price, convexity)
 
-        fra = IborFRA(self._delivery_dt,
-                      self._end_of_interest_period,
+        fra = IborFRA(self.delivery_dt,
+                      self.end_of_interest_period,
                       fra_rate,
-                      self._dc_type,
-                      notional=self._contract_size,
-                      payFixedRate=False)
+                      self.dc_type,
+                      notional=self.contract_size,
+                      pay_fixed_rate=False)
 
         return fra
 
 ###############################################################################
 
     def futures_rate(self, futures_price):
         """ Calculate implied futures rate from the futures price."""
-        futuresRate = (100.0 - futures_price) / 100.0
-        return futuresRate
+        futures_rate = (100.0 - futures_price) / 100.0
+        return futures_rate
 
 ###############################################################################
 
     def fra_rate(self, futures_price, convexity):
         """ Convert futures price and convexity to a FRA rate using the BBG
         negative convexity (in percent). This is then divided by 100 before
         being added to the futures rate. """
@@ -106,16 +106,16 @@
         http://www-2.rotman.utoronto.ca/~hull/TechnicalNotes/TechnicalNote1.pdf
 
         NOTE THIS DOES NOT APPEAR TO AGREE WITH BLOOMBERG!! INVESTIGATE.
         """
 
         a = mean_reversion
         t0 = 0.0
-        t1 = (self._last_trading_dt - value__dt) / gDaysInYear
-        t2 = (self._end_of_interest_period - value__dt) / gDaysInYear
+        t1 = (self.last_trading_dt - value__dt) / gDaysInYear
+        t2 = (self.end_of_interest_period - value__dt) / gDaysInYear
 
         # Hull White model for short rate dr = (theta(t)-ar) dt + sigma * dz
         # This reduces to Ho-Lee when a = 0 so to avoid divergences I provide
         # this numnerical limit
         if abs(a) > 1e-10:
 
             bt1t2 = (1.0 - np.exp(-a * (t2 - t1))) / a
@@ -131,15 +131,15 @@
 
 ##########################################################################
 
     def __repr__(self):
         """ Print a list of the unadjusted coupon payment _dts used in
         analytic calculations for the bond. """
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("LAST TRADING DATE", self._last_trading_dt)
-        s += label_to_string("DELIVERY DATE", self._delivery_dt)
-        s += label_to_string("END INTEREST PERIOD", self._end_of_interest_period)
-        s += label_to_string("DAY COUNT TYPE", self._dc_type)
-        s += label_to_string("CONTRACT SIZE", self._contract_size)
+        s += label_to_string("LAST TRADING DATE", self.last_trading_dt)
+        s += label_to_string("DELIVERY DATE", self.delivery_dt)
+        s += label_to_string("END INTEREST PERIOD", self.end_of_interest_period)
+        s += label_to_string("DAY COUNT TYPE", self.dc_type)
+        s += label_to_string("CONTRACT SIZE", self.contract_size)
         return s
 
 ##########################################################################
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_lmm_products.py` & `financepy-0.360/financepy/products/rates/ibor_lmm_products.py`

 * *Files 11% similar despite different names*

```diff
@@ -51,164 +51,171 @@
                  float_freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  float_dc_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create a European-style swaption by defining the exercise date of
         the swaption, and all of the details of the underlying interest rate
-        swap including the fixed coupon and the details of the fixed and the
+        swap including the fixed cpn and the details of the fixed and the
         floating leg payment schedules. """
 
         check_argument_types(self.__init__, locals())
 
         if settle_dt > maturity_dt:
             raise FinError("Settlement date must be before maturity date")
 
         """ Set up the grid for the Ibor rates that are to be simulated. These
         must be consistent with the floating rate leg of the product that is to
         be priced. """
 
-        self._start_dt = settle_dt
-        self._grid_dates = Schedule(settle_dt,
+        self.start_dt = settle_dt
+        self.grid_dts = Schedule(settle_dt,
                                    maturity_dt,
                                    float_freq_type,
                                    cal_type,
                                    bd_type,
                                    dg_type).generate()
 
-        self._accrual_factors = []
-        self._float_dc_type = float_dc_type
+        self.accrual_factors = []
+        self.float_dc_type = float_dc_type
 
-        basis = DayCount(self._float_dc_type)
-        prev_dt = self._grid_dates[0]
+        basis = DayCount(self.float_dc_type)
+        prev_dt = self.grid_dts[0]
 
-        self._grid_times = [0.0]
+        self.grid_times = [0.0]
 
-        for next_dt in self._grid_dates[1:]:
+        for next_dt in self.grid_dts[1:]:
             tau = basis.year_frac(prev_dt, next_dt)[0]
-            t = (next_dt - self._grid_dates[0]) / gDaysInYear
-            self._accrual_factors.append(tau)
-            self._grid_times.append(t)
+            t = (next_dt - self.grid_dts[0]) / gDaysInYear
+            self.accrual_factors.append(tau)
+            self.grid_times.append(t)
             prev_dt = next_dt
 
-#        print(self._grid_times)
-        self._accrual_factors = np.array(self._accrual_factors)
-        self._num_fwds = len(self._accrual_factors)
-        self._fwds = None
+#        print(self.grid_times)
+        self.accrual_factors = np.array(self.accrual_factors)
+        self.num_fwds = len(self.accrual_factors)
+        self.fwds = None
+        self.use_sobol = None
+        self.num_paths = None
+        self.numeraire_index = None
+        self.fwd_curve = None
+        self.vol_curves = None
+        self.corr_matrix = None
+        self.model_type = None
 
-#        print("Num FORWARDS", self._num_fwds)
+#        print("Num FORWARDS", self.num_fwds)
 
 ###############################################################################
 
     def simulate_1f(self,
                     discount_curve,
                     vol_curve: IborCapVolCurve,
                     num_paths: int = 1000,
-                    numeraireIndex: int = 0,
+                    numeraire_index: int = 0,
                     use_sobol: bool = True,
                     seed: int = 42):
         """ Run the one-factor simulation of the evolution of the forward
         Ibors to generate and store all of the Ibor forward rate paths. """
 
         if num_paths < 2 or num_paths > 1000000:
             raise FinError("NumPaths must be between 2 and 1 million")
 
-        if discount_curve._value_dt != self._start_dt:
+        if discount_curve.value_dt != self.start_dt:
             raise FinError("Curve anchor date not the same as LMM start date.")
 
-        self._num_paths = num_paths
-        self._numeraire_index = numeraireIndex
-        self._use_sobol = use_sobol
+        self.num_paths = num_paths
+        self.numeraire_index = numeraire_index
+        self.use_sobol = use_sobol
 
-        num_grid_points = len(self._grid_dates)
+        num_grid_points = len(self.grid_dts)
 
-        self._num_fwds = num_grid_points
-        self._fwd_curve = []
+        self.num_fwds = num_grid_points
+        self.fwd_curve = []
 
         for i in range(1, num_grid_points):
-            start_dt = self._grid_dates[i-1]
-            end_dt = self._grid_dates[i]
+            start_dt = self.grid_dts[i-1]
+            end_dt = self.grid_dts[i]
             fwd_rate = discount_curve.fwd_rate(start_dt,
                                                end_dt,
-                                               self._float_dc_type)
-            self._fwd_curve.append(fwd_rate)
+                                               self.float_dc_type)
+            self.fwd_curve.append(fwd_rate)
 
-        self._fwd_curve = np.array(self._fwd_curve)
+        self.fwd_curve = np.array(self.fwd_curve)
 
         gammas = np.zeros(num_grid_points)
         for ix in range(1, num_grid_points):
-            dt = self._grid_dates[ix]
+            dt = self.grid_dts[ix]
             gammas[ix] = vol_curve.caplet_vol(dt)
 
-        self._fwds = lmm_simulate_fwds_1f(self._num_fwds,
+        self.fwds = lmm_simulate_fwds_1f(self.num_fwds,
                                           num_paths,
-                                          numeraireIndex,
-                                          self._fwd_curve,
+                                          numeraire_index,
+                                          self.fwd_curve,
                                           gammas,
-                                          self._accrual_factors,
+                                          self.accrual_factors,
                                           use_sobol,
                                           seed)
 
 ###############################################################################
 
     def simulate_mf(self,
                     discount_curve,
-                    numFactors: int,
+                    num_factors: int,
                     lambdas: np.ndarray,
                     num_paths: int = 10000,
-                    numeraireIndex: int = 0,
+                    numeraire_index: int = 0,
                     use_sobol: bool = True,
                     seed: int = 42):
         """ Run the simulation to generate and store all of the Ibor forward
         rate paths. This is a multi-factorial version so the user must input
         a numpy array consisting of a column for each factor and the number of
         rows must equal the number of grid times on the underlying simulation
         grid. CHECK THIS. """
 
 #        check_argument_types(self.__init__, locals())
 
         if num_paths < 2 or num_paths > 1000000:
             raise FinError("NumPaths must be between 2 and 1 million")
 
-        if discount_curve._curve_dt != self._start_dt:
+        if discount_curve.curve_dt != self.start_dt:
             raise FinError("Curve anchor date not the same as LMM start date.")
 
         print("LEN LAMBDAS", len(lambdas))
         print("LEN", len(lambdas[0]))
         # We pass a vector of vol discount, one for each factor
-        if numFactors != len(lambdas):
+        if num_factors != len(lambdas):
             raise FinError("Lambda doesn't have specified number of factors.")
 
         num_rows = len(lambdas[0])
-        if num_rows != self._num_fwds+1:
+        if num_rows != self.num_fwds+1:
             raise FinError("Vol Components needs same number of rows as grid")
 
-        self._num_paths = num_paths
-        self._numeraire_index = numeraireIndex
-        self._use_sobol = use_sobol
-
-        self._num_fwds = len(self._grid_dates) - 1
-        self._fwd_curve = []
-
-        for i in range(1, self._num_fwds):
-            start_dt = self._grid_dates[i-1]
-            end_dt = self._grid_dates[i]
+        self.num_paths = num_paths
+        self.numeraire_index = numeraire_index
+        self.use_sobol = use_sobol
+
+        self.num_fwds = len(self.grid_dts) - 1
+        self.fwd_curve = []
+
+        for i in range(1, self.num_fwds):
+            start_dt = self.grid_dts[i-1]
+            end_dt = self.grid_dts[i]
             fwd_rate = discount_curve.fwd_rate(start_dt, end_dt,
-                                               self._float_dc_type)
-            self._fwd_curve.append(fwd_rate)
+                                               self.float_dc_type)
+            self.fwd_curve.append(fwd_rate)
 
-        self._fwd_curve = np.array(self._fwd_curve)
+        self.fwd_curve = np.array(self.fwd_curve)
 
-        self._fwds = lmm_simulate_fwds_mf(self._num_fwds,
-                                          numFactors,
+        self.fwds = lmm_simulate_fwds_mf(self.num_fwds,
+                                          num_factors,
                                           num_paths,
-                                          numeraireIndex,
-                                          self._fwd_curve,
+                                          numeraire_index,
+                                          self.fwd_curve,
                                           lambdas,
-                                          self._accrual_factors,
+                                          self.accrual_factors,
                                           use_sobol,
                                           seed)
 
 ###############################################################################
 
     def simulate_nf(self,
                     discount_curve,
@@ -227,61 +234,61 @@
 
         if num_paths < 2 or num_paths > 1000000:
             raise FinError("NumPaths must be between 2 and 1 million")
 
         if isinstance(model_type, ModelLMMModelTypes) is False:
             raise FinError("Model type must be type FinRateModelLMMModelTypes")
 
-        if discount_curve.curve_dt != self._start_dt:
+        if discount_curve.curve_dt != self.start_dt:
             raise FinError("Curve anchor date not the same as LMM start date.")
 
-        self._num_paths = num_paths
-        self._vol_curves = vol_curve
-        self._corr_matrix = corr_matrix
-        self._modelType = model_type
-        self._numeraire_index = numeraire_index
-        self._use_sobol = use_sobol
+        self.num_paths = num_paths
+        self.vol_curves = vol_curve
+        self.corr_matrix = corr_matrix
+        self.model_type = model_type
+        self.numeraire_index = numeraire_index
+        self.use_sobol = use_sobol
 
-        num_grid_points = len(self._grid_times)
+        num_grid_points = len(self.grid_times)
 
-        self._num_fwds = num_grid_points - 1
-        self._fwd_curve = []
+        self.num_fwds = num_grid_points - 1
+        self.fwd_curve = []
 
         for i in range(1, num_grid_points):
-            start_dt = self._grid_dates[i-1]
-            end_dt = self._grid_dates[i]
+            start_dt = self.grid_dts[i-1]
+            end_dt = self.grid_dts[i]
             fwd_rate = discount_curve.forward_rate(start_dt,
                                                    end_dt,
-                                                   self._float_dc_type)
-            self._fwd_curve.append(fwd_rate)
+                                                   self.float_dc_type)
+            self.fwd_curve.append(fwd_rate)
 
-        self._fwd_curve = np.array(self._fwd_curve)
+        self.fwd_curve = np.array(self.fwd_curve)
 
         zetas = np.zeros(num_grid_points)
         for ix in range(1, num_grid_points):
-            dt = self._grid_dates[ix]
+            dt = self.grid_dts[ix]
             zetas[ix] = vol_curve.caplet_vol(dt)
 
         # This function does not use Sobol - TODO
-        self._fwds = lmm_simulate_fwds_nf(self._num_fwds,
+        self.fwds = lmm_simulate_fwds_nf(self.num_fwds,
                                           num_paths,
-                                          self._fwd_curve,
+                                          self.fwd_curve,
                                           zetas,
                                           corr_matrix,
-                                          self._accrual_factors,
+                                          self.accrual_factors,
                                           seed)
 
 ###############################################################################
 
     def value_swaption(self,
                        settle_dt: Date,
                        exercise_dt: Date,
                        maturity_dt: Date,
                        swaption_type: SwapTypes,
-                       fixed_coupon: float,
+                       fixed_cpn: float,
                        fixed_freq_type: FrequencyTypes,
                        fixed_dc_type: DayCountTypes,
                        notional: float = ONE_MILLION,
                        float_freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                        float_dc_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
                        cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                        bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
@@ -304,58 +311,58 @@
                                       float_freq_type,
                                       cal_type,
                                       bd_type,
                                       dg_type).generate()
 
         for swaption_dt in swaption_float_dts:
             found_dt = False
-            for grid_dt in self._grid_dates:
+            for grid_dt in self.grid_dts:
                 if swaption_dt == grid_dt:
                     found_dt = True
                     break
             if found_dt is False:
                 raise FinError("Swaption float leg not on grid.")
 
-        swaption_fixed_dates = Schedule(settle_dt,
+        swaption_fixed_dts = Schedule(settle_dt,
                                         maturity_dt,
                                         fixed_freq_type,
                                         cal_type,
                                         bd_type,
                                         dg_type).generate()
 
-        for swaption_dt in swaption_fixed_dates:
+        for swaption_dt in swaption_fixed_dts:
             found_dt = False
-            for grid_dt in self._grid_dates:
+            for grid_dt in self.grid_dts:
                 if swaption_dt == grid_dt:
                     found_dt = True
                     break
             if found_dt is False:
                 raise FinError("Swaption fixed leg not on grid.")
 
         a = 0
         b = 0
 
-        for grid_dt in self._grid_dates:
+        for grid_dt in self.grid_dts:
             if grid_dt == exercise_dt:
                 break
             else:
                 a += 1
 
-        for grid_dt in self._grid_dates:
+        for grid_dt in self.grid_dts:
             if grid_dt == maturity_dt:
                 break
             else:
                 b += 1
 
         if b == 0:
             raise FinError("Swaption swap maturity date is today.")
 
 #        num_paths = 1000
-#        v = LMMSwaptionPricer(fixed_coupon, a, b, num_paths,
-#                              fwd0, fwds, taus, isPayer)
+#        v = LMMSwaptionPricer(fixed_cpn, a, b, num_paths,
+#                              fwd0, fwds, taus, is_payer)
         v = 0.0
         return v
 
 ###############################################################################
 
     def value_cap_floor(self,
                         settle_dt: Date,
@@ -375,42 +382,42 @@
                                  freq_type,
                                  cal_type,
                                  bd_type,
                                  dg_type).generate()
 
         for cap_floorlet_dt in cap_floor_dts:
             found_dt = False
-            for grid_dt in self._grid_dates:
+            for grid_dt in self.grid_dts:
                 if cap_floorlet_dt == grid_dt:
                     found_dt = True
                     break
             if found_dt is False:
                 raise FinError("CapFloor date not on grid.")
 
         num_fwds = len(cap_floor_dts)
-        num_paths = self._num_paths
+        num_paths = self.num_paths
         K = cap_floor_rate
 
         is_cap = 0
         if cap_floor_type == FinCapFloorTypes.CAP:
             is_cap = 1
 
-        fwd0 = self._fwd_curve
-        fwds = self._fwds
-        taus = self._accrual_factors
+        fwd0 = self.fwd_curve
+        fwds = self.fwds
+        taus = self.accrual_factors
 
         v = lmm_cap_flr_pricer(num_fwds, num_paths, K,
                                fwd0, fwds, taus, is_cap)
 
         # Sum the cap/floorlets to get cap/floor value
-        v_capFloor = 0.0
-        for v_capFloorLet in v:
-            v_capFloor += v_capFloorLet * notional
+        v_cap_floor = 0.0
+        for v_cap_floor_let in v:
+            v_cap_floor += v_cap_floor_let * notional
 
-        return v_capFloor
+        return v_cap_floor
 
 ###############################################################################
 
     def __repr__(self):
         """ Function to allow us to print the LMM Products details. """
 
         s = "Function not written"
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_single_curve.py` & `financepy-0.360/financepy/products/rates/ibor_single_curve.py`

 * *Files 8% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 from ...utils.global_vars import gDaysInYear
 from ...market.curves.interpolator import InterpTypes, Interpolator
 from ...market.curves.discount_curve import DiscountCurve
 from ...products.rates.ibor_deposit import IborDeposit
 from ...products.rates.ibor_fra import IborFRA
 from ...products.rates.ibor_swap import IborSwap
 
-swaptol = 1e-10
+SWAP_TOL = 1e-10
 
 ##############################################################################
 # TODO: CHANGE times to df_times
 ##############################################################################
 
 
 def _f(df, *args):
@@ -36,15 +36,15 @@
     swap = args[2]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
 
     # For discount that need a fit function, we fit it now
     curve._interpolator.fit(curve._times, curve._dfs)
     v_swap = swap.value(value_dt, curve, curve, None)
-    notional = swap._fixed_leg._notional
+    notional = swap.fixed_leg.notional
     v_swap /= notional
     return v_swap
 
 ###############################################################################
 
 
 def _g(df, *args):
@@ -54,54 +54,54 @@
     fra = args[2]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
 
     # For discount that need a fit function, we fit it now
     curve._interpolator.fit(curve._times, curve._dfs)
     v_fra = fra.value(value_dt, curve)
-    v_fra /= fra._notional
+    v_fra /= fra.notional
     return v_fra
 
 ###############################################################################
 
 
 def _cost_function(dfs, *args):
     """ Root search objective function for swaps """
 
 #    print("Discount factors:", dfs)
 
     libor_curve = args[0]
-    value_dt = libor_curve._value_dt
+    value_dt = libor_curve.value_dt
     libor_curve._dfs = dfs
 
     times = libor_curve._times
     values = -np.log(dfs)
 
     # For discount that need a fit function, we fit it now
     libor_curve._interpolator.fit(libor_curve._times, libor_curve._dfs)
 
-    if libor_curve._interp_type == InterpTypes.CUBIC_SPLINE_log_dfs:
-        libor_curve._splineFunction = CubicSpline(times, values)
+    if libor_curve._interp_type == InterpTypes.CUBIC_SPLINE_LOG_DFS:
+        libor_curve.splineFunction = CubicSpline(times, values)
     elif libor_curve._interp_type == InterpTypes.PCHIP_CUBIC_SPLINE:
-        libor_curve._splineFunction = PchipInterpolator(times, values)
+        libor_curve.splineFunction = PchipInterpolator(times, values)
 
     cost = 0.0
-    for depo in libor_curve._usedDeposits:
-        v = depo.value(value_dt, libor_curve) / depo._notional
-#        print("DEPO:", depo._maturity_dt, v)
+    for depo in libor_curve.used_deposits:
+        v = depo.value(value_dt, libor_curve) / depo.notional
+#        print("DEPO:", depo.maturity_dt, v)
         cost += (v-1.0)**2
 
-    for fra in libor_curve._usedFRAs:
-        v = fra.value(value_dt, libor_curve) / fra._notional
-#        print("FRA:", fra._maturity_dt, v)
+    for fra in libor_curve.used_fras:
+        v = fra.value(value_dt, libor_curve) / fra.notional
+#        print("FRA:", fra.maturity_dt, v)
         cost += v*v
 
-    for swap in libor_curve._usedSwaps:
-        v = swap.value(value_dt, libor_curve) / swap._notional
-#        print("SWAP:", swap._maturity_dt, v)
+    for swap in libor_curve.used_swaps:
+        v = swap.value(value_dt, libor_curve) / swap.notional
+#        print("SWAP:", swap.maturity_dt, v)
         cost += v*v
 
     print("Cost:", cost)
     return cost
 
 ###############################################################################
 
@@ -158,19 +158,20 @@
         The curve will assign a discount factor of 1.0 to the valuation date.
         If no instrument is starting on the valuation date, the curve is then
         assumed to be flat out to the first instrument using its zero rate.
         """
 
         check_argument_types(getattr(self, _func_name(), None), locals())
 
-        self._value_dt = value_dt
-        self._validate_inputs(ibor_deposits, ibor_fras, ibor_swaps)
+        self.value_dt = value_dt
         self._interp_type = interp_type
-        self._check_refit = check_refit
         self._interpolator = None
+
+        self._validate_inputs(ibor_deposits, ibor_fras, ibor_swaps)
+        self.check_refit = check_refit
         self._build_curve()
 
 ###############################################################################
 
     def _build_curve(self):
         """ Build curve based on interpolation. """
 
@@ -184,183 +185,183 @@
                          ibor_swaps):
         """ Validate the inputs for each of the Ibor products. """
 
         num_depos = len(ibor_deposits)
         num_fras = len(ibor_fras)
         num_swaps = len(ibor_swaps)
 
-        depo_start_dt = self._value_dt
-        swap_start_dt = self._value_dt
+        depo_start_dt = self.value_dt
+        swap_start_dt = self.value_dt
 
         if num_depos + num_fras + num_swaps == 0:
             raise FinError("No calibration instruments.")
 
         # Validation of the inputs.
         if num_depos > 0:
 
-            depo_start_dt = ibor_deposits[0]._start_dt
+            depo_start_dt = ibor_deposits[0].start_dt
 
             for depo in ibor_deposits:
 
                 if isinstance(depo, IborDeposit) is False:
                     raise FinError("Deposit is not of type IborDeposit")
 
-                start_dt = depo._start_dt
+                start_dt = depo.start_dt
 
-                if start_dt < self._value_dt:
+                if start_dt < self.value_dt:
                     raise FinError(
                         "First deposit starts before valuation date.")
 
                 if start_dt < depo_start_dt:
                     depo_start_dt = start_dt
 
             for depo in ibor_deposits:
-                startDt = depo._start_dt
-                endDt = depo._maturity_dt
-                if startDt >= endDt:
+                start_dt = depo.start_dt
+                end_dt = depo.maturity_dt
+                if start_dt >= end_dt:
                     raise FinError("First deposit ends on or before it begins")
 
         # Ensure order of depos
         if num_depos > 1:
 
-            prev_dt = ibor_deposits[0]._maturity_dt
+            prev_dt = ibor_deposits[0].maturity_dt
             for depo in ibor_deposits[1:]:
-                next_dt = depo._maturity_dt
+                next_dt = depo.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Deposits must be in increasing maturity")
                 prev_dt = next_dt
 
         # REMOVED THIS AS WE WANT TO ANCHOR CURVE AT VALUATION DATE
         # USE A SYNTHETIC DEPOSIT TO BRIDGE GAP FROM VALUE DATE TO SETTLEMENT DATE
         # Ensure that valuation date is on or after first deposit start date
         # if num_depos > 1:
-        #    if ibor_deposits[0]._effective_dt > self._value_dt:
+        #    if ibor_deposits[0].effective_dt > self.value_dt:
         #        raise FinError("Valuation date must not be before first deposit settles.")
 
         if num_fras > 0:
             for fra in ibor_fras:
                 if isinstance(fra, IborFRA) is False:
                     raise FinError("FRA is not of type IborFRA")
 
-                startDt = fra._start_dt
-                if startDt < self._value_dt:
+                start_dt = fra.start_dt
+                if start_dt < self.value_dt:
                     raise FinError("FRAs starts before valuation date")
 
         if num_fras > 1:
-            prev_dt = ibor_fras[0]._maturity_dt
+            prev_dt = ibor_fras[0].maturity_dt
             for fra in ibor_fras[1:]:
-                next_dt = fra._maturity_dt
+                next_dt = fra.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("FRAs must be in increasing maturity")
                 prev_dt = next_dt
 
         if num_swaps > 0:
 
-            swap_start_dt = ibor_swaps[0]._effective_dt
+            swap_start_dt = ibor_swaps[0].effective_dt
 
             for swap in ibor_swaps:
 
                 # is False and isinstance(swap, IborSwap) is False:
                 if isinstance(swap, IborSwap) is False:
                     raise FinError("Swap is not of type IborSwap")
 
-                startDt = swap._effective_dt
-                if startDt < self._value_dt:
+                start_dt = swap.effective_dt
+                if start_dt < self.value_dt:
                     raise FinError("Swaps starts before valuation date.")
 
-                if swap._effective_dt < swap_start_dt:
-                    swap_start_dt = swap._effective_dt
+                if swap.effective_dt < swap_start_dt:
+                    swap.start_dt = swap.effective_dt
 
         if num_swaps > 1:
 
             # Swaps must all start on the same date for the bootstrap
-            startDt = ibor_swaps[0]._effective_dt
+            start_dt = ibor_swaps[0].effective_dt
             for swap in ibor_swaps[1:]:
-                nextStartDt = swap._effective_dt
-                if nextStartDt != startDt:
+                next_start_dt = swap.effective_dt
+                if next_start_dt != start_dt:
                     raise FinError("Swaps must all have same start date.")
 
             # Swaps must be increasing in tenor/maturity
-            prev_dt = ibor_swaps[0]._maturity_dt
+            prev_dt = ibor_swaps[0].maturity_dt
             for swap in ibor_swaps[1:]:
-                next_dt = swap._maturity_dt
+                next_dt = swap.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Swaps must be in increasing maturity")
                 prev_dt = next_dt
 
             # Swaps must have same cash flows for bootstrap to work
-            longestSwap = ibor_swaps[-1]
+            longest_swap = ibor_swaps[-1]
 
-            longestSwapCpnDates = longestSwap._fixed_leg._payment_dts
+            longest_swapCpnDates = longest_swap.fixed_leg.payment_dts
 
             for swap in ibor_swaps[0:-1]:
 
-                swapCpnDates = swap._fixed_leg._payment_dts
+                swapCpnDates = swap.fixed_leg.payment_dts
 
                 num_flows = len(swapCpnDates)
                 for i_flow in range(0, num_flows):
-                    if swapCpnDates[i_flow] != longestSwapCpnDates[i_flow]:
+                    if swapCpnDates[i_flow] != longest_swapCpnDates[i_flow]:
                         raise FinError(
                             "Swap coupons are not on the same date grid.")
 
         #######################################################################
         # Now we have ensure they are in order check for overlaps and the like
         #######################################################################
 
-        lastDeposit_maturityDate = Date(1, 1, 1900)
-        firstFRAMaturityDate = Date(1, 1, 1900)
-        lastFRAMaturityDate = Date(1, 1, 1900)
+        last_deposit_maturity_dt = Date(1, 1, 1900)
+        first_fra_maturity_dt = Date(1, 1, 1900)
+        last_fra_maturity_dt = Date(1, 1, 1900)
 
         if num_depos > 0:
-            lastDeposit_maturityDate = ibor_deposits[-1]._maturity_dt
+            last_deposit_maturity_dt = ibor_deposits[-1].maturity_dt
 
         if num_fras > 0:
-            firstFRAMaturityDate = ibor_fras[0]._maturity_dt
-            lastFRAMaturityDate = ibor_fras[-1]._maturity_dt
+            first_fra_maturity_dt = ibor_fras[0].maturity_dt
+            last_fra_maturity_dt = ibor_fras[-1].maturity_dt
 
         if num_swaps > 0:
-            first_swap_maturity_dt = ibor_swaps[0]._maturity_dt
+            first_swap_maturity_dt = ibor_swaps[0].maturity_dt
 
         if num_depos > 0 and num_fras > 0:
-            if firstFRAMaturityDate <= lastDeposit_maturityDate:
-                print("FRA Maturity Date:", firstFRAMaturityDate)
-                print("Last Deposit Date:", lastDeposit_maturityDate)
+            if first_fra_maturity_dt <= last_deposit_maturity_dt:
+                print("FRA Maturity Date:", first_fra_maturity_dt)
+                print("Last Deposit Date:", last_deposit_maturity_dt)
                 raise FinError("First FRA must end after last Deposit")
 
         if num_fras > 0 and num_swaps > 0:
-            if first_swap_maturity_dt <= lastFRAMaturityDate:
+            if first_swap_maturity_dt <= last_fra_maturity_dt:
                 raise FinError("First Swap must mature after last FRA ends")
 
         # If both depos and swaps start after T, we need a rate to get them to
         # the first deposit. So we create a synthetic deposit rate contract.
 
-        if swap_start_dt > self._value_dt:
+        if swap_start_dt > self.value_dt:
 
             if num_depos == 0:
                 raise FinError("Need a deposit rate to pin down short end.")
 
-            if depo_start_dt > self._value_dt:
-                firstDepo = ibor_deposits[0]
-                if firstDepo._start_dt > self._value_dt:
-                    syntheticDeposit = copy.deepcopy(firstDepo)
-                    syntheticDeposit._start_dt = self._value_dt
-                    syntheticDeposit._maturity_dt = firstDepo._start_dt
-                    ibor_deposits.insert(0, syntheticDeposit)
+            if depo_start_dt > self.value_dt:
+                first_depo = ibor_deposits[0]
+                if first_depo.start_dt > self.value_dt:
+                    synthetic_deposit = copy.deepcopy(first_depo)
+                    synthetic_deposit.start_dt = self.value_dt
+                    synthetic_deposit.maturity_dt = first_depo.start_dt
+                    ibor_deposits.insert(0, synthetic_deposit)
                     num_depos += 1
 
         # Now determine which instruments are used
-        self._usedDeposits = ibor_deposits
-        self._usedFRAs = ibor_fras
-        self._usedSwaps = ibor_swaps
+        self.used_deposits = ibor_deposits
+        self.used_fras = ibor_fras
+        self.used_swaps = ibor_swaps
 
         #  Need the floating leg basis for the curve
-        if len(self._usedSwaps) > 0:
-            self._dc_type = ibor_swaps[0]._float_leg._dc_type
+        if len(self.used_swaps) > 0:
+            self.dc_type = ibor_swaps[0].float_leg.dc_type
         else:
-            self._dc_type = None
+            self.dc_type = None
 
 ###############################################################################
 
     def _build_curve_using_1d_solver(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the non-linear slower method that allows the user to choose a number
         of interpolation approaches between the swap rates and other rates. It
@@ -373,99 +374,99 @@
         # time zero is now.
         t_mat = 0.0
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
         self._interpolator.fit(self._times, self._dfs)
 
-        for depo in self._usedDeposits:
-            dfSettle = self.df(depo._start_dt)
-            df_mat = depo._maturity_df() * dfSettle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+        for depo in self.used_deposits:
+            df_settle_dt = self.df(depo.start_dt)
+            df_mat = depo._maturity_df() * df_settle_dt
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
         oldt_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < oldt_mat and t_mat > oldt_mat:
                 df_mat = fra.maturity_df(self)
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
             else:
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
-                argtuple = (self, self._value_dt, fra)
+                argtuple = (self, self.value_dt, fra)
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                         args=argtuple, tol=swaptol,
+                                         args=argtuple, tol=SWAP_TOL,
                                          maxiter=50, fprime2=None)
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # I use the lastPaymentDate in case a date has been adjusted fwd
             # over a holiday as the maturity date is usually not adjusted CHECK
-            maturity_dt = swap._fixed_leg._payment_dts[-1]
-            t_mat = (maturity_dt - self._value_dt) / gDaysInYear
+            maturity_dt = swap.fixed_leg.payment_dts[-1]
+            t_mat = (maturity_dt - self.value_dt) / gDaysInYear
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
-            argtuple = (self, self._value_dt, swap)
+            argtuple = (self, self.value_dt, swap)
 
             df_mat = optimize.newton(_f, x0=df_mat, fprime=None, args=argtuple,
-                                     tol=swaptol, maxiter=50, fprime2=None,
+                                     tol=SWAP_TOL, maxiter=50, fprime2=None,
                                      full_output=False)
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self._check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
     def _build_curve_using_quadratic_minimiser(self):
         """ Construct the discount curve using a minimisation approach. This is
         the This enables a more complex interpolation scheme. """
 
         t_mat = 0.0
         df_mat = 1.0
 
         grid_times = [t_mat]
-        gridDfs = [df_mat]
+        grid_dfs = [df_mat]
 
-        for depo in self._usedDeposits:
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+        for depo in self.used_deposits:
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             grid_times.append(t_mat)
 
-        for fra in self._usedFRAs:
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+        for fra in self.used_fras:
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
             grid_times.append(t_mat)
-            gridDfs.append(df_mat)
+            grid_dfs.append(df_mat)
 
-        for swap in self._usedSwaps:
-            t_mat = (swap._maturity_dt - self._value_dt) / gDaysInYear
+        for swap in self.used_swaps:
+            t_mat = (swap.maturity_dt - self.value_dt) / gDaysInYear
             grid_times.append(t_mat)
 
         self._times = np.array(grid_times)
         self._dfs = np.exp(-self._times * 0.05)
 
         argtuple = (self)
 
         res = optimize.minimize(_cost_function, self._dfs, method='BFGS',
                                 args=argtuple, options={'gtol': 1e-3})
 
         self._dfs = np.array(res.x)
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self.check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
     def _build_curve_linear_swap_rate_interpolation(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the linear swap rate method that is fast and exact as it does not
         require the use of a solver. It is also market standard. """
@@ -478,28 +479,28 @@
         # time zero is now.
         t_mat = 0.0
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
         self._interpolator.fit(self._times, self._dfs)
 
-        for depo in self._usedDeposits:
-            dfSettle = self.df(depo._start_dt)
-            df_mat = depo._maturity_df() * dfSettle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+        for depo in self.used_deposits:
+            df_settle_dt = self.df(depo.start_dt)
+            df_mat = depo.maturity_df() * df_settle_dt
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
         oldt_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < oldt_mat and t_mat > oldt_mat:
 
                 df_mat = fra.maturity_df(self)
@@ -510,157 +511,157 @@
 
             else:
 
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
                 self._interpolator.fit(self._times, self._dfs)
 
-                argtuple = (self, self._value_dt, fra)
+                argtuple = (self, self.value_dt, fra)
 
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                         args=argtuple, tol=swaptol,
+                                         args=argtuple, tol=SWAP_TOL,
                                          maxiter=50, fprime2=None)
 
-        if len(self._usedSwaps) == 0:
-            if self._check_refit is True:
-                self._check_refits(1e-10, swaptol, 1e-5)
+        if len(self.used_swaps) == 0:
+            if self.check_refit is True:
+                self.check_refits(1e-10, SWAP_TOL, 1e-5)
             return
 
         #######################################################################
         # ADD SWAPS TO CURVE
         #######################################################################
 
         # Find where the FRAs and Depos go up to as this bit of curve is done
-        foundStart = False
-        lastDate = self._value_dt
-        if len(self._usedDeposits) != 0:
-            lastDate = self._usedDeposits[-1]._maturity_dt
+        found_start = False
+        last_dt = self.value_dt
+        if len(self.used_deposits) != 0:
+            last_dt = self.used_deposits[-1].maturity_dt
 
-        if len(self._usedFRAs) != 0:
-            lastDate = self._usedFRAs[-1]._maturity_dt
+        if len(self.used_fras) != 0:
+            last_dt = self.used_fras[-1].maturity_dt
 
         # We use the longest swap assuming it has a superset of ALL of the
         # swap flow dates used in the curve construction
-        longestSwap = self._usedSwaps[-1]
-        cpn_dts = longestSwap._adjusted_fixed_dts
+        longest_swap = self.used_swaps[-1]
+        cpn_dts = longest_swap.adjusted_fixed_dts
         num_flows = len(cpn_dts)
 
         # Find where first coupon without discount factor starts
         start_index = 0
         for i in range(0, num_flows):
-            if cpn_dts[i] > lastDate:
+            if cpn_dts[i] > last_dt:
                 start_index = i
-                foundStart = True
+                found_start = True
                 break
 
-        if foundStart is False:
+        if found_start is False:
             raise FinError("Found start is false. Swaps payments inside FRAs")
 
         swap_rates = []
         swap_times = []
 
         # I use the last coupon date for the swap rate interpolation as this
         # may be different from the maturity date due to a holiday adjustment
         # and the swap rates need to align with the coupon payment dates
-        for swap in self._usedSwaps:
-            swap_rate = swap._fixed_leg._coupon
-            maturity_dt = swap._adjusted_fixed_dts[-1]
-            tswap = (maturity_dt - self._value_dt) / gDaysInYear
+        for swap in self.used_swaps:
+            swap_rate = swap.fixed_leg.coupon
+            maturity_dt = swap.adjusted_fixed_dts[-1]
+            tswap = (maturity_dt - self.value_dt) / gDaysInYear
             swap_times.append(tswap)
             swap_rates.append(swap_rate)
 
         interpolated_swap_rates = [0.0]
         interpolated_swap_times = [0.0]
 
         for dt in cpn_dts[1:]:
-            swapTime = (dt - self._value_dt) / gDaysInYear
-            swap_rate = np.interp(swapTime, swap_times, swap_rates)
+            swap_years = (dt - self.value_dt) / gDaysInYear
+            swap_rate = np.interp(swap_years, swap_times, swap_rates)
             interpolated_swap_rates.append(swap_rate)
-            interpolated_swap_times.append(swapTime)
+            interpolated_swap_times.append(swap_years)
 
         # Do I need this line ?
         interpolated_swap_rates[0] = interpolated_swap_rates[1]
 
-        accrual_factors = longestSwap._fixed_year_fracs
+        accrual_factors = longest_swap.fixed_year_fracs
 
         acc = 0.0
         df = 1.0
         pv01 = 0.0
-        dfSettle = self.df(longestSwap._effective_dt)
+        df_settle_dt = self.df(longest_swap.effective_dt)
 
         for i in range(1, start_index):
             dt = cpn_dts[i]
             df = self.df(dt)
             acc = accrual_factors[i-1]
             pv01 += acc * df
 
         for i in range(start_index, num_flows):
 
             dt = cpn_dts[i]
-            t_mat = (dt - self._value_dt) / gDaysInYear
+            t_mat = (dt - self.value_dt) / gDaysInYear
             swap_rate = interpolated_swap_rates[i]
             acc = accrual_factors[i-1]
-            pv01End = (acc * swap_rate + 1.0)
+            pv01_end = (acc * swap_rate + 1.0)
 
-            df_mat = (dfSettle - swap_rate * pv01) / pv01End
+            df_mat = (df_settle_dt - swap_rate * pv01) / pv01_end
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
             pv01 += acc * df_mat
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self.check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
-    def _check_refits(self, depoTol, fraTol, swapTol):
+    def _check_refits(self, depo_tol, fra_tol, swap_tol):
         """ Ensure that the Ibor curve refits the calibration instruments. """
-        for depo in self._usedDeposits:
-            v = depo.value(self._value_dt, self) / depo._notional
-            if abs(v - 1.0) > depoTol:
+        for depo in self.used_deposits:
+            v = depo.value(self.value_dt, self) / depo.notional
+            if abs(v - 1.0) > depo_tol:
                 print("Value", v)
                 raise FinError("Deposit not repriced.")
 
-        for fra in self._usedFRAs:
-            v = fra.value(self._value_dt, self, self) / fra._notional
-            if abs(v) > fraTol:
+        for fra in self.used_fras:
+            v = fra.value(self.value_dt, self, self) / fra.notional
+            if abs(v) > fra_tol:
                 print("Value", v)
                 raise FinError("FRA not repriced.")
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # We value it as of the start date of the swap
-            v = swap.value(swap._effective_dt, self, self, None)
-            v = v / swap._fixed_leg._notional
-#            print("REFIT SWAP VALUATION:", swap._adjustedMaturityDate, v)
-            if abs(v) > swapTol:
-                print("Swap with maturity " + str(swap._maturity_dt)
+            v = swap.value(swap.effective_dt, self, self, None)
+            v = v / swap.fixed_leg.notional
+#            print("REFIT SWAP VALUATION:", swap.adjustedMaturityDate, v)
+            if abs(v) > swap_tol:
+                print("Swap with maturity " + str(swap.maturity_dt)
                       + " Not Repriced. Has Value", v)
                 swap.print_fixed_leg_pv()
                 swap.print_float_leg_pv()
                 raise FinError("Swap not repriced.")
 
 ###############################################################################
 
     def __repr__(self):
         """ Print out the details of the Ibor curve. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUATION DATE", self._value_dt)
+        s += label_to_string("VALUATION DATE", self.value_dt)
 
-        for depo in self._usedDeposits:
+        for depo in self.used_deposits:
             s += label_to_string("DEPOSIT", "")
             s += depo.__repr__()
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
             s += label_to_string("FRA", "")
             s += fra.__repr__()
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             s += label_to_string("SWAP", "")
             s += swap.__repr__()
 
         num_points = len(self._times)
 
         s += label_to_string("INTERP TYPE", self._interp_type)
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_swap.py` & `financepy-0.360/financepy/products/rates/ibor_swap.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import numpy as np
 
 from ...utils.error import FinError
 from ...utils.date import Date
-from ...utils.global_vars import gSmall
+from ...utils.global_vars import g_small
 from ...utils.day_count import DayCountTypes
 from ...utils.frequency import FrequencyTypes, annual_frequency
 from ...utils.calendar import CalendarTypes, DateGenRuleTypes
 from ...utils.calendar import Calendar, BusDayAdjustTypes
 from ...utils.helpers import check_argument_types, label_to_string
 from ...utils.math import ONE_MILLION
 from ...utils.global_types import SwapTypes
@@ -29,80 +29,79 @@
     payments linked to some IBOR index rate. There is no exchange of principal.
     The contract is entered into at zero initial cost. The contract lasts from
     a start date to a specified maturity date.
 
     The floating rate is not known fully until the end of the preceding payment
     period. It is set in advance and paid in arrears.
 
-    The value of the contract is the NPV of the two coupon streams. Discounting
+    The value of the contract is the NPV of the two cpn streams. Discounting
     is done on a supplied discount curve which is separate from the curve from
     which the implied index rates are extracted. """
 
     def __init__(self,
                  effective_dt: Date,  # Date interest starts to accrue
                  term_dt_or_tenor: (Date, str),  # Date contract ends
                  fixed_leg_type: SwapTypes,
-                 fixed_coupon: float,  # Fixed coupon (annualised)
+                 fixed_cpn: float,  # Fixed cpn (annualised)
                  fixed_freq_type: FrequencyTypes,
                  fixed_dc_type: DayCountTypes,
                  notional: float = ONE_MILLION,
                  float_spread: float = 0.0,
                  float_freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  float_dc_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create an interest rate swap contract giving the contract start
-        date, its maturity, fixed coupon, fixed leg frequency, fixed leg day
+        date, its maturity, fixed cpn, fixed leg frequency, fixed leg day
         count convention and notional. The floating leg parameters have default
         values that can be overwritten if needed. The start date is contractual
         and is the same as the settlement date for a new swap. It is the date
         on which interest starts to accrue. The end of the contract is the
         termination date. This is not adjusted for business days. The adjusted
         termination date is called the maturity date. This is calculated. """
 
         check_argument_types(self.__init__, locals())
 
-        if type(term_dt_or_tenor) == Date:
-            self._termination_dt = term_dt_or_tenor
+        if isinstance(term_dt_or_tenor, Date):
+            self.termination_dt = term_dt_or_tenor
         else:
-            self._termination_dt = effective_dt.add_tenor(
+            self.termination_dt = effective_dt.add_tenor(
                 term_dt_or_tenor)
 
         calendar = Calendar(cal_type)
-        self._maturity_dt = calendar.adjust(self._termination_dt,
-                                            bd_type)
+        self.maturity_dt = calendar.adjust(self.termination_dt, bd_type)
 
-        if effective_dt > self._maturity_dt:
+        if effective_dt > self.maturity_dt:
             raise FinError("Start date after maturity date")
 
-        self._effective_dt = effective_dt
+        self.effective_dt = effective_dt
 
         float_leg_type = SwapTypes.PAY
         if fixed_leg_type == SwapTypes.PAY:
             float_leg_type = SwapTypes.RECEIVE
 
         payment_lag = 0
         principal = 0.0
 
-        self._fixed_leg = SwapFixedLeg(effective_dt,
-                                       self._termination_dt,
+        self.fixed_leg = SwapFixedLeg(effective_dt,
+                                       self.termination_dt,
                                        fixed_leg_type,
-                                       fixed_coupon,
+                                       fixed_cpn,
                                        fixed_freq_type,
                                        fixed_dc_type,
                                        notional,
                                        principal,
                                        payment_lag,
                                        cal_type,
                                        bd_type,
                                        dg_type)
 
-        self._float_leg = SwapFloatLeg(effective_dt,
-                                       self._termination_dt,
+        self.float_leg = SwapFloatLeg(effective_dt,
+                                       self.termination_dt,
                                        float_leg_type,
                                        float_spread,
                                        float_freq_type,
                                        float_dc_type,
                                        notional,
                                        principal,
                                        payment_lag,
@@ -112,81 +111,81 @@
 
     ###########################################################################
 
     def value(self,
               value_dt: Date,
               discount_curve: DiscountCurve,
               index_curve: DiscountCurve = None,
-              firstFixingRate=None):
+              first_fixing_rate=None):
         """ Value the interest rate swap on a value date given a single Ibor
         discount curve. """
 
         if index_curve is None:
             index_curve = discount_curve
 
-        fixed_leg_value = self._fixed_leg.value(value_dt,
+        fixed_leg_value = self.fixed_leg.value(value_dt,
                                                 discount_curve)
 
-        float_leg_value = self._float_leg.value(value_dt,
+        float_leg_value = self.float_leg.value(value_dt,
                                                 discount_curve,
                                                 index_curve,
-                                                firstFixingRate)
+                                                first_fixing_rate)
 
         value = fixed_leg_value + float_leg_value
         return value
 
     ###########################################################################
 
     def pv01(self, value_dt, discount_curve):
-        """ Calculate the value of 1 basis point coupon on the fixed leg. """
+        """ Calculate the value of 1 basis point cpn on the fixed leg. """
 
-        pv = self._fixed_leg.value(value_dt, discount_curve)
-        pv01 = pv / self._fixed_leg._cpn / self._fixed_leg._notional
+        pv = self.fixed_leg.value(value_dt, discount_curve)
+        pv01 = pv / self.fixed_leg.cpn / self.fixed_leg.notional
         # Needs to be positive even if it is a payer leg
         pv01 = np.abs(pv01)
         return pv01
 
     ###########################################################################
 
     def swap_rate(self,
                   value_dt: Date,
                   discount_curve: DiscountCurve,
                   index_curve: DiscountCurve = None,
                   first_fixing: float = None):
-        """ Calculate the fixed leg coupon that makes the swap worth zero.
+        """ Calculate the fixed leg cpn that makes the swap worth zero.
         If the valuation date is before the swap payments start then this
         is the forward swap rate as it starts in the future. The swap rate
         is then a forward swap rate and so we use a forward discount
         factor. If the swap fixed leg has begun then we have a spot
         starting swap. The swap rate can also be calculated in a dual curve
         approach but in this case the first fixing on the floating leg is
         needed. """
 
         pv01 = self.pv01(value_dt, discount_curve)
 
-        if abs(pv01) < gSmall:
+        if abs(pv01) < g_small:
             raise FinError("PV01 is zero. Cannot compute swap rate.")
 
-        if value_dt < self._effective_dt:
-            df0 = discount_curve.df(self._effective_dt)
+        if value_dt < self.effective_dt:
+            df0 = discount_curve.df(self.effective_dt)
         else:
             df0 = discount_curve.df(value_dt)
 
         float_leg_pv = 0.0
 
         if index_curve is None:
-            df_t = discount_curve.df(self._maturity_dt)
+            df_t = discount_curve.df(self.maturity_dt)
             float_leg_pv = (df0 - df_t)
         else:
-            float_leg_pv = self._float_leg.value(value_dt,
-                                                 discount_curve,
-                                                 index_curve,
-                                                 first_fixing)
+            float_leg_pv = self.float_leg.value(value_dt,
+                                                discount_curve,
+                                                index_curve,
+                                                first_fixing)
 
-            float_leg_pv /= self._fixed_leg._notional
+            float_leg_pv /= self.fixed_leg.notional
 
         cpn = float_leg_pv / pv01
         return cpn
 
     ###########################################################################
 
     def cash_settled_pv01(self,
@@ -202,69 +201,69 @@
 
         if m == 0:
             raise FinError("Frequency cannot be zero.")
 
         """ The swap may have started in the past but we can only value
         payments that have occurred after the valuation date. """
         start_index = 0
-        while self._fixed_leg._payment_dts[start_index] < value_dt:
+        while self.fixed_leg.payment_dts[start_index] < value_dt:
             start_index += 1
 
         """ If the swap has yet to settle then we do not include the
-        start date of the swap as a coupon payment date. """
-        if value_dt <= self._effective_dt:
+        start date of the swap as a cpn payment date. """
+        if value_dt <= self.effective_dt:
             start_index = 1
 
         """ Now PV fixed leg flows. """
-        flatPV01 = 0.0
+        flat_pv01 = 0.0
         df = 1.0
         alpha = 1.0 / m
 
-        for _ in self._fixed_leg._payment_dts[start_index:]:
+        for _ in self.fixed_leg.payment_dts[start_index:]:
             df = df / (1.0 + alpha * flat_swap_rate)
-            flatPV01 += df * alpha
+            flat_pv01 += df * alpha
 
-        return flatPV01
+        return flat_pv01
 
     ###########################################################################
 
     def print_fixed_leg_pv(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._fixed_leg.print_valuation()
+        self.fixed_leg.print_valuation()
 
     ###########################################################################
 
     def print_float_leg_pv(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._float_leg.print_valuation()
+        self.float_leg.print_valuation()
 
     ###########################################################################
 
     def print_payments(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._fixed_leg.print_payments()
-        self._float_leg.print_payments()
+        self.fixed_leg.print_payments()
+        self.float_leg.print_payments()
 
     ###########################################################################
 
     def __repr__(self):
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += self._fixed_leg.__repr__()
+        s += self.fixed_leg.__repr__()
         s += "\n"
-        s += self._float_leg.__repr__()
+        s += self.float_leg.__repr__()
         return s
 
     ###########################################################################
 
     def _print(self):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted cpn payment dates used in
         analytic calculations for the bond. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/rates/ibor_swaption.py` & `financepy-0.360/financepy/products/rates/ibor_swaption.py`

 * *Files 14% similar despite different names*

```diff
@@ -38,66 +38,67 @@
 from ...utils.global_types import FinExerciseTypes
 
 ###############################################################################
 
 
 class IborSwaption():
     """ This is the class for the European-style swaption, an option to enter
-    into a swap (payer or receiver of the fixed coupon), that starts in the
+    into a swap (payer or receiver of the fixed cpn), that starts in the
     future and with a fixed maturity, at a swap rate fixed today. """
 
     def __init__(self,
                  settle_dt: Date,
                  exercise_dt: Date,
                  maturity_dt: Date,
                  fixed_leg_type: SwapTypes,
-                 fixed_coupon: float,
+                 fixed_cpn: float,
                  fixed_freq_type: FrequencyTypes,
                  fixed_dc_type: DayCountTypes,
                  notional: float = ONE_MILLION,
                  float_freq_type: FrequencyTypes = FrequencyTypes.QUARTERLY,
                  float_dc_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create a European-style swaption by defining the exercise date of
         the swaption, and all of the details of the underlying interest rate
-        swap including the fixed coupon and the details of the fixed and the
+        swap including the fixed cpn and the details of the fixed and the
         floating leg payment schedules. Bermudan style swaption should be
         priced using the IborBermudanSwaption class. """
 
         check_argument_types(self.__init__, locals())
 
         if settle_dt > exercise_dt:
             raise FinError("Settlement date must be before expiry date")
 
         if exercise_dt > maturity_dt:
             raise FinError("Exercise date must be before swap maturity date")
 
-        self._settle_dt = settle_dt
-        self._exercise_dt = exercise_dt
-        self._maturity_dt = maturity_dt
-        self._fixed_leg_type = fixed_leg_type
-
-        self._notional = notional
-
-        self._fixed_coupon = fixed_coupon
-        self._fixed_freq_type = fixed_freq_type
-        self._fixed_dc_type = fixed_dc_type
-        self._float_freq_type = float_freq_type
-        self._float_dc_type = float_dc_type
-
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
-
-        self._pv01 = None
-        self._fwd_swap_rate = None
-        self._forward_df = None
-        self._underlying_swap = None
+        self.settle_dt = settle_dt
+        self.exercise_dt = exercise_dt
+        self.maturity_dt = maturity_dt
+        self.fixed_leg_type = fixed_leg_type
+
+        self.notional = notional
+
+        self.fixed_cpn = fixed_cpn
+        self.fixed_freq_type = fixed_freq_type
+        self.fixed_dc_type = fixed_dc_type
+        self.float_freq_type = float_freq_type
+        self.float_dc_type = float_dc_type
+
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+
+        self.pv01 = None
+        self.fwd_swap_rate = None
+        self.forward_df = None
+        self.underlying_swap = None
+        self.swap_type = None
 
 ###############################################################################
 
     def value(self,
               value_dt,
               discount_curve,
               model):
@@ -106,185 +107,185 @@
         FinModelBlackShifted, SABR, SABRShifted, FinModelHW,
         FinModelBK and FinModelBDT. The last two involved a tree-based
         valuation. """
 
         float_spread = 0.0
 
         # We create a swap that starts on the exercise date.
-        swap = IborSwap(self._exercise_dt,
-                        self._maturity_dt,
-                        self._fixed_leg_type,
-                        self._fixed_coupon,
-                        self._fixed_freq_type,
-                        self._fixed_dc_type,
-                        self._notional,
+        swap = IborSwap(self.exercise_dt,
+                        self.maturity_dt,
+                        self.fixed_leg_type,
+                        self.fixed_cpn,
+                        self.fixed_freq_type,
+                        self.fixed_dc_type,
+                        self.notional,
                         float_spread,
-                        self._float_freq_type,
-                        self._float_dc_type,
-                        self._cal_type,
-                        self._bd_type,
-                        self._dg_type)
+                        self.float_freq_type,
+                        self.float_dc_type,
+                        self.cal_type,
+                        self.bd_type,
+                        self.dg_type)
 
-        k = self._fixed_coupon
+        k = self.fixed_cpn
 
         # The pv01 is the value of the swap cash flows as of the curve date
         pv01 = swap.pv01(value_dt, discount_curve)
 
         # We need to calculate the forward swap rate on the swaption exercise
         # date that makes the forward swap worth par including principal
         s = swap.swap_rate(value_dt, discount_curve)
 
-        t_exp = (self._exercise_dt - self._settle_dt) / gDaysInYear
-        t_mat = (self._maturity_dt - self._settle_dt) / gDaysInYear
+        t_exp = (self.exercise_dt - self.settle_dt) / gDaysInYear
+        t_mat = (self.maturity_dt - self.settle_dt) / gDaysInYear
 
         # Discounting is done via the PV01 annuity so no discounting in Black
         df = 1.0
 
         #######################################################################
-        # For the tree models we need to generate a vector of the coupons
+        # For the tree models we need to generate a vector of the cpns
         #######################################################################
 
         cpn_times = [t_exp]
         cpn_flows = [0.0]
 
         # The first flow is on the day after the expiry date
-        num_flows = len(swap._fixed_leg._payment_dts)
+        num_flows = len(swap.fixed_leg.payment_dts)
 
         for i_flow in range(0, num_flows):
 
-            flow_dt = swap._fixed_leg._payment_dts[i_flow]
+            flow_dt = swap.fixed_leg.payment_dts[i_flow]
 
             # Only flows occurring after option expiry are counted.
             # Flows on the expiry date are not included
-            if flow_dt > self._exercise_dt:
+            if flow_dt > self.exercise_dt:
                 cpn_time = (flow_dt - value_dt) / gDaysInYear
-                cpn_flow = swap._fixed_leg._payments[i_flow] / self._notional
+                cpn_flow = swap.fixed_leg.payments[i_flow] / self.notional
                 cpn_times.append(cpn_time)
                 cpn_flows.append(cpn_flow)
 
         cpn_times = np.array(cpn_times)
         cpn_flows = np.array(cpn_flows)
 
         df_times = discount_curve._times
         df_values = discount_curve._dfs
 
         if np.any(cpn_times < 0.0):
-            raise FinError("No coupon times can be before the value date.")
+            raise FinError("No cpn times can be before the value date.")
 
         strike_price = 1.0
         face_amount = 1.0
         swaption_price = None
 
         #######################################################################
 
         if isinstance(model, Black):
 
-            if self._fixed_leg_type == SwapTypes.PAY:
+            if self.fixed_leg_type == SwapTypes.PAY:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_CALL)
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, BlackShifted):
 
-            if self._fixed_leg_type == SwapTypes.PAY:
+            if self.fixed_leg_type == SwapTypes.PAY:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_CALL)
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, SABR):
 
-            if self._fixed_leg_type == SwapTypes.PAY:
+            if self.fixed_leg_type == SwapTypes.PAY:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_CALL)
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, SABRShifted):
 
-            if self._fixed_leg_type == SwapTypes.PAY:
+            if self.fixed_leg_type == SwapTypes.PAY:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_CALL)
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_PUT)
 
         elif isinstance(model, HWTree):
 
-            swaptionPx = model.european_bond_option_jamshidian(t_exp,
-                                                               strike_price,
-                                                               face_amount,
-                                                               cpn_times,
-                                                               cpn_flows,
-                                                               df_times,
-                                                               df_values)
-
-            if self._fixed_leg_type == SwapTypes.PAY:
-                swaption_price = swaptionPx['put']
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
-                swaption_price = swaptionPx['call']
+            swaption_px = model.european_bond_option_jamshidian(t_exp,
+                                                                strike_price,
+                                                                face_amount,
+                                                                cpn_times,
+                                                                cpn_flows,
+                                                                df_times,
+                                                                df_values)
+
+            if self.fixed_leg_type == SwapTypes.PAY:
+                swaption_price = swaption_px['put']
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
+                swaption_price = swaption_px['call']
             else:
                 raise FinError("Unknown swaption option type" +
-                               str(self._swapType))
+                               str(self.swap_type))
 
             # Cancel the multiplication at the end below
             swaption_price /= pv01
 
         elif isinstance(model, BKTree):
 
             model.build_tree(t_mat, df_times, df_values)
-            swaptionPx = model.bermudan_swaption(t_exp,
-                                                 t_mat,
-                                                 strike_price,
-                                                 face_amount,
-                                                 cpn_times,
-                                                 cpn_flows,
-                                                 FinExerciseTypes.EUROPEAN)
-
-            if self._fixed_leg_type == SwapTypes.PAY:
-                swaption_price = swaptionPx['pay']
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
-                swaption_price = swaptionPx['rec']
+            swaption_px = model.bermudan_swaption(t_exp,
+                                                  t_mat,
+                                                  strike_price,
+                                                  face_amount,
+                                                  cpn_times,
+                                                  cpn_flows,
+                                                  FinExerciseTypes.EUROPEAN)
+
+            if self.fixed_leg_type == SwapTypes.PAY:
+                swaption_price = swaption_px['pay']
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
+                swaption_price = swaption_px['rec']
 
             swaption_price /= pv01
 
         elif isinstance(model, BDTTree):
 
             model.build_tree(t_mat, df_times, df_values)
-            swaptionPx = model.bermudan_swaption(t_exp,
-                                                 t_mat,
-                                                 strike_price,
-                                                 face_amount,
-                                                 cpn_times,
-                                                 cpn_flows,
-                                                 FinExerciseTypes.EUROPEAN)
-
-            if self._fixed_leg_type == SwapTypes.PAY:
-                swaption_price = swaptionPx['pay']
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
-                swaption_price = swaptionPx['rec']
+            swaption_px = model.bermudan_swaption(t_exp,
+                                                  t_mat,
+                                                  strike_price,
+                                                  face_amount,
+                                                  cpn_times,
+                                                  cpn_flows,
+                                                  FinExerciseTypes.EUROPEAN)
+
+            if self.fixed_leg_type == SwapTypes.PAY:
+                swaption_price = swaption_px['pay']
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
+                swaption_price = swaption_px['rec']
 
             swaption_price /= pv01
         else:
             raise FinError("Unknown swaption model " + str(model))
 
-        self._pv01 = pv01
-        self._fwd_swap_rate = s
-        self._forward_df = discount_curve.df(self._exercise_dt)
-        self._underlying_swap = swap
+        self.pv01 = pv01
+        self.fwd_swap_rate = s
+        self.forward_df = discount_curve.df(self.exercise_dt)
+        self.underlying_swap = swap
 
         # The exchange of cash occurs on the settlement date. However the
         # actual value is that on the specified valuation date which could
         # be the swaption settlement date.
-        df_settle = discount_curve.df(self._settle_dt)
-        swaption_price = swaption_price * pv01 * self._notional / df_settle
+        df_settle = discount_curve.df(self.settle_dt)
+        swaption_price = swaption_price * pv01 * self.notional / df_settle
         return swaption_price
 
 ###############################################################################
 
     def cash_settled_value(self,
                            value_dt: Date,
                            discount_curve,
@@ -294,108 +295,108 @@
         approach which is a market convention that used Black's model and that
         discounts all of the future payments at a flat swap rate. Note that the
         Black volatility for this valuation should in general not equal the
         Black volatility for the standard arbitrage-free valuation. """
 
         float_spread = 0.0
 
-        swap = IborSwap(self._exercise_dt,
-                        self._maturity_dt,
-                        self._fixed_leg_type,
-                        self._fixed_coupon,
-                        self._fixed_freq_type,
-                        self._fixed_dc_type,
-                        self._notional,
+        swap = IborSwap(self.exercise_dt,
+                        self.maturity_dt,
+                        self.fixed_leg_type,
+                        self.fixed_cpn,
+                        self.fixed_freq_type,
+                        self.fixed_dc_type,
+                        self.notional,
                         float_spread,
-                        self._float_freq_type,
-                        self._float_dc_type,
-                        self._cal_type,
-                        self._bd_type,
-                        self._dg_type)
+                        self.float_freq_type,
+                        self.float_dc_type,
+                        self.cal_type,
+                        self.bd_type,
+                        self.dg_type)
 
-        k = self._fixed_coupon
+        k = self.fixed_cpn
         s = swap_rate
 
         pv01 = swap.cash_settled_pv01(value_dt,
                                       swap_rate,
-                                      self._fixed_freq_type)
+                                      self.fixed_freq_type)
 
-        t_exp = (self._exercise_dt - self._settle_dt) / gDaysInYear
+        t_exp = (self.exercise_dt - self.settle_dt) / gDaysInYear
 
         # Discounting is done via the PV01 annuity so no discounting in Black
         df = 1.0
 
         if isinstance(model, Black):
 
-            if self._fixed_leg_type == SwapTypes.PAY:
+            if self.fixed_leg_type == SwapTypes.PAY:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_CALL)
-            elif self._fixed_leg_type == SwapTypes.RECEIVE:
+            elif self.fixed_leg_type == SwapTypes.RECEIVE:
                 swaption_price = model.value(s, k, t_exp, df,
                                              OptionTypes.EUROPEAN_PUT)
         else:
             raise FinError("Cash settled swaptions must be priced using"
                            + " Black's model.")
 
-        self._fwd_swap_rate = swap_rate
-        self._forward_df = discount_curve.df(self._exercise_dt)
-        self._underlying_swap = swap
+        self.fwd_swap_rate = swap_rate
+        self.forward_df = discount_curve.df(self.exercise_dt)
+        self.underlying_swap = swap
         # The annuity needs to be discounted to today using the correct df
-        self._pv01 = pv01 * self._forward_df
+        self.pv01 = pv01 * self.forward_df
 
         # The exchange of cash occurs on the settlement date but we need to
         # value the swaption on the provided valuation date - which could be
         # the settlement date or may be a different date.
-        dfValuation = discount_curve.df(value_dt)
-        swaption_price = swaption_price * self._pv01 * self._notional / dfValuation
+        df_value_dt = discount_curve.df(value_dt)
+        swaption_price = swaption_price * self.pv01 * self.notional / df_value_dt
         return swaption_price
 
 ###############################################################################
 
     def print_swap_fixed_leg(self):
 
-        if self._underlying_swap is None:
+        if self.underlying_swap is None:
             raise FinError("Underlying swap has not been set. Do a valuation.")
 
-        self._underlying_swap.print_fixed_leg_pv()
+        self.underlying_swap.print_fixed_leg_pv()
 
 ###############################################################################
 
     def print_swap_float_leg(self):
 
-        if self._underlying_swap is None:
+        if self.underlying_swap is None:
             raise FinError("Underlying swap has not been set. Do a valuation.")
 
-        self._underlying_swap.print_float_leg_pv()
+        self.underlying_swap.print_float_leg_pv()
 
 ###############################################################################
 
     def __repr__(self):
         """ Function to allow us to print the swaption details. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("SETTLEMENT DATE", self._settle_dt)
-        s += label_to_string("EXERCISE DATE", self._exercise_dt)
-        s += label_to_string("SWAP FIXED LEG TYPE", str(self._fixed_leg_type))
-        s += label_to_string("SWAP MATURITY DATE", self._maturity_dt)
-        s += label_to_string("SWAP NOTIONAL", self._notional)
-        s += label_to_string("FIXED COUPON", self._fixed_coupon * 100)
+        s += label_to_string("SETTLEMENT DATE", self.settle_dt)
+        s += label_to_string("EXERCISE DATE", self.exercise_dt)
+        s += label_to_string("SWAP FIXED LEG TYPE", str(self.fixed_leg_type))
+        s += label_to_string("SWAP MATURITY DATE", self.maturity_dt)
+        s += label_to_string("SWAP NOTIONAL", self.notional)
+        s += label_to_string("FIXED cpn", self.fixed_cpn * 100)
         s += label_to_string("FIXED FREQUENCY",
-                             str(self._fixed_freq_type))
+                             str(self.fixed_freq_type))
         s += label_to_string("FIXED DAY COUNT",
-                             str(self._fixed_dc_type))
+                             str(self.fixed_dc_type))
         s += label_to_string("FLOAT FREQUENCY",
-                             str(self._float_freq_type))
+                             str(self.float_freq_type))
         s += label_to_string("FLOAT DAY COUNT",
-                             str(self._float_dc_type))
+                             str(self.float_dc_type))
 
-        if self._pv01 is not None:
-            s += label_to_string("PV01", self._pv01)
-            s += label_to_string("FWD SWAP RATE", self._fwd_swap_rate*100)
-            s += label_to_string("FWD DF TO EXPIRY", self._forward_df, "")
+        if self.pv01 is not None:
+            s += label_to_string("PV01", self.pv01)
+            s += label_to_string("FWD SWAP RATE", self.fwd_swap_rate*100)
+            s += label_to_string("FWD DF TO EXPIRY", self.forward_df, "")
 
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Alternative print method. """
```

### Comparing `financepy-0.350/financepy/products/rates/ois.py` & `financepy-0.360/financepy/products/rates/ois.py`

 * *Files 6% similar despite different names*

```diff
@@ -39,192 +39,192 @@
     of par. The contract is entered into at zero initial cost.
 
     NOTE: This class is almost identical to IborSwap but will possibly
     deviate as distinctions between the two become clear to me. If not they
     will be converged (or inherited) to avoid duplication.
 
     The contract lasts from a start date to a specified maturity date.
-    The fixed coupon is the OIS fixed rate for the corresponding tenor which is
+    The fixed cpn is the OIS fixed rate for the corresponding tenor which is
     set at contract initiation.
 
     The floating rate is not known fully until the end of each payment period.
     It's calculated at the contract maturity and is based on daily observations
     of the overnight index rate which are compounded according to a specific
     convention. Hence the OIS floating rate is determined by the history of the
     OIS rates.
 
     In its simplest form, there is just one fixed rate payment and one floating
     rate payment at contract maturity. However when the contract becomes longer
     than one year the floating and fixed payments become periodic, usually with
     annual exchanges of cash.
 
-    The value of the contract is the NPV of the two coupon streams. Discounting
+    The value of the contract is the NPV of the two cpn streams. Discounting
     is done on the OIS curve which is itself implied by the term structure of
     market OIS rates. """
 
     def __init__(self,
                  effective_dt: Date,  # Date interest starts to accrue
                  term_dt_or_tenor: (Date, str),  # Date contract ends
                  fixed_leg_type: SwapTypes,
-                 fixed_coupon: float,  # Fixed coupon (annualised)
+                 fixed_cpn: float,  # Fixed cpn (annualised)
                  fixed_freq_type: FrequencyTypes,
                  fixed_dc_type: DayCountTypes,
                  notional: float = ONE_MILLION,
                  payment_lag: int = 0,  # Number of days after period payment occurs
                  float_spread: float = 0.0,
                  float_freq_type: FrequencyTypes = FrequencyTypes.ANNUAL,
                  float_dc_type: DayCountTypes = DayCountTypes.THIRTY_E_360,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
                  dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
         """ Create an overnight index swap contract giving the contract start
-        date, its maturity, fixed coupon, fixed leg frequency, fixed leg day
+        date, its maturity, fixed cpn, fixed leg frequency, fixed leg day
         count convention and notional. The floating leg parameters have default
         values that can be overwritten if needed. The start date is contractual
         and is the same as the settlement date for a new swap. It is the date
         on which interest starts to accrue. The end of the contract is the
         termination date. This is not adjusted for business days. The adjusted
         termination date is called the maturity date. This is calculated. """
 
         check_argument_types(self.__init__, locals())
 
-        if type(term_dt_or_tenor) == Date:
-            self._termination_dt = term_dt_or_tenor
+        if isinstance(term_dt_or_tenor, Date):
+            self.termination_dt = term_dt_or_tenor
         else:
-            self._termination_dt = effective_dt.add_tenor(
+            self.termination_dt = effective_dt.add_tenor(
                 term_dt_or_tenor)
 
         calendar = Calendar(cal_type)
-        self._maturity_dt = calendar.adjust(self._termination_dt,
-                                              bd_type)
+        self.maturity_dt = calendar.adjust(self.termination_dt,
+                                           bd_type)
 
-        if effective_dt > self._maturity_dt:
+        if effective_dt > self.maturity_dt:
             raise FinError("Start date after maturity date")
 
-        self._effective_dt = effective_dt
+        self.effective_dt = effective_dt
 
         float_leg_type = SwapTypes.PAY
         if fixed_leg_type == SwapTypes.PAY:
             float_leg_type = SwapTypes.RECEIVE
 
         principal = 0.0
 
-        self._fixed_leg = SwapFixedLeg(effective_dt,
-                                       self._termination_dt,
-                                       fixed_leg_type,
-                                       fixed_coupon,
-                                       fixed_freq_type,
-                                       fixed_dc_type,
-                                       notional,
-                                       principal,
-                                       payment_lag,
-                                       cal_type,
-                                       bd_type,
-                                       dg_type)
-
-        self._float_leg = SwapFloatLeg(effective_dt,
-                                       self._termination_dt,
-                                       float_leg_type,
-                                       float_spread,
-                                       float_freq_type,
-                                       float_dc_type,
-                                       notional,
-                                       principal,
-                                       payment_lag,
-                                       cal_type,
-                                       bd_type,
-                                       dg_type)
+        self.fixed_leg = SwapFixedLeg(effective_dt,
+                                      self.termination_dt,
+                                      fixed_leg_type,
+                                      fixed_cpn,
+                                      fixed_freq_type,
+                                      fixed_dc_type,
+                                      notional,
+                                      principal,
+                                      payment_lag,
+                                      cal_type,
+                                      bd_type,
+                                      dg_type)
+
+        self.float_leg = SwapFloatLeg(effective_dt,
+                                      self.termination_dt,
+                                      float_leg_type,
+                                      float_spread,
+                                      float_freq_type,
+                                      float_dc_type,
+                                      notional,
+                                      principal,
+                                      payment_lag,
+                                      cal_type,
+                                      bd_type,
+                                      dg_type)
 
 ###############################################################################
 
     def value(self,
               value_dt: Date,
               ois_curve: DiscountCurve,
               first_fixing_rate=None):
         """ Value the interest rate swap on a value date given a single Ibor
         discount curve. """
 
-        fixed_leg_value = self._fixed_leg.value(value_dt,
-                                                ois_curve)
+        fixed_leg_value = self.fixed_leg.value(value_dt,
+                                               ois_curve)
 
-        float_leg_value = self._float_leg.value(value_dt,
-                                                ois_curve,
-                                                ois_curve,
-                                                first_fixing_rate)
+        float_leg_value = self.float_leg.value(value_dt,
+                                               ois_curve,
+                                               ois_curve,
+                                               first_fixing_rate)
 
         value = fixed_leg_value + float_leg_value
         return value
 
 ##########################################################################
 
     def pv01(self, value_dt, discount_curve):
-        """ Calculate the value of 1 basis point coupon on the fixed leg. """
+        """ Calculate the value of 1 basis point cpn on the fixed leg. """
 
-        pv = self._fixed_leg.value(value_dt, discount_curve)
-        pv01 = pv / self._fixed_leg._coupon / self._fixed_leg._notional
+        pv = self.fixed_leg.value(value_dt, discount_curve)
+        pv01 = pv / self.fixed_leg.cpn / self.fixed_leg.notional
 
-        # Needs to be positive even if it is a payer leg and/or coupon < 0
+        # Needs to be positive even if it is a payer leg and/or cpn < 0
         pv01 = np.abs(pv01)
         return pv01
 
 ##########################################################################
 
     def swap_rate(self, value_dt, ois_curve, first_fixing_rate=None):
-        """ Calculate the fixed leg coupon that makes the swap worth zero.
+        """ Calculate the fixed leg cpn that makes the swap worth zero.
         If the valuation date is before the swap payments start then this
         is the forward swap rate as it starts in the future. The swap rate
         is then a forward swap rate and so we use a forward discount
         factor. If the swap fixed leg has begun then we have a spot
         starting swap. """
 
         pv01 = self.pv01(value_dt, ois_curve)
 
-        float_leg_value = self._float_leg.value(value_dt,
-                                                ois_curve,
-                                                ois_curve,
-                                                first_fixing_rate)
+        float_leg_value = self.float_leg.value(value_dt,
+                                               ois_curve,
+                                               ois_curve,
+                                               first_fixing_rate)
 
-        cpn = float_leg_value / pv01 / self._fixed_leg._notional
+        cpn = float_leg_value / pv01 / self.fixed_leg.notional
         return cpn
 
 ###############################################################################
 
     def print_fixed_leg_pv(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._fixed_leg.print_valuation()
+        self.fixed_leg.print_valuation()
 
 ###############################################################################
 
     def print_float_leg_pv(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._float_leg.print_valuation()
+        self.float_leg.print_valuation()
 
 ###############################################################################
 
     def print_payments(self):
         """ Prints the fixed leg amounts without any valuation details. Shows
         the dates and sizes of the promised fixed leg flows. """
 
-        self._fixed_leg.print_payments()
-        self._float_leg.print_payments()
+        self.fixed_leg.print_payments()
+        self.float_leg.print_payments()
 
 ##########################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += self._fixed_leg.__repr__()
+        s += self.fixed_leg.repr__()
         s += "\n"
-        s += self._float_leg.__repr__()
+        s += self.float_leg.repr__()
         return s
 
 ###############################################################################
 
     def _print(self):
-        """ Print a list of the unadjusted coupon payment dates used in
+        """ Print a list of the unadjusted cpn payment dates used in
         analytic calculations for the bond. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/products/rates/ois_basis_swap.py` & `financepy-0.360/tests_golden/TestFinBondEmbeddedOptionHW.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,159 +1,187 @@
-##############################################################################
+###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
-##############################################################################
+###############################################################################
 
-from ...utils.error import FinError
-from ...utils.date import Date
-from ...utils.day_count import DayCountTypes
-from ...utils.frequency import FrequencyTypes
-from ...utils.calendar import CalendarTypes, DateGenRuleTypes
-from ...utils.calendar import Calendar, BusDayAdjustTypes
-from ...utils.helpers import check_argument_types, label_to_string
-from ...utils.math import ONE_MILLION
-from ...utils.global_types import SwapTypes
-from ...market.curves.discount_curve import DiscountCurve
+import matplotlib.pyplot as plt
+import time
 
-from .swap_float_leg import SwapFloatLeg
+import sys
+sys.path.append("..")
 
-###############################################################################
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.products.bonds.bond_callable import BondEmbeddedOption
+from financepy.products.bonds.bond import Bond
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.products.rates.ibor_single_curve import IborSingleCurve
+from financepy.products.rates.ibor_swap import IborSwap
+from financepy.models.hw_tree import HWTree
+from financepy.utils.day_count import DayCountTypes
+from financepy.utils.frequency import FrequencyTypes
+from financepy.utils.date import Date
+from financepy.utils.global_types import SwapTypes
 
+test_cases = FinTestCases(__file__, globalTestCaseMode)
 
-class OISBasisSwap:
-    """ Class for managing an Ibor-OIS basis swap contract. This is a
-    contract in which a floating leg with one LIBOR tenor is exchanged for a
-    floating leg payment of an overnight index swap. There is no exchange of
-    par. The contract is entered into at zero initial cost. The contract lasts
-    from a start date to a specified maturity date.
-
-    The value of the contract is the NPV of the two coupon streams. Discounting
-    is done on a supplied discount curve which is separate from the discount from
-    which the implied index rates are extracted. """
-
-    def __init__(self,
-                 effective_dt: Date,  # Date interest starts to accrue
-                 term_dt_or_tenor: (Date, str),  # Date contract ends
-                 iborType: SwapTypes,
-                 iborFreqType: FrequencyTypes = FrequencyTypes.QUARTERLY,
-                 iborDayCountType: DayCountTypes = DayCountTypes.THIRTY_E_360,
-                 iborSpread: float = 0.0,
-                 oisFreqType: FrequencyTypes = FrequencyTypes.QUARTERLY,
-                 oisDayCountType: DayCountTypes = DayCountTypes.THIRTY_E_360,
-                 oisSpread: float = 0.0,
-                 oisPaymentLag: int = 0,
-                 notional: float = ONE_MILLION,
-                 cal_type: CalendarTypes = CalendarTypes.WEEKEND,
-                 bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
-                 dg_type: DateGenRuleTypes = DateGenRuleTypes.BACKWARD):
-        """ Create a Ibor basis swap contract giving the contract start
-        date, its maturity, frequency and day counts on the two floating
-        legs and notional. The floating leg parameters have default
-        values that can be overwritten if needed. The start date is contractual
-        and is the same as the settlement date for a new swap. It is the date
-        on which interest starts to accrue. The end of the contract is the
-        termination date. This is not adjusted for business days. The adjusted
-        termination date is called the maturity date. This is calculated. """
-
-        check_argument_types(self.__init__, locals())
-
-        if type(term_dt_or_tenor) == Date:
-            self._termination_dt = term_dt_or_tenor
-        else:
-            self._termination_dt = effective_dt.add_tenor(
-                term_dt_or_tenor)
-
-        calendar = Calendar(cal_type)
-        self._maturity_dt = calendar.adjust(self._termination_dt,
-                                              bd_type)
-
-        if effective_dt > self._maturity_dt:
-            raise FinError("Start date after maturity date")
-
-        oisType = SwapTypes.PAY
-        if iborType == SwapTypes.PAY:
-            oisType = SwapTypes.RECEIVE
-
-        principal = 0.0
-
-        self._floatIborLeg = SwapFloatLeg(effective_dt,
-                                          self._termination_dt,
-                                          iborType,
-                                          iborSpread,
-                                          iborFreqType,
-                                          iborDayCountType,
-                                          notional,
-                                          principal,
-                                          0,
-                                          cal_type,
-                                          bd_type,
-                                          dg_type)
-
-        self._floatOISLeg = SwapFloatLeg(effective_dt,
-                                         self._termination_dt,
-                                         oisType,
-                                         oisSpread,
-                                         oisFreqType,
-                                         oisDayCountType,
-                                         notional,
-                                         principal,
-                                         oisPaymentLag,
-                                         cal_type,
-                                         bd_type,
-                                         dg_type)
+plotGraphs = False
 
 ###############################################################################
 
-    def value(self,
-              value_dt: Date,
-              discount_curve: DiscountCurve,
-              indexIborCurve: DiscountCurve = None,
-              indexOISCurve: DiscountCurve = None,
-              firstFixingRateLeg1=None,
-              firstFixingRateLeg2=None):
-        """ Value the interest rate swap on a value date given a single Ibor
-        discount curve and an index curve for the Ibors on each swap leg. """
-
-        if indexIborCurve is None:
-            indexIborCurve = discount_curve
-
-        if indexOISCurve is None:
-            indexOISCurve = discount_curve
-
-        floatIborLegValue = self._floatIborLeg.value(value_dt,
-                                                     discount_curve,
-                                                     indexIborCurve,
-                                                     firstFixingRateLeg1)
-
-        floatOISLegValue = self._floatOISLeg.value(value_dt,
-                                                   discount_curve,
-                                                   indexOISCurve,
-                                                   firstFixingRateLeg2)
 
-        value = floatIborLegValue + floatOISLegValue
-        return value
+def test_BondEmbeddedOptionMATLAB():
+
+    # https://fr.mathworks.com/help/fininst/optembndbyhw.html
+    # I FIND THAT THE PRICE CONVERGES TO 102.88 WHICH IS CLOSE TO 102.9127
+    # FOUND BY MATLAB ALTHOUGH THEY DO NOT EXAMINE THE ASYMPTOTIC PRICE
+    # WHICH MIGHT BE A BETTER MATCH
+
+    settle_dt = Date(1, 1, 2007)
+    value_dt = settle_dt
+
+    ###########################################################################
+
+    dcType = DayCountTypes.THIRTY_E_360
+    fixedFreq = FrequencyTypes.ANNUAL
+    fixed_leg_type = SwapTypes.PAY
+    swap1 = IborSwap(settle_dt, "1Y", fixed_leg_type,
+                     0.0350, fixedFreq, dcType)
+    swap2 = IborSwap(settle_dt, "2Y", fixed_leg_type,
+                     0.0400, fixedFreq, dcType)
+    swap3 = IborSwap(settle_dt, "3Y", fixed_leg_type,
+                     0.0450, fixedFreq, dcType)
+    swaps = [swap1, swap2, swap3]
+    discount_curve = IborSingleCurve(value_dt, [], [], swaps)
+
+    ###########################################################################
+
+    issue_dt = Date(1, 1, 2004)
+    maturity_dt = Date(1, 1, 2010)
+
+    coupon = 0.0525
+    freq_type = FrequencyTypes.ANNUAL
+    dc_type = DayCountTypes.ACT_ACT_ICMA
+    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
+
+    call_dts = []
+    call_prices = []
+    put_dts = []
+    put_prices = []
+
+    put_dt = Date(1, 1, 2008)
+    for _ in range(0, 24):
+        put_dts.append(put_dt)
+        put_prices.append(100)
+        put_dt = put_dt.add_months(1)
+
+    test_cases.header("BOND PRICE", "PRICE")
+    v = bond.clean_price_from_discount_curve(settle_dt, discount_curve)
+    test_cases.print("Bond Pure Price:", v)
+
+    sigma = 0.01  # basis point volatility
+    a = 0.1
+
+    puttable_bond = BondEmbeddedOption(issue_dt,
+                                       maturity_dt, coupon,
+                                       freq_type, dc_type,
+                                       call_dts, call_prices,
+                                       put_dts, put_prices)
+
+    test_cases.header("TIME", "Numtime_steps", "BondWithOption", "BondPure")
+
+    time_steps = range(50, 1000, 50)
+    values = []
+    for num_time_steps in time_steps:
+        model = HWTree(sigma, a, num_time_steps)
+        start = time.time()
+        v = puttable_bond.value(settle_dt, discount_curve, model)
+        end = time.time()
+        period = end - start
+        test_cases.print(period, num_time_steps, v['bondwithoption'],
+                         v['bondpure'])
+        values.append(v['bondwithoption'])
+
+    if plotGraphs:
+        plt.figure()
+        plt.plot(time_steps, values)
 
 ###############################################################################
 
-    def print_payments(self):
-        """ Prints the fixed leg amounts without any valuation details. Shows
-        the dates and sizes of the promised fixed leg flows. """
-
-        self._floatIborLeg.print_payments()
-        self._floatOISLeg.print_payments()
-
-##########################################################################
-
-    def __repr__(self):
-        s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += self._floatIborLeg.__repr__()
-        s += "\n"
-        s += self._floatOISLeg.__repr__()
-        return s
 
-###############################################################################
+def test_BondEmbeddedOptionQUANTLIB():
 
-    def _print(self):
-        """ Print a list of the unadjusted coupon payment dates used in
-        analytic calculations for the bond. """
-        print(self)
+    # Based on example at the nice blog on Quantlib at
+    # http://gouthamanbalaraman.com/blog/callable-bond-quantlib-python.html
+    # I get a price of 68.97 for 1000 time steps which is higher than the
+    # 68.38 found in blog article. But this is for 40 grid points.
+    # Note also that a basis point vol of 0.120 is 12% which is VERY HIGH!
+
+    value_dt = Date(16, 8, 2016)
+    settle_dt = value_dt.add_weekdays(3)
+
+    ###########################################################################
+
+    discount_curve = DiscountCurveFlat(value_dt, 0.035,
+                                       FrequencyTypes.SEMI_ANNUAL)
+
+    ###########################################################################
+
+    issue_dt = Date(15, 9, 2010)
+    maturity_dt = Date(15, 9, 2022)
+    coupon = 0.025
+    freq_type = FrequencyTypes.QUARTERLY
+    dc_type = DayCountTypes.ACT_ACT_ICMA
+    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
+
+    ###########################################################################
+    # Set up the call and put times and prices
+    ###########################################################################
+
+    nextCallDate = Date(15, 9, 2016)
+    call_dts = [nextCallDate]
+    call_prices = [100.0]
+
+    for _ in range(1, 24):
+        nextCallDate = nextCallDate.add_months(3)
+        call_dts.append(nextCallDate)
+        call_prices.append(100.0)
+
+    put_dts = []
+    put_prices = []
+
+    # the value used in blog of 12% bp vol is unrealistic
+    sigma = 0.12  # basis point volatility
+    a = 0.03
+
+    puttable_bond = BondEmbeddedOption(issue_dt,
+                                      maturity_dt, coupon,
+                                      freq_type, dc_type,
+                                      call_dts, call_prices,
+                                      put_dts, put_prices)
+
+    test_cases.header("BOND PRICE", "PRICE")
+    v = bond.clean_price_from_discount_curve(settle_dt, discount_curve)
+    test_cases.print("Bond Pure Price:", v)
+
+    test_cases.header("TIME", "Numtime_steps", "BondWithOption", "BondPure")
+    time_steps = range(100, 200, 50)
+    values = []
+    for num_time_steps in time_steps:
+        model = HWTree(sigma, a, num_time_steps)
+        start = time.time()
+        v = puttable_bond.value(settle_dt, discount_curve, model)
+        end = time.time()
+        period = end - start
+        test_cases.print(period, num_time_steps,
+                        v['bondwithoption'], v['bondpure'])
+        values.append(v['bondwithoption'])
+
+    if plotGraphs:
+        plt.figure()
+        plt.title("Puttable Bond Price Convergence")
+        plt.plot(time_steps, values)
 
 ###############################################################################
+
+
+test_BondEmbeddedOptionMATLAB()
+test_BondEmbeddedOptionQUANTLIB()
+test_cases.compareTestCases()
```

### Comparing `financepy-0.350/financepy/products/rates/ois_curve.py` & `financepy-0.360/financepy/products/rates/ois_curve.py`

 * *Files 13% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 from ...utils.global_vars import gDaysInYear
 from ...market.curves.interpolator import InterpTypes, Interpolator
 from ...market.curves.discount_curve import DiscountCurve
 
 from ...products.rates.ibor_deposit import IborDeposit
 from ...products.rates.ois import OIS
 
-swaptol = 1e-10
+SWAP_TOL = 1e-10
 
 ##############################################################################
 # TODO: CHANGE times to df_times
 ##############################################################################
 
 
 def _fois(oir, *args):
@@ -58,15 +58,15 @@
     swap = args[2]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
 
     # For discount that need a fit function, we fit it now
     curve._interpolator.fit(curve._times, curve._dfs)
     v_swap = swap.value(value_dt, curve, None)
-    notional = swap._fixed_leg._notional
+    notional = swap.fixed_leg.notional
     v_swap /= notional
     return v_swap
 
 ###############################################################################
 
 
 def _g(df, *args):
@@ -76,15 +76,15 @@
     fra = args[2]
     num_points = len(curve._times)
     curve._dfs[num_points - 1] = df
 
     # For discount that need a fit function, we fit it now
     curve._interpolator.fit(curve._times, curve._dfs)
     v_fra = fra.value(value_dt, curve)
-    v_fra /= fra._notional
+    v_fra /= fra.notional
     return v_fra
 
 ###############################################################################
 
 
 class OISCurve(DiscountCurve):
     """ Constructs a discount curve as implied by the prices of Overnight
@@ -108,209 +108,209 @@
                  ois_swaps: list,
                  interp_type: InterpTypes = InterpTypes.FLAT_FWD_RATES,
                  check_refit: bool = False):  # Set to True to test it works
         """ Create an instance of an overnight index rate swap curve given a
         valuation date and a set of OIS rates. Some of these may
         be left None and the algorithm will just use what is provided. An
         interpolation method has also to be provided. The default is to use a
-        linear interpolation for swap rates on coupon dates and to then assume
-        flat forwards between these coupon dates.
+        linear interpolation for swap rates on cpn dates and to then assume
+        flat forwards between these cpn dates.
 
         The curve will assign a discount factor of 1.0 to the valuation date.
         """
 
         check_argument_types(getattr(self, _func_name(), None), locals())
 
-        self._value_dt = value_dt
+        self.value_dt = value_dt
         self._validate_inputs(ois_deposits, ois_fras, ois_swaps)
         self._interp_type = interp_type
-        self._check_refit = check_refit
+        self.check_refit = check_refit
         self._interpolator = None
         self._build_curve()
 
 ###############################################################################
 
     def _build_curve(self):
         """ Build curve based on interpolation. """
 
         self._build_curve_using_1d_solver()
 
 ###############################################################################
 
     def _validate_inputs(self,
-                         oisDeposits,
-                         oisFRAs,
-                         oisSwaps):
+                         ois_deposits,
+                         ois_fras,
+                         ois_swaps):
         """ Validate the inputs for each of the Libor products. """
 
-        num_depos = len(oisDeposits)
-        num_fras = len(oisFRAs)
-        num_swaps = len(oisSwaps)
+        num_depos = len(ois_deposits)
+        num_fras = len(ois_fras)
+        num_swaps = len(ois_swaps)
 
-        depo_start_dt = self._value_dt
-        swap_start_dt = self._value_dt
+        depo_start_dt = self.value_dt
+        swap_start_dt = self.value_dt
 
         if num_depos + num_fras + num_swaps == 0:
             raise FinError("No calibration instruments.")
 
         # Validation of the inputs.
         if num_depos > 0:
 
-            depo_start_dt = oisDeposits[0]._start_dt
+            depo_start_dt = ois_deposits[0].start_dt
 
-            for depo in oisDeposits:
+            for depo in ois_deposits:
 
                 if isinstance(depo, IborDeposit) is False:
                     raise FinError("Deposit is not of type IborDeposit")
 
-                start_dt = depo._start_dt
+                start_dt = depo.start_dt
 
-                if start_dt < self._value_dt:
+                if start_dt < self.value_dt:
                     raise FinError("First deposit starts before value date.")
 
                 if start_dt < depo_start_dt:
                     depo_start_dt = start_dt
 
-            for depo in oisDeposits:
-                startDt = depo._start_dt
-                endDt = depo._maturity_dt
-                if startDt >= endDt:
+            for depo in ois_deposits:
+                start_dt = depo.start_dt
+                end_dt = depo.maturity_dt
+                if start_dt >= end_dt:
                     raise FinError("First deposit ends on or before it begins")
 
         # Ensure order of depos
         if num_depos > 1:
 
-            prev_dt = oisDeposits[0]._maturity_dt
-            for depo in oisDeposits[1:]:
-                next_dt = depo._maturity_dt
+            prev_dt = ois_deposits[0].maturity_dt
+            for depo in ois_deposits[1:]:
+                next_dt = depo.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Deposits must be in increasing maturity")
                 prev_dt = next_dt
 
         # REMOVED THIS AS WE WANT TO ANCHOR CURVE AT VALUATION DATE
         # USE A SYNTHETIC DEPOSIT TO BRIDGE GAP FROM VALUE DATE TO SETTLEMENT DATE
         # Ensure that valuation date is on or after first deposit start date
         # Ensure that valuation date is on or after first deposit start date
         # if num_depos > 1:
-        #    if oisDeposits[0]._start_dt > self._value_dt:
+        #    if ois_deposits[0].start_dt > self.value_dt:
         #        raise FinError("Valuation date must not be before first deposit settles.")
 
         # Validation of the inputs.
         if num_fras > 0:
-            for fra in oisFRAs:
-                startDt = fra._start_dt
-                if startDt <= self._value_dt:
+            for fra in ois_fras:
+                start_dt = fra.start_dt
+                if start_dt <= self.value_dt:
                     raise FinError("FRAs starts before valuation date")
 
-                startDt = fra._start_dt
-                if startDt < self._value_dt:
+                start_dt = fra.start_dt
+                if start_dt < self.value_dt:
                     raise FinError("FRAs starts before valuation date")
 
         if num_fras > 1:
-            prev_dt = oisFRAs[0]._maturity_dt
-            for fra in oisFRAs[1:]:
-                next_dt = fra._maturity_dt
+            prev_dt = ois_fras[0].maturity_dt
+            for fra in ois_fras[1:]:
+                next_dt = fra.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("FRAs must be in increasing maturity")
                 prev_dt = next_dt
 
         if num_swaps > 0:
 
-            swap_start_dt = oisSwaps[0]._effective_dt
+            swap_start_dt = ois_swaps[0].effective_dt
 
-            for swap in oisSwaps:
+            for swap in ois_swaps:
 
                 if isinstance(swap, OIS) is False:
                     raise FinError("Swap is not of type FinOIS")
 
-                startDt = swap._effective_dt
-                if startDt < self._value_dt:
+                start_dt = swap.effective_dt
+                if start_dt < self.value_dt:
                     raise FinError("Swaps starts before valuation date.")
 
-                if swap._effective_dt < swap_start_dt:
-                    swap_start_dt = swap._effective_dt
+                if swap.effective_dt < swap_start_dt:
+                    swap_start_dt = swap.effective_dt
 
         if num_swaps > 1:
 
             # Swaps must be increasing in tenor/maturity
-            prev_dt = oisSwaps[0]._maturity_dt
-            for swap in oisSwaps[1:]:
-                next_dt = swap._maturity_dt
+            prev_dt = ois_swaps[0].maturity_dt
+            for swap in ois_swaps[1:]:
+                next_dt = swap.maturity_dt
                 if next_dt <= prev_dt:
                     raise FinError("Swaps must be in increasing maturity")
                 prev_dt = next_dt
 
         # TODO: REINSTATE THESE CHECKS ?
             # Swaps must have same cash flows for linear swap bootstrap to work
-#            longestSwap = oisSwaps[-1]
-#            longestSwapCpnDates = longestSwap._adjusted_fixed_dts
-#            for swap in oisSwaps[0:-1]:
-#                swapCpnDates = swap._adjusted_fixed_dts
+#            longest_swap = ois_swaps[-1]
+#            longest_swapCpnDates = longest_swap.adjusted_fixed_dts
+#            for swap in ois_swaps[0:-1]:
+#                swapCpnDates = swap.adjusted_fixed_dts
 #                num_flows = len(swapCpnDates)
 #                for i_flow in range(0, num_flows):
-#                    if swapCpnDates[i_flow] != longestSwapCpnDates[i_flow]:
-#                        raise FinError("Swap coupons are not on the same date grid.")
+#                    if swapCpnDates[i_flow] != longest_swapCpnDates[i_flow]:
+#                        raise FinError("Swap cpns are not on the same date grid.")
 
         #######################################################################
         # Now we have ensure they are in order check for overlaps and the like
         #######################################################################
 
-        lastDeposit_maturityDate = Date(1, 1, 1900)
-        firstFRAMaturityDate = Date(1, 1, 1900)
-        lastFRAMaturityDate = Date(1, 1, 1900)
+        last_deposit_maturity_dt = Date(1, 1, 1900)
+        first_fra_maturity_dt = Date(1, 1, 1900)
+        last_fra_maturity_dt = Date(1, 1, 1900)
 
         if num_depos > 0:
-            lastDeposit_maturityDate = oisDeposits[-1]._maturity_dt
+            last_deposit_maturity_dt = ois_deposits[-1].maturity_dt
 
         if num_fras > 0:
-            firstFRAMaturityDate = oisFRAs[0]._maturity_dt
-            lastFRAMaturityDate = oisFRAs[-1]._maturity_dt
+            first_fra_maturity_dt = ois_fras[0].maturity_dt
+            last_fra_maturity_dt = ois_fras[-1].maturity_dt
 
         if num_swaps > 0:
-            first_swap_maturity_dt = oisSwaps[0]._maturity_dt
+            first_swap_maturity_dt = ois_swaps[0].maturity_dt
 
         if num_fras > 0 and num_swaps > 0:
-            if first_swap_maturity_dt <= lastFRAMaturityDate:
+            if first_swap_maturity_dt <= last_fra_maturity_dt:
                 raise FinError("First Swap must mature after last FRA ends")
 
         if num_depos > 0 and num_fras > 0:
-            if firstFRAMaturityDate <= lastDeposit_maturityDate:
-                print("FRA Maturity Date:", firstFRAMaturityDate)
-                print("Last Deposit Date:", lastDeposit_maturityDate)
+            if first_fra_maturity_dt <= last_deposit_maturity_dt:
+                print("FRA Maturity Date:", first_fra_maturity_dt)
+                print("Last Deposit Date:", last_deposit_maturity_dt)
                 raise FinError("First FRA must end after last Deposit")
 
         if num_fras > 0 and num_swaps > 0:
-            if first_swap_maturity_dt <= lastFRAMaturityDate:
+            if first_swap_maturity_dt <= last_fra_maturity_dt:
                 raise FinError("First Swap must mature after last FRA")
 
-        if swap_start_dt > self._value_dt:
+        if swap_start_dt > self.value_dt:
 
             if num_depos == 0:
                 raise FinError("Need a deposit rate to pin down short end.")
 
-            if depo_start_dt > self._value_dt:
-                firstDepo = oisDeposits[0]
-                if firstDepo._start_dt > self._value_dt:
+            if depo_start_dt > self.value_dt:
+                first_depo = ois_deposits[0]
+                if first_depo.start_dt > self.value_dt:
                     print("Inserting synthetic deposit")
-                    syntheticDeposit = copy.deepcopy(firstDepo)
-                    syntheticDeposit._start_dt = self._value_dt
-                    syntheticDeposit._maturity_dt = firstDepo._start_dt
-                    oisDeposits.insert(0, syntheticDeposit)
+                    synthetic_deposit = copy.deepcopy(first_depo)
+                    synthetic_deposit.start_dt = self.value_dt
+                    synthetic_deposit.maturity_dt = first_depo.start_dt
+                    ois_deposits.insert(0, synthetic_deposit)
                     num_depos += 1
 
         # Now determine which instruments are used
-        self._usedDeposits = oisDeposits
-        self._usedFRAs = oisFRAs
-        self._usedSwaps = oisSwaps
-
-       # Need the floating leg basis for the curve
-        if len(self._usedSwaps) > 0:
-            self._dc_type = oisSwaps[0]._float_leg._dc_type
+        self.used_deposits = ois_deposits
+        self.used_fras = ois_fras
+        self.used_swaps = ois_swaps
+
+        # Need the floating leg basis for the curve
+        if len(self.used_swaps) > 0:
+            self.dc_type = ois_swaps[0].float_leg.dc_type
         else:
-            self._dc_type = None
+            self.dc_type = None
 
 ###############################################################################
 
     def _build_curve_using_1d_solver(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the non-linear slower method that allows the user to choose a number
         of interpolation approaches between the swap rates and other rates. It
@@ -323,61 +323,61 @@
         # time zero is now.
         t_mat = 0.0
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
         self._interpolator.fit(self._times, self._dfs)
 
-        for depo in self._usedDeposits:
-            df_settle = self.df(depo._start_dt)
+        for depo in self.used_deposits:
+            df_settle = self.df(depo.start_dt)
             df_mat = depo._maturity_df() * df_settle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
         old_t_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < old_t_mat and t_mat > old_t_mat:
                 df_mat = fra.maturity_df(self)
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
             else:
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
-                argtuple = (self, self._value_dt, fra)
+                argtuple = (self, self.value_dt, fra)
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                        args=argtuple, tol=swaptol,
-                                        maxiter=50, fprime2=None)
+                                         args=argtuple, tol=SWAP_TOL,
+                                         maxiter=50, fprime2=None)
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # I use the lastPaymentDate in case a date has been adjusted fwd
             # over a holiday as the maturity date is usually not adjusted CHECK
-            maturity_dt = swap._fixed_leg._payment_dts[-1]
-            t_mat = (maturity_dt - self._value_dt) / gDaysInYear
+            maturity_dt = swap.fixed_leg.payment_dts[-1]
+            t_mat = (maturity_dt - self.value_dt) / gDaysInYear
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
 
-            argtuple = (self, self._value_dt, swap)
+            argtuple = (self, self.value_dt, swap)
 
             df_mat = optimize.newton(_f, x0=df_mat, fprime=None, args=argtuple,
-                                    tol=swaptol, maxiter=50, fprime2=None,
-                                    full_output=False)
+                                     tol=SWAP_TOL, maxiter=50, fprime2=None,
+                                     full_output=False)
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self.check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
     def _build_curve_linear_swap_rate_interpolation(self):
         """ Construct the discount curve using a bootstrap approach. This is
         the linear swap rate method that is fast and exact as it does not
         require the use of a solver. It is also market standard. """
@@ -388,156 +388,156 @@
 
         # time zero is now.
         t_mat = 0.0
         df_mat = 1.0
         self._times = np.append(self._times, 0.0)
         self._dfs = np.append(self._dfs, df_mat)
 
-        for depo in self._usedDeposits:
-            df_settle = self.df(depo._start_dt)
-            df_mat = depo._maturity_df() * df_settle
-            t_mat = (depo._maturity_dt - self._value_dt) / gDaysInYear
+        for depo in self.used_deposits:
+            df_settle = self.df(depo.start_dt)
+            df_mat = depo.maturity_df() * df_settle
+            t_mat = (depo.maturity_dt - self.value_dt) / gDaysInYear
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
         old_t_mat = t_mat
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
 
-            t_set = (fra._start_dt - self._value_dt) / gDaysInYear
-            t_mat = (fra._maturity_dt - self._value_dt) / gDaysInYear
+            t_set = (fra.start_dt - self.value_dt) / gDaysInYear
+            t_mat = (fra.maturity_dt - self.value_dt) / gDaysInYear
 
             # if both dates are after the previous FRA/FUT then need to
             # solve for 2 discount factors simultaneously using root search
 
             if t_set < old_t_mat and t_mat > old_t_mat:
                 df_mat = fra.maturity_df(self)
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
                 self._interpolator.fit(self._times, self._dfs)
             else:
                 self._times = np.append(self._times, t_mat)
                 self._dfs = np.append(self._dfs, df_mat)
                 self._interpolator.fit(self._times, self._dfs)
 
-                argtuple = (self, self._value_dt, fra)
+                argtuple = (self, self.value_dt, fra)
                 df_mat = optimize.newton(_g, x0=df_mat, fprime=None,
-                                         args=argtuple, tol=swaptol,
+                                         args=argtuple, tol=SWAP_TOL,
                                          maxiter=50, fprime2=None)
 
-        if len(self._usedSwaps) == 0:
-            if self._check_refit is True:
-                self._check_refits(1e-10, swaptol, 1e-5)
+        if len(self.used_swaps) == 0:
+            if self.check_refit is True:
+                self.check_refits(1e-10, SWAP_TOL, 1e-5)
             return
 
         #######################################################################
         # ADD SWAPS TO CURVE
         #######################################################################
 
         # Find where the FRAs and Depos go up to as this bit of curve is done
         found_start = False
-        last_dt = self._value_dt
-        if len(self._usedDeposits) != 0:
-            last_dt = self._usedDeposits[-1]._maturity_dt
+        last_dt = self.value_dt
+        if len(self.used_deposits) != 0:
+            last_dt = self.used_deposits[-1].maturity_dt
 
-        if len(self._usedFRAs) != 0:
-            last_dt = self._usedFRAs[-1]._maturity_dt
+        if len(self.used_fras) != 0:
+            last_dt = self.used_fras[-1].maturity_dt
 
         # We use the longest swap assuming it has a superset of ALL of the
         # swap flow dates used in the curve construction
-        longestSwap = self._usedSwaps[-1]
-        cpn_dts = longestSwap._adjusted_fixed_dts
+        longest_swap = self.used_swaps[-1]
+        cpn_dts = longest_swap.adjusted_fixed_dts
         num_flows = len(cpn_dts)
 
-        # Find where first coupon without discount factor starts
+        # Find where first cpn without discount factor starts
         start_index = 0
         for i in range(0, num_flows):
             if cpn_dts[i] > last_dt:
                 start_index = i
                 found_start = True
                 break
 
         if found_start is False:
             raise FinError("Found start is false. Swaps payments inside FRAs")
 
         swap_rates = []
         swap_times = []
 
-        # I use the last coupon date for the swap rate interpolation as this
+        # I use the last cpn date for the swap rate interpolation as this
         # may be different from the maturity date due to a holiday adjustment
-        # and the swap rates need to align with the coupon payment dates
-        for swap in self._usedSwaps:
-            swap_rate = swap._fixed_coupon
-            maturity_dt = swap._adjusted_fixed_dts[-1]
-            tswap = (maturity_dt - self._value_dt) / gDaysInYear
+        # and the swap rates need to align with the cpn payment dates
+        for swap in self.used_swaps:
+            swap_rate = swap.fixed_cpn
+            maturity_dt = swap.adjusted_fixed_dts[-1]
+            tswap = (maturity_dt - self.value_dt) / gDaysInYear
             swap_times.append(tswap)
             swap_rates.append(swap_rate)
 
         interpolated_swap_rates = [0.0]
         interpolated_swap_times = [0.0]
 
         for dt in cpn_dts[1:]:
-            swap_time = (dt - self._value_dt) / gDaysInYear
+            swap_time = (dt - self.value_dt) / gDaysInYear
             swap_rate = np.interp(swap_time, swap_times, swap_rates)
             interpolated_swap_rates.append(swap_rate)
             interpolated_swap_times.append(swap_time)
 
         # Do I need this line ?
         interpolated_swap_rates[0] = interpolated_swap_rates[1]
-        accrual_factors = longestSwap._fixed_year_fracs
+        accrual_factors = longest_swap.fixed_year_fracs
 
         acc = 0.0
         df = 1.0
         pv01 = 0.0
-        df_settle = self.df(longestSwap._start_dt)
+        df_settle = self.df(longest_swap.start_dt)
 
         for i in range(1, start_index):
             dt = cpn_dts[i]
             df = self.df(dt)
             acc = accrual_factors[i-1]
             pv01 += acc * df
 
         for i in range(start_index, num_flows):
 
             dt = cpn_dts[i]
-            t_mat = (dt - self._value_dt) / gDaysInYear
+            t_mat = (dt - self.value_dt) / gDaysInYear
             swap_rate = interpolated_swap_rates[i]
             acc = accrual_factors[i-1]
-            pv01End = (acc * swap_rate + 1.0)
+            pv01_end = (acc * swap_rate + 1.0)
 
-            df_mat = (df_settle - swap_rate * pv01) / pv01End
+            df_mat = (df_settle - swap_rate * pv01) / pv01_end
 
             self._times = np.append(self._times, t_mat)
             self._dfs = np.append(self._dfs, df_mat)
             self._interpolator.fit(self._times, self._dfs)
 
             pv01 += acc * df_mat
 
-        if self._check_refit is True:
-            self._check_refits(1e-10, swaptol, 1e-5)
+        if self.check_refit is True:
+            self.check_refits(1e-10, SWAP_TOL, 1e-5)
 
 ###############################################################################
 
-    def _check_refits(self, depoTol, fraTol, swapTol):
+    def _check_refits(self, depo_tol, fra_tol, swap_tol):
         """ Ensure that the Libor curve refits the calibration instruments. """
 
-        for fra in self._usedFRAs:
-            v = fra.value(self._value_dt, self) / fra._notional
-            if abs(v) > fraTol:
+        for fra in self.used_fras:
+            v = fra.value(self.value_dt, self) / fra.notional
+            if abs(v) > fra_tol:
                 print("Value", v)
                 raise FinError("FRA not repriced.")
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             # We value it as of the start date of the swap
-            v = swap.value(swap._effective_dt, self,
+            v = swap.value(swap.effective_dt, self,
                            self, None, principal=0.0)
-            v = v / swap._notional
-            if abs(v) > swapTol:
-                print("Swap with maturity " + str(swap._maturity_dt)
+            v = v / swap.notional
+            if abs(v) > swap_tol:
+                print("Swap with maturity " + str(swap.maturity_dt)
                       + " Not Repriced. Has Value", v)
                 swap.print_fixed_leg_pv()
                 swap.print_float_leg_pv()
                 raise FinError("Swap not repriced.")
 
 ###############################################################################
 
@@ -556,39 +556,39 @@
     #     if isinstance(maturity_dt, Date):
     #         maturity_dts = [maturity_dt]
     #     else:
     #         maturity_dts = maturity_dt
 
     #     overnightRates = []
 
-    #     dfValuationDate = self.df(settle_dt)
+    #     df_value_dt = self.df(settle_dt)
 
     #     for maturity_dt in maturity_dts:
 
     #         schedule = FinSchedule(start_dt,
     #                                maturity_dt,
     #                                frequencyType)
 
-    #         flow_dts = schedule._generate()
+    #         flow_dts = schedule.generate()
     #         flow_dts[0] = start_dt
 
     #         day_counter = FinDayCount(dc_type)
     #         prev_dt = flow_dts[0]
     #         pv01 = 0.0
     #         df = 1.0
 
     #         for next_dt in flow_dts[1:]:
     #             if next_dt > settle_dt:
-    #                 df = self.df(next_dt) / dfValuationDate
+    #                 df = self.df(next_dt) / df_value_dt
     #                 alpha = day_counter.year_frac(prev_dt, next_dt)[0]
     #                 pv01 += alpha * df
 
     #             prev_dt = next_dt
 
-    #         if abs(pv01) < gSmall:
+    #         if abs(pv01) < g_small:
     #             par_rate = None
     #         else:
     #             df_start = self.df(start_dt)
     #             par_rate = (df_start - df) / pv01
 
     #         par_rates.append(par_rate)
 
@@ -599,25 +599,25 @@
 
 ###############################################################################
 
     def __repr__(self):
         """ Print out the details of the Libor curve. """
 
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("VALUATION DATE", self._value_dt)
+        s += label_to_string("VALUATION DATE", self.value_dt)
 
-        for depo in self._usedDeposits:
+        for depo in self.used_deposits:
             s += label_to_string("DEPOSIT", "")
             s += depo.__repr__()
 
-        for fra in self._usedFRAs:
+        for fra in self.used_fras:
             s += label_to_string("FRA", "")
             s += fra.__repr__()
 
-        for swap in self._usedSwaps:
+        for swap in self.used_swaps:
             s += label_to_string("SWAP", "")
             s += swap.__repr__()
 
         num_points = len(self._times)
 
         s += label_to_string("INTERP TYPE", self._interp_type)
```

### Comparing `financepy-0.350/financepy/products/rates/swap_fixed_leg.py` & `financepy-0.360/financepy/products/rates/swap_float_leg.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,24 +13,24 @@
 from ...utils.helpers import format_table, label_to_string, check_argument_types
 from ...utils.global_types import SwapTypes
 from ...market.curves.discount_curve import DiscountCurve
 
 ##########################################################################
 
 
-class SwapFixedLeg:
-    """ Class for managing the fixed leg of a swap. A fixed leg is a leg with
+class SwapFloatLeg:
+    """ Class for managing the floating leg of a swap. A float leg consists of
     a sequence of flows calculated according to an ISDA schedule and with a
-    coupon that is fixed over the life of the swap. """
+    coupon determined by an index curve which changes over life of the swap."""
 
     def __init__(self,
                  effective_dt: Date,  # Date interest starts to accrue
                  end_dt: (Date, str),  # Date contract ends
                  leg_type: SwapTypes,
-                 coupon: (float),
+                 spread: (float),
                  freq_type: FrequencyTypes,
                  dc_type: DayCountTypes,
                  notional: float = ONE_MILLION,
                  principal: float = 0.0,
                  payment_lag: int = 0,
                  cal_type: CalendarTypes = CalendarTypes.WEEKEND,
                  bd_type: BusDayAdjustTypes = BusDayAdjustTypes.FOLLOWING,
@@ -39,254 +39,283 @@
         """ Create the fixed leg of a swap contract giving the contract start
         date, its maturity, fixed coupon, fixed leg frequency, fixed leg day
         count convention and notional.  """
 
         check_argument_types(self.__init__, locals())
 
         if type(end_dt) == Date:
-            self._termination_dt = end_dt
+            self.termination_dt = end_dt
         else:
-            self._termination_dt = effective_dt.add_tenor(end_dt)
+            self.termination_dt = effective_dt.add_tenor(end_dt)
 
         calendar = Calendar(cal_type)
 
-        self._maturity_dt = calendar.adjust(self._termination_dt,
+        self.maturity_dt = calendar.adjust(self.termination_dt,
                                             bd_type)
 
-        if effective_dt > self._maturity_dt:
-            raise FinError("Effective date after maturity date")
+        if effective_dt > self.maturity_dt:
+            raise FinError("Start date after maturity date")
 
-        self._effective_dt = effective_dt
-        self._end_dt = end_dt
-        self._leg_type = leg_type
-        self._freq_type = freq_type
-        self._payment_lag = payment_lag
-        self._notional = notional
-        self._principal = principal
-        self._cpn = coupon
-
-        self._dc_type = dc_type
-        self._cal_type = cal_type
-        self._bd_type = bd_type
-        self._dg_type = dg_type
-        self._end_of_month = end_of_month
-
-        self._start_accrued_dts = []
-        self._end_accrued_dts = []
-        self._payment_dts = []
-        self._payments = []
-        self._year_fracs = []
-        self._accrued_days = []
-        self._rates = []
+        self.effective_dt = effective_dt
+        self.end_dt = end_dt
+        self.leg_type = leg_type
+        self.freq_type = freq_type
+        self.payment_lag = payment_lag
+        self.principal = 0.0
+        self.notional = notional
+        self.notional_array = []
+        self.spread = spread
+
+        self.dc_type = dc_type
+        self.cal_type = cal_type
+        self.bd_type = bd_type
+        self.dg_type = dg_type
+        self.end_of_month = end_of_month
+
+        self.start_accrued_dts = []
+        self.end_accrued_dts = []
+        self.payment_dts = []
+        self.payments = []
+        self.year_fracs = []
+        self.accrued_days = []
 
-        self.generate_payments()
+        self.generate_payment_dts()
 
 ###############################################################################
 
-    def generate_payments(self):
-        ''' These are generated immediately as they are for the entire
-        life of the swap. Given a valuation date we can determine
-        which cash flows are in the future and value the swap
-        The schedule allows for a specified lag in the payment date
-        Nothing is paid on the swap effective date and so the first payment
-        date is the first actual payment date. '''
-
-        schedule = Schedule(self._effective_dt,
-                            self._termination_dt,
-                            self._freq_type,
-                            self._cal_type,
-                            self._bd_type,
-                            self._dg_type,
-                            end_of_month=self._end_of_month)
+    def generate_payment_dts(self):
+        """ Generate the floating leg payment dates and accrual factors. The
+        coupons cannot be generated yet as we do not have the index curve. """
+
+        schedule = Schedule(self.effective_dt,
+                            self.termination_dt,
+                            self.freq_type,
+                            self.cal_type,
+                            self.bd_type,
+                            self.dg_type,
+                            end_of_month=self.end_of_month)
 
-        scheduleDates = schedule._adjusted_dts
+        schedule_dts = schedule.adjusted_dts
 
-        if len(scheduleDates) < 2:
+        if len(schedule_dts) < 2:
             raise FinError("Schedule has none or only one date")
 
-        self._start_accrued_dts = []
-        self._end_accrued_dts = []
-        self._payment_dts = []
-        self._payments = []
-        self._year_fracs = []
-        self._accrued_days = []
-        self._rates = []
+        self.start_accrued_dts = []
+        self.end_accrued_dts = []
+        self.payment_dts = []
+        self.year_fracs = []
+        self.accrued_days = []
 
-        prev_dt = scheduleDates[0]
+        prev_dt = schedule_dts[0]
 
-        day_counter = DayCount(self._dc_type)
-        calendar = Calendar(self._cal_type)
+        day_counter = DayCount(self.dc_type)
+        calendar = Calendar(self.cal_type)
 
-        for next_dt in scheduleDates[1:]:
+        # All of the lists end up with the same length
+        for next_dt in schedule_dts[1:]:
 
-            self._start_accrued_dts.append(prev_dt)
-            self._end_accrued_dts.append(next_dt)
+            self.start_accrued_dts.append(prev_dt)
+            self.end_accrued_dts.append(next_dt)
 
-            if self._payment_lag == 0:
+            if self.payment_lag == 0:
                 payment_dt = next_dt
             else:
                 payment_dt = calendar.add_business_days(next_dt,
-                                                        self._payment_lag)
+                                                        self.payment_lag)
 
-            self._payment_dts.append(payment_dt)
+            self.payment_dts.append(payment_dt)
 
-            (year_frac, num, den) = day_counter.year_frac(prev_dt,
-                                                          next_dt)
+            (year_frac, num, _) = day_counter.year_frac(prev_dt,
+                                                        next_dt)
 
-            self._rates.append(self._cpn)
-
-            payment = year_frac * self._notional * self._cpn
-
-            self._payments.append(payment)
-            self._year_fracs.append(year_frac)
-            self._accrued_days.append(num)
+            self.year_fracs.append(year_frac)
+            self.accrued_days.append(num)
 
             prev_dt = next_dt
 
 ###############################################################################
 
     def value(self,
-              value_dt: Date,
-              discount_curve: DiscountCurve):
+              value_dt: Date,  # This should be the settlement date
+              discount_curve: DiscountCurve,
+              index_curve: DiscountCurve,
+              first_fixing_rate: float = None):
+        """ Value the floating leg with payments from an index curve and
+        discounting based on a supplied discount curve as of the valuation date
+        supplied. For an existing swap, the user must enter the next fixing
+        coupon. """
+
+        if discount_curve is None:
+            raise FinError("Discount curve is None")
+
+        if index_curve is None:
+            index_curve = discount_curve
+
+        self.rates = []
+        self.payments = []
+        self.payment_dfs = []
+        self.payment_pvs = []
+        self.cumulative_pvs = []
 
-        self._paymentDfs = []
-        self._payment_pvs = []
-        self._cumulativePVs = []
-
-        notional = self._notional
-        dfValue = discount_curve.df(value_dt)
+        df_value = discount_curve.df(value_dt)
         leg_pv = 0.0
-        numPayments = len(self._payment_dts)
+        num_payments = len(self.payment_dts)
+        first_payment = False
+
+        if not len(self.notional_array):
+            self.notional_array = [self.notional] * num_payments
+
+        index_basis = index_curve.dc_type
+        index_day_counter = DayCount(index_basis)
+
+        for i_pmnt in range(0, num_payments):
+
+            payment_dt = self.payment_dts[i_pmnt]
 
-        dfPmnt = 0.0
+            if payment_dt > value_dt:
 
-        for iPmnt in range(0, numPayments):
+                start_accrued_dt = self.start_accrued_dts[i_pmnt]
+                end_accrued_dt = self.end_accrued_dts[i_pmnt]
+                pay_alpha = self.year_fracs[i_pmnt]
 
-            pmntDate = self._payment_dts[iPmnt]
-            pmntAmount = self._payments[iPmnt]
+                (index_alpha, num, _) = index_day_counter.year_frac(start_accrued_dt,
+                                                                    end_accrued_dt)
 
-            if pmntDate > value_dt:
+                if first_payment is False and first_fixing_rate is not None:
 
-                dfPmnt = discount_curve.df(pmntDate) / dfValue
-                pmntPV = pmntAmount * dfPmnt
-                leg_pv += pmntPV
+                    fwd_rate = first_fixing_rate
+                    first_payment = True
 
-                self._paymentDfs.append(dfPmnt)
-                self._payment_pvs.append(pmntAmount*dfPmnt)
-                self._cumulativePVs.append(leg_pv)
+                else:
+
+                    df_start = index_curve.df(start_accrued_dt)
+                    df_end = index_curve.df(end_accrued_dt)
+                    fwd_rate = (df_start / df_end - 1.0) / index_alpha
+
+                payment_amount = (fwd_rate + self.spread) * \
+                    pay_alpha * self.notional_array[i_pmnt]
+
+                df_payment = discount_curve.df(payment_dt) / df_value
+                payment_pv = payment_amount * df_payment
+                leg_pv += payment_pv
+
+                self.rates.append(fwd_rate)
+                self.payments.append(payment_amount)
+                self.payment_dfs.append(df_payment)
+                self.payment_pvs.append(payment_pv)
+                self.cumulative_pvs.append(leg_pv)
 
             else:
 
-                self._paymentDfs.append(0.0)
-                self._payment_pvs.append(0.0)
-                self._cumulativePVs.append(0.0)
-
-        if pmntDate > value_dt:
-            payment_pv = self._principal * dfPmnt * notional
-            self._payment_pvs[-1] += payment_pv
+                self.rates.append(0.0)
+                self.payments.append(0.0)
+                self.payment_dfs.append(0.0)
+                self.payment_pvs.append(0.0)
+                self.cumulative_pvs.append(leg_pv)
+
+        if payment_dt > value_dt:
+            payment_pv = self.principal * df_payment * self.notional_array[-1]
+            self.payment_pvs[-1] += payment_pv
             leg_pv += payment_pv
-            self._cumulativePVs[-1] = leg_pv
+            self.cumulative_pvs[-1] = leg_pv
 
-        if self._leg_type == SwapTypes.PAY:
+        if self.leg_type == SwapTypes.PAY:
             leg_pv = leg_pv * (-1.0)
 
         return leg_pv
 
 ##########################################################################
 
     def print_payments(self):
         """ Prints the fixed leg dates, accrual factors, discount factors,
         cash amounts, their present value and their cumulative PV using the
         last valuation performed. """
 
-        print("START DATE:", self._effective_dt)
-        print("MATURITY DATE:", self._maturity_dt)
-        print("COUPON (%):", self._cpn * 100)
-        print("FREQUENCY:", str(self._freq_type))
-        print("DAY COUNT:", str(self._dc_type))
+        print("START DATE:", self.effective_dt)
+        print("MATURITY DATE:", self.maturity_dt)
+        print("SPREAD (bp):", self.spread * 10000)
+        print("FREQUENCY:", str(self.freq_type))
+        print("DAY COUNT:", str(self.dc_type))
 
-        if len(self._payments) == 0:
-            print("Payments not calculated.")
+        if len(self.payment_dts) == 0:
+            print("Payments Dates not calculated.")
             return
 
-        header = ["PAY_NUM", "PAY_dt", "ACCR_START", "ACCR_END",
-                  "DAYS", "YEARFRAC", "RATE", "PMNT"]
+        header = ["PAY_NUM", "PAY_dt", "ACCR_START",
+                  "ACCR_END", "DAYS", "YEARFRAC"]
 
         rows = []
-        num_flows = len(self._payment_dts)
+        num_flows = len(self.payment_dts)
         for i_flow in range(0, num_flows):
             rows.append([
                 i_flow + 1,
-                self._payment_dts[i_flow],
-                self._start_accrued_dts[i_flow],
-                self._end_accrued_dts[i_flow],
-                self._accrued_days[i_flow],
-                round(self._year_fracs[i_flow], 4),
-                round(self._rates[i_flow] * 100.0, 4),
-                round(self._payments[i_flow], 2),
+                self.payment_dts[i_flow],
+                self.start_accrued_dts[i_flow],
+                self.end_accrued_dts[i_flow],
+                self.accrued_days[i_flow],
+                round(self.year_fracs[i_flow], 4),
             ])
 
         table = format_table(header, rows)
         print("\nPAYMENTS SCHEDULE:")
         print(table)
 
 ###############################################################################
 
     def print_valuation(self):
         """ Prints the fixed leg dates, accrual factors, discount factors,
         cash amounts, their present value and their cumulative PV using the
         last valuation performed. """
 
-        print("START DATE:", self._effective_dt)
-        print("MATURITY DATE:", self._maturity_dt)
-        print("COUPON (%):", self._cpn * 100)
-        print("FREQUENCY:", str(self._freq_type))
-        print("DAY COUNT:", str(self._dc_type))
+        print("START DATE:", self.effective_dt)
+        print("MATURITY DATE:", self.maturity_dt)
+        print("SPREAD (BPS):", self.spread * 10000)
+        print("FREQUENCY:", str(self.freq_type))
+        print("DAY COUNT:", str(self.dc_type))
 
-        if len(self._payments) == 0:
+        if len(self.payments) == 0:
             print("Payments not calculated.")
             return
 
-        header = ["PAY_NUM", "PAY_dt", "NOTIONAL",
-                  "RATE", "PMNT", "DF", "PV", "CUM_PV"]
+        header = ["PAY_NUM", "PAY_dt",  "NOTIONAL",
+                  "IBOR", "PMNT", "DF", "PV", "CUM_PV"]
 
         rows = []
-        num_flows = len(self._payment_dts)
+        num_flows = len(self.payment_dts)
         for i_flow in range(0, num_flows):
             rows.append([
                 i_flow + 1,
-                self._payment_dts[i_flow],
-                round(self._notional, 0),
-                round(self._rates[i_flow] * 100.0, 4),
-                round(self._payments[i_flow], 2),
-                round(self._paymentDfs[i_flow], 4),
-                round(self._payment_pvs[i_flow], 2),
-                round(self._cumulativePVs[i_flow], 2),
+                self.payment_dts[i_flow],
+                round(self.notional_array[i_flow], 0),
+                round(self.rates[i_flow] * 100.0, 4),
+                round(self.payments[i_flow], 2),
+                round(self.payment_dfs[i_flow], 4),
+                round(self.payment_pvs[i_flow], 2),
+                round(self.cumulative_pvs[i_flow], 2),
             ])
 
         table = format_table(header, rows)
         print("\nPAYMENTS VALUATION:")
         print(table)
 
-##########################################################################
+###############################################################################
 
     def __repr__(self):
         s = label_to_string("OBJECT TYPE", type(self).__name__)
-        s += label_to_string("START DATE", self._effective_dt)
-        s += label_to_string("TERMINATION DATE", self._termination_dt)
-        s += label_to_string("MATURITY DATE", self._maturity_dt)
-        s += label_to_string("NOTIONAL", self._notional)
-        s += label_to_string("PRINCIPAL", self._principal)
-        s += label_to_string("LEG TYPE", self._leg_type)
-        s += label_to_string("COUPON", self._cpn)
-        s += label_to_string("FREQUENCY", self._freq_type)
-        s += label_to_string("DAY COUNT", self._dc_type)
-        s += label_to_string("CALENDAR", self._cal_type)
-        s += label_to_string("BUS DAY ADJUST", self._bd_type)
-        s += label_to_string("DATE GEN TYPE", self._dg_type)
+        s += label_to_string("START DATE", self.effective_dt)
+        s += label_to_string("TERMINATION DATE", self.termination_dt)
+        s += label_to_string("MATURITY DATE", self.maturity_dt)
+        s += label_to_string("NOTIONAL", self.notional)
+        s += label_to_string("SWAP TYPE", self.leg_type)
+        s += label_to_string("SPREAD (BPS)", self.spread*10000)
+        s += label_to_string("FREQUENCY", self.freq_type)
+        s += label_to_string("DAY COUNT", self.dc_type)
+        s += label_to_string("CALENDAR", self.cal_type)
+        s += label_to_string("BUS DAY ADJUST", self.bd_type)
+        s += label_to_string("DATE GEN TYPE", self.dg_type)
         return s
 
 ###############################################################################
 
     def _print(self):
         """ Print a list of the unadjusted coupon payment dates used in
         analytic calculations for the bond. """
```

### Comparing `financepy-0.350/financepy/utils/amount.py` & `financepy-0.360/financepy/utils/amount.py`

 * *Files 9% similar despite different names*

```diff
@@ -16,32 +16,31 @@
     def __init__(self,
                  notional: float = ONE_MILLION,
                  currency_type: CurrencyTypes = CurrencyTypes.NONE):
         """ Create Amount object. """
 
         check_argument_types(self.__init__, locals())
 
-        self._notional = notional
-        self._currency_type = currency_type
+        self.notional = notional
+        self.currency_type = currency_type
 
     def __repr__(self):
-        """ Print out the details of the schedule and the actual dates. This
-        can be used for providing transparency on schedule calculations. """
+        """ Print out amount object. """
 
         s = ""
-        if self._currency_type != CurrencyTypes.NONE:
-            s += self._currency_type.name
+        if self.currency_type != CurrencyTypes.NONE:
+            s += self.currency_type.name
             s += " "
 
-        s += '{:,.2f}'.format(self._notional)
+        s += '{:,.2f}'.format(self.notional)
 
         return s
 
     def amount(self):
-        return self._notional
+        return self.notional
 
     def _print(self):
         """ Print out the details of the schedule and the actual dates. This
         can be used for providing transparency on schedule calculations. """
         print(self)
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/utils/calendar.py` & `financepy-0.360/financepy/utils/calendar.py`

 * *Files 3% similar despite different names*

```diff
@@ -91,29 +91,31 @@
         """ Create a calendar based on a specified calendar type. """
 
         if cal_type not in CalendarTypes:
             raise FinError(
                 "Need to pass FinCalendarType and not " +
                 str(cal_type))
 
-        self._cal_type = cal_type
+        self.cal_type = cal_type
+        self.day_in_year = None
+        self.weekday = None
 
     ###########################################################################
 
     def adjust(self,
                dt: Date,
                bd_type: BusDayAdjustTypes):
         """ Adjust a payment date if it falls on a holiday according to the
         specified business day convention. """
 
-        if type(bd_type) != BusDayAdjustTypes:
+        if isinstance(bd_type, BusDayAdjustTypes) is False:
             raise FinError("Invalid type passed. Need Finbd_type")
 
         # If calendar type is NONE then every day is a business day
-        if self._cal_type == CalendarTypes.NONE:
+        if self.cal_type == CalendarTypes.NONE:
             return dt
 
         if bd_type == BusDayAdjustTypes.NONE:
             return dt
 
         elif bd_type == BusDayAdjustTypes.FOLLOWING:
 
@@ -121,26 +123,26 @@
             while self.is_business_day(dt) is False:
                 dt = dt.add_days(1)
 
             return dt
 
         elif bd_type == BusDayAdjustTypes.MODIFIED_FOLLOWING:
 
-            d_start = dt.d()
-            m_start = dt.m()
-            y_start = dt.y()
+            d_start = dt.d
+            m_start = dt.m
+            y_start = dt.y
 
             # step forward until we find a business day
             while self.is_business_day(dt) is False:
                 dt = dt.add_days(1)
 
             # if the business day is in a different month look back
             # for previous first business day one day at a time
             # TODO: I could speed this up by starting it at initial date
-            if dt._m != m_start:
+            if dt.m != m_start:
                 dt = Date(d_start, m_start, y_start)
                 while self.is_business_day(dt) is False:
                     dt = dt.add_days(-1)
 
             return dt
 
         elif bd_type == BusDayAdjustTypes.PRECEDING:
@@ -150,26 +152,26 @@
             while self.is_business_day(dt) is False:
                 dt = dt.add_days(-1)
 
             return dt
 
         elif bd_type == BusDayAdjustTypes.MODIFIED_PRECEDING:
 
-            d_start = dt.d()
-            m_start = dt.m()
-            y_start = dt.y()
+            d_start = dt.d
+            m_start = dt.m
+            y_start = dt.y
 
             # step backward until we find a business day
             while self.is_business_day(dt) is False:
                 dt = dt.add_days(-1)
 
             # if the business day is in a different month look forward
             # for previous first business day one day at a time
             # I could speed this up by starting it at initial date
-            if dt._m != m_start:
+            if dt.m != m_start:
                 dt = Date(d_start, m_start, y_start)
                 while self.is_business_day(dt) is False:
                     dt = dt.add_days(+1)
 
             return dt
 
         else:
@@ -179,45 +181,45 @@
 
         return dt
 
 ###############################################################################
 
     def add_business_days(self,
                           start_dt: Date,
-                          numDays: int):
-        """ Returns a new date that is numDays business days after Date.
+                          num_days: int):
+        """ Returns a new date that is num_days business days after Date.
         All holidays in the chosen calendar are assumed not business days. """
 
         # TODO: REMOVE DATETIME DEPENDENCE HERE ???
 
-        if isinstance(numDays, int) is False:
+        if isinstance(num_days, int) is False:
             raise FinError("Num days must be an integer")
 
-        dt = datetime.date(start_dt._y, start_dt._m, start_dt._d)
+        dt = datetime.date(start_dt.y, start_dt.m, start_dt.d)
         d = dt.day
         m = dt.month
         y = dt.year
-        newDt = Date(d, m, y)
+        new_dt = Date(d, m, y)
 
         s = +1
-        if numDays < 0:
-            numDays = -1 * numDays
+        if num_days < 0:
+            num_days = -1 * num_days
             s = -1
 
-        while numDays > 0:
+        while num_days > 0:
             dt = dt + s * datetime.timedelta(days=1)
             d = dt.day
             m = dt.month
             y = dt.year
-            newDt = Date(d, m, y)
+            new_dt = Date(d, m, y)
 
-            if self.is_business_day(newDt) is True:
-                numDays -= 1
+            if self.is_business_day(new_dt) is True:
+                num_days -= 1
 
-        return newDt
+        return new_dt
 
 ###############################################################################
 
     def is_business_day(self,
                         dt: Date):
         """ Determines if a date is a business day according to the specified
         calendar. If it is it returns True, otherwise False. """
@@ -236,50 +238,50 @@
 
     def is_holiday(self,
                    dt: Date):
         """ Determines if a date is a Holiday according to the specified
         calendar. Weekends are not holidays unless the holiday falls on a
         weekend date. """
 
-        start_dt = Date(1, 1, dt.y())
-        self._day_in_year = dt.excel_dt() - start_dt.excel_dt() + 1
-        self._weekday = dt.weekday()
+        start_dt = Date(1, 1, dt.y)
+        self.day_in_year = dt.excel_dt - start_dt.excel_dt + 1
+        self.weekday = dt.weekday
 
-        if self._cal_type == CalendarTypes.NONE:
+        if self.cal_type == CalendarTypes.NONE:
             return self.holiday_none(dt)
-        elif self._cal_type == CalendarTypes.WEEKEND:
+        elif self.cal_type == CalendarTypes.WEEKEND:
             return self.holiday_weekend(dt)
-        elif self._cal_type == CalendarTypes.AUSTRALIA:
+        elif self.cal_type == CalendarTypes.AUSTRALIA:
             return self.holiday_australia(dt)
-        elif self._cal_type == CalendarTypes.CANADA:
+        elif self.cal_type == CalendarTypes.CANADA:
             return self.holiday_canada(dt)
-        elif self._cal_type == CalendarTypes.FRANCE:
+        elif self.cal_type == CalendarTypes.FRANCE:
             return self.holiday_france(dt)
-        elif self._cal_type == CalendarTypes.GERMANY:
+        elif self.cal_type == CalendarTypes.GERMANY:
             return self.holiday_germany(dt)
-        elif self._cal_type == CalendarTypes.ITALY:
+        elif self.cal_type == CalendarTypes.ITALY:
             return self.holiday_italy(dt)
-        elif self._cal_type == CalendarTypes.JAPAN:
+        elif self.cal_type == CalendarTypes.JAPAN:
             return self.holiday_japan(dt)
-        elif self._cal_type == CalendarTypes.NEW_ZEALAND:
+        elif self.cal_type == CalendarTypes.NEW_ZEALAND:
             return self.holiday_new_zealand(dt)
-        elif self._cal_type == CalendarTypes.NORWAY:
+        elif self.cal_type == CalendarTypes.NORWAY:
             return self.holiday_norway(dt)
-        elif self._cal_type == CalendarTypes.SWEDEN:
+        elif self.cal_type == CalendarTypes.SWEDEN:
             return self.holiday_sweden(dt)
-        elif self._cal_type == CalendarTypes.SWITZERLAND:
+        elif self.cal_type == CalendarTypes.SWITZERLAND:
             return self.holiday_switzerland(dt)
-        elif self._cal_type == CalendarTypes.TARGET:
+        elif self.cal_type == CalendarTypes.TARGET:
             return self.holiday_target(dt)
-        elif self._cal_type == CalendarTypes.UNITED_KINGDOM:
+        elif self.cal_type == CalendarTypes.UNITED_KINGDOM:
             return self.holiday_united_kingdom(dt)
-        elif self._cal_type == CalendarTypes.UNITED_STATES:
+        elif self.cal_type == CalendarTypes.UNITED_STATES:
             return self.holiday_united_states(dt)
         else:
-            print(self._cal_type)
+            print(self.cal_type)
             raise FinError("Unknown calendar")
 
 ###############################################################################
 
     def holiday_weekend(self, dt: Date):
         """ Weekends by themselves are a holiday. """
 
@@ -289,19 +291,19 @@
             return False
 
 ###############################################################################
 
     def holiday_australia(self, dt: Date):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 26:  # Australia day
             return True
 
@@ -355,34 +357,34 @@
         return False
 
 ###############################################################################
 
     def holiday_united_kingdom(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 2 and weekday == Date.MON:  # new years day
             return True
 
         if m == 1 and d == 3 and weekday == Date.MON:  # new years day
             return True
 
         em = easterMondayDay[y - 1901]
 
-        if self._day_in_year == em:  # Easter Monday
+        if self.day_in_year == em:  # Easter Monday
             return True
 
-        if self._day_in_year == em - 3:  # good friday
+        if self.day_in_year == em - 3:  # good friday
             return True
 
         if m == 5 and d <= 7 and weekday == Date.MON:
             return True
 
         if m == 5 and d >= 25 and weekday == Date.MON:
             return True
@@ -417,18 +419,18 @@
         return False
 
 ###############################################################################
 
     def holiday_france(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
 
         if m == 1 and d == 1:  # new years day
             return True
 
         em = easterMondayDay[y - 1901]
 
         if day_in_year == em:  # Easter Monday
@@ -470,19 +472,19 @@
         return False
 
 ###############################################################################
 
     def holiday_sweden(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 6:  # epiphany day
             return True
 
@@ -521,18 +523,18 @@
         return False
 
 ###############################################################################
 
     def holiday_germany(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
 
         if m == 1 and d == 1:  # new years day
             return True
 
         em = easterMondayDay[y - 1901]
 
         if day_in_year == em:  # Easter Monday
@@ -565,19 +567,19 @@
         return False
 
 ###############################################################################
 
     def holiday_switzerland(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 2:  # berchtoldstag
             return True
 
@@ -610,19 +612,19 @@
         return False
 
 ###############################################################################
 
     def holiday_japan(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 2 and weekday == Date.MON:  # bank holiday
             return True
 
@@ -713,19 +715,19 @@
         return False
 
 ###############################################################################
 
     def holiday_new_zealand(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 2 and weekday == Date.MON:  # new years day
             return True
 
@@ -776,19 +778,19 @@
         return False
 
 ###############################################################################
 
     def holiday_norway(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # new years day
             return True
 
         em = easterMondayDay[y - 1901]
 
         if day_in_year == em - 4:  # holy thursday
@@ -824,17 +826,17 @@
 
     def holiday_united_states(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday.
         This is a generic US calendar that contains the superset of
         holidays for bond markets, NYSE, and public holidays. For each of
         these and other categories there will be some variations. """
 
-        m = dt.m()
-        d = dt.d()
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # NYD
             return True
 
         if m == 1 and d == 2 and weekday == Date.MON:  # NYD
             return True
 
@@ -892,19 +894,19 @@
         return False
 
 ###############################################################################
 
     def holiday_canada(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
-        weekday = self._weekday
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
+        weekday = self.weekday
 
         if m == 1 and d == 1:  # NYD
             return True
 
         if m == 1 and d == 2 and weekday == Date.MON:  # NYD
             return True
 
@@ -970,18 +972,18 @@
         return False
 
 ###############################################################################
 
     def holiday_italy(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
 
         if m == 1 and d == 1:  # new years day
             return True
 
         if m == 1 and d == 6:  # epiphany
             return True
 
@@ -1020,18 +1022,18 @@
         return False
 
 ###############################################################################
 
     def holiday_target(self, dt):
         """ Only bank holidays. Weekends by themselves are not a holiday. """
 
-        m = dt.m()
-        d = dt.d()
-        y = dt.y()
-        day_in_year = self._day_in_year
+        m = dt.m
+        d = dt.d
+        y = dt.y
+        day_in_year = self.day_in_year
 
         if m == 1 and d == 1:  # new year's day
             return True
 
         if m == 5 and d == 1:  # May day
             return True
 
@@ -1049,57 +1051,57 @@
         if m == 12 and d == 26:  # Xmas bank holiday
             return True
 
         return False
 
 ###############################################################################
 
-    def holiday_none(self, dt):
+    def holiday_none(self, dt=None):
         """ No day is a holiday. """
         return False
 
 ###############################################################################
 
     def get_holiday_list(self, year: float):
         """ generates a list of holidays in a specific year for the specified
         calendar. Useful for diagnostics. """
         start_dt = Date(1, 1, year)
         end_dt = Date(1, 1, year + 1)
-        holidayList = []
+        holiday_list = []
         while start_dt < end_dt:
             if self.is_business_day(start_dt) is False and \
                     start_dt.is_weekend() is False:
-                holidayList.append(start_dt.__str__())
+                holiday_list.append(start_dt.__str__())
 
             start_dt = start_dt.add_days(1)
 
-        return holidayList
+        return holiday_list
 
 ###############################################################################
 
     def easter_monday(self,
                       year: float):
         """ Get the day in a given year that is Easter Monday. This is not
-        easy to compute so we rely on a pre-calculated array. """
+        easy to compute, so we rely on a pre-calculated array. """
 
         if year > 2100:
             raise FinError(
                 "Unable to determine Easter monday in year " + str(year))
 
-        emDays = easterMondayDay[year - 1901]
+        em_days = easterMondayDay[year - 1901]
         start_dt = Date(1, 1, year)
-        em = start_dt.add_days(emDays-1)
+        em = start_dt.add_days(em_days-1)
         return em
 
 ###############################################################################
 
     def __str__(self):
-        s = self._cal_type.name
+        s = self.cal_type.name
         return s
 
 ###############################################################################
 
     def __repr__(self):
-        s = self._cal_type
+        s = self.cal_type
         return s
 
 ###############################################################################
```

### Comparing `financepy-0.350/financepy/utils/currency.py` & `financepy-0.360/financepy/utils/currency.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/utils/date.py` & `financepy-0.360/financepy/utils/date.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 from collections.abc import Iterable
 from functools import partial
+from enum import Enum
 
 from numba import njit
 import numpy as np
 import datetime
 import math
 
 # from financepy.utils.error import FinError
 from .error import FinError
 
 ###############################################################################
 
-from enum import Enum
-
 
 class DateFormatTypes(Enum):
     BLOOMBERG = 1
     US_SHORT = 2
     US_MEDIUM = 3
     US_LONG = 4
     US_LONGEST = 5
@@ -101,15 +100,15 @@
     return dt_obj.day, dt_obj.month, dt_obj.year
 
 ###############################################################################
 # CREATE DATE COUNTER
 ###############################################################################
 
 
-g_date_counter_list = None
+g_dt_counter_list = None
 g_start_year = 1900
 g_end_year = 2100
 
 
 def calculate_list():
     """ Calculate list of dates so that we can do quick lookup to get the
     number of dates since 1 Jan 1900 (inclusive) BUT TAKING INTO ACCOUNT THE
@@ -117,19 +116,19 @@
     Excel is more important than this leap year error and in any case, we will
     not usually be calculating day differences with start dates before 28 Feb
     1900. Note that Excel inherited this "BUG" from LOTUS 1-2-3. """
 
     day_counter = 0
     max_days = 0
 
-    global g_date_counter_list
+    global g_dt_counter_list
     global g_start_year
     global g_end_year
 
-    g_date_counter_list = []
+    g_dt_counter_list = []
 
     idx = -1  # the first element will be idx=0
 
     for yy in range(1900, g_end_year+1):
 
         # DO NOT CHANGE THIS FOR AGREEMENT WITH EXCEL WHICH ASSUMES THAT 1900
         # WAS A LEAP YEAR AND THAT 29 FEB 1900 ACTUALLY HAPPENED. A LOTUS BUG.
@@ -145,20 +144,20 @@
             else:
                 max_days = month_days_not_leap_year[mm-1]
 
             for _ in range(1, max_days+1):
                 idx += 1
                 day_counter += 1
                 if yy >= g_start_year:
-                    g_date_counter_list.append(day_counter)
+                    g_dt_counter_list.append(day_counter)
 
             for _ in range(max_days, 31):
                 idx += 1
                 if yy >= g_start_year:
-                    g_date_counter_list.append(-999)
+                    g_dt_counter_list.append(-999)
 
 ###############################################################################
 # The index in these functions is not the Excel date index used as the
 # internal representation of the date but the index of that date in the
 # padded date object used to store the dates in a way that allows for a
 # quick lookup. Do not confuse them as you will find they are out by months
 ###############################################################################
@@ -236,15 +235,15 @@
 
         # If the date has been entered as y, m, d we flip it to d, m, y
         # This message should be removed after a few releases
         if d >= g_start_year and d < g_end_year and y > 0 and y <= 31:
             raise FinError(
                 "Date arguments must now be in the order Date(dd, mm, yyyy)")
 
-        if g_date_counter_list is None:
+        if g_dt_counter_list is None:
             calculate_list()
 
         if y < 1900:
             raise FinError("Year cannot be before 1900")
 
         # Resize date list dynamically if required
         if y < g_start_year:
@@ -279,64 +278,42 @@
 
         if mm < 0 or mm > 59:
             raise FinError("Minutes must be in range 0-59")
 
         if ss < 0 or ss > 59:
             raise FinError("Seconds must be in range 0-59")
 
-        self._y = y
-        self._m = m
-        self._d = d
-
-        self._hh = hh
-        self._mm = mm
-        self._ss = ss
+        self.y = y
+        self.m = m
+        self.d = d
+
+        self.hh = hh
+        self.mm = mm
+        self.ss = ss
 
-        self._excel_dt = 0  # This is a float as it includes intraday time
+        self.excel_dt = 0  # This is a float as it includes intraday time
 
         # update the Excel date used for doing lots of financial calculations
         self._refresh()
 
-        day_fraction = self._hh/24.0
-        day_fraction += self._mm/24.0/60.0
-        day_fraction += self._ss/24.0/60.0/60.0
-
-        self._excel_dt += day_fraction  # This is float - holds intraday time
-
-    ###########################################################################
-
-    def d(self):
-        ''' Get day of month as integer '''
-        return self._d
-
-    def m(self):
-        ''' Get month of year as integer '''
-        return self._m
-
-    def y(self):
-        ''' Get year as integer '''
-        return self._y
-
-    def excel_dt(self):
-        ''' get this date in form of Excel date i.e. as an integer'''
-        return self._excel_dt
+        day_fraction = self.hh/24.0
+        day_fraction += self.mm/24.0/60.0
+        day_fraction += self.ss/24.0/60.0/60.0
 
-    def weekday(self):
-        ''' get day of week as integer '''
-        return self._weekday
+        self.excel_dt += day_fraction  # This is float - holds intraday time
 
     ###########################################################################
 
     @classmethod
-    def from_string(cls, date_string, formatString):
+    def from_string(cls, date_string, format_string):
         """  Create a Date from a date and format string.
         Example Input:
         start_dt = Date('1-1-2018', '%d-%m-%Y') """
 
-        d, m, y = parse_dt(date_string, formatString)
+        d, m, y = parse_dt(date_string, format_string)
         return cls(d, m, y)
 
     ###########################################################################
 
     @classmethod
     def from_date(cls, date: [datetime.date, np.datetime64]):
         """  Create a Date from a python datetime.date object or from a
@@ -357,80 +334,80 @@
             return cls(d, m, y)
 
     ###########################################################################
 
     def _refresh(self):
         """ Update internal representation of date as number of days since the
         1st Jan 1900. This is same as Excel convention. """
-        idx = date_index(self._d, self._m, self._y)
-        days_since_first_jan_1900 = g_date_counter_list[idx]
+        idx = date_index(self.d, self.m, self.y)
+        days_since_first_jan_1900 = g_dt_counter_list[idx]
         wd = weekday(days_since_first_jan_1900)
-        self._excel_dt = days_since_first_jan_1900
-        self._weekday = wd
+        self.excel_dt = days_since_first_jan_1900
+        self.weekday = wd
 
     ###########################################################################
 
     @vectorisation_helper
     def __gt__(self, other):
-        return self._excel_dt > other._excel_dt
+        return self.excel_dt > other.excel_dt
 
     ###########################################################################
 
     @vectorisation_helper
     def __lt__(self, other):
-        return self._excel_dt < other._excel_dt
+        return self.excel_dt < other.excel_dt
 
     ###########################################################################
 
     @vectorisation_helper
     def __ge__(self, other):
-        return self._excel_dt >= other._excel_dt
+        return self.excel_dt >= other.excel_dt
 
     ###########################################################################
 
     @vectorisation_helper
     def __le__(self, other):
-        return self._excel_dt <= other._excel_dt
+        return self.excel_dt <= other.excel_dt
 
     ###########################################################################
 
     @vectorisation_helper
     def __sub__(self, other):
-        return self._excel_dt - other._excel_dt
+        return self.excel_dt - other.excel_dt
 
     ###########################################################################
 
     @vectorisation_helper
     def __rsub__(self, other):
-        return self._excel_dt - other._excel_dt
+        return self.excel_dt - other.excel_dt
 
     ###########################################################################
 
     @vectorisation_helper
     def __eq__(self, other):
-        return self._excel_dt == other._excel_dt
+        return self.excel_dt == other.excel_dt
 
     ###########################################################################
 
     def is_weekend(self):
         """ returns True if the date falls on a weekend. """
 
-        if self._weekday == Date.SAT or self._weekday == Date.SUN:
+        if self.weekday == Date.SAT or self.weekday == Date.SUN:
             return True
 
         return False
 
     ###########################################################################
 
     def is_eom(self):
         """ returns True if this date falls on a month end. """
 
-        y = self._y
-        m = self._m
-        d = self._d
+        y = self.y
+        m = self.m
+        d = self.d
 
         leap_year = is_leap_year(y)
 
         if leap_year:
             if d == month_days_leap_year[m - 1]:
                 return True
         else:
@@ -440,16 +417,16 @@
         return False
 
     ###########################################################################
 
     def eom(self):
         """ returns last date of month of this date. """
 
-        y = self._y
-        m = self._m
+        y = self.y
+        m = self.m
 
         leap_year = is_leap_year(y)
 
         if leap_year:
             last_day = month_days_leap_year[m - 1]
             return Date(last_day, m, y)
         else:
@@ -462,42 +439,42 @@
 
     def add_hours(self, hours):
         """ Returns a new date that is h hours after the Date. """
 
         if hours < 0:
             raise FinError("Number of hours must be positive")
 
-        start_hour = self._hh
+        start_hour = self.hh
         final_hour = start_hour + hours
         days = int(final_hour/24)
         hour = final_hour % 24
 
         # Move forward a specific number of days
         dt_1 = self.add_days(days)
 
         # On that date we then move to the correct hour
-        dt_2 = Date(dt_1.d(), dt_1.m(), dt_1.y(), hour, dt_1._mm, dt_1._ss)
+        dt_2 = Date(dt_1.d, dt_1.m, dt_1.y, hour, dt_1.mm, dt_1.ss)
         return dt_2
 
     ###########################################################################
 
     def add_days(self,
                  num_days: int = 1):
         """ Returns a new date that is num_days after the Date. I also make
         it possible to go backwards a number of days. """
 
-        idx = date_index(self._d, self._m, self._y)
+        idx = date_index(self.d, self.m, self.y)
 
         step = +1
         if num_days < 0:
             step = -1
 
         while num_days != 0:
             idx += step
-            if g_date_counter_list[idx] > 0:
+            if g_dt_counter_list[idx] > 0:
                 num_days -= step
 
         (d, m, y) = date_from_index(idx)
         new_dt = Date(d, m, y)
         return new_dt
 
     ###########################################################################
@@ -523,31 +500,31 @@
         old_logic = False
 
         if old_logic is True:
 
             num_weeks = int(num_days / 5)
             remaining_days = num_days % 5
 
-            if self._weekday == Date.SAT:
+            if self.weekday == Date.SAT:
                 weekend_adjust = 1
-            elif self._weekday == Date.SUN:
+            elif self.weekday == Date.SUN:
                 weekend_adjust = 0
             else:
                 weekend_adjust = 2
 
             if positive_num_days is True:
-                if self._weekday + remaining_days > self.FRI:
+                if self.weekday + remaining_days > self.FRI:
                     # add weekend
                     remaining_days += weekend_adjust
 
                 return self.add_days(num_weeks * 7 + remaining_days)
 
             else:
 
-                if self._weekday - remaining_days < self.MON:
+                if self.weekday - remaining_days < self.MON:
                     # add weekend
                     remaining_days += weekend_adjust
 
             return self.add_days(-(num_weeks * 7 + remaining_days))
 
         else:  # new logic
 
@@ -557,15 +534,15 @@
             while num_days_left > 0:
 
                 if positive_num_days is True:
                     end_dt = end_dt.add_days(1)
                 else:
                     end_dt = end_dt.add_days(-1)
 
-                if end_dt.weekday() == Date.SAT or end_dt.weekday() == Date.SUN:
+                if end_dt.weekday == Date.SAT or end_dt.weekday == Date.SUN:
                     pass
                 else:
                     num_days_left -= 1
 
             return end_dt
 
     ###########################################################################
@@ -595,17 +572,17 @@
 
             # If I get a float I check it has no decimal places
             if int(mmi) != mmi:
                 raise FinError("Must only pass integers or float integers.")
 
             mmi = int(mmi)
 
-            d = self._d
-            m = self._m + mmi
-            y = self._y
+            d = self.d
+            m = self.m + mmi
+            y = self.y
 
             while m > 12:
                 m = m - 12
                 y += 1
 
             while m < 1:
                 m = m + 12
@@ -674,42 +651,42 @@
     def next_cds_date(self,
                       mm: int = 0):
         """ Returns a CDS date that is mm months after the Date. If no
         argument is supplied then the next CDS date after today is returned."""
 
         next_dt = self.add_months(mm)
 
-        y = next_dt.y()
-        m = next_dt.m()
-        d = next_dt.d()
+        y = next_dt.y
+        m = next_dt.m
+        d = next_dt.d
 
         d_cds = 20
         y_cds = y
         m_cds = 999
 
         if m == 12 and d >= 20:
             m_cds = 3
             y_cds = y + 1
-        elif m == 10 or m == 11 or m == 12:
+        elif m in (10, 11, 12):
             m_cds = 12
         elif m == 9 and d >= 20:
             m_cds = 12
-        elif m == 7 or m == 8 or m == 9:
+        elif m in (7, 8, 9):
             m_cds = 9
         elif m == 6 and d >= 20:
             m_cds = 9
-        elif m == 4 or m == 5 or m == 6:
+        elif m in (4, 5, 6):
             m_cds = 6
         elif m == 3 and d >= 20:
             m_cds = 6
-        elif m == 1 or m == 2 or m == 3:
+        elif m in (1, 2, 3):
             m_cds = 3
 
-        cds_date = Date(d_cds, m_cds, y_cds)
-        return cds_date
+        cds_dt = Date(d_cds, m_cds, y_cds)
+        return cds_dt
 
     ##########################################################################
 
     def third_wednesday_of_month(self,
                                  m: int,  # Month number
                                  y: int):  # Year number
         """ For a specific month and year this returns the day number of the
@@ -719,57 +696,57 @@
         # Suppose 1st is Thur then 7th is Wed and 14th is 2nd Wednesday so 21
         # is 3rd so earliest and latest dates are 15th and 21st
 
         d_start = 15
         d_end = 21
 
         for d in range(d_start, d_end+1):
-            imm_date = Date(d, m, y)
-            if imm_date.weekday() == self.WED:
+            imm_dt = Date(d, m, y)
+            if imm_dt.weekday == self.WED:
                 return d
 
         # Should never reach this line but just to be defensive
         raise FinError("Third Wednesday not found")
 
     ##########################################################################
 
     def next_imm_date(self):
         """ This function returns the next IMM date after the current date
             This is a 3rd Wednesday of Jun, March, Sep or December. For an
             IMM contract the IMM date is the First Delivery Date of the
             futures contract. """
 
-        y = self._y
-        m = self._m
-        d = self._d
+        y = self.y
+        m = self.m
+        d = self.d
 
         y_imm = y
 
         if m == 12 and d >= self.third_wednesday_of_month(m, y):
             m_imm = 3
             y_imm = y + 1
-        elif m == 10 or m == 11 or m == 12:
+        elif m in (10, 11, 12):
             m_imm = 12
         elif m == 9 and d >= self.third_wednesday_of_month(m, y):
             m_imm = 12
-        elif m == 7 or m == 8 or m == 9:
+        elif m in (7, 8, 9):
             m_imm = 9
         elif m == 6 and d >= self.third_wednesday_of_month(m, y):
             m_imm = 9
-        elif m == 4 or m == 5 or m == 6:
+        elif m in (4, 5, 6):
             m_imm = 6
         elif m == 3 and d >= self.third_wednesday_of_month(m, y):
             m_imm = 6
-        elif m == 1 or m == 2 or m == 3:
+        elif m in (1, 2, 3):
             m_imm = 3
 
         d_imm = self.third_wednesday_of_month(m_imm, y_imm)
 
-        imm_date = Date(d_imm, m_imm, y_imm)
-        return imm_date
+        imm_dt = Date(d_imm, m_imm, y_imm)
+        return imm_dt
 
     ###########################################################################
 
     def add_tenor(self,
                   tenor: (list, str)):
         """ Return the date following the Date by a period given by the
         tenor which is a string consisting of a number and a letter, the
@@ -787,15 +764,15 @@
                     raise FinError("Tenor must be a string e.g. '5Y'")
         else:
             if isinstance(tenor, str) is True:
                 tenor = [tenor]
             else:
                 raise FinError("Tenor must be a string e.g. '5Y'")
 
-        new_dates = []
+        new_dts = []
 
         for tenor_str in tenor:
 
             tenor_str = tenor_str.upper()
             DAYS = 1
             WEEKS = 2
             MONTHS = 3
@@ -821,91 +798,91 @@
                 num_periods = int(tenor_str[0:-1])
             elif tenor_str[-1] == "Y":
                 period_type = YEARS
                 num_periods = int(tenor_str[0:-1])
             else:
                 raise FinError("Unknown tenor type in " + tenor)
 
-            new_date = Date(self._d, self._m, self._y)
+            new_dt = Date(self.d, self.m, self.y)
 
             if period_type == DAYS:
                 for _ in range(0, abs(num_periods)):
-                    new_date = new_date.add_days(math.copysign(1, num_periods))
+                    new_dt = new_dt.add_days(math.copysign(1, num_periods))
             elif period_type == WEEKS:
                 for _ in range(0, abs(num_periods)):
-                    new_date = new_date.add_days(math.copysign(7, num_periods))
+                    new_dt = new_dt.add_days(math.copysign(7, num_periods))
             elif period_type == MONTHS:
                 for _ in range(0, abs(num_periods)):
-                    new_date = new_date.add_months(math.copysign(1, num_periods))
+                    new_dt = new_dt.add_months(math.copysign(1, num_periods))
 
                 # in case we landed on a 28th Feb and lost the month day we add this logic
-                y = new_date.y()
-                m = new_date.m()
-                d = min(self.d(), new_date.eom()._d)
-                new_date = Date(d, m, y)
+                y = new_dt.y
+                m = new_dt.m
+                d = min(self.d, new_dt.eom().d)
+                new_dt = Date(d, m, y)
 
             elif period_type == YEARS:
                 for _ in range(0, abs(num_periods)):
-                    new_date = new_date.add_months(math.copysign(12, num_periods))
+                    new_dt = new_dt.add_months(math.copysign(12, num_periods))
 
-            new_dates.append(new_date)
+            new_dts.append(new_dt)
 
         if list_flag is True:
-            return new_dates
+            return new_dts
         else:
-            return new_dates[0]
+            return new_dts[0]
 
     ###########################################################################
 
     def datetime(self):
         """ Returns a datetime of the date """
 
         # Remember that datetime likes inputs in opposite order
-        return datetime.date(self._y, self._m, self._d)
+        return datetime.date(self.y, self.m, self.d)
 
     ###########################################################################
     # TODO: Find elegant way to return long and short strings
     ###########################################################################
 
     def str(self):
         """ returns a formatted string of the date """
         date_str = ""
 
-        if self._d < 10:
-            date_str += "0" + str(self._d) + ""
+        if self.d < 10:
+            date_str += "0" + str(self.d) + ""
         else:
-            date_str += "" + str(self._d) + ""
+            date_str += "" + str(self.d) + ""
 
-        date_str += short_month_names[self._m - 1]
-        date_str += "" + str(self._y)
+        date_str += short_month_names[self.m - 1]
+        date_str += "" + str(self.y)
         return date_str
 
     ###########################################################################
 
     def __repr__(self):
         """ returns a formatted string of the date """
 
         global g_date_type_format
 
-        day_name_str = short_day_names[self._weekday]
+        day_name_str = short_day_names[self.weekday]
 
-        if self._d < 10:
-            day_str = "0" + str(self._d)
+        if self.d < 10:
+            day_str = "0" + str(self.d)
         else:
-            day_str = "" + str(self._d)
+            day_str = "" + str(self.d)
 
-        if self._m < 10:
-            short_month_str = "0" + str(self._m)
+        if self.m < 10:
+            short_month_str = "0" + str(self.m)
         else:
-            short_month_str = str(self._m)
+            short_month_str = str(self.m)
 
-        long_month_str = short_month_names[self._m - 1]
+        long_month_str = short_month_names[self.m - 1]
 
-        short_year_str = str(self._y)[2:]
-        long_year_str = str(self._y)
+        short_year_str = str(self.y)[2:]
+        long_year_str = str(self.y)
 
         if g_date_type_format == DateFormatTypes.UK_LONGEST:
 
             sep = " "
             date_str = day_name_str + " " + day_str + sep + long_month_str + sep + long_year_str
             return date_str
 
@@ -957,28 +934,28 @@
             date_str = short_month_str + sep + day_str + sep + short_year_str
             return date_str
 
         elif g_date_type_format == DateFormatTypes.DATETIME:
 
             sep = "/"
 
-            if self._hh < 10:
-                hour_str = "0" + str(self._hh)
+            if self.hh < 10:
+                hour_str = "0" + str(self.hh)
             else:
-                hour_str = str(self._hh)
+                hour_str = str(self.hh)
 
-            if self._mm < 10:
-                minute_str = "0" + str(self._mm)
+            if self.mm < 10:
+                minute_str = "0" + str(self.mm)
             else:
-                minute_str = str(self._mm)
+                minute_str = str(self.mm)
 
-            if self._ss < 10:
-                second_str = "0" + str(self._ss)
+            if self.ss < 10:
+                second_str = "0" + str(self.ss)
             else:
-                second_str = str(self._ss)
+                second_str = str(self.ss)
 
             time_str = hour_str + ":" + minute_str + ":" + second_str
             date_str = day_str + sep + short_month_str + sep + long_year_str
             date_str = date_str + " " + time_str
             return date_str
 
         else:
@@ -1014,26 +991,26 @@
 
 ###############################################################################
 
 
 def datediff(d1: Date,
              d2: Date):
     """ Calculate the number of days between two Findates. """
-    dd = d2.excel_dt() - d1.excel_dt()
+    dd = d2.excel_dt - d1.excel_dt
     return int(dd)
 
 ###############################################################################
 
 
 def from_datetime(dt: Date):
     """ Construct a Date from a datetime as this is often needed if we
     receive inputs from other Python objects such as Pandas dataframes. """
 
-    fin_date = Date(dt.day, dt.month, dt.year)
-    return fin_date
+    fin_dt = Date(dt.day, dt.month, dt.year)
+    return fin_dt
 
 ###############################################################################
 
 
 def days_in_month(m, y):
     """ Get the number of days in the month (1-12) of a given year y. """
```

### Comparing `financepy-0.350/financepy/utils/day_count.py` & `financepy-0.360/financepy/utils/day_count.py`

 * *Files 3% similar despite different names*

```diff
@@ -19,26 +19,24 @@
 
 ###############################################################################
 
 
 def is_last_day_of_feb(dt: Date):
     ''' Returns True if we are on the last day of February '''
 
-    if dt.m() == 2:
-        is_leap = is_leap_year(dt._y)
-        if is_leap is True and dt.d() == 29:
+    if dt.m == 2:
+        is_leap = is_leap_year(dt.y)
+        if is_leap is True and dt.d == 29:
             return True
-        if is_leap is False and dt.d() == 28:
+        if is_leap is False and dt.d == 28:
             return True
     else:
         return False
 
 ###############################################################################
-
-###############################################################################
 #    THIRTY_360_BOND = 1  # 30E/360 ISDA 2006 4.16f, German, Eurobond(ISDA2000)
 #    THIRTY_E_360 = 2  # ISDA 2006 4.16(g) 30/360 ISMA, ICMA
 #    THIRTY_E_360_ISDA = 3  # ISDA 2006 4.16(h)
 #    THIRTY_E_PLUS_360 = 4  # ROLLS D2 TO NEXT MONTH IF D2 = 31
 #    ACT_ACT_ISDA = 5  # SPLITS ACCRUAL PERIOD INTO LEAP YEAR AND NON LEAP YEAR
 #    ACT_ACT_ICMA = 6  # METHOD FOR ALL US TREASURY NOTES AND BONDS
 #    ACT_365F = 7  # Denominator is always Fixed at 365, even in a leap year
@@ -63,31 +61,30 @@
 ###############################################################################
 
 
 class DayCount:
     """ Calculate the fractional day count between two dates according to a
     specified day count convention. """
 
-    def __init__(self,
-                 dccType: DayCountTypes):
+    def __init__(self, dcc_type: DayCountTypes):
         """ Create Day Count convention by passing in the Day Count Type. """
 
-        if dccType not in DayCountTypes:
+        if dcc_type not in DayCountTypes:
             raise FinError("Need to pass FinDayCountType")
 
-        self._type = dccType
+        self._type = dcc_type
 
 ###############################################################################
 
     def year_frac(self,
                   dt1: Date,  # Start of coupon period
                   dt2: Date,  # Settlement (for bonds) or period end(swaps)
                   dt3: Date = None,  # End of coupon period for accrued
                   freq_type: FrequencyTypes = FrequencyTypes.ANNUAL,
-                  isTerminationDate: bool = False):  # Is dt2 a term date
+                  is_termination_date: bool = False):  # Is dt2 a term date
         """ This method performs two functions:
 
         1) It calculates the year fraction between dates dt1 and dt2 using the
         specified day count convention which is useful for calculating year
         fractions for Libor products whose flows are day count adjusted. In
         this case we will set dt3 to be None
         2) This function is also for calculating bond accrued where dt1 is the
@@ -104,21 +101,21 @@
         https://www.eclipsesoftware.biz/DayCountConventions.html
         Wikipedia also has a decent survey of the conventions
         https://en.wikipedia.org/wiki/Day_count_convention
         and
         http://data.cbonds.info/files/cbondscalc/Calculator.pdf
         """
 
-        d1 = dt1.d()
-        m1 = dt1.m()
-        y1 = dt1.y()
-
-        d2 = dt2.d()
-        m2 = dt2.m()
-        y2 = dt2.y()
+        d1 = dt1.d
+        m1 = dt1.m
+        y1 = dt1.y
+
+        d2 = dt2.d
+        m2 = dt2.m
+        y2 = dt2.y
 
         num = 0
         den = 0
 
         if self._type == DayCountTypes.THIRTY_360_BOND:
             # It is in accordance with section 4.16(f) of ISDA 2006 Definitions
             # Also known as 30/360, Bond Basis, 30A/360, 30-360 US Municipal
@@ -163,15 +160,15 @@
             if last_day_of_feb1 is True:
                 d1 = 30
 
             if d2 == 31:
                 d2 = 30
 
             last_day_of_feb2 = is_last_day_of_feb(dt2)
-            if last_day_of_feb2 is True and isTerminationDate is False:
+            if last_day_of_feb2 is True and is_termination_date is False:
                 d2 = 30
 
             num = 360 * (y2 - y1) + 30 * (m2 - m1) + (d2 - d1)
             den = 360
             acc_factor = num / den
             return acc_factor, num, den
 
@@ -251,15 +248,15 @@
             # non-leap and the leap year which I do not see in any conventions.
 
             frequency = annual_frequency(freq_type)
 
             if dt3 is None:
                 y3 = y2
             else:
-                y3 = dt3._y
+                y3 = dt3.y
 
             num = dt2 - dt1
             den = 365
 
             if is_leap_year(y1):
                 feb29 = Date(29, 2, y1)
             elif is_leap_year(y3):
```

### Comparing `financepy-0.350/financepy/utils/distribution.py` & `financepy-0.360/financepy/utils/distribution.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/utils/error.py` & `financepy-0.360/financepy/utils/error.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,31 +7,31 @@
 ###############################################################################
 
 import traceback
 import sys
 
 # iPython dependency is only loaded if required.
 
-ipython = None
+IPYTHON = None
 
 try:
     from IPython import get_ipython
-    ipython = get_ipython()
+    IPYTHON = get_ipython()
 except Exception:
     pass
 
 
 def _hide_traceback(exc_tuple=None, filename=None, tb_offset=None,
                     exception_only=False, running_compiled_code=False):
     ''' Avoid long error message '''
     etype, value, _ = sys.exc_info()
-    ip = ipython.InteractiveTB
+    ip = IPYTHON.InteractiveTB
 
     if ipython is not None:
-        msg = ipython._showtraceback(etype, value,
+        msg = IPYTHON._showtraceback(etype, value,
                                      ip.get_exception_only(etype, value))
     else:
         msg = None
     return msg
 
 ##############################################################################
```

### Comparing `financepy-0.350/financepy/utils/frequency.py` & `financepy-0.360/financepy/utils/frequency.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/utils/global_types.py` & `financepy-0.360/financepy/utils/global_types.py`

 * *Files 2% similar despite different names*

```diff
@@ -78,19 +78,19 @@
     NELDER_MEAD = 1
     NELDER_MEAD_NUMBA = 2
 
 
 ###############################################################################
 
 class TouchOptionTypes(Enum):
-    DOWN_AND_IN_CASH_AT_HIT = 1         # S0>H pays $1 at hit time from above
-    UP_AND_IN_CASH_AT_HIT = 2           # S0<H pays $1 at hit time from below
-    DOWN_AND_IN_CASH_AT_EXPIRY = 3      # S0>H pays $1 at T if hit from below
-    UP_AND_IN_CASH_AT_EXPIRY = 4        # S0<H pays $1 at T if hit from below
-    DOWN_AND_OUT_CASH_OR_NOTHING = 5    # S0>H pays $1 at T if S>H for all t<T
-    UP_AND_OUT_CASH_OR_NOTHING = 6      # S0<H pays $1 at T if S<H for all t<T
-    DOWN_AND_IN_ASSET_AT_HIT = 7        # S0>H pays H at hit time from above
-    UP_AND_IN_ASSET_AT_HIT = 8          # S0>H pays H at hit time from below
-    DOWN_AND_IN_ASSET_AT_EXPIRY = 9     # S0>H pays S(T) at T if S<H for t < T
-    UP_AND_IN_ASSET_AT_EXPIRY = 10      # S0<H pays S(T) at T if S>H for t < T
-    DOWN_AND_OUT_ASSET_OR_NOTHING = 11  # S0>H pays S(T) at T if S>H for t < T
-    UP_AND_OUT_ASSET_OR_NOTHING = 12     # S0<H pays S(T) at T if S<H for t < T
+    DOWN_AND_IN_CASH_AT_HIT = 1         # s0>H pays $1 at hit time from above
+    UP_AND_IN_CASH_AT_HIT = 2           # s0<H pays $1 at hit time from below
+    DOWN_AND_IN_CASH_AT_EXPIRY = 3      # s0>H pays $1 at T if hit from below
+    UP_AND_IN_CASH_AT_EXPIRY = 4        # s0<H pays $1 at T if hit from below
+    DOWN_AND_OUT_CASH_OR_NOTHING = 5    # s0>H pays $1 at T if S>H for all t<T
+    UP_AND_OUT_CASH_OR_NOTHING = 6      # s0<H pays $1 at T if S<H for all t<T
+    DOWN_AND_IN_ASSET_AT_HIT = 7        # s0>H pays H at hit time from above
+    UP_AND_IN_ASSET_AT_HIT = 8          # s0>H pays H at hit time from below
+    DOWN_AND_IN_ASSET_AT_EXPIRY = 9     # s0>H pays S(T) at T if S<H for t < T
+    UP_AND_IN_ASSET_AT_EXPIRY = 10      # s0<H pays S(T) at T if S>H for t < T
+    DOWN_AND_OUT_ASSET_OR_NOTHING = 11  # s0>H pays S(T) at T if S>H for t < T
+    UP_AND_OUT_ASSET_OR_NOTHING = 12     # s0<H pays S(T) at T if S<H for t < T
```

### Comparing `financepy-0.350/financepy/utils/helpers.py` & `financepy-0.360/financepy/utils/helpers.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
 import sys
+from typing import Union
+
 import numpy as np
 from numba import njit, float64
-from typing import Union
 from prettytable import PrettyTable
 
 from .date import Date
-from .global_vars import gDaysInYear, gSmall
+from .global_vars import gDaysInYear, g_small
 from .error import FinError
 from .day_count import DayCountTypes, DayCount
 
 
 ###############################################################################
 
 
@@ -26,15 +27,15 @@
 ###############################################################################
 
 
 def grid_index(t, grid_times):
     n = len(grid_times)
     for i in range(0, n):
         grid_time = grid_times[i]
-        if abs(grid_time - t) < gSmall:
+        if abs(grid_time - t) < g_small:
             print(t, grid_times, i)
             return i
 
     raise FinError("Grid index not found")
 
 
 ###############################################################################
@@ -62,21 +63,21 @@
                f: float):
     """ Calculate a bond style pv01 by calculating remaining coupon times for a
     bond with t years to maturity and a coupon frequency of f. The order of the
     list is reverse time order - it starts with the last coupon date and ends
     with the first coupon date. """
 
     dt = 1.0 / f
-    pv01_times = []
+    ptimes = []
 
     while t >= 0.0:
-        pv01_times.append(t)
+        ptimes.append(t)
         t -= dt
 
-    return pv01_times
+    return ptimes
 
 
 ###############################################################################
 
 
 def times_from_dates(dt: (Date, list),
                      value_dt: Date,
@@ -91,38 +92,41 @@
 
     if day_count_type is None:
         dc_counter = None
     else:
         dc_counter = DayCount(day_count_type)
 
     if isinstance(dt, Date):
-        num_dates = 1
+        num_dts = 1
         times = [None]
         if dc_counter is None:
             times[0] = (dt - value_dt) / gDaysInYear
         else:
             times[0] = dc_counter.year_frac(value_dt, dt)[0]
 
         return times[0]
 
     elif isinstance(dt, list) and isinstance(dt[0], Date):
-        num_dates = len(dt)
+        num_dts = len(dt)
         times = []
-        for i in range(0, num_dates):
+        for i in range(0, num_dts):
             if dc_counter is None:
                 t = (dt[i] - value_dt) / gDaysInYear
             else:
                 t = dc_counter.year_frac(value_dt, dt[i])[0]
             times.append(t)
 
         return np.array(times)
 
     elif isinstance(dt, np.ndarray):
+
         raise FinError("You passed an ndarray instead of dates.")
+
     else:
+
         raise FinError("Discount factor must take dates.")
 
     return None
 
 ###############################################################################
 
 
@@ -142,15 +146,15 @@
         if abs(diff) > tol:
             print("Vector difference of:", diff, " at index: ", i)
 
 
 ###############################################################################
 
 
-def check_date(d: Date):
+def check_dt(d: Date):
     """ Check that input d is a Date. """
 
     if isinstance(d, Date) is False:
         raise FinError("Should be a date dummy!")
 
 
 ###############################################################################
@@ -217,24 +221,24 @@
     as long as it is all positive. """
 
     small = 1e-8
 
     def check(t):
         if t < 0.0:
             raise FinError("Date " + str(dt) +
-                           " is before curve date " + str(curve._curve_date))
+                           " is before curve date " + str(curve._curve_dt))
         elif t < small:
             t = small
         return t
 
     if isinstance(dt, float):
         t = dt
         return check(t)
     elif isinstance(dt, Date):
-        t = (dt - curve._value_dt) / gDaysInYear
+        t = (dt - curve.value_dt) / gDaysInYear
         return check(t)
     elif isinstance(dt, np.ndarray):
         t = dt
         if np.any(t) < 0:
             raise FinError("Date is before curve value date.")
         t = np.maximum(small, t)
         return t
@@ -260,25 +264,24 @@
     return diff
 
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
-def dotproduct(xVector: np.ndarray,
-               yVector: np.ndarray):
+def dotproduct(x_vector: np.ndarray,
+               y_vector: np.ndarray):
     """ Fast calculation of dot product using Numba. """
 
     dotprod = 0.0
-    n = len(xVector)
+    n = len(x_vector)
     for i in range(0, n):
-        dotprod += xVector[i] * yVector[i]
+        dotprod += x_vector[i] * y_vector[i]
     return dotprod
 
-
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def frange(start: int,
            stop: int,
            step: int):
@@ -295,19 +298,19 @@
 
 
 @njit(fastmath=True, cache=True)
 def normalise_weights(wt_vector: np.ndarray):
     """ Normalise a vector of weights so that they sum up to 1.0. """
 
     n = len(wt_vector)
-    sumWts = 0.0
+    sum_wts = 0.0
     for i in range(0, n):
-        sumWts += wt_vector[i]
+        sum_wts += wt_vector[i]
     for i in range(0, n):
-        wt_vector[i] = wt_vector[i] / sumWts
+        wt_vector[i] = wt_vector[i] / sum_wts
     return wt_vector
 
 
 ###############################################################################
 
 
 def label_to_string(label: str,
@@ -317,26 +320,26 @@
     """ Format label/value pairs for a unified formatting. """
     # Format option for lists such that all values are aligned:
     # Label: value1
     #        value2
     #        ...
     label = str(label)
 
-    if list_format and type(value) is list and len(value) > 0:
+    if list_format and isinstance(value, list) and len(value) > 0:
         s = label + ": "
-        labelSpacing = " " * len(s)
+        label_spacing = " " * len(s)
         s += str(value[0])
 
         for v in value[1:]:
-            s += "\n" + labelSpacing + str(v)
+            s += "\n" + label_spacing + str(v)
         s += separator
 
         return s
-    else:
-        return f"{label}: {value}{separator}"
+
+    return f"{label}: {value}{separator}"
 
 ###############################################################################
 
 
 def table_to_string(header: str,
                     value_table,
                     float_precision="10.7f"):
@@ -345,20 +348,20 @@
         print(len(value_table))
         return ""
 
     num_rows = len(value_table[0])
 
     s = header + "\n"
     for i in range(num_rows):
-        for vList in value_table:
+        for v_list in value_table:
             # isinstance is needed instead of type in case of pandas floats
-            if (isinstance(vList[i], float)):
-                s += format(vList[i], float_precision) + ", "
+            if isinstance(v_list[i], float):
+                s += format(v_list[i], float_precision) + ", "
             else:
-                s += str(vList[i]) + ", "
+                s += str(v_list[i]) + ", "
         s = s[:-2] + "\n"
 
     return s[:-1]
 
 ###############################################################################
 
 
@@ -468,27 +471,27 @@
     cpn_flows = np.zeros(0)
 
     for i_grid in range(1, numgrid_times):
 
         cpn_time = grid_times[i_grid]
         cpn_flow = grid_flows[i_grid]
 
-        if grid_flows[i_grid] > gSmall:
+        if grid_flows[i_grid] > g_small:
             cpn_times = np.append(cpn_times, cpn_time)
             cpn_flows = np.append(cpn_flows, cpn_flow)
 
     num_cpns = len(cpn_times)
 
     # interpolate between coupons
     for i_grid in range(0, numgrid_times):
         t = grid_times[i_grid]
         for i in range(0, num_cpns):
             if t > cpn_times[i - 1] and t <= cpn_times[i]:
                 den = cpn_times[i] - cpn_times[i - 1]
-                num = (t - cpn_times[i - 1])
+                num = t - cpn_times[i - 1]
                 accrued[i_grid] = face * num * cpn_flows[i] / den
                 break
 
     return accrued
 
 
 ###############################################################################
@@ -500,15 +503,15 @@
     will not be checked. """
     for value_name, annotation_type in func.__annotations__.items():
 
         if value_name in values:
             value = values[value_name]
             usable_type = to_usable_type(annotation_type)
 
-        if (not isinstance(value, usable_type)):
+        if not isinstance(value, usable_type):
 
             print("ERROR with function arguments for", func.__name__)
             print("This is in module", func.__module__)
             print("Please check inputs for argument >>", value_name, "<<")
             print("You have input an argument", value, "of type", type(value))
             print("The allowed types are", usable_type)
             print("It is none of these so FAILS. Please amend.")
```

### Comparing `financepy-0.350/financepy/utils/latex.py` & `financepy-0.360/financepy/utils/latex.py`

 * *Files 7% similar despite different names*

```diff
@@ -45,57 +45,57 @@
             if num_cols != num_header_cols:
                 print("Num row cols " + str(num_cols) +
                       " is not the same as the number of header cols "
                       + str(num_header_cols))
                 return ""
 
         col_str = cols[0]
-        for i in range(1, num_cols):
-            col_str += " & " + cols[i]
+        for j in range(1, num_cols):
+            col_str += " & " + cols[j]
 
         table_str += col_str + "\\\ \n"
 
     table_str += "\end{tabular}\n"
     table_str += "\end{center}\n"
     table_str += "\end{table}\n"
 
     return table_str
 
 ###############################################################################
 
 
-if 1 == 0:
+# if 1 == 0:
 
-    txt = "NOV-15-2017      11875.00\n\
-    MAY-15-2018      11875.00\n\
-    NOV-15-2018      11875.00\n\
-    MAY-15-2019      11875.00\n\
-    NOV-15-2019      11875.00\n\
-    MAY-15-2020      11875.00\n\
-    NOV-15-2020      11875.00\n\
-    MAY-15-2021      11875.00\n\
-    NOV-15-2021      11875.00\n\
-    MAY-15-2022      11875.00\n\
-    NOV-15-2022      11875.00\n\
-    MAY-15-2023      11875.00\n\
-    NOV-15-2023      11875.00\n\
-    MAY-15-2024      11875.00\n\
-    NOV-15-2024      11875.00\n\
-    MAY-15-2025      11875.00\n\
-    NOV-15-2025      11875.00\n\
-    MAY-15-2026      11875.00\n\
-    NOV-15-2026      11875.00\n\
-    MAY-15-2027    1011875.00"
-
-    latex_str = convertToLatexTable(txt, " ", ["Dates","Flows"])
-    print(latex_str)
-
-    txt="OBJECT TYPE: Bond\n\
-    ISSUE DATE: MAY-15-2010\n\
-    MATURITY DATE: MAY-15-2027\n\
-    COUPON: 0.02375\n\
-    FREQUENCY: FrequencyTypes.SEMI_ANNUAL\n\
-    DAY COUNT TYPE: DayCountTypes.ACT_ACT_ICMA\n\
-    FACE AMOUNT: 1000000"
+#     TXT = "NOV-15-2017      11875.00\n\
+#     MAY-15-2018      11875.00\n\
+#     NOV-15-2018      11875.00\n\
+#     MAY-15-2019      11875.00\n\
+#     NOV-15-2019      11875.00\n\
+#     MAY-15-2020      11875.00\n\
+#     NOV-15-2020      11875.00\n\
+#     MAY-15-2021      11875.00\n\
+#     NOV-15-2021      11875.00\n\
+#     MAY-15-2022      11875.00\n\
+#     NOV-15-2022      11875.00\n\
+#     MAY-15-2023      11875.00\n\
+#     NOV-15-2023      11875.00\n\
+#     MAY-15-2024      11875.00\n\
+#     NOV-15-2024      11875.00\n\
+#     MAY-15-2025      11875.00\n\
+#     NOV-15-2025      11875.00\n\
+#     MAY-15-2026      11875.00\n\
+#     NOV-15-2026      11875.00\n\
+#     MAY-15-2027    1011875.00"
+
+#     latex_str = convertToLatexTable(TXT, " ", ["Dates","Flows"])
+#     print(latex_str)
+
+#     txt="OBJECT TYPE: Bond\n\
+#     ISSUE DATE: MAY-15-2010\n\
+#     MATURITY DATE: MAY-15-2027\n\
+#     COUPON: 0.02375\n\
+#     FREQUENCY: FrequencyTypes.SEMI_ANNUAL\n\
+#     DAY COUNT TYPE: DayCountTypes.ACT_ACT_ICMA\n\
+#     FACE AMOUNT: 1000000"
 
-    latex_str = convertToLatexTable(txt, ":", ["FIELD", "VALUE"])
-    print(latex_str)
+#     latex_str = convertToLatexTable(TXT, ":", ["FIELD", "VALUE"])
+#     print(latex_str)
```

### Comparing `financepy-0.350/financepy/utils/math.py` & `financepy-0.360/financepy/utils/math.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,32 +5,31 @@
 
 # from math import exp, sqrt, fabs, log
 from numba import njit, boolean, int64, float64, vectorize
 import numpy as np
 from .error import FinError
 
 PI = 3.14159265358979323846
-INVROOT2PI = 0.3989422804014327
+INV_ROOT_2_PI = 0.3989422804014327
 
 ONE_MILLION = 1000000
 TEN_MILLION = 10000000
 ONE_BILLION = 1000000000
 
 ###############################################################################
 # TODO: Move this somewhere else.
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def accrued_interpolator(t_set: float,  # Settlement time in years
                          cpn_times: np.ndarray,
                          cpn_amounts: np.ndarray):
-    """ Fast calculation of accrued interest using an Actual/Actual type of
-    convention. This does not calculate according to other conventions. """
-
+    """Fast calculation of accrued interest using an Actual/Actual type of
+    convention. This does not calculate according to other conventions."""
     num_cpns = len(cpn_times)
 
     for i in range(1, num_cpns):
 
         pct = cpn_times[i - 1]
         nct = cpn_times[i]
         denom = (nct-pct)
@@ -38,19 +37,14 @@
         if t_set >= pct and t_set < nct:
             accd_frac = (t_set-pct) / denom
             accd_cpn = accd_frac * cpn_amounts[i]
             return accd_cpn
 
     # TODO: NEED TO REVISIT THIS TODO
     return 0.0
-    print("t", t_set)
-    print("CPN TIMES", cpn_times)
-    print("CPN AMNTS", cpn_amounts)
-
-    raise FinError("Failed to calculate accrued")
 
 ###############################################################################
 
 
 @njit(boolean(int64), fastmath=True, cache=True)
 def is_leap_year(y: int):
     """ Test whether year y is a leap year - if so return True, else False """
@@ -121,48 +115,46 @@
 @njit(float64[:](float64[:, :]), fastmath=True, cache=True)
 def maxaxis(s: np.ndarray):
     """ Perform a search for the vector of maximum values over an axis of a
     2D Numpy Array """
 
     shp = s.shape
 
-    maxVector = np.empty(shp[0])
+    max_vector = np.empty(shp[0])
 
     for i in range(0, shp[0]):
         xmax = s[i, 0]
         for j in range(1, shp[1]):
             x = s[i, j]
-            if x > xmax:
-                xmax = x
+            xmax = max(xmax, x)
+            
+        max_vector[i] = xmax
 
-        maxVector[i] = xmax
-
-    return maxVector
+    return max_vector
 
 ###############################################################################
 
 
 @njit(float64[:](float64[:, :]), fastmath=True, cache=True)
 def minaxis(s: np.ndarray):
     """ Perform a search for the vector of minimum values over an axis of a
     2D Numpy Array """
     shp = s.shape
 
-    minVector = np.empty(shp[0])
+    min_vector = np.empty(shp[0])
 
     for i in range(0, shp[0]):
         xmin = s[i, 0]
         for j in range(1, shp[1]):
             x = s[i, j]
-            if x < xmin:
-                xmin = x
-
-        minVector[i] = xmin
+            xmin = min(xmin, x)
+            
+        min_vector[i] = xmin
 
-    return minVector
+    return min_vector
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def covar(a: np.ndarray,
           b: np.ndarray):
@@ -216,27 +208,26 @@
 
     while v2 != 0:
         temp = v2
         factor = v1 / v2
         v2 = v1 - factor * v2
         v1 = temp
 
-    pairGCD = abs(v1)
-    return pairGCD
+    gcd = abs(v1)
+    return gcd
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def nprime(x: float):
     """Calculate the first derivative of the Cumulative Normal CDF which is
     simply the PDF of the Normal Distribution """
 
-    InvRoot2Pi = 0.3989422804014327
-    return np.exp(-x * x / 2.0) * InvRoot2Pi
+    return np.exp(-x * x / 2.0) * INV_ROOT_2_PI
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def heaviside(x: float):
     """ Calculate the Heaviside function for x """
@@ -263,15 +254,15 @@
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
 def normpdf(x: float):
     """ Calculate the probability density function for a Gaussian (Normal)
     function at value x"""
-    return np.exp(-x * x / 2.0) * INVROOT2PI
+    return np.exp(-x * x / 2.0) * INV_ROOT_2_PI
 
 ###############################################################################
 
 
 @njit(float64(float64), fastmath=True, cache=True)
 def N(x):
     """ Fast Normal CDF function based on Hull OFAODS  4th Edition Page 252.
@@ -288,15 +279,15 @@
     k2 = k * k
     k3 = k2 * k
     k4 = k3 * k
     k5 = k4 * k
 
     if x >= 0.0:
         c = (a1 * k + a2 * k2 + a3 * k3 + a4 * k4 + a5 * k5)
-        phi = 1.0 - c * np.exp(-x*x/2.0) * INVROOT2PI
+        phi = 1.0 - c * np.exp(-x*x/2.0) * INV_ROOT_2_PI
     else:
         phi = 1.0 - N(-x)
 
     return phi
 
 ###############################################################################
 
@@ -334,30 +325,30 @@
         x = x + dx
         fx = np.exp(-x * x / 2.0)
         integral += fx
 
     x = x + dx
     fx = np.exp(-x * x / 2.0)
     integral += fx / 2.0
-    integral *= INVROOT2PI * dx
+    integral *= INV_ROOT_2_PI * dx
     return integral
 
 ###############################################################################
 
 
 @njit(float64(float64), fastmath=True, cache=True)
 def normcdf_slow(z: float):
     """  Calculation of Normal Distribution CDF accurate to 1d-15. This
     method is faster than integration but slower than other approximations.
     Reference: J.L. Schonfelder, Math Comp 32(1978), pp 1232-1240. """
 
     a = [0.0] * 25
     bp = 0.0
 
-    RTWO = 1.4142135623731
+    root_2 = 1.4142135623731
 
     a[0] = 0.6101430819232
     a[1] = -0.434841272712578
     a[2] = 0.176351193643605
     a[3] = -6.07107956092494E-02
     a[4] = 1.77120689956941E-02
     a[5] = -4.32111938556729E-03
@@ -377,15 +368,15 @@
     a[19] = 1.72815333899861E-14
     a[20] = -4.26410169494238E-15
     a[21] = -5.45371977880191E-16
     a[22] = 1.58697607761671E-16
     a[23] = 2.0899837844334E-17
     a[24] = -5.900526869409E-18
 
-    xa = abs(z) / RTWO
+    xa = abs(z) / root_2
 
     if xa > 100:
         p = 0
     else:
         t = (8 * xa - 30) / (4 * xa + 15)
         bm = 0.0
         b = 0.0
@@ -445,19 +436,19 @@
          r23: float):
     """ Bivariate Normal CDF function to upper limits $b1$ and $b2$ which uses
     integration to perform the innermost integral. This may need further
     refinement to ensure it is optimal as the current range of integration is
     from -7 and the integration steps are dx = 0.001. This may be excessive."""
 
     dx = 0.001
-    lowerLimit = -7
-    upperlimit = b1
-    num_points = int((b1 - lowerLimit) / dx)
-    dx = (upperlimit - lowerLimit) / num_points
-    x = lowerLimit
+    lower_limit = -7
+    upper_limit = b1
+    num_points = int((b1 - lower_limit) / dx)
+    dx = (upper_limit - lower_limit) / num_points
+    x = lower_limit
 
     r12p = np.sqrt(1.0 - r12 * r12)
     r13p = np.sqrt(1.0 - r13 * r13)
     r123 = (r23 - r12 * r13) / r12p / r13p
 
     v = 0.0
 
@@ -523,26 +514,26 @@
         p = 1.0 - 1e-10
 
     if p < p_low:
         # Rational approximation for lower region
         q = np.sqrt(-2.0 * np.log(p))
         inverse_cdf = (((((c1 * q + c2) * q + c3) * q + c4) * q + c5)
                        * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q
-                           + 1.0)
+                                    + 1.0)
     elif p <= p_high:
         # Rational approximation for lower region
         q = p - 0.5
         r = q * q
         inverse_cdf = (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * \
             q / (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1.0)
     elif p < 1.0:
         # Rational approximation for upper region
         q = np.sqrt(-2.0 * np.log(1 - p))
         inverse_cdf = -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5)
-                       * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1.0)
+                        * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1.0)
 
     return inverse_cdf
 
 ###############################################################################
 # This is used for consistency with Haug and its conciseness. Consider renaming
 # phi2 to M
 
@@ -665,47 +656,47 @@
         _npv += c / ((1 + irr) ** t)
     return _npv
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
-def band_matrix_multiplication(A, m1, m2, b):
-    n = A.shape[0]
+def band_matrix_multiplication(a, m1, m2, b):
+    n = a.shape[0]
     x = np.zeros(n)
 
     jl = np.arange(n) - m1
     jl[jl < 0] = 0
 
     ju = np.arange(n) + m2
     ju[ju > n - 1] = n - 1
 
     for i in range(n):
         for j in range(jl[i], ju[i] + 1):
             k = j - i + m1
-            x[i] += A[i, k] * b[j]
+            x[i] += a[i, k] * b[j]
 
     return x
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
-def solve_tridiagonal_matrix(A, r):
+def solve_tridiagonal_matrix(a_matrix, r):
     """
     Solve A u = r for vector u when A is tridiagonal
 
     The matrix A is split into vectors a, b, and c contain the three
     non-zero elements of each row of A, in order.
     i.e. the vector b is the main diagonal of A, with a and c the elements
     either side of the main diagonal.
 
     Note that a[0] and c[-1] are not used, and so can be any value.
     """
-    a, b, c = A.T
+    a, b, c = a_matrix.T
 
     if b[0] == 0:
         raise ValueError("First entry is zero, rewrite as set of N-1 eqns")
 
     n = len(a)  # Length of output vector
     u = np.zeros(n)  # Output vector
     gam = np.zeros(n)  # Workspace
@@ -728,11 +719,11 @@
 
     return u
 
 ###############################################################################
 
 
 @njit(fastmath=True, cache=True)
-def transpose_tridiagonal_matrix(A):
-    out = np.zeros_like(A)
-    out[:, 0], out[:, 1], out[:, 2] = A[:, 2], A[:, 1], A[:, 0]
+def transpose_tridiagonal_matrix(a_matrix):
+    out = np.zeros_like(a_matrix)
+    out[:, 0], out[:, 1], out[:, 2] = a_matrix[:, 2], a_matrix[:, 1], a_matrix[:, 0]
     return out
```

### Comparing `financepy-0.350/financepy/utils/polyfit.py` & `financepy-0.360/financepy/utils/polyfit.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,31 +14,31 @@
 # our coefficients e.g. x**2, x, constants
 
 ###############################################################################
 
 
 @numba.njit("f8[:,:](f8[:], i8)")
 def _coeff_mat(x, deg):
-    mat_ = np.zeros(shape=(x.shape[0], deg + 1))
+    mat = np.zeros(shape=(x.shape[0], deg + 1))
     c = np.ones_like(x)
-    mat_[:, 0] = c
-    mat_[:, 1] = x
+    mat[:, 0] = c
+    mat[:, 1] = x
     if deg > 1:
         for n in range(2, deg + 1):
-            mat_[:, n] = x**n
-    return mat_
+            mat[:, n] = x**n
+    return mat
 
 ###############################################################################
 
 
 @numba.njit("f8[:](f8[:,:], f8[:])")
 def _fit_x(a, b):
     # linalg solves ax = b
-    det_ = np.linalg.lstsq(a, b)[0]
-    return det_
+    det = np.linalg.lstsq(a, b)[0]
+    return det
 
 ###############################################################################
 
 
 @numba.njit("f8[:](f8[:], f8[:], i8)")
 def fit_poly(x, y, deg):
     a = _coeff_mat(x, deg)
@@ -61,20 +61,20 @@
     for coeff in P:
         result = x * result + coeff
     return result
 
 ###############################################################################
 
 
-if __name__ == "__main__":
+# if __name__ == "__main__":
 
-    # Create Dummy Data and use existing numpy polyfit as test
-    x = np.linspace(0, 2, 20)
-    y = np.cos(x) + 0.3*np.random.rand(20)
-    p = np.poly1d(np.polyfit(x, y, 3))
-
-    t = np.linspace(0, 2, 200)
-    plt.plot(x, y, 'o', t, p(t), '-')
-
-    # Now plot using the Numba (amazing) functions
-    p_coeffs = fit_poly(x, y, deg=3)
-    plt.plot(x, y, 'o', t, eval_polynomial(p_coeffs, t), '-')
+#     # Create Dummy Data and use existing numpy polyfit as test
+#     x = np.linspace(0, 2, 20)
+#     y = np.cos(x) + 0.3*np.random.rand(20)
+#     p = np.poly1d(np.polyfit(x, y, 3))
+
+#     t = np.linspace(0, 2, 200)
+#     plt.plot(x, y, 'o', t, p(t), '-')
+
+#     # Now plot using the Numba (amazing) functions
+#     p_coeffs = fit_poly(x, y, deg=3)
+#     plt.plot(x, y, 'o', t, eval_polynomial(p_coeffs, t), '-')
```

### Comparing `financepy-0.350/financepy/utils/solver_1d.py` & `financepy-0.360/financepy/utils/solver_1d.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,16 +24,16 @@
 
 ###############################################################################
 
 
 @njit(cache=True, fastmath=True)
 def _results(r):
     r"""Select from a tuple of(root, funccalls, iterations, flag)"""
-    x, funcalls, iterations, flag = r
-    return x  # results(x, funcalls, iterations, flag == 0)
+    x, fun_calls, iterations, flag = r
+    return x  # results(x, fun_calls, iterations, flag == 0)
 
 ###############################################################################
 # DO NOT TOUCH THIS FUNCTION AS IT IS USED IN FX VOL CALIBRATION !!!!!!!!!
 # IT NEEDS TO PASS IN ARGS AS A TUPLE AS ONE OF THE ARGS IS AN NDARRAY
 ###############################################################################
 # UNABLE TO NJIT THIS DUE TO ERROR
 # FIXED ERROR BY MAKING CACHE=FALSE!!!????
@@ -82,28 +82,28 @@
 
     if maxiter < 1:
         raise FinError("maxiter must be greater than 0")
 
     # Convert to float (don't use float(x0); this works also for complex x0)
     eps = 1e-4
     p0 = 1.0 * x0
-    funcalls = 0
+    fun_calls = 0
     status = _ECONVERR
 
     p1 = x0 * (1.0 + eps)
 
     if p1 > 0.0:
         p1 = p1 + eps
     else:
         p1 = p1 - eps
 
     q0 = func(p0, *args)
-    funcalls += 1
+    fun_calls += 1
     q1 = func(p1, *args)
-    funcalls += 1
+    fun_calls += 1
 
     if np.abs(q1) < np.abs(q0):
         p0, p1, q0, q1 = p1, p0, q1, q0
 
     for _ in range(maxiter):
 
         if q1 == q0:
@@ -122,15 +122,15 @@
         if np.abs(p - p1) < tol:
             status = _ECONVERGED
             return p
 
         p0, q0 = p1, q1
         p1 = p
         q1 = func(p1, *args)
-        funcalls += 1
+        fun_calls += 1
 
     if disp and status == _ECONVERR:
         msg = "Failed to converge"
         raise FinError(msg)
 
     return p
 
@@ -294,39 +294,39 @@
 
     maxiter = operator.index(maxiter)
     if maxiter < 1:
         raise FinError("maxiter must be greater than 0")
 
     # Convert to float (don't use float(x0); this works also for complex x0)
     p0 = 1.0 * x0
-    funcalls = 0
+    fun_calls = 0
     if fprime is not None:
         # Newton-Raphson method
         for itr in range(maxiter):
             # first evaluate fval
             fval = func(p0, args)
-            funcalls += 1
+            fun_calls += 1
             # If fval is 0, a root has been found, then terminate
             if fval == 0:
                 return p0
             fder = fprime(p0, args)
-            funcalls += 1
+            fun_calls += 1
 
 #            print("==>", itr, p0, fval, fder)
 
             if fder == 0:
                 if disp is True:
                     print("Derivative is zero. Newton Failed to converge " +
                           "after ", str(itr+1), "iterations, value is ", p0)
                 return None
 
             newton_step = fval / fder
             if fprime2:
                 fder2 = fprime2(p0, args)
-                funcalls += 1
+                fun_calls += 1
                 # Halley's method:
                 #   newton_step /= (1.0 - 0.5 * newton_step * fder2 / fder)
                 # Only do it if denominator stays close enough to 1
                 # Rationale: If 1-adj < 0, then Halley sends x in the
                 # opposite direction to Newton. Doesn't happen if x is close
                 # enough to root.
                 adj = newton_step * fder2 / fder / 2
@@ -343,17 +343,17 @@
                 raise ValueError("x1 and x0 must be different")
             p1 = x1
         else:
             eps = 1e-4
             p1 = x0 * (1 + eps)
             p1 += (eps if p1 >= 0 else -eps)
         q0 = func(p0, args)
-        funcalls += 1
+        fun_calls += 1
         q1 = func(p1, args)
-        funcalls += 1
+        fun_calls += 1
         if abs(q1) < abs(q0):
             p0, p1, q0, q1 = p1, p0, q1, q0
         for itr in range(maxiter):
             if q1 == q0:
                 if p1 != p0:
                     if disp:
                         print("Tolerance reached. Failed to converge after ",
@@ -367,15 +367,15 @@
                 else:
                     p = (-q1 / q0 * p0 + p1) / (1 - q1 / q0)
             if np.isclose(p, p1, rtol=rtol, atol=tol):
                 return p
             p0, q0 = p1, q1
             p1 = p
             q1 = func(p1, *args)
-            funcalls += 1
+            fun_calls += 1
 
     if disp:
         print("Failed to converge after ", str(itr+1),
               "iterations, value is ", str(p))
 
     return p
 
@@ -530,15 +530,15 @@
     return xf, fval, info
 
 ###############################################################################
 
 # @jit(fastmath=True, cache=True)
 
 
-def bisection(func, x1, x2, args, xtol=1e-6, maxIter=100):
+def bisection(func, x1, x2, args, xtol=1e-6, maxiter=100):
     """ Bisection algorithm. You need to supply root brackets x1 and x2. """
 
     if np.abs(x1-x2) < 1e-10:
         raise FinError("Brackets should not be equal")
 
     if x1 > x2:
         raise FinError("Bracket x2 should be greater than x1")
@@ -551,28 +551,28 @@
     elif np.abs(fmid) < xtol:
         return x2
 
     if f1 * fmid >= 0:
         print("Root not bracketed")
         return None
 
-    for i in range(0, maxIter):
+    for i in range(0, maxiter):
 
         xmid = (x1 + x2)/2.0
         fmid = func(xmid, args)
 
         if f1 * fmid < 0:
             x2 = xmid
         else:
             x1 = xmid
 
         if np.abs(fmid) < xtol:
             return xmid
 
-    print("Bisection exceeded number of iterations", maxIter)
+    print("Bisection exceeded number of iterations", maxiter)
     return None
 
 ###############################################################################
 # https://github.com/linesd/minimize/blob/master/optimizer/minimize.py
 
 # The function uses conjugate gradients and approximate linesearches based
 # on polynomial interpolation with Wolfe-Powel conditions
```

### Comparing `financepy-0.350/financepy/utils/solver_cg.py` & `financepy-0.360/financepy/utils/solver_cg.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/financepy/utils/solver_nm.py` & `financepy-0.360/financepy/utils/solver_nm.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,17 +8,17 @@
 
 ###############################################################################
 # from https://quanteconpy.readthedocs.io/en/latest/_modules/quantecon/optimize/root_finding.html #####################
 
 _ECONVERGED = 0
 _ECONVERR = -1
 
-_iter = 100
-_xtol = 2e-12
-_rtol = 4*np.finfo(float).eps
+_ITER = 100
+_XTOL = 2e-12
+_RTOL = 4*np.finfo(float).eps
 
 
 results = namedtuple('results', 'root function_calls iterations converged')
 
 ###############################################################################
 
 # This is from https://quanteconpy.readthedocs.io/en/latest/_modules/quantecon/optimize/nelder_mead.html#nelder_mead
```

### Comparing `financepy-0.350/financepy/utils/stats.py` & `financepy-0.360/financepy/utils/stats.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
-
 from math import sqrt
 from numpy import ndarray
 from numba import njit, float64, int32
 
 ##########################################################################
```

### Comparing `financepy-0.350/financepy.egg-info/PKG-INFO` & `financepy-0.360/financepy.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,31 @@
 Metadata-Version: 2.1
 Name: financepy
-Version: 0.350
+Version: 0.360
 Summary: A Finance Securities Valuation Library
 Home-page: https://github.com/domokane/FinancePy
 Author: Dominic O'Kane
 Author-email: dominic.okane@edhec.edu
 Keywords: FINANCE,OPTIONS,BONDS,VALUATION,DERIVATIVES
 Classifier: Development Status :: 2 - Pre-Alpha
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
-# Latest News and Versions
+## I'D LIKE YOUR OPINION  
+### I AM CONSIDERING SPENDING TIME THIS YEAR IMPROVING THE LIBRARY. LET ME HAVE ANY COMMENTS, REQUESTS OR ISSUES YOU MAY HAVE. JUST ENTER THEM IN THE DISCUSSION SECTION HERE OR EMAIL ME.
+
+# Latest News and Version
+19 February 2024 version 0.350 released
+- A lot of various pep8 fixes - should all be nearly done soon
+- Fixed a bug in gauss_approx_tranche_loss
+
 9 December 2023  version 0.34 released
 - A lot of various pep8 fixes - should all be nearly done soon
 - Some minor bug fixes
 
 10 November 2023  version 0.33 released
 - Tidied up key rate code
 - Fixed unit tests for pytest
```

### Comparing `financepy-0.350/financepy.egg-info/SOURCES.txt` & `financepy-0.360/financepy.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -34,15 +34,15 @@
 financepy/models/black.py
 financepy/models/black_scholes.py
 financepy/models/black_scholes_analytic.py
 financepy/models/black_scholes_mc.py
 financepy/models/black_scholes_mc_tests.py
 financepy/models/black_shifted.py
 financepy/models/bond_analytics.py
-financepy/models/cir_mc.py
+financepy/models/cir_montecarlo.py
 financepy/models/equity_barrier_models.py
 financepy/models/equity_crr_tree.py
 financepy/models/equity_lsmc.py
 financepy/models/finite_difference.py
 financepy/models/finite_difference_PSOR.py
 financepy/models/gauss_copula.py
 financepy/models/gauss_copula_lhp.py
```

### Comparing `financepy-0.350/setup.py` & `financepy-0.360/setup.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinAmount.py` & `financepy-0.360/tests/test_FinAmount.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinBond.py` & `financepy-0.360/tests/test_FinBond.py`

 * *Files 0% similar despite different names*

```diff
@@ -112,15 +112,15 @@
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     assert round(clean_price, 4) == 99.7825
 
     accrued_interest = bond.accrued_interest(settle_dt, face)
     assert round(accrued_interest, 4) == 0.4324
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     assert round(accddays, 4) == 67.0
 
     duration = bond.dollar_duration(settle_dt, ytm)
     assert round(duration, 4) == 869.0934
 
     modified_duration = bond.modified_duration(settle_dt, ytm)
     assert round(modified_duration, 4) == 8.6723
@@ -164,15 +164,15 @@
 
     dirty_price = bond.dirty_price_from_ytm(settle_dt, ytm)
     assert round(dirty_price, 4) == 102.0932
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     assert round(clean_price, 4) == 101.5832
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     assert accddays == 68
 
     accrued_interest = bond.accrued_interest(settle_dt, face)
     assert round(accrued_interest, 4) == 0.51
 
     duration = bond.dollar_duration(settle_dt, ytm)
     assert round(duration, 4) == 456.5778
@@ -276,15 +276,15 @@
     face = 100.0
     test_case_file = './data/test_cases_bond_cfets.csv'
     path = os.path.join(os.path.dirname(__file__), test_case_file)
 
     df = pd.read_csv(path,
                      parse_dates=['settlement_date', 'issue_date',
                                   'maturity_date'])
-
+    
     for row in df.itertuples(index=False):
 
         issue_dt = Date(row.issue_date.day,
                         row.issue_date.month,
                         row.issue_date.year)
 
         maturity_dt = Date(row.maturity_date.day,
@@ -321,24 +321,24 @@
             continue
 
 ###############################################################################
 
 
 def test_key_rate_durations_bloomberg_example():
 
-    dc_type, freq_type, settlementDays, exDiv, calendar = \
+    dc_type, freq_type, settle_days, exDiv, calendar = \
         get_bond_market_conventions(BondMarkets.UNITED_STATES)
 
     # interest accrues on this date. Issue date is 01/08/2022
     issue_dt = Date(31, 7, 2022)
     maturity_dt = Date(31, 7, 2027)
     coupon = 2.75/100.0
     ex_div_days = 0
 
-    dc_type, freq_type, settlementDays, exDiv, calendar =\
+    dc_type, freq_type, settle_days, exDiv, calendar =\
         get_bond_market_conventions(BondMarkets.UNITED_STATES)
 
     bond = Bond(issue_dt, maturity_dt, coupon,
                 freq_type, dc_type, ex_div_days)
 
     settle_dt = Date(24, 4, 2023)
```

### Comparing `financepy-0.350/tests/test_FinBondAnnuity.py` & `financepy-0.360/tests/test_FinBondAnnuity.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,11 +1,14 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 from financepy.utils.calendar import DateGenRuleTypes
 from financepy.utils.calendar import BusDayAdjustTypes
 from financepy.utils.day_count import DayCountTypes
 from financepy.utils.calendar import CalendarTypes
 from financepy.utils.frequency import FrequencyTypes
 from financepy.utils.date import Date
 from financepy.products.bonds.bond_annuity import BondAnnuity
@@ -31,22 +34,22 @@
                           cal_type,
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
-    assert len(annuity._flow_amounts) == 2 * 1 + 1
-    assert len(annuity._cpn_dts) == 2 * 1 + 1
+    assert len(annuity.flow_amounts) == 2 * 1 + 1
+    assert len(annuity.cpn_dts) == 2 * 1 + 1
 
-    assert annuity._cpn_dts[0] == settle_dt
-    assert annuity._cpn_dts[-1] == maturity_dt
+    assert annuity.cpn_dts[0] == settle_dt
+    assert annuity.cpn_dts[-1] == maturity_dt
 
-    assert annuity._flow_amounts[0] == 0.0
-    assert round(annuity._flow_amounts[-1]) == 25278.0
+    assert annuity.flow_amounts[0] == 0.0
+    assert round(annuity.flow_amounts[-1]) == 25278.0
 
     assert annuity.accrued_interest(settle_dt, face) == 0.0
 
 
 def test_Quarterly_BondAnnuity():
 
     settle_dt = Date(20, 6, 2018)
@@ -68,22 +71,22 @@
         cal_type,
         bd_type,
         dg_type,
         basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
-    assert len(annuity._flow_amounts) == 10 * 4 + 1
-    assert len(annuity._cpn_dts) == 10 * 4 + 1
+    assert len(annuity.flow_amounts) == 10 * 4 + 1
+    assert len(annuity.cpn_dts) == 10 * 4 + 1
 
-    assert annuity._cpn_dts[0] == settle_dt
-    assert annuity._cpn_dts[-1] == maturity_dt
+    assert annuity.cpn_dts[0] == settle_dt
+    assert annuity.cpn_dts[-1] == maturity_dt
 
-    assert annuity._flow_amounts[0] == 0.0
-    assert round(annuity._flow_amounts[-1]) == 12778.0
+    assert annuity.flow_amounts[0] == 0.0
+    assert round(annuity.flow_amounts[-1]) == 12778.0
 
     assert annuity.accrued_interest(settle_dt, face) == 0.0
 
 
 def test_Monthly_BondAnnuity():
 
     settle_dt = Date(20, 6, 2018)
@@ -104,22 +107,22 @@
                           cal_type,
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
-    assert len(annuity._flow_amounts) == 10*12 + 1
-    assert len(annuity._cpn_dts) == 10*12 + 1
+    assert len(annuity.flow_amounts) == 10*12 + 1
+    assert len(annuity.cpn_dts) == 10*12 + 1
 
-    assert annuity._cpn_dts[0] == settle_dt
-    assert annuity._cpn_dts[-1] == maturity_dt
+    assert annuity.cpn_dts[0] == settle_dt
+    assert annuity.cpn_dts[-1] == maturity_dt
 
-    assert annuity._flow_amounts[0] == 0.0
-    assert round(annuity._flow_amounts[-1]) == 4028.0
+    assert annuity.flow_amounts[0] == 0.0
+    assert round(annuity.flow_amounts[-1]) == 4028.0
 
     assert annuity.accrued_interest(settle_dt, face) == 0.0
 
 
 def test_ForwardGen_BondAnnuity():
 
     settle_dt = Date(20, 6, 2018)
@@ -139,22 +142,22 @@
                           cal_type,
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
-    assert len(annuity._flow_amounts) == 10 * 1 + 1
-    assert len(annuity._cpn_dts) == 10 * 1 + 1
+    assert len(annuity.flow_amounts) == 10 * 1 + 1
+    assert len(annuity.cpn_dts) == 10 * 1 + 1
 
-    assert annuity._cpn_dts[0] == settle_dt
-    assert annuity._cpn_dts[-1] == maturity_dt
+    assert annuity.cpn_dts[0] == settle_dt
+    assert annuity.cpn_dts[-1] == maturity_dt
 
-    assert round(annuity._flow_amounts[0]) == 0.0
-    assert round(annuity._flow_amounts[-1]) == 50694.0
+    assert round(annuity.flow_amounts[0]) == 0.0
+    assert round(annuity.flow_amounts[-1]) == 50694.0
 
     assert annuity.accrued_interest(settle_dt, face) == 0.0
 
 
 def test_ForwardGenWithLongEndStub_BondAnnuity():
 
     settle_dt = Date(20, 6, 2018)
@@ -174,17 +177,19 @@
                           cal_type,
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
-    assert len(annuity._flow_amounts) == 10 * 2 + 1
-    assert len(annuity._cpn_dts) == 10 * 2 + 1
+    assert len(annuity.flow_amounts) == 10 * 2 + 1
+    assert len(annuity.cpn_dts) == 10 * 2 + 1
 
-    assert annuity._cpn_dts[0] == settle_dt
-    assert annuity._cpn_dts[-1] == maturity_dt
+    assert annuity.cpn_dts[0] == settle_dt
+    assert annuity.cpn_dts[-1] == maturity_dt
 
-    assert round(annuity._flow_amounts[0]) == 0.0
-    assert round(annuity._flow_amounts[-1]) == 25417.0
+    assert round(annuity.flow_amounts[0]) == 0.0
+    assert round(annuity.flow_amounts[-1]) == 25417.0
 
     assert annuity.accrued_interest(settle_dt, face) == 0.0
+
+test_SemiAnnual_BondAnnuity()
```

### Comparing `financepy-0.350/tests/test_FinBondConvertible.py` & `financepy-0.360/tests/test_FinBondConvertible.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,36 +15,36 @@
 
 maturity_dt = Date(15, 3, 2022)
 coupon = 0.0575
 freq_type = FrequencyTypes.SEMI_ANNUAL
 start_convert_date = Date(31, 12, 2003)
 conversion_ratio = 3.84615  # adjust for face
 
-call_dates = [Date(20, 3, 2007),
+call_dts = [Date(20, 3, 2007),
               Date(15, 3, 2012),
               Date(15, 3, 2017)]
 call_price = 1100
 call_prices = np.array([call_price, call_price, call_price])
 
-put_dates = [Date(20, 3, 2007),
+put_dts = [Date(20, 3, 2007),
              Date(15, 3, 2012),
              Date(15, 3, 2017)]
 
 putPrice = 90.0
 put_prices = np.array([putPrice, putPrice, putPrice])
 accrualBasis = DayCountTypes.ACT_365F
 
 bond = BondConvertible(maturity_dt,
                        coupon,
                        freq_type,
                        start_convert_date,
                        conversion_ratio,
-                       call_dates,
+                       call_dts,
                        call_prices,
-                       put_dates,
+                       put_dts,
                        put_prices,
                        accrualBasis)
 
 settle_dt = Date(31, 12, 2003)
 stock_price = 28.5
 stock_volatility = 0.370
 dividend_dts = [Date(20, 3, 2007),
```

### Comparing `financepy-0.350/tests/test_FinBondEmbeddedOption.py` & `financepy-0.360/tests/test_FinBondEmbeddedOption.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,28 +40,28 @@
 swap3 = IborSwap(settle_dt_matlab, "3Y",
                  fixed_leg_type, 0.0450, fixedFreq, dcType)
 swaps = [swap1, swap2, swap3]
 discount_curve_matlab = IborSingleCurve(value_dt, [], [], swaps)
 
 bond_matlab = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
 
-call_dates = []
+call_dts = []
 call_prices = []
-put_dates = []
+put_dts = []
 put_prices = []
 
-put_date = Date(1, 1, 2008)
+put_dt = Date(1, 1, 2008)
 for _ in range(0, 24):
-    put_dates.append(put_date)
+    put_dts.append(put_dt)
     put_prices.append(100)
-    put_date = put_date.add_months(1)
+    put_dt = put_dt.add_months(1)
 puttable_bond_matlab = BondEmbeddedOption(issue_dt, maturity_dt, coupon,
                                          freq_type, dc_type,
-                                         call_dates, call_prices,
-                                         put_dates, put_prices)
+                                         call_dts, call_prices,
+                                         put_dts, put_prices)
 
 
 def test_matlab_clean_price_from_discount_curve():
     v = bond_matlab.clean_price_from_discount_curve(
         settle_dt_matlab, discount_curve_matlab)
 
     assert round(v, 4) == 102.0746
@@ -106,27 +106,27 @@
 discount_curve_quantlib = DiscountCurveFlat(value_dt, 0.035,
                                             FrequencyTypes.SEMI_ANNUAL)
 
 bond_quantlib = Bond(issue_dt, maturity_dt,
                      coupon, freq_type, dc_type)
 
 nextCallDate = Date(15, 9, 2016)
-call_dates = [nextCallDate]
+call_dts = [nextCallDate]
 call_prices = [100.0]
-put_dates = []
+put_dts = []
 put_prices = []
 for _ in range(1, 24):
     nextCallDate = nextCallDate.add_months(3)
-    call_dates.append(nextCallDate)
+    call_dts.append(nextCallDate)
     call_prices.append(100.0)
 
 puttable_bond_quantlib = BondEmbeddedOption(issue_dt, maturity_dt, coupon,
                                            freq_type, dc_type,
-                                           call_dates, call_prices,
-                                           put_dates, put_prices)
+                                           call_dts, call_prices,
+                                           put_dts, put_prices)
 
 
 def test_quantlib_clean_price_from_discount_curve():
     v = bond_quantlib.clean_price_from_discount_curve(
         settle_dt_quantlib, discount_curve_quantlib)
 
     assert round(v, 4) == 94.6318
```

### Comparing `financepy-0.350/tests/test_FinBondFRN.py` & `financepy-0.360/tests/test_FinBondFRN.py`

 * *Files 5% similar despite different names*

```diff
@@ -41,21 +41,21 @@
                                            reset_ibor,
                                            current_ibor,
                                            future_ibors,
                                            dm)
 
     assert round(dirty_price, 4) == 97.0266
 
-    lastCouponDt = bond._pcd
+    lastCouponDt = bond.pcd
     assert lastCouponDt == Date(10, 5, 2017)
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     assert accddays == 71
 
-    accdAmount = bond._accrued_interest
+    accdAmount = bond.accrued_int
     assert round(accdAmount, 4) == 0.0023
 
     principal = bond.principal(settle_dt,
                                reset_ibor,
                                current_ibor,
                                future_ibors,
                                dm)
@@ -143,21 +143,21 @@
                                            reset_ibor,
                                            current_ibor,
                                            future_ibors,
                                            dm)
 
     assert round(dirty_price, 4) == 93.1315
 
-    lastCouponDt = bond._pcd
+    lastCouponDt = bond.pcd
     assert lastCouponDt == Date(3, 2, 2014)
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     assert accddays == 55
 
-    accdAmount = bond._accrued_interest
+    accdAmount = bond.accrued_int
     assert round(accdAmount, 4) == 0.0005
 
     principal = bond.principal(settle_dt,
                                reset_ibor,
                                current_ibor,
                                future_ibors,
                                dm)
@@ -215,7 +215,9 @@
     modified_duration = bond.modified_credit_duration(settle_dt,
                                                       reset_ibor,
                                                       current_ibor,
                                                       future_ibors,
                                                       dm)
 
     assert round(modified_duration, 4) == 6.0480
+
+test_bond_frn_1()
```

### Comparing `financepy-0.350/tests/test_FinBondFutures.py` & `financepy-0.360/tests/test_FinBondFutures.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,16 +12,16 @@
 basis = DayCountTypes.ACT_ACT_ICMA
 issue_dt = Date(15, 2, 2004)
 
 
 def test_bond_future_1():
     bond = Bond(issue_dt, Date(15, 8, 2011), 0.0500, freq, basis)
 
-    assert bond._maturity_dt == Date(15, 8, 2011)
-    assert bond._cpn * 100 == 5.0
+    assert bond.maturity_dt == Date(15, 8, 2011)
+    assert bond.cpn * 100 == 5.0
 
     first_delivery_date = Date(1, 3, 2002)
     last_delivery_date = Date(28, 3, 2002)
     contract_size = 100000
     contractCoupon = 0.06
     bondFutureContract = BondFuture("TYH2",
                                     first_delivery_date,
@@ -32,15 +32,15 @@
     cf = bondFutureContract.conversion_factor(bond)
 
     assert round(cf, 4) == 92.9688
 
 
 def test_bond_future_2():
     bond = Bond(issue_dt, Date(15, 8, 2027), 0.0225, freq, basis)
-    assert bond._maturity_dt == Date(15, 8, 2027)
+    assert bond.maturity_dt == Date(15, 8, 2027)
 
     settle_dt = Date(10, 10, 2017)
     price = 99 + 1 / 32
 
     yld = bond.yield_to_maturity(settle_dt, price)
 
     assert round(yld, 4) == 0.0236
@@ -135,8 +135,8 @@
 
     futures_price = 125.265625
 
     ctd = bondFutureContract.cheapest_to_deliver(bonds,
                                                  prices,
                                                  futures_price)
 
-    assert round(ctd._cpn, 4) == 0.0238
+    assert round(ctd.cpn, 4) == 0.0238
```

### Comparing `financepy-0.350/tests/test_FinBondMortgage.py` & `financepy-0.360/tests/test_FinBondMortgage.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,22 +14,22 @@
 
 rate = 0.035
 
 
 def test_bond_mortgage_repayment():
     mortgage.generate_flows(rate, BondMortgageTypes.REPAYMENT)
     i = 10
-    assert mortgage._schedule._adjusted_dts[i] == Date(24, 12, 2018)
-    assert round(mortgage._interest_flows[i], 4) == 355.0955
-    assert round(mortgage._principal_flows[i], 4) == 930.4208
-    assert round(mortgage._principal_remaining[i], 4) == 120816.6155
-    assert round(mortgage._total_flows[i], 4) == 1285.5163
+    assert mortgage.schedule.adjusted_dts[i] == Date(24, 12, 2018)
+    assert round(mortgage.interest_flows[i], 4) == 355.0955
+    assert round(mortgage.principal_flows[i], 4) == 930.4208
+    assert round(mortgage.principal_remaining[i], 4) == 120816.6155
+    assert round(mortgage.total_flows[i], 4) == 1285.5163
 
 
 def test_bond_mortgage_interest():
     mortgage.generate_flows(rate, BondMortgageTypes.INTEREST_ONLY)
     i = 10
-    assert mortgage._schedule._adjusted_dts[i] == Date(24, 12, 2018)
-    assert round(mortgage._interest_flows[i], 4) == 379.1667
-    assert round(mortgage._principal_flows[i], 4) == 0.0000
-    assert round(mortgage._principal_remaining[i], 4) == 130000.0000
-    assert round(mortgage._total_flows[i], 4) == 379.1667
+    assert mortgage.schedule.adjusted_dts[i] == Date(24, 12, 2018)
+    assert round(mortgage.interest_flows[i], 4) == 379.1667
+    assert round(mortgage.principal_flows[i], 4) == 0.0000
+    assert round(mortgage.principal_remaining[i], 4) == 130000.0000
+    assert round(mortgage.total_flows[i], 4) == 379.1667
```

### Comparing `financepy-0.350/tests/test_FinBondOption.py` & `financepy-0.360/tests/test_FinBondOption.py`

 * *Files 4% similar despite different names*

```diff
@@ -27,26 +27,26 @@
 
 t_mat = (maturity_dt - settle_dt) / gDaysInYear
 times = np.linspace(0, t_mat, 20)
 dates = settle_dt.add_years(times)
 dfs = np.exp(-0.05*times)
 discount_curve = DiscountCurve(settle_dt, dates, dfs)
 
-expiry_date = settle_dt.add_tenor("18m")
+expiry_dt = settle_dt.add_tenor("18m")
 face = 100.0
 
 num_time_steps = 100
 
 
 def test_european_call_bk():
     option_type = OptionTypes.EUROPEAN_CALL
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.20
     a = 0.1
     num_time_steps = 20
     model = BKTree(sigma, a, num_time_steps)
 
     v = bond_option.value(settle_dt, discount_curve, model)
@@ -55,15 +55,15 @@
 
 
 def test_american_call_bk():
     option_type = OptionTypes.AMERICAN_CALL
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.01
     a = 0.1
     model = BKTree(sigma, a)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
@@ -71,15 +71,15 @@
 
 
 def test_european_put_bk():
     option_type = OptionTypes.EUROPEAN_PUT
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.01
     a = 0.1
     model = BKTree(sigma, a)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
@@ -87,15 +87,15 @@
 
 
 def test_american_put_bk():
     option_type = OptionTypes.AMERICAN_PUT
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.02
     a = 0.1
     model = BKTree(sigma, a)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
@@ -103,60 +103,60 @@
 
 
 def test_european_call_bdt():
     option_type = OptionTypes.EUROPEAN_CALL
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.20
     model = BDTTree(sigma, num_time_steps)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
     assert round(v, 4) == 2.9156
 
 
 def test_american_call_bdt():
     option_type = OptionTypes.AMERICAN_CALL
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.20
     model = BDTTree(sigma, num_time_steps)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
     assert round(v, 4) == 3.0939
 
 
 def test_european_put_bdt():
     option_type = OptionTypes.EUROPEAN_PUT
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.01
     model = BDTTree(sigma, num_time_steps)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
     assert round(v, 4) == 0.4326
 
 
 def test_american_put_bdt():
     option_type = OptionTypes.AMERICAN_PUT
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.02
     model = BDTTree(sigma, num_time_steps)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
     assert round(v, 4) == 0.6141
@@ -166,15 +166,15 @@
 # because t_mat != 10.0
 def test_european_call_hw():
     option_type = OptionTypes.EUROPEAN_CALL
     strike_price = 100
     num_time_steps = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.01
     a = 0.1
     model = HWTree(sigma, a, num_time_steps)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
@@ -182,15 +182,15 @@
 
 
 def test_american_call_hw():
     option_type = OptionTypes.AMERICAN_CALL
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.01
     a = 0.1
     model = HWTree(sigma, a)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
@@ -198,15 +198,15 @@
 
 
 def test_european_put_hw():
     option_type = OptionTypes.EUROPEAN_PUT
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.01
     a = 0.1
     model = HWTree(sigma, a)
 
     v = bond_option.value(settle_dt, discount_curve, model)
 
@@ -214,15 +214,15 @@
 
 
 def test_american_put_hw():
     option_type = OptionTypes.AMERICAN_PUT
     strike_price = 100
 
     bond_option = BondOption(
-        bond, expiry_date, strike_price, option_type)
+        bond, expiry_dt, strike_price, option_type)
 
     sigma = 0.02
     a = 0.1
     model = HWTree(sigma, a)
 
     v = bond_option.value(settle_dt, discount_curve, model)
```

### Comparing `financepy-0.350/tests/test_FinBondPortfolio.py` & `financepy-0.360/tests/test_FinBondPortfolio.py`

 * *Files 12% similar despite different names*

```diff
@@ -15,175 +15,175 @@
 
 def test_1():
     dc_type = DayCountTypes.THIRTY_360_BOND
     maturity_dt = Date(7, 3, 2013)
     coupon = 0.045
     clean_price = 101.99500000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.001500
+    assert round(bond.accrued_int, 4) == 0.001500
     assert round(ytm * 100, 4) == 0.2203
 
 
 def test_2():
     dc_type = DayCountTypes.THIRTY_360_BOND
     maturity_dt = Date(7, 3, 2013)
     coupon = 0.045
     clean_price = 101.99500000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.001500
+    assert round(bond.accrued_int, 4) == 0.001500
     assert round(ytm * 100, 4) == 0.2203
 
 
 def test_3():
     dc_type = DayCountTypes.THIRTY_E_360
     maturity_dt = Date(27, 9, 2013)
     coupon = 0.080000
     clean_price = 107.92000000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0382
+    assert round(bond.accrued_int, 4) == 0.0382
     assert round(ytm * 100, 4) == 0.2380
 
 
 def test_4():
     dc_type = DayCountTypes.THIRTY_E_360_ISDA
     maturity_dt = Date(7, 3, 2014)
     coupon = 0.022500
     clean_price = 102.9750
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0008
+    assert round(bond.accrued_int, 4) == 0.0008
     assert round(ytm * 100, 4) == 0.2172
 
 
 def test_5():
     dc_type = DayCountTypes.THIRTY_E_PLUS_360
     maturity_dt = Date(7, 9, 2014)
     coupon = 0.0500000000
     clean_price = 109.35500000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0017
+    assert round(bond.accrued_int, 4) == 0.0017
     assert round(ytm * 100, 4) == 0.2297
 
 
 def test_6():
     dc_type = DayCountTypes.ACT_ACT_ISDA
     maturity_dt = Date(22, 1, 2015)
     coupon = 0.0275000000
     clean_price = 105.62500000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0044
+    assert round(bond.accrued_int, 4) == 0.0044
     assert round(ytm * 100, 4) == 0.3334
 
 
 def test_7():
     dc_type = DayCountTypes.ACT_ACT_ICMA
     maturity_dt = Date(7, 9, 2015)
     coupon = 0.0475000000
     clean_price = 112.98000000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0016
+    assert round(bond.accrued_int, 4) == 0.0016
     assert round(ytm * 100, 4) == 0.3485
 
 
 def test_8():
     dc_type = DayCountTypes.ACT_365F
     maturity_dt = Date(7, 12, 2015)
     coupon = 0.0800000000
     clean_price = 124.47000000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0228
+    assert round(bond.accrued_int, 4) == 0.0228
     assert round(ytm * 100, 4) == 0.3405
 
 
 def test_9():
     dc_type = DayCountTypes.ACT_360
     maturity_dt = Date(22, 1, 2016)
     coupon = 0.0200000000
     clean_price = 104.98000000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0033
+    assert round(bond.accrued_int, 4) == 0.0033
     assert round(ytm * 100, 4) == 0.4930
 
 
 def test_10():
     dc_type = DayCountTypes.ACT_365L
     maturity_dt = Date(7, 9, 2016)
     coupon = 0.0400000000
     clean_price = 113.49500000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0013
+    assert round(bond.accrued_int, 4) == 0.0013
     assert round(ytm * 100, 4) == 0.5559
 
 
 def test_11():
     dc_type = DayCountTypes.SIMPLE
     maturity_dt = Date(25, 8, 2017)
     coupon = 0.0875000000
     clean_price = 138.57000000
 
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     freq_type = FrequencyTypes.SEMI_ANNUAL
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     ytm = bond.yield_to_maturity(settlement, clean_price)
-    assert round(bond._accrued_interest, 4) == 0.0060
+    assert round(bond.accrued_int, 4) == 0.0060
     assert round(ytm * 100, 4) == 0.7652
```

### Comparing `financepy-0.350/tests/test_FinBondYieldCurve.py` & `financepy-0.360/tests/test_FinBondYieldCurve.py`

 * *Files 15% similar despite different names*

```diff
@@ -27,58 +27,58 @@
 ylds = []
 
 for _, bond in bondDataFrame.iterrows():
 
     date_string = bond['maturity']
     mat_date_time = dt.datetime.strptime(date_string, '%d-%b-%y')
     maturity_dt = from_datetime(mat_date_time)
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     coupon = bond['coupon']/100.0
     clean_price = bond['mid']
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
     yld = bond.yield_to_maturity(settlement, clean_price)
     bonds.append(bond)
     ylds.append(yld)
 
 
 def test_poly():
     curveFitMethod = CurveFitPolynomial(5)
     fitted_curve = BondYieldCurve(settlement, bonds, ylds, curveFitMethod)
 
-    coeffs = fitted_curve._curve_fit._coeffs
+    coeffs = fitted_curve.curve_fit.coeffs
     assert round(coeffs[0] * 1e9, 4) == -1.4477
     assert round(coeffs[1] * 1e7, 4) == 1.7840
     assert round(coeffs[2] * 1e6, 4) == -7.4147
     assert round(coeffs[3] * 1e5, 4) == 9.0622
     assert round(coeffs[4] * 1e3, 4) == 1.3536
     assert round(coeffs[5] * 1e7, 4) == 4.1514
 
 
 def test_nelson_siegel():
     curveFitMethod = CurveFitNelsonSiegel()
     fitted_curve = BondYieldCurve(settlement, bonds, ylds, curveFitMethod)
 
-    assert round(fitted_curve._curve_fit._beta_1, 3) == -0.094
-    assert round(fitted_curve._curve_fit._beta_2, 3) == 0.092
-    assert round(fitted_curve._curve_fit._beta_3, 3) == 0.259
-    assert round(fitted_curve._curve_fit._tau, 1) == 35.8
+    assert round(fitted_curve.curve_fit.beta_1, 3) == -0.094
+    assert round(fitted_curve.curve_fit.beta_2, 3) == 0.092
+    assert round(fitted_curve.curve_fit.beta_3, 3) == 0.259
+    assert round(fitted_curve.curve_fit.tau, 1) == 35.8
 
 
 def test_nelson_siegel_svensson():
     curveFitMethod = CurveFitNelsonSiegelSvensson()
     fitted_curve = BondYieldCurve(settlement, bonds, ylds, curveFitMethod)
 
-    assert round(fitted_curve._curve_fit._beta_1, 4) == 0.0460
-    assert round(fitted_curve._curve_fit._beta_2, 4) == -0.0433
-    assert round(fitted_curve._curve_fit._beta_3, 4) == -0.0523
-    assert round(fitted_curve._curve_fit._beta_4, 4) == -0.0376
-    assert round(fitted_curve._curve_fit._tau_1, 3) == 3.177
-    assert round(fitted_curve._curve_fit._tau_2, 4) == 100.0000
+    assert round(fitted_curve.curve_fit.beta_1, 4) == 0.0460
+    assert round(fitted_curve.curve_fit.beta_2, 4) == -0.0433
+    assert round(fitted_curve.curve_fit.beta_3, 4) == -0.0523
+    assert round(fitted_curve.curve_fit.beta_4, 4) == -0.0376
+    assert round(fitted_curve.curve_fit.tau_1, 3) == 3.177
+    assert round(fitted_curve.curve_fit.tau_2, 4) == 100.0000
 
 
-def test_interpolated_yield():
+def test_interp_yield():
     curveFitMethod = CurveFitBSpline()
     fitted_curve = BondYieldCurve(settlement, bonds, ylds, curveFitMethod)
 
     maturity_dt = Date(19, 9, 2030)
-    interpolated_yield = fitted_curve.interpolated_yield(maturity_dt)
-    assert round(float(interpolated_yield), 8) == 0.02601858
+    interp_yield = fitted_curve.interp_yield(maturity_dt)
+    assert round(float(interp_yield), 8) == 0.02601858
```

### Comparing `financepy-0.350/tests/test_FinBondZeroCurve.py` & `financepy-0.360/tests/test_FinBondZeroCurve.py`

 * *Files 5% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 bonds = []
 clean_prices = []
 
 for _, bondRow in bondDataFrame.iterrows():
     date_string = bondRow['maturity']
     mat_date_time = dt.datetime.strptime(date_string, '%d-%b-%y')
     maturity_dt = from_datetime(mat_date_time)
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
     coupon = bondRow['coupon']/100.0
     clean_price = bondRow['mid']
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
     bonds.append(bond)
     clean_prices.append(clean_price)
 
 bondCurve = BondZeroCurve(settlement, bonds, clean_prices)
```

### Comparing `financepy-0.350/tests/test_FinCDS.py` & `financepy-0.360/tests/test_FinCDS.py`

 * *Files 8% similar despite different names*

```diff
@@ -168,50 +168,50 @@
         dcType)
     swaps.append(swap10)
 
     libor_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     cdsMarketContracts = []
 
-    cds_coupon = 0.04 + mktSpreadBump
+    cds_cpn = 0.04 + mktSpreadBump
 
     maturity_dt = value_dt.next_cds_date(6)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(12)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(24)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(36)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(48)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(60)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(84)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(120)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(180)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -295,40 +295,40 @@
         m * 0.003290 + irBump,
         fixedFreq,
         dcType)
     swaps.append(swap4)
 
     libor_curve = IborSingleCurve(value_dt, depos, [], swaps)
 
-    cds_coupon = 0.01 + mktSpreadBump
+    cds_cpn = 0.01 + mktSpreadBump
 
     cdsMarketContracts = []
     effective_dt = Date(21, 8, 2020)
-    cds = CDS(effective_dt, "6M", cds_coupon)
+    cds = CDS(effective_dt, "6M", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "1Y", cds_coupon)
+    cds = CDS(effective_dt, "1Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "2Y", cds_coupon)
+    cds = CDS(effective_dt, "2Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "3Y", cds_coupon)
+    cds = CDS(effective_dt, "3Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "4Y", cds_coupon)
+    cds = CDS(effective_dt, "4Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "5Y", cds_coupon)
+    cds = CDS(effective_dt, "5Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "7Y", cds_coupon)
+    cds = CDS(effective_dt, "7Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "10Y", cds_coupon)
+    cds = CDS(effective_dt, "10Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(settle_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -343,48 +343,48 @@
     return libor_curve, issuer_curve
 
 
 cdsRecovery = 0.40
 
 libor_curve, issuer_curve1 = buildFullIssuerCurve1(0.0, 0.0)
 
-# This is the 10 year contract at an off market coupon
+# This is the 10 year contract at an off market cpn
 maturity_dt = Date(20, 6, 2029)
-cds_coupon = 0.0150
+cds_cpn = 0.0150
 notional = ONE_MILLION
 long_protection = True
 tradeDate = Date(9, 8, 2019)
 value_dt1 = tradeDate.add_days(1)
 effective_dt = value_dt1
 
 cds_contract1 = CDS(effective_dt,
                     maturity_dt,
-                    cds_coupon,
+                    cds_cpn,
                     notional,
                     long_protection)
 t = (maturity_dt - value_dt1) / gDaysInYear
 z = libor_curve.df(maturity_dt)
 r1 = -np.log(z) / t
 print(t, z, r1, maturity_dt)
 mktSpread1 = 0.040
 
 libor_curve, issuer_curve2 = buildFullIssuerCurve2(0.0, 0.0)
 
-# This is the 10 year contract at an off market coupon
+# This is the 10 year contract at an off market cpn
 maturity_dt = Date(20, 6, 2025)
-cds_coupon = 0.050
+cds_cpn = 0.050
 notional = ONE_MILLION
 long_protection = True
 tradeDate = Date(20, 8, 2020)
 effective_dt = Date(21, 8, 2020)
 value_dt2 = tradeDate
 
 cds_contract2 = CDS(effective_dt,
                     maturity_dt,
-                    cds_coupon,
+                    cds_cpn,
                     notional,
                     long_protection)
 t = (maturity_dt - value_dt2) / gDaysInYear
 z = libor_curve.df(maturity_dt)
 r2 = -np.log(z) / t
 mktSpread2 = 0.01
 
@@ -417,15 +417,15 @@
     p = cds_contract1.clean_price(value_dt1, issuer_curve1, cdsRecovery)
     assert round(p, 4) == 82.936
 
     p = cds_contract2.clean_price(value_dt2, issuer_curve2, cdsRecovery)
     assert round(p, 4) == 119.1509
 
 
-def test_accrued_days():
+def testaccrued_days():
     accrued_days = cds_contract1.accrued_days()
     assert accrued_days == 51.0
 
     accrued_days = cds_contract2.accrued_days()
     assert accrued_days == 60.0
 
 
@@ -433,20 +433,20 @@
     accrued_interest = cds_contract1.accrued_interest()
     assert accrued_interest == -2125.0
 
     accrued_interest = cds_contract2.accrued_interest()
     assert round(accrued_interest, 4) == -8333.3333
 
 
-def test_protection_leg_pv():
-    prot_pv = cds_contract1.protection_leg_pv(
+def test_prot_leg_pv():
+    prot_pv = cds_contract1.prot_leg_pv(
         value_dt1, issuer_curve1, cdsRecovery)
     assert round(prot_pv, 4) == 273023.5221
 
-    prot_pv = cds_contract2.protection_leg_pv(
+    prot_pv = cds_contract2.prot_leg_pv(
         value_dt2, issuer_curve2, cdsRecovery)
     assert round(prot_pv, 4) == 47629.7343
 
 
 def test_premium_leg_pv():
     premPV = cds_contract1.premium_leg_pv(
         value_dt1, issuer_curve1, cdsRecovery)
```

### Comparing `financepy-0.350/tests/test_FinCDSBasket.py` & `financepy-0.360/tests/test_FinCDSBasket.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 from financepy.products.credit.cds_basket import CDSBasket
 from financepy.products.credit.cds_index_portfolio import CDSIndexPortfolio
 import numpy as np
 from os.path import dirname, join
 
 
 tradeDate = Date(1, 3, 2007)
-step_in_date = tradeDate.add_days(1)
+step_in_dt = tradeDate.add_days(1)
 value_dt = tradeDate.add_days(1)
 
 libor_curve = build_Ibor_Curve(tradeDate)
 
 basketMaturity = Date(20, 12, 2011)
 
 cdsIndex = CDSIndexPortfolio()
@@ -29,33 +29,33 @@
 seed = 1967
 basket = CDSBasket(value_dt,
                    basketMaturity)
 
 
 def test_inhomogeneous_curve():
     intrinsicSpd = cdsIndex.intrinsic_spread(value_dt,
-                                             step_in_date,
+                                             step_in_dt,
                                              basketMaturity,
                                              issuer_curves) * 10000.0
     assert round(intrinsicSpd, 4) == 32.0971
 
     totalSpd = cdsIndex.total_spread(value_dt,
-                                     step_in_date,
+                                     step_in_dt,
                                      basketMaturity,
                                      issuer_curves) * 10000.0
     assert round(totalSpd, 4) == 161.3169
 
     minSpd = cdsIndex.min_spread(value_dt,
-                                 step_in_date,
+                                 step_in_dt,
                                  basketMaturity,
                                  issuer_curves) * 10000.0
     assert round(minSpd, 4) == 10.6722
 
     maxSpd = cdsIndex.max_spread(value_dt,
-                                 step_in_date,
+                                 step_in_dt,
                                  basketMaturity,
                                  issuer_curves) * 10000.0
     assert round(maxSpd, 4) == 81.1466
 
 
 def test_gaussian_copula():
     num_trials = 1000
```

### Comparing `financepy-0.350/tests/test_FinCDSCurve.py` & `financepy-0.360/tests/test_FinCDSCurve.py`

 * *Files 5% similar despite different names*

```diff
@@ -18,23 +18,23 @@
 
     swaps = []
     depos = []
     fras = []
 
     fixedDCC = DayCountTypes.ACT_365F
     fixedFreq = FrequencyTypes.SEMI_ANNUAL
-    fixed_coupon = 0.05
+    fixed_cpn = 0.05
 
     for i in range(1, 11):
 
         maturity_dt = curve_dt.add_months(12 * i)
         swap = IborSwap(curve_dt,
                         maturity_dt,
                         SwapTypes.PAY,
-                        fixed_coupon,
+                        fixed_cpn,
                         fixedFreq,
                         fixedDCC)
         swaps.append(swap)
 
     libor_curve = IborSingleCurve(curve_dt, depos, fras, swaps)
 
     cds_contracts = []
```

### Comparing `financepy-0.350/tests/test_FinCDSIndex.py` & `financepy-0.360/tests/test_FinCDSIndex.py`

 * *Files 5% similar despite different names*

```diff
@@ -14,26 +14,26 @@
 from financepy.products.credit.cds import CDS
 
 
 # We treat an index as a CDS contract with a flat CDS curve
 tradeDate = Date(7, 2, 2006)
 libor_curve = build_Ibor_Curve(tradeDate)
 issuer_curve = buildIssuerCurve(tradeDate, libor_curve)
-step_in_date = tradeDate.add_days(1)
-value_dt = step_in_date
+step_in_dt = tradeDate.add_days(1)
+value_dt = step_in_dt
 maturity_dt = Date(20, 6, 2010)
 
 cdsRecovery = 0.40
 notional = 10.0 * ONE_MILLION
 long_protection = True
-index_coupon = 0.004
+index_cpn = 0.004
 
-cdsIndexContract = CDS(step_in_date,
+cdsIndexContract = CDS(step_in_dt,
                        maturity_dt,
-                       index_coupon,
+                       index_cpn,
                        notional,
                        long_protection)
 
 
 def test_cds_index():
     spd = cdsIndexContract.par_spread(
         value_dt, issuer_curve, cdsRecovery) * 10000.0
@@ -48,14 +48,14 @@
 
     accrued_days = cdsIndexContract.accrued_days()
     assert accrued_days == 50.0
 
     accrued_interest = cdsIndexContract.accrued_interest()
     assert round(accrued_interest, 4) == -5555.5556
 
-    prot_pv = cdsIndexContract.protection_leg_pv(
+    prot_pv = cdsIndexContract.prot_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     assert round(prot_pv, 4) == 188423.9948
 
     premPV = cdsIndexContract.premium_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     assert round(premPV, 4) == 161359.0042
```

### Comparing `financepy-0.350/tests/test_FinCDSIndexAdjustHazards.py` & `financepy-0.360/tests/test_FinCDSIndexAdjustHazards.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,16 +9,16 @@
 from financepy.products.credit.cds_index_portfolio import CDSIndexPortfolio
 from os.path import dirname, join
 
 
 def test_performCDSIndexHazardRateAdjustment():
 
     tradeDate = Date(1, 8, 2007)
-    step_in_date = tradeDate.add_days(1)
-    value_dt = step_in_date
+    step_in_dt = tradeDate.add_days(1)
+    value_dt = step_in_dt
 
     libor_curve = build_Ibor_Curve(tradeDate)
 
     maturity3Y = tradeDate.next_cds_date(36)
     maturity5Y = tradeDate.next_cds_date(60)
     maturity7Y = tradeDate.next_cds_date(84)
     maturity10Y = tradeDate.next_cds_date(120)
@@ -36,76 +36,76 @@
         splitRow = row.split(",")
         spd3Y = float(splitRow[1]) / 10000.0
         spd5Y = float(splitRow[2]) / 10000.0
         spd7Y = float(splitRow[3]) / 10000.0
         spd10Y = float(splitRow[4]) / 10000.0
         recovery_rate = float(splitRow[5])
 
-        cds3Y = CDS(step_in_date, maturity3Y, spd3Y)
-        cds5Y = CDS(step_in_date, maturity5Y, spd5Y)
-        cds7Y = CDS(step_in_date, maturity7Y, spd7Y)
-        cds10Y = CDS(step_in_date, maturity10Y, spd10Y)
+        cds3Y = CDS(step_in_dt, maturity3Y, spd3Y)
+        cds5Y = CDS(step_in_dt, maturity5Y, spd5Y)
+        cds7Y = CDS(step_in_dt, maturity7Y, spd7Y)
+        cds10Y = CDS(step_in_dt, maturity10Y, spd10Y)
         cds_contracts = [cds3Y, cds5Y, cds7Y, cds10Y]
 
         issuer_curve = CDSCurve(value_dt,
                                 cds_contracts,
                                 libor_curve,
                                 recovery_rate)
 
         issuer_curves.append(issuer_curve)
 
     # Now determine the average spread of the index
     cdsIndex = CDSIndexPortfolio()
 
     averageSpd3Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity3Y,
                                            issuer_curves) * 10000.0
 
     averageSpd5Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity5Y,
                                            issuer_curves) * 10000.0
 
     averageSpd7Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity7Y,
                                            issuer_curves) * 10000.0
 
     averageSpd10Y = cdsIndex.average_spread(value_dt,
-                                            step_in_date,
+                                            step_in_dt,
                                             maturity10Y,
                                             issuer_curves) * 10000.0
 
     assert round(averageSpd3Y, 4) == 19.8221
     assert round(averageSpd5Y, 4) == 36.0357
     assert round(averageSpd7Y, 4) == 50.1336
     assert round(averageSpd10Y, 4) == 63.6622
 
     # Now determine the intrinsic spread of the index to the same maturity dates
     # As the single name CDS contracts
     cdsIndex = CDSIndexPortfolio()
 
     intrinsicSpd3Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity3Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd5Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity5Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd7Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity7Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd10Y = cdsIndex.intrinsic_spread(value_dt,
-                                                step_in_date,
+                                                step_in_dt,
                                                 maturity10Y,
                                                 issuer_curves) * 10000.0
 
     assert round(intrinsicSpd3Y, 4) == 19.6789
     assert round(intrinsicSpd5Y, 4) == 35.5394
     assert round(intrinsicSpd7Y, 4) == 49.0121
     assert round(intrinsicSpd10Y, 4) == 61.4140
```

### Comparing `financepy-0.350/tests/test_FinCDSIndexAdjustSpreads.py` & `financepy-0.360/tests/test_FinCDSIndexAdjustSpreads.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from financepy.products.credit.cds_index_portfolio import CDSIndexPortfolio
 from os.path import dirname, join
 
 
 def test_CDSIndexAdjustSpreads():
 
     tradeDate = Date(1, 8, 2007)
-    step_in_date = tradeDate.add_days(1)
+    step_in_dt = tradeDate.add_days(1)
     value_dt = tradeDate.add_days(1)
 
     libor_curve = build_Ibor_Curve(tradeDate)
 
     maturity3Y = tradeDate.next_cds_date(36)
     maturity5Y = tradeDate.next_cds_date(60)
     maturity7Y = tradeDate.next_cds_date(84)
@@ -36,76 +36,76 @@
         splitRow = row.split(",")
         spd3Y = float(splitRow[1]) / 10000.0
         spd5Y = float(splitRow[2]) / 10000.0
         spd7Y = float(splitRow[3]) / 10000.0
         spd10Y = float(splitRow[4]) / 10000.0
         recovery_rate = float(splitRow[5])
 
-        cds3Y = CDS(step_in_date, maturity3Y, spd3Y)
-        cds5Y = CDS(step_in_date, maturity5Y, spd5Y)
-        cds7Y = CDS(step_in_date, maturity7Y, spd7Y)
-        cds10Y = CDS(step_in_date, maturity10Y, spd10Y)
+        cds3Y = CDS(step_in_dt, maturity3Y, spd3Y)
+        cds5Y = CDS(step_in_dt, maturity5Y, spd5Y)
+        cds7Y = CDS(step_in_dt, maturity7Y, spd7Y)
+        cds10Y = CDS(step_in_dt, maturity10Y, spd10Y)
         cds_contracts = [cds3Y, cds5Y, cds7Y, cds10Y]
 
         issuer_curve = CDSCurve(value_dt,
                                 cds_contracts,
                                 libor_curve,
                                 recovery_rate)
 
         issuer_curves.append(issuer_curve)
 
     # Now determine the average spread of the index
     cdsIndex = CDSIndexPortfolio()
 
     averageSpd3Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity3Y,
                                            issuer_curves) * 10000.0
 
     averageSpd5Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity5Y,
                                            issuer_curves) * 10000.0
 
     averageSpd7Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity7Y,
                                            issuer_curves) * 10000.0
 
     averageSpd10Y = cdsIndex.average_spread(value_dt,
-                                            step_in_date,
+                                            step_in_dt,
                                             maturity10Y,
                                             issuer_curves) * 10000.0
 
     assert round(averageSpd3Y, 4) == 19.8221
     assert round(averageSpd5Y, 4) == 36.0357
     assert round(averageSpd7Y, 4) == 50.1336
     assert round(averageSpd10Y, 4) == 63.6622
 
     # Now determine the intrinsic spread of the index to the same maturity dates
     # As the single name CDS contracts
     cdsIndex = CDSIndexPortfolio()
 
     intrinsicSpd3Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity3Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd5Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity5Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd7Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity7Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd10Y = cdsIndex.intrinsic_spread(value_dt,
-                                                step_in_date,
+                                                step_in_dt,
                                                 maturity10Y,
                                                 issuer_curves) * 10000.0
 
     assert round(intrinsicSpd3Y, 4) == 19.6789
     assert round(intrinsicSpd5Y, 4) == 35.5394
     assert round(intrinsicSpd7Y, 4) == 49.0121
     assert round(intrinsicSpd10Y, 4) == 61.4140
```

### Comparing `financepy-0.350/tests/test_FinCDSIndexOption.py` & `financepy-0.360/tests/test_FinCDSIndexOption.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,16 +16,16 @@
 import os
 import numpy as np
 
 
 def test_dirty_priceCDSIndexOption():
 
     tradeDate = Date(1, 8, 2007)
-    step_in_date = tradeDate.add_days(1)
-    value_dt = step_in_date
+    step_in_dt = tradeDate.add_days(1)
+    value_dt = step_in_dt
 
     libor_curve = build_Ibor_Curve(tradeDate)
 
     maturity3Y = tradeDate.next_cds_date(36)
     maturity5Y = tradeDate.next_cds_date(60)
     maturity7Y = tradeDate.next_cds_date(84)
     maturity10Y = tradeDate.next_cds_date(120)
@@ -42,18 +42,18 @@
         splitRow = row.split(",")
         spd3Y = float(splitRow[1]) / 10000.0
         spd5Y = float(splitRow[2]) / 10000.0
         spd7Y = float(splitRow[3]) / 10000.0
         spd10Y = float(splitRow[4]) / 10000.0
         recovery_rate = float(splitRow[5])
 
-        cds3Y = CDS(step_in_date, maturity3Y, spd3Y)
-        cds5Y = CDS(step_in_date, maturity5Y, spd5Y)
-        cds7Y = CDS(step_in_date, maturity7Y, spd7Y)
-        cds10Y = CDS(step_in_date, maturity10Y, spd10Y)
+        cds3Y = CDS(step_in_dt, maturity3Y, spd3Y)
+        cds5Y = CDS(step_in_dt, maturity5Y, spd5Y)
+        cds7Y = CDS(step_in_dt, maturity7Y, spd7Y)
+        cds10Y = CDS(step_in_dt, maturity10Y, spd10Y)
         cds_contracts = [cds3Y, cds5Y, cds7Y, cds10Y]
 
         issuer_curve = CDSCurve(value_dt,
                                 cds_contracts,
                                 libor_curve,
                                 recovery_rate)
 
@@ -65,17 +65,17 @@
     index_upfronts = [0.0, 0.0, 0.0, 0.0]
     index_maturity_dts = [Date(20, 12, 2009),
                             Date(20, 12, 2011),
                             Date(20, 12, 2013),
                             Date(20, 12, 2016)]
     index_recovery = 0.40
 
-    index_coupon = 0.004
+    index_cpn = 0.004
     volatility = 0.50
-    expiry_date = Date(1, 2, 2008)
+    expiry_dt = Date(1, 2, 2008)
     maturity_dt = Date(20, 12, 2011)
     notional = 10000.0
     tolerance = 1e-6
 
     index_strike_results = [
         (20.0, 20.0, [16.0, 6.2, -70.8, 22.9, -60.8, 16.1, 6.1]),
         (25.0, 30.0, [11.8, 16.9, -35.3, 28.6, -40.5, 11.8, 16.8]),
@@ -104,17 +104,17 @@
             index_upfronts,
             index_maturity_dts,
             index_recovery,
             tolerance)
 
         #######################################################################
 
-        option = CDSIndexOption(expiry_date,
+        option = CDSIndexOption(expiry_dt,
                                 maturity_dt,
-                                index_coupon,
+                                index_cpn,
                                 strike / 10000.0,
                                 notional)
 
         v_pay_1, v_rec_1, strike_value, mu, expH = option.value_anderson(
             value_dt, adjustedIssuerCurves, index_recovery, volatility)
 
         v_pay_2, v_rec_2 = option.value_adjusted_black(value_dt,
```

### Comparing `financepy-0.350/tests/test_FinCDSIndexPortfolio.py` & `financepy-0.360/tests/test_FinCDSIndexPortfolio.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 from financepy.products.credit.cds import CDS
 from financepy.products.credit.cds_index_portfolio import CDSIndexPortfolio
 import os
 
 
 def test_CDSIndexPortfolio():
     tradeDate = Date(1, 8, 2007)
-    step_in_date = tradeDate.add_days(1)
-    value_dt = step_in_date
+    step_in_dt = tradeDate.add_days(1)
+    value_dt = step_in_dt
 
     libor_curve = build_Ibor_Curve(tradeDate)
 
     maturity3Y = tradeDate.next_cds_date(36)
     maturity5Y = tradeDate.next_cds_date(60)
     maturity7Y = tradeDate.next_cds_date(84)
     maturity10Y = tradeDate.next_cds_date(120)
@@ -34,76 +34,76 @@
         splitRow = row.split(",")
         spd3Y = float(splitRow[1]) / 10000.0
         spd5Y = float(splitRow[2]) / 10000.0
         spd7Y = float(splitRow[3]) / 10000.0
         spd10Y = float(splitRow[4]) / 10000.0
         recovery_rate = float(splitRow[5])
 
-        cds3Y = CDS(step_in_date, maturity3Y, spd3Y)
-        cds5Y = CDS(step_in_date, maturity5Y, spd5Y)
-        cds7Y = CDS(step_in_date, maturity7Y, spd7Y)
-        cds10Y = CDS(step_in_date, maturity10Y, spd10Y)
+        cds3Y = CDS(step_in_dt, maturity3Y, spd3Y)
+        cds5Y = CDS(step_in_dt, maturity5Y, spd5Y)
+        cds7Y = CDS(step_in_dt, maturity7Y, spd7Y)
+        cds10Y = CDS(step_in_dt, maturity10Y, spd10Y)
         cds_contracts = [cds3Y, cds5Y, cds7Y, cds10Y]
 
         issuer_curve = CDSCurve(value_dt,
                                 cds_contracts,
                                 libor_curve,
                                 recovery_rate)
 
         issuer_curves.append(issuer_curve)
 
     # Now determine the average spread of the index
     cdsIndex = CDSIndexPortfolio()
 
     averageSpd3Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity3Y,
                                            issuer_curves) * 10000.0
 
     averageSpd5Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity5Y,
                                            issuer_curves) * 10000.0
 
     averageSpd7Y = cdsIndex.average_spread(value_dt,
-                                           step_in_date,
+                                           step_in_dt,
                                            maturity7Y,
                                            issuer_curves) * 10000.0
 
     averageSpd10Y = cdsIndex.average_spread(value_dt,
-                                            step_in_date,
+                                            step_in_dt,
                                             maturity10Y,
                                             issuer_curves) * 10000.0
 
     assert round(averageSpd3Y, 4) == 19.8221
     assert round(averageSpd5Y, 4) == 36.0357
     assert round(averageSpd7Y, 4) == 50.1336
     assert round(averageSpd10Y, 4) == 63.6622
 
     # Now determine the intrinsic spread of the index to the same maturity
     # dates. As the single name CDS contracts
     cdsIndex = CDSIndexPortfolio()
 
     intrinsicSpd3Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity3Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd5Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity5Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd7Y = cdsIndex.intrinsic_spread(value_dt,
-                                               step_in_date,
+                                               step_in_dt,
                                                maturity7Y,
                                                issuer_curves) * 10000.0
 
     intrinsicSpd10Y = cdsIndex.intrinsic_spread(value_dt,
-                                                step_in_date,
+                                                step_in_dt,
                                                 maturity10Y,
                                                 issuer_curves) * 10000.0
 
     assert round(intrinsicSpd3Y, 4) == 19.6789
     assert round(intrinsicSpd5Y, 4) == 35.5394
     assert round(intrinsicSpd7Y, 4) == 49.0121
     assert round(intrinsicSpd10Y, 4) == 61.4140
```

### Comparing `financepy-0.350/tests/test_FinCDSOption.py` & `financepy-0.360/tests/test_FinCDSOption.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,17 +6,17 @@
 from financepy.utils.date import Date
 from financepy.products.credit.cds_option import CDSOption
 
 
 # This reproduces example on page 38 of Open Gamma note on CDS Option
 tradeDate = Date(5, 2, 2014)
 _, issuer_curve = buildFullIssuerCurve(tradeDate)
-step_in_date = tradeDate.add_days(1)
-value_dt = step_in_date
-expiry_date = Date(20, 3, 2014)
+step_in_dt = tradeDate.add_days(1)
+value_dt = step_in_dt
+expiry_dt = Date(20, 3, 2014)
 maturity_dt = Date(20, 6, 2019)
 notional = 100.0
 
 
 def test_cds_option():
     volatility = 0.3
 
@@ -24,15 +24,15 @@
         (100, 4.0007),
         (150, 1.5874),
         (200, 0.0955),
         (300, 0.0)
     ]
 
     for strike, result in strike_result:
-        cdsOption = CDSOption(expiry_date,
+        cdsOption = CDSOption(expiry_dt,
                               maturity_dt,
                               strike / 10000.0,
                               notional)
 
         v = cdsOption.value(value_dt,
                             issuer_curve,
                             volatility)
```

### Comparing `financepy-0.350/tests/test_FinCDSTranche.py` & `financepy-0.360/tests/test_FinCDSTranche.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 from financepy.utils.date import Date
 from financepy.products.credit.cds_tranche import CDSTranche
 from financepy.products.credit.cds_index_portfolio import CDSIndexPortfolio
 from financepy.products.credit.cds_tranche import FinLossDistributionBuilder
 
 
 tradeDate = Date(1, 3, 2007)
-step_in_date = tradeDate.add_days(1)
+step_in_dt = tradeDate.add_days(1)
 value_dt = tradeDate.add_days(1)
 
 libor_curve = build_Ibor_Curve(tradeDate)
 
 trancheMaturity = Date(20, 12, 2011)
 tranche1 = CDSTranche(value_dt, trancheMaturity, 0.00, 0.03)
 tranche2 = CDSTranche(value_dt, trancheMaturity, 0.03, 0.06)
@@ -54,15 +54,15 @@
                                              spd3Y,
                                              spd5Y,
                                              spd7Y,
                                              spd10Y,
                                              num_credits)
 
     intrinsicSpd = cdsIndex.intrinsic_spread(value_dt,
-                                             step_in_date,
+                                             step_in_dt,
                                              trancheMaturity,
                                              issuer_curves) * 10000.0
 
     assert round(intrinsicSpd, 4) == 23.9767
 
     method = FinLossDistributionBuilder.RECURSION
     v = tranche1.value_bc(
@@ -116,15 +116,15 @@
 def test_heterogeneous():
     num_points = 40
 
     issuer_curves = loadHeterogeneousSpreadCurves(value_dt,
                                                   libor_curve)
 
     intrinsicSpd = cdsIndex.intrinsic_spread(value_dt,
-                                             step_in_date,
+                                             step_in_dt,
                                              trancheMaturity,
                                              issuer_curves) * 10000.0
 
     assert round(intrinsicSpd, 4) == 34.3326
 
     method = FinLossDistributionBuilder.RECURSION
     v = tranche1.value_bc(
```

### Comparing `financepy-0.350/tests/test_FinCalendar.py` & `financepy-0.360/tests/test_FinCalendar.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinDateAdjust.py` & `financepy-0.360/tests/test_FinDateAdjust.py`

 * *Files 5% similar despite different names*

```diff
@@ -24,15 +24,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    assert schedule._adjusted_dts == [
+    assert schedule.adjusted_dts == [
         Date(28, 2, 2008), Date(28, 8, 2008), Date(
             28, 2, 2009), Date(28, 8, 2009),
         Date(28, 2, 2010), Date(28, 8, 2010), Date(28, 2, 2011)]
 
 
 def test_date_adjust_noweekend_following():
     start_dt = Date(28, 2, 2008)
@@ -44,15 +44,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    assert schedule._adjusted_dts == [
+    assert schedule.adjusted_dts == [
         Date(28, 2, 2008), Date(28, 8, 2008), Date(
             2, 3, 2009), Date(28, 8, 2009),
         Date(1, 3, 2010), Date(30, 8, 2010), Date(28, 2, 2011)]
 
 
 def test_date_adjust_noweekend_modfollowing():
     start_dt = Date(28, 2, 2008)
@@ -64,15 +64,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    assert schedule._adjusted_dts == [
+    assert schedule.adjusted_dts == [
         Date(28, 2, 2008), Date(28, 8, 2008), Date(
             27, 2, 2009), Date(28, 8, 2009),
         Date(26, 2, 2010), Date(30, 8, 2010), Date(28, 2, 2011)]
 
 
 def test_date_adjust_noweekend_usholidays_modfollowing():
     start_dt = Date(4, 7, 2008)
@@ -84,10 +84,10 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    assert schedule._adjusted_dts == [
+    assert schedule.adjusted_dts == [
         Date(4, 7, 2008), Date(5, 1, 2009), Date(6, 7, 2009), Date(4, 1, 2010),
         Date(6, 7, 2010), Date(4, 1, 2011), Date(5, 7, 2011)]
```

### Comparing `financepy-0.350/tests/test_FinDayCount.py` & `financepy-0.360/tests/test_FinDayCount.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinDiscountCurveFlat.py` & `financepy-0.360/tests/test_FinDiscountCurveFlat.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinDiscountCurveNS.py` & `financepy-0.360/tests/test_FinDiscountCurveNS.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinDiscountCurveNSS.py` & `financepy-0.360/tests/test_FinDiscountCurveNSS.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinDiscountCurveZeros.py` & `financepy-0.360/tests/test_FinDiscountCurveZeros.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityAmericanOption.py` & `financepy-0.360/tests/test_FinEquityAmericanOption.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 from financepy.models.black_scholes import BlackScholes, BlackScholesTypes
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.global_types import OptionTypes
 from financepy.products.equity.equity_american_option import EquityAmericanOption
 
 
 value_dt = Date(1, 1, 2016)
-expiry_date = Date(1, 1, 2017)
+expiry_dt = Date(1, 1, 2017)
 stock_price = 50.0
 interest_rate = 0.06
 dividend_yield = 0.04
 volatility = 0.40
 strike_price = 50.0
 num_steps = 100
 
@@ -24,43 +24,43 @@
 model = BlackScholes(volatility,
                      BlackScholesTypes.CRR_TREE,
                      num_steps)
 
 
 def test_european_put():
     put_option = EquityAmericanOption(
-        expiry_date, strike_price, OptionTypes.EUROPEAN_PUT)
+        expiry_dt, strike_price, OptionTypes.EUROPEAN_PUT)
 
     value = put_option.value(value_dt, stock_price,
                              discount_curve, dividend_curve, model)
 
     assert round(value, 4) == 7.0833
 
 
 def test_american_put():
     put_option = EquityAmericanOption(
-        expiry_date, strike_price, OptionTypes.AMERICAN_PUT)
+        expiry_dt, strike_price, OptionTypes.AMERICAN_PUT)
 
     value = put_option.value(value_dt, stock_price,
                              discount_curve, dividend_curve, model)
 
     assert round(value, 4) == 7.2583
 
 
 def test_european_call():
     call_option = EquityAmericanOption(
-        expiry_date, strike_price, OptionTypes.EUROPEAN_CALL)
+        expiry_dt, strike_price, OptionTypes.EUROPEAN_CALL)
 
     value = call_option.value(value_dt, stock_price,
                               discount_curve, dividend_curve, model)
 
     assert round(value, 4) == 8.0345
 
 
 def test_american_call():
     call_option = EquityAmericanOption(
-        expiry_date, strike_price, OptionTypes.AMERICAN_CALL)
+        expiry_dt, strike_price, OptionTypes.AMERICAN_CALL)
 
     value = call_option.value(value_dt, stock_price, discount_curve,
                               dividend_curve, model)
 
     assert round(value, 4) == 8.0556
```

### Comparing `financepy-0.350/tests/test_FinEquityAsianOption.py` & `financepy-0.360/tests/test_FinEquityAsianOption.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,32 +7,32 @@
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.products.equity.equity_asian_option import AsianOptionValuationMethods
 from financepy.products.equity.equity_asian_option import EquityAsianOption
 from financepy.utils.global_types import OptionTypes
 
 
 value_dt = Date(1, 1, 2014)
-startAveragingDate = Date(1, 6, 2014)
-expiry_date = Date(1, 1, 2015)
+start_averaging_dt = Date(1, 6, 2014)
+expiry_dt = Date(1, 1, 2015)
 stock_price = 100.0
 volatility = 0.20
 interest_rate = 0.30
 dividend_yield = 0.10
 num_observations = 120  # daily as we have a half year
 accruedAverage = None
 K = 100
 seed = 1976
 num_paths = 5000
 
 model = BlackScholes(volatility)
 discount_curve = DiscountCurveFlat(value_dt, interest_rate)
 dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
-asianOption = EquityAsianOption(startAveragingDate,
-                                expiry_date,
+asianOption = EquityAsianOption(start_averaging_dt,
+                                expiry_dt,
                                 K,
                                 OptionTypes.EUROPEAN_CALL,
                                 num_observations)
 
 
 def test_geometric():
     valueGeometric = asianOption.value(value_dt,
```

### Comparing `financepy-0.350/tests/test_FinEquityBarrierOption.py` & `financepy-0.360/tests/test_FinEquityBarrierOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityBasketOption.py` & `financepy-0.360/tests/test_FinEquityBasketOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityBinomialTree.py` & `financepy-0.360/tests/test_FinEquityBinomialTree.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 
 stock_price = 50.0
 risk_free_rate = 0.06
 dividend_yield = 0.04
 volatility = 0.40
 
 value_dt = Date(1, 1, 2016)
-expiry_date = Date(1, 1, 2017)
+expiry_dt = Date(1, 1, 2017)
 
 model = BlackScholes(volatility)
 discount_curve = DiscountCurveFlat(value_dt, risk_free_rate)
 dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
 num_steps = 100
 
@@ -40,15 +40,15 @@
         stock_price,
         discount_curve,
         dividend_curve,
         volatility,
         num_steps,
         value_dt,
         payoff,
-        expiry_date,
+        expiry_dt,
         payoff,
         exercise,
         params)
 
     assert [round(x, 4) for x in value] == [7.1050, -0.3865, 0.0187, -2.9453]
 
 
@@ -61,15 +61,15 @@
         stock_price,
         discount_curve,
         dividend_curve,
         volatility,
         num_steps,
         value_dt,
         payoff,
-        expiry_date,
+        expiry_dt,
         payoff,
         exercise,
         params)
 
     assert [round(x, 4) for x in value] == [7.2753, -0.4008, 0.0200, -3.1803]
 
 
@@ -82,15 +82,15 @@
         stock_price,
         discount_curve,
         dividend_curve,
         volatility,
         num_steps,
         value_dt,
         payoff,
-        expiry_date,
+        expiry_dt,
         payoff,
         exercise,
         params)
 
     assert [round(x, 4) for x in value] == [8.0175, 0.5747, 0.0187, -3.8111]
 
 
@@ -103,13 +103,13 @@
         stock_price,
         discount_curve,
         dividend_curve,
         volatility,
         num_steps,
         value_dt,
         payoff,
-        expiry_date,
+        expiry_dt,
         payoff,
         exercise,
         params)
 
     assert [round(x, 4) for x in value] == [8.0399, 0.5775, 0.0189, -3.8676]
```

### Comparing `financepy-0.350/tests/test_FinEquityChooserOption.py` & `financepy-0.360/tests/test_FinEquityChooserOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityCliquetOption.py` & `financepy-0.360/tests_golden/TestFinEquityCliquetOption.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,28 +1,36 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-from financepy.utils.global_types import OptionTypes
-from financepy.utils.date import Date
-from financepy.utils.frequency import FrequencyTypes
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.models.black_scholes import BlackScholes
+import sys
+sys.path.append("..")
+
 from financepy.products.equity.equity_cliquet_option import EquityCliquetOption
+from financepy.models.black_scholes import BlackScholes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.utils.frequency import FrequencyTypes
+from financepy.utils.date import Date
+from financepy.utils.global_types import OptionTypes
+from FinTestCases import FinTestCases, globalTestCaseMode
+
+test_cases = FinTestCases(__file__, globalTestCaseMode)
+
+###############################################################################
 
 
 def test_EquityCliquetOption():
 
     start_dt = Date(1, 1, 2014)
-    final_expiry_date = Date(1, 1, 2017)
+    final_expiry_dt = Date(1, 1, 2017)
     freq_type = FrequencyTypes.QUARTERLY
     option_type = OptionTypes.EUROPEAN_CALL
 
     cliquetOption = EquityCliquetOption(start_dt,
-                                        final_expiry_date,
+                                        final_expiry_dt,
                                         option_type,
                                         freq_type)
 
     value_dt = Date(1, 1, 2015)
     stock_price = 100.0
     volatility = 0.20
     interest_rate = 0.05
@@ -33,8 +41,15 @@
 
     v = cliquetOption.value(value_dt,
                             stock_price,
                             discount_curve,
                             dividend_curve,
                             model)
 
-    assert round(v, 4) == 34.5287
+    test_cases.header("LABEL", "VALUE")
+    test_cases.print("FINANCEPY", v)
+
+###############################################################################
+
+
+test_EquityCliquetOption()
+test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests/test_FinEquityCompoundOption.py` & `financepy-0.360/tests/test_FinEquityCompoundOption.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.date import Date
 import sys
 sys.path.append("./..")
 
 
 value_dt = Date(1, 1, 2015)
-expiry_date1 = Date(1, 1, 2017)
-expiry_date2 = Date(1, 1, 2018)
+expiry_dt1 = Date(1, 1, 2017)
+expiry_dt2 = Date(1, 1, 2018)
 k1 = 5.0
 k2 = 95.0
 stock_price = 85.0
 volatility = 0.15
 interest_rate = 0.035
 dividend_yield = 0.01
 
@@ -30,55 +30,55 @@
 
 def test_european():
     stock_price = 85.0
 
     option_type1 = OptionTypes.EUROPEAN_CALL
     option_type2 = OptionTypes.EUROPEAN_CALL
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 4.6039
     assert round(values[0], 4) == 4.5587
 
     option_type1 = OptionTypes.EUROPEAN_CALL
     option_type2 = OptionTypes.EUROPEAN_PUT
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 6.7176
     assert round(values[0], 4) == 6.7676
 
     option_type1 = OptionTypes.EUROPEAN_PUT
     option_type2 = OptionTypes.EUROPEAN_CALL
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 2.0165
     assert round(values[0], 4) == 2.0361
 
     option_type1 = OptionTypes.EUROPEAN_PUT
     option_type2 = OptionTypes.EUROPEAN_PUT
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 1.0873
     assert round(values[0], 4) == 1.0789
@@ -86,71 +86,71 @@
 
 def test_american():
     stock_price = 85.0
 
     option_type1 = OptionTypes.AMERICAN_CALL
     option_type2 = OptionTypes.AMERICAN_CALL
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 4.5587
     assert round(values[0], 4) == 4.5587
 
     option_type1 = OptionTypes.AMERICAN_CALL
     option_type2 = OptionTypes.AMERICAN_PUT
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 12.8630
     assert round(values[0], 4) == 12.8630
 
     option_type1 = OptionTypes.AMERICAN_PUT
     option_type2 = OptionTypes.AMERICAN_CALL
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 4.6697
     assert round(values[0], 4) == 4.6697
 
     option_type1 = OptionTypes.AMERICAN_PUT
     option_type2 = OptionTypes.AMERICAN_PUT
 
-    cmpdOption = EquityCompoundOption(expiry_date1, option_type1, k1,
-                                      expiry_date2, option_type2, k2)
+    cmpdOption = EquityCompoundOption(expiry_dt1, option_type1, k1,
+                                      expiry_dt2, option_type2, k2)
     value = cmpdOption.value(value_dt, stock_price, discount_curve,
                              dividend_curve, model)
     values = cmpdOption._value_tree(value_dt, stock_price, discount_curve,
                                     dividend_curve, model, num_steps)
 
     assert round(value, 4) == 4.3034
     assert round(values[0], 4) == 4.3034
 
 
 def test_greeks():
     stock_price = 70
     option_type1 = OptionTypes.EUROPEAN_CALL
     option_type2 = OptionTypes.EUROPEAN_PUT
     cmpdOption = EquityCompoundOption(
-        expiry_date1, option_type1, k1,
-        expiry_date2, option_type2, k2)
+        expiry_dt1, option_type1, k1,
+        expiry_dt2, option_type2, k2)
 
     delta = cmpdOption.delta(
         value_dt,
         stock_price,
         discount_curve,
         dividend_curve,
         model)
```

### Comparing `financepy-0.350/tests/test_FinEquityDigitalOption.py` & `financepy-0.360/tests/test_FinEquityDigitalOption.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 import sys
 sys.path.append("./..")
 
 
 underlying_type = FinDigitalOptionTypes.CASH_OR_NOTHING
 
 value_dt = Date(1, 1, 2015)
-expiry_date = Date(1, 1, 2016)
+expiry_dt = Date(1, 1, 2016)
 stock_price = 100.0
 volatility = 0.30
 interest_rate = 0.05
 dividend_yield = 0.01
 discount_curve = DiscountCurveFlat(value_dt, interest_rate)
 dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
@@ -26,15 +26,15 @@
 
 num_paths = 40000
 
 
 def test_value():
 
     call_option = EquityDigitalOption(
-        expiry_date, 100.0, OptionTypes.EUROPEAN_CALL, underlying_type)
+        expiry_dt, 100.0, OptionTypes.EUROPEAN_CALL, underlying_type)
     value = call_option.value(
         value_dt,
         stock_price,
         discount_curve,
         dividend_curve,
         model)
     value_mc = call_option.value_mc(
@@ -47,15 +47,15 @@
 
     assert round(value, 4) == 0.4693
     assert round(value_mc, 4) == 0.4694
 
 
 def test_greeks():
     call_option = EquityDigitalOption(
-        expiry_date, 100.0, OptionTypes.EUROPEAN_CALL, underlying_type)
+        expiry_dt, 100.0, OptionTypes.EUROPEAN_CALL, underlying_type)
 
     delta = call_option.delta(
         value_dt,
         stock_price,
         discount_curve,
         dividend_curve,
         model)
```

### Comparing `financepy-0.350/tests/test_FinEquityForward.py` & `financepy-0.360/tests/test_FinEquityForward.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,28 +7,28 @@
 from financepy.utils.date import Date
 from financepy.products.equity.equity_forward import EquityForward
 
 
 def test_equity_forward():
 
     value_dt = Date(13, 2, 2018)
-    expiry_date = value_dt.add_months(12)
+    expiry_dt = value_dt.add_months(12)
 
     stock_price = 130.0
     forward_price = 125.0  # Locked
     discount_rate = 0.05
     dividend_rate = 0.02
 
-    expiry_date = value_dt.add_months(12)
+    expiry_dt = value_dt.add_months(12)
     notional = 100.0
 
     discount_curve = DiscountCurveFlat(value_dt, discount_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_rate)
 
-    equityForward = EquityForward(expiry_date,
+    equityForward = EquityForward(expiry_dt,
                                   forward_price,
                                   notional,
                                   FinLongShort.LONG)
 
     fwdPrice = equityForward.forward(value_dt,
                                      stock_price,
                                      discount_curve,
```

### Comparing `financepy-0.350/tests/test_FinEquityIndexOption.py` & `financepy-0.360/tests/test_FinEquityIndexOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityLookbackOption.py` & `financepy-0.360/tests/test_FinEquityLookbackOption.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.global_types import OptionTypes
 from financepy.products.equity.equity_fixed_lookback_option import EquityFixedLookbackOption
 from financepy.products.equity.equity_float_lookback_option import EquityFloatLookbackOption
 
 
 value_dt = Date(1, 1, 2015)
-expiry_date = Date(1, 1, 2016)
+expiry_dt = Date(1, 1, 2016)
 stock_price = 100.0
 volatility = 0.3
 interest_rate = 0.05
 dividend_yield = 0.01
 num_paths = 10000
 stock_priceRange = range(90, 110, 10)
 num_steps_per_year = 252
@@ -22,15 +22,15 @@
 discount_curve = DiscountCurveFlat(value_dt, interest_rate)
 dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
 
 def test_european_call():
     option_type = OptionTypes.EUROPEAN_CALL
     k = 100.0
-    option = EquityFixedLookbackOption(expiry_date, option_type, k)
+    option = EquityFixedLookbackOption(expiry_dt, option_type, k)
 
     stockMax = stock_price + 10.0
     value = option.value(
         value_dt,
         stock_price,
         discount_curve,
         dividend_curve,
@@ -49,15 +49,15 @@
     assert round(value, 4) == 28.7477
     assert round(value_mc, 4) == 27.8592
 
 
 def test_european_put():
     option_type = OptionTypes.EUROPEAN_PUT
     k = 100.0
-    option = EquityFixedLookbackOption(expiry_date, option_type, k)
+    option = EquityFixedLookbackOption(expiry_dt, option_type, k)
 
     stockMin = stock_price - 10
     value = option.value(
         value_dt,
         stock_price,
         discount_curve,
         dividend_curve,
```

### Comparing `financepy-0.350/tests/test_FinEquityOneTouchOption.py` & `financepy-0.360/tests/test_FinEquityOneTouchOption.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 from financepy.utils.date import Date
 from financepy.models.black_scholes import BlackScholes
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.global_types import TouchOptionTypes
 from financepy.products.equity.equity_one_touch_option import EquityOneTouchOption
 
 value_dt = Date(1, 1, 2016)
-expiry_date = Date(2, 7, 2016)
+expiry_dt = Date(2, 7, 2016)
 interest_rate = 0.10
 volatility = 0.20
 barrier_level = 100.0  # H
 model = BlackScholes(volatility)
 dividend_yield = 0.03
 num_paths = 10000
 num_steps_per_year = 252
@@ -23,15 +23,15 @@
 
 payment_size = 15.0
 
 
 def test_DOWN_AND_IN_CASH_AT_HIT():
     stock_price = 105.0
     downType = TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -48,15 +48,15 @@
     assert round(v, 5) == 10.15381
     assert round(v_mc, 5) == 10.20050
 
 
 def test_DOWN_AND_IN_CASH_AT_EXPIRY():
     stock_price = 105.0
     downType = TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -73,15 +73,15 @@
     assert round(v, 5) == 9.77218
     assert round(v_mc, 5) == 9.82371
 
 
 def test_DOWN_AND_OUT_CASH_OR_NOTHING():
     stock_price = 105.0
     downType = TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -98,15 +98,15 @@
     assert round(v, 5) == 4.49627
     assert round(v_mc, 5) == 4.44473
 
 
 def test_UP_AND_IN_CASH_AT_HIT():
     stock_price = 95.0
     downType = TouchOptionTypes.UP_AND_IN_CASH_AT_HIT
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -123,15 +123,15 @@
     assert round(v, 5) == 11.28531
     assert round(v_mc, 5) == 11.07631
 
 
 def test_UP_AND_IN_CASH_AT_EXPIRY():
     stock_price = 95.0
     downType = TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -148,15 +148,15 @@
     assert round(v, 5) == 10.86668
     assert round(v_mc, 5) == 10.67302
 
 
 def test_UP_AND_OUT_CASH_OR_NOTHING():
     stock_price = 95.0
     downType = TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -173,15 +173,15 @@
     assert round(v, 5) == 3.40176
     assert round(v_mc, 5) == 3.59542
 
 
 def test_DOWN_AND_IN_ASSET_AT_HIT():
     stock_price = 105.0
     downType = TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -198,15 +198,15 @@
     assert round(v, 5) == 67.69205
     assert round(v_mc, 5) == 68.00333
 
 
 def test_DOWN_AND_IN_ASSET_AT_EXPIRY():
     stock_price = 105.0
     downType = TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -223,15 +223,15 @@
     assert round(v, 5) == 66.91760
     assert round(v_mc, 5) == 68.84921
 
 
 def test_DOWN_AND_OUT_ASSET_OR_NOTHING():
     stock_price = 105.0
     downType = TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -248,15 +248,15 @@
     assert round(v, 5) == 36.51916
     assert round(v_mc, 5) == 36.33674
 
 
 def test_UP_AND_IN_ASSET_AT_HIT():
     stock_price = 95.0
     downType = TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -273,15 +273,15 @@
     assert round(v, 5) == 75.23538
     assert round(v_mc, 5) == 73.84206
 
 
 def test_UP_AND_IN_ASSET_AT_EXPIRY():
     stock_price = 95.0
     downType = TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
@@ -298,15 +298,15 @@
     assert round(v, 5) == 74.38596
     assert round(v_mc, 5) == 74.80159
 
 
 def test_UP_AND_OUT_ASSET_OR_NOTHING():
     stock_price = 95.0
     downType = TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING
-    option = EquityOneTouchOption(expiry_date,
+    option = EquityOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
     v = option.value(value_dt,
                      stock_price,
                      discount_curve,
                      dividend_curve,
```

### Comparing `financepy-0.350/tests/test_FinEquityRainbowOption.py` & `financepy-0.360/tests/test_FinEquityRainbowOption.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 from financepy.utils.helpers import beta_vector_to_corr_matrix
 from financepy.products.equity.equity_rainbow_option import EquityRainbowOptionTypes
 from financepy.products.equity.equity_rainbow_option import EquityRainbowOption
 import numpy as np
 from math import sqrt
 
 value_dt = Date(1, 1, 2015)
-expiry_date = Date(1, 1, 2016)
+expiry_dt = Date(1, 1, 2016)
 interest_rate = 0.05
 
 discount_curve = DiscountCurveFlat(value_dt, interest_rate)
 
 num_assets = 2
 volatilities = np.ones(num_assets) * 0.3
 
@@ -34,15 +34,15 @@
 correlation = 0.39999960
 
 
 def test_call_on_max():
     payoff_type = EquityRainbowOptionTypes.CALL_ON_MAXIMUM
     payoff_params = [strike]
     rainbowOption = EquityRainbowOption(
-        expiry_date, payoff_type, payoff_params, num_assets)
+        expiry_dt, payoff_type, payoff_params, num_assets)
 
     betas = np.ones(num_assets) * sqrt(correlation)
     corr_matrix = beta_vector_to_corr_matrix(betas)
 
     v = rainbowOption.value(
         value_dt,
         stock_prices,
@@ -64,15 +64,15 @@
     assert round(v_MC, 4) == 21.5586
 
 
 def test_call_on_min():
     payoff_type = EquityRainbowOptionTypes.CALL_ON_MINIMUM
     payoff_params = [strike]
     rainbowOption = EquityRainbowOption(
-        expiry_date, payoff_type, payoff_params, num_assets)
+        expiry_dt, payoff_type, payoff_params, num_assets)
 
     betas = np.ones(num_assets) * sqrt(correlation)
     corr_matrix = beta_vector_to_corr_matrix(betas)
 
     v = rainbowOption.value(
         value_dt,
         stock_prices,
@@ -94,15 +94,15 @@
     assert round(v_MC, 4) == 5.8795
 
 
 def test_put_on_max():
     payoff_type = EquityRainbowOptionTypes.PUT_ON_MAXIMUM
     payoff_params = [strike]
     rainbowOption = EquityRainbowOption(
-        expiry_date, payoff_type, payoff_params, num_assets)
+        expiry_dt, payoff_type, payoff_params, num_assets)
 
     betas = np.ones(num_assets) * sqrt(correlation)
     corr_matrix = beta_vector_to_corr_matrix(betas)
 
     v = rainbowOption.value(
         value_dt,
         stock_prices,
@@ -124,15 +124,15 @@
     assert round(v_MC, 4) == 4.6839
 
 
 def test_put_on_min():
     payoff_type = EquityRainbowOptionTypes.PUT_ON_MINIMUM
     payoff_params = [strike]
     rainbowOption = EquityRainbowOption(
-        expiry_date, payoff_type, payoff_params, num_assets)
+        expiry_dt, payoff_type, payoff_params, num_assets)
 
     betas = np.ones(num_assets) * sqrt(correlation)
     corr_matrix = beta_vector_to_corr_matrix(betas)
 
     v = rainbowOption.value(
         value_dt,
         stock_prices,
@@ -176,15 +176,15 @@
         1.6182
     ]
 
     for n in [1, 2, 3, 4, 5]:
         print(n)
         payoff_params = [n, strike]
         rainbowOption = EquityRainbowOption(
-            expiry_date, payoff_type, payoff_params, num_assets)
+            expiry_dt, payoff_type, payoff_params, num_assets)
 
         betas = np.ones(num_assets) * sqrt(correlation)
         corr_matrix = beta_vector_to_corr_matrix(betas)
 
         v_MC = rainbowOption.value_mc(
             value_dt,
             stock_prices,
@@ -221,15 +221,15 @@
         22.3467
     ]
 
     for n in [1, 2, 3, 4, 5]:
         print(n)
         payoff_params = [n, strike]
         rainbowOption = EquityRainbowOption(
-            expiry_date, payoff_type, payoff_params, num_assets)
+            expiry_dt, payoff_type, payoff_params, num_assets)
 
         betas = np.ones(num_assets) * sqrt(correlation)
         corr_matrix = beta_vector_to_corr_matrix(betas)
 
         v_MC = rainbowOption.value_mc(
             value_dt,
             stock_prices,
```

### Comparing `financepy-0.350/tests/test_FinEquitySwap.py` & `financepy-0.360/tests/test_FinEquitySwap.py`

 * *Files 0% similar despite different names*

```diff
@@ -95,20 +95,20 @@
     discount_curve = DiscountCurveFlat(value_dt, discount_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_rate)
 
     index_curve = discount_curve
 
     # Rate determined at last reset date, from that date to maturity
     index_curve_first = DiscountCurveFlat(effective_dt, discount_rate)
-    index_alpha_first = DayCount(index_curve_first._dc_type).year_frac(effective_dt, maturity_dt)[0]
+    index_alpha_first = DayCount(index_curve_first.dc_type).year_frac(effective_dt, maturity_dt)[0]
     firstFixing = ((index_curve_first.df(effective_dt) / index_curve_first.df(maturity_dt))  - 1.0 ) / index_alpha_first
 
     # Rate between valuation date to maturity
     index_curve_period = DiscountCurveFlat(value_dt, discount_rate)
-    index_alpha_period = DayCount(index_curve_period._dc_type).year_frac(value_dt, maturity_dt)[0]
+    index_alpha_period = DayCount(index_curve_period.dc_type).year_frac(value_dt, maturity_dt)[0]
     periodFixing = ((index_curve_period.df(value_dt) / index_curve_period.df(maturity_dt))  - 1.0 ) / index_alpha_period
 
     # This is the price at which abs_value(equity leg) == abs_value(float leg)
     stock_price = stock_strike * (1 + firstFixing * index_alpha_first) / (1 + periodFixing * index_alpha_period)
 
     equity_swap = EquitySwap(effective_dt,
                              maturity_dt,
```

### Comparing `financepy-0.350/tests/test_FinEquityVanillaOption.py` & `financepy-0.360/tests/test_FinEquityVanillaOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityVarianceSwap.py` & `financepy-0.360/tests/test_FinEquityVarianceSwap.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinEquityVolSurface.py` & `financepy-0.360/tests/test_FinEquityVolSurface.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import numpy as np
 import matplotlib.pyplot as plt
 
 from financepy.models.volatility_fns import VolFuncTypes
 from financepy.utils.date import Date
 from financepy.market.volatility.equity_vol_surface import EquityVolSurface
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-import numpy as np
 
 
 def test_equity_vol_surface():
     value_dt = Date(11, 1, 2021)
 
     stock_price = 3800.0  # Check
 
@@ -50,22 +50,22 @@
                                      expiry_dts,
                                      strikes,
                                      volSurface,
                                      vol_functionType)
 
     expiry_dt = expiry_dts[0]
     delta = 0.10
-    vol = equitySurface.vol_from_delta_dt(delta, expiry_dt)
+    vol = equitySurface.vol_from_delta_date(delta, expiry_dt)
     assert round(vol[0], 4) == 0.1544
     assert round(vol[1], 4) == 4032.9156
 
     expiry_dt = expiry_dts[1]
     delta = 0.20
-    vol = equitySurface.vol_from_delta_dt(delta, expiry_dt)
+    vol = equitySurface.vol_from_delta_date(delta, expiry_dt)
     assert round(vol[0], 4) == 0.1555
     assert round(vol[1], 4) == 4019.3793
 
     expiry_dt = expiry_dts[6]
     delta = 0.90
-    vol = equitySurface.vol_from_delta_dt(delta, expiry_dt)
+    vol = equitySurface.vol_from_delta_date(delta, expiry_dt)
     assert round(vol[0], 4) == 0.3498
     assert round(vol[1], 4) == 2199.6665
```

### Comparing `financepy-0.350/tests/test_FinFXAmericanOption.py` & `financepy-0.360/tests/test_FinFXAmericanOption.py`

 * *Files 25% similar despite different names*

```diff
@@ -24,16 +24,16 @@
 ccy1CCRate = 0.030  # EUR
 ccy2CCRate = 0.025  # USD
 
 currency_pair = ccy1 + ccy2  # Always ccy1ccy2
 strike_fx_rate = 1.250
 volatility = 0.10
 
-dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
 model = BlackScholes(volatility)
 
 
 def test_call():
     spot_fx_rate = 0.5
 
@@ -42,29 +42,29 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   1000000,
                                   "USD")
 
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_CALL,
                                   1000000,
                                   "USD")
 
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     diff = (valueAmerican - valueEuropean)
     assert round(valueAmerican, 4) == 0.0
     assert round(valueEuropean, 4) == 0.0
 
     spot_fx_rate = 1.2
@@ -74,29 +74,29 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   1000000,
                                   "USD")
 
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_CALL,
                                   1000000,
                                   "USD")
 
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     diff = (valueAmerican - valueEuropean)
     assert round(valueAmerican, 4) == 0.0255
     assert round(valueEuropean, 4) == 0.0251
 
     spot_fx_rate = 1.9
@@ -106,29 +106,29 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   1000000,
                                   "USD")
 
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_CALL,
                                   1000000,
                                   "USD")
 
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     diff = (valueAmerican - valueEuropean)
     assert round(valueAmerican, 4) == 0.6500
     assert round(valueEuropean, 4) == 0.6247
 
 
@@ -140,29 +140,29 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_PUT,
                                   1000000,
                                   "USD")
 
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_PUT,
                                   1000000,
                                   "USD")
 
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     diff = (valueAmerican - valueEuropean)
     assert round(valueAmerican, 4) == 0.7500
     assert round(valueEuropean, 4) == 0.7339
 
     spot_fx_rate = 1.2
@@ -172,29 +172,29 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_PUT,
                                   1000000,
                                   "USD")
 
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_PUT,
                                   1000000,
                                   "USD")
 
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     diff = (valueAmerican - valueEuropean)
     assert round(valueAmerican, 4) == 0.0798
     assert round(valueEuropean, 4) == 0.0797
 
     spot_fx_rate = 1.9
@@ -204,27 +204,27 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_PUT,
                                   1000000,
                                   "USD")
 
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_PUT,
                                   1000000,
                                   "USD")
 
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     diff = (valueAmerican - valueEuropean)
     assert round(valueAmerican, 4) == 0.0
     assert round(valueEuropean, 4) == 0.0
```

### Comparing `financepy-0.350/tests/test_FinFXForward.py` & `financepy-0.360/tests/test_FinFXForward.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,17 +14,17 @@
     #  https://stackoverflow.com/questions/48778712
     #  /fx-vanilla-call-price-in-quantlib-doesnt-match-bloomberg
 
     value_dt = Date(13, 2, 2018)
     expiry_dt = value_dt.add_months(12)
     # Forward is on EURUSD which is expressed as number of USD per EUR
     # ccy1 = EUR and ccy2 = USD
-    forName = "EUR"
-    domName = "USD"
-    currency_pair = forName + domName  # Always ccy1ccy2
+    for_name = "EUR"
+    dom_name = "USD"
+    currency_pair = for_name + dom_name  # Always ccy1ccy2
     spot_fx_rate = 1.300  # USD per EUR
     strike_fx_rate = 1.365  # USD per EUR
     ccy1InterestRate = 0.02  # USD Rates
     ccy2InterestRate = 0.05  # EUR rates
 
     spot_days = 0
     settle_dt = value_dt.add_weekdays(spot_days)
@@ -35,42 +35,42 @@
     depos = []
     fras = []
     swaps = []
     deposit_rate = ccy1InterestRate
     depo = IborDeposit(settle_dt, maturity_dt, deposit_rate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    for_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    foreign_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     depos = []
     fras = []
     swaps = []
     deposit_rate = ccy2InterestRate
     depo = IborDeposit(settle_dt, maturity_dt, deposit_rate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    dom_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    domestic_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     notional = 100.0
-    notional_currency = forName
+    notional_currency = for_name
 
     fxForward = FXForward(expiry_dt,
                           strike_fx_rate,
                           currency_pair,
                           notional,
                           notional_currency)
 
     fwdValue = fxForward.value(value_dt, spot_fx_rate,
-                               dom_discount_curve, for_discount_curve)
+                               domestic_curve, foreign_curve)
 
-    fwdFXRate = fxForward.forward(value_dt, spot_fx_rate,
-                                  dom_discount_curve,
-                                  for_discount_curve)
+    fwd_fx_rate = fxForward.forward(value_dt, spot_fx_rate,
+                                    domestic_curve,
+                                    foreign_curve)
 
-    assert round(fwdFXRate, 4) == 1.3388
+    assert round(fwd_fx_rate, 4) == 1.3388
 
     assert round(fwdValue['value'], 4) == -2.4978
     assert round(fwdValue['cash_dom'], 4) == -249.7797
     assert round(fwdValue['cash_for'], 4) == -192.1382
     assert fwdValue['not_dom'] == 136.5
     assert fwdValue['not_for'] == 100.0
     assert fwdValue['ccy_dom'] == 'USD'
```

### Comparing `financepy-0.350/tests/test_FinFXLookbackOption.py` & `financepy-0.360/tests/test_FinFXLookbackOption.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.products.fx.fx_fixed_lookback_option import FXFixedLookbackOption
 from financepy.products.fx.fx_float_lookback_option import FXFloatLookbackOption
 from financepy.utils.global_types import OptionTypes
 
 
 value_dt = Date(1, 1, 2015)
-expiry_date = Date(1, 1, 2016)
+expiry_dt = Date(1, 1, 2016)
 stock_price = 100.0
 volatility = 0.3
 num_paths = 10000
 stock_priceRange = range(90, 110, 5)
 num_steps_per_year = 252
 
 domesticRate = 0.05
@@ -22,15 +22,15 @@
 
 foreignRate = 0.02
 foreign_curve = DiscountCurveFlat(value_dt, foreignRate)
 
 
 def test_european_call():
     option_type = OptionTypes.EUROPEAN_CALL
-    option = FXFloatLookbackOption(expiry_date, option_type)
+    option = FXFloatLookbackOption(expiry_dt, option_type)
     stockMin = stock_price - 10
     value = option.value(
         value_dt,
         stock_price,
         domestic_curve,
         foreign_curve,
         volatility,
@@ -46,15 +46,15 @@
         num_paths,
         num_steps_per_year)
 
     assert round(value, 4) == 23.7455
     assert round(value_mc, 4) == 23.3281
 
     k = 100.0
-    option = FXFixedLookbackOption(expiry_date, option_type, k)
+    option = FXFixedLookbackOption(expiry_dt, option_type, k)
     stockMin = stock_price
     value = option.value(
         value_dt,
         stock_price,
         domestic_curve,
         foreign_curve,
         volatility,
@@ -72,15 +72,15 @@
 
     assert round(value, 4) == 26.8608
     assert round(value_mc, 4) == 25.6946
 
 
 def test_european_put():
     option_type = OptionTypes.EUROPEAN_PUT
-    option = FXFloatLookbackOption(expiry_date, option_type)
+    option = FXFloatLookbackOption(expiry_dt, option_type)
     stockMax = stock_price + 10
     value = option.value(
         value_dt,
         stock_price,
         domestic_curve,
         foreign_curve,
         volatility,
@@ -96,15 +96,15 @@
         num_paths,
         num_steps_per_year)
 
     assert round(value, 4) == 25.2429
     assert round(value_mc, 4) == 24.2806
 
     k = 105.0
-    option = FXFixedLookbackOption(expiry_date, option_type, k)
+    option = FXFixedLookbackOption(expiry_dt, option_type, k)
     stockMin = stock_price - 10.0
     value = option.value(
         value_dt,
         stock_price,
         domestic_curve,
         foreign_curve,
         volatility,
```

### Comparing `financepy-0.350/tests/test_FinFXOptionSABR.py` & `financepy-0.360/tests/test_FinFXOptionSABR.py`

 * *Files 14% similar despite different names*

```diff
@@ -24,16 +24,16 @@
 ccy2CCRate = 0.025  # USD
 
 strike_fx_rate = 1.250
 volatility = 0.10
 
 notional = 1000000.0
 
-dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
 model = BlackScholes(volatility)
 
 # Two examples to show that changing the notional currency and notional
 # keeps the value unchanged
 notional = 1000000.0
 
@@ -47,32 +47,32 @@
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   "USD")
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueEuropean, 4) == 0.0251
 
     spot_fx_rate = 1.80
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   "USD")
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueEuropean, 4) == 0.5277
 
 
 def test_american_call():
     spot_fx_rate = 1.20
@@ -81,32 +81,32 @@
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_CALL,
                                   1000000,
                                   "USD")
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueAmerican, 4) == 0.0255
 
     spot_fx_rate = 1.80
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_CALL,
                                   1000000,
                                   "USD")
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueAmerican, 4) == 0.5500
 
 
 def test_european_put():
     spot_fx_rate = 1.20
@@ -115,32 +115,32 @@
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.EUROPEAN_PUT,
                                   notional,
                                   "USD")
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueEuropean, 4) == 0.0797
 
     spot_fx_rate = 1.80
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.EUROPEAN_PUT,
                                   notional,
                                   "USD")
     valueEuropean = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueEuropean, 4) == 0.0000
 
 
 def test_american_put():
     spot_fx_rate = 1.20
@@ -149,28 +149,28 @@
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_PUT,
                                   1000000,
                                   "USD")
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueAmerican, 4) == 0.0798
 
     spot_fx_rate = 1.80
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.AMERICAN_PUT,
                                   1000000,
                                   "USD")
     valueAmerican = call_option.value(value_dt,
                                       spot_fx_rate,
-                                      dom_discount_curve,
-                                      for_discount_curve,
+                                      domestic_curve,
+                                      foreign_curve,
                                       model)['v']
 
     assert round(valueAmerican, 4) == 0.0000
```

### Comparing `financepy-0.350/tests/test_FinFXVanillaOption.py` & `financepy-0.360/tests/test_FinFXVanillaOption.py`

 * *Files 8% similar despite different names*

```diff
@@ -36,16 +36,16 @@
     currency_pair = ccy1 + ccy2  # Always ccy1ccy2
     spot_fx_rate = 1.20
     strike_fx_rate = 1.250
     volatility = 0.10
 
     notional = 1000000.0
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+    foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
     model = BlackScholes(volatility)
 
     # Two examples to show that changing the notional currency and notional
     # keeps the value unchanged
     notional = 1000000.0
     call_option = FXVanillaOption(expiry_dt,
@@ -53,31 +53,31 @@
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   "EUR", 2)
 
     value = call_option.value(value_dt,
                               spot_fx_rate,
-                              dom_discount_curve,
-                              for_discount_curve,
+                              domestic_curve,
+                              foreign_curve,
                               model)
 
     notional = 1250000.0
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   "USD", 2)
 
     value = call_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(value['v'], 4) == 0.0251
     assert round(value['cash_dom'], 4) == 25125.1772
     assert round(value['cash_for'], 4) == 20937.6477
     assert round(value['pips_dom'], 4) == 0.0251
     assert round(value['pips_for'], 4) == 0.0168
@@ -87,16 +87,16 @@
     assert round(value['not_for'], 4) == 1000000.0
     assert value['ccy_dom'] == 'USD'
     assert value['ccy_for'] == 'EUR'
 
     delta = call_option.delta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(delta['pips_spot_delta'], 4) == 0.3315
     assert round(delta['pips_fwd_delta'], 4) == 0.3416
     assert round(delta['pct_spot_delta_prem_adj'], 4) == 0.3105
     assert round(delta['pct_fwd_delta_prem_adj'], 4) == 0.3200
 
@@ -122,16 +122,16 @@
     currency_pair = ccy1 + ccy2  # Always ccy1ccy2
     spot_fx_rate = 0.9090
     strike_fx_rate = 0.9090
     volatility = 0.12
 
     notional = 1000000.0
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+    foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
     model = BlackScholes(volatility)
 
     # Two examples to show that changing the notional currency and notional
     # keeps the value unchanged
     notional = 1000000.0
     call_option = FXVanillaOption(expiry_dt,
@@ -140,16 +140,16 @@
                                   OptionTypes.EUROPEAN_PUT,
                                   notional,
                                   "EUR", 2)
 
     value = call_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(value['v'], 4) == 0.0436
     assert round(value['cash_dom'], 4) == 43612.8769
     assert round(value['cash_for'], 4) == 47978.9625
     assert round(value['pips_dom'], 4) == 0.0436
     assert round(value['pips_for'], 4) == 0.0528
@@ -159,16 +159,16 @@
     assert round(value['not_for'], 4) == 1000000.0
     assert value['ccy_dom'] == 'USD'
     assert value['ccy_for'] == 'EUR'
 
     delta = call_option.delta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(delta['pips_spot_delta'], 4) == -0.4700
     assert round(delta['pips_fwd_delta'], 4) == -0.4890
     assert round(delta['pct_spot_delta_prem_adj'], 4) == -0.5180
     assert round(delta['pct_fwd_delta_prem_adj'], 4) == -0.5389
 
@@ -181,20 +181,20 @@
 
     value_dt = Date(13, 2, 2018)
     expiry_dt = Date(15, 2, 2019)
 
     # In BS the FX rate is the price in domestic of one unit of foreign
     # In case of EURUSD = 1.3 the domestic currency is USD and foreign is EUR
     # DOM = USD , FOR = EUR
-    forName = "EUR"
-    domName = "USD"
+    for_name = "EUR"
+    dom_name = "USD"
     forDepoRate = 0.05  # EUR
     domDepoRate = 0.02  # USD
 
-    currency_pair = forName + domName  # Always FORDOM
+    currency_pair = for_name + dom_name  # Always FORDOM
     spot_fx_rate = 1.30
     strike_fx_rate = 1.3650
     volatility = 0.20
 
     spot_days = 0
     settle_dt = value_dt.add_weekdays(spot_days)
     maturity_dt = settle_dt.add_months(12)
@@ -204,38 +204,38 @@
 
     depos = []
     fras = []
     swaps = []
     depo = IborDeposit(settle_dt, maturity_dt, domDepoRate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    dom_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    domestic_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     depos = []
     fras = []
     swaps = []
     depo = IborDeposit(settle_dt, maturity_dt, forDepoRate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    for_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    foreign_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     model = BlackScholes(volatility)
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   notional_currency, 2)
 
     value = call_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(value['v'], 4) == 0.0601
     assert round(value['cash_dom'], 4) == 60145.5078
     assert round(value['cash_for'], 4) == 46265.7752
     assert round(value['pips_dom'], 4) == 0.0601
     assert round(value['pips_for'], 4) == 0.0339
@@ -245,16 +245,16 @@
     assert round(value['not_for'], 4) == 1000000.0
     assert value['ccy_dom'] == 'USD'
     assert value['ccy_for'] == 'EUR'
 
     delta = call_option.delta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(delta['pips_spot_delta'], 4) == 0.3671
     assert round(delta['pips_fwd_delta'], 4) == 0.3859
     assert round(delta['pct_spot_delta_prem_adj'], 4) == 0.3208
     assert round(delta['pct_fwd_delta_prem_adj'], 4) == 0.3373
 
@@ -264,32 +264,32 @@
     value_dt = Date(1, 1, 2015)
     expiry_dt = value_dt.add_months(4)
     spot_fx_rate = 1.60
     volatility = 0.1411
     dom_interest_rate = 0.08
     forInterestRate = 0.11
     model = BlackScholes(volatility)
-    dom_discount_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forInterestRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, forInterestRate)
     num_paths = 100000
 
     strike_fx_rate = 1.6
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.EUROPEAN_CALL,
                                   1000000,
                                   "USD")
 
     value_mc = call_option.value_mc(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model,
         num_paths)
 
     assert round(value_mc, 4) == 0.0429
 
     put_option = FXVanillaOption(expiry_dt,
                                  strike_fx_rate,
@@ -297,16 +297,16 @@
                                  OptionTypes.EUROPEAN_PUT,
                                  1000000,
                                  "USD")
 
     value_mc = put_option.value_mc(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model,
         num_paths)
 
     assert round(value_mc, 4) == 0.0582
 
 
 def test_vega_theta():
@@ -314,36 +314,36 @@
     value_dt = Date(1, 1, 2015)
     expiry_dt = value_dt.add_months(4)
     spot_fx_rate = 1.60
     volatility = 0.1411
     dom_interest_rate = 0.08
     forInterestRate = 0.11
     model = BlackScholes(volatility)
-    dom_discount_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forInterestRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, forInterestRate)
 
     strike_fx_rate = 1.6
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   "EURUSD",
                                   OptionTypes.EUROPEAN_CALL,
                                   1000000,
                                   "USD")
 
     vega = call_option.vega(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(vega, 4) == 0.3518
 
     theta = call_option.theta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     assert round(theta, 4) == -0.0504
```

### Comparing `financepy-0.350/tests/test_FinFXVolSurface.py` & `financepy-0.360/tests/test_FinFXVolSurface.py`

 * *Files 13% similar despite different names*

```diff
@@ -15,180 +15,180 @@
 
 def test_FinFXMktVolSurface1(capsys):
     # Example from Book extract by Iain Clarke using Tables 3.3 and 3.4
     # print("EURUSD EXAMPLE CLARK")
 
     value_dt = Date(10, 4, 2020)
 
-    forName = "EUR"
-    domName = "USD"
-    forCCRate = 0.03460  # EUR
-    domCCRate = 0.02940  # USD
+    for_name = "EUR"
+    dom_name = "USD"
+    for_cc_rate = 0.03460  # EUR
+    dom_cc_rate = 0.02940  # USD
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-    currency_pair = forName + domName
+    currency_pair = for_name + dom_name
     spot_fx_rate = 1.3465
 
     tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
     atm_vols = [21.00, 21.00, 20.750, 19.400, 18.250, 17.677]
-    marketStrangle25DeltaVols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
-    riskReversal25DeltaVols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
+    mkt_strangle_25d_vols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
+    rsk_reversal_25d_vols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
 
-    notional_currency = forName
+    notional_currency = for_name
 
-    atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+    atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
     delta_method = FinFXDeltaMethod.SPOT_DELTA
     vol_functionType = VolFuncTypes.CLARK
 
-    fxMarket = FXVolSurface(value_dt,
+    fx_market = FXVolSurface(value_dt,
                             spot_fx_rate,
                             currency_pair,
                             notional_currency,
-                            dom_discount_curve,
-                            for_discount_curve,
+                            domestic_curve,
+                            foreign_curve,
                             tenors,
                             atm_vols,
-                            marketStrangle25DeltaVols,
-                            riskReversal25DeltaVols,
-                            atmMethod,
+                            mkt_strangle_25d_vols,
+                            rsk_reversal_25d_vols,
+                            atm_method,
                             delta_method,
                             vol_functionType)
 
-    fxMarket.check_calibration(verboseCalibration, tol=1e-5)
+    fx_market.check_calibration(verboseCalibration, tol=1e-5)
     captured = capsys.readouterr()
     assert captured.out == ""
 
 
 def test_FinFXMktVolSurface2(capsys):
     # Example from Book extract by Iain Clark using Tables 3.3 and 3.4
     # print("EURJPY EXAMPLE CLARK")
 
     value_dt = Date(10, 4, 2020)
 
-    forName = "EUR"
-    domName = "JPY"
-    forCCRate = 0.0294  # EUR
-    domCCRate = 0.0171  # USD
+    for_name = "EUR"
+    dom_name = "JPY"
+    for_cc_rate = 0.0294  # EUR
+    dom_cc_rate = 0.0171  # USD
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-    currency_pair = forName + domName
+    currency_pair = for_name + dom_name
     spot_fx_rate = 90.72
 
     tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
     atm_vols = [21.50, 20.50, 19.85, 18.00, 15.95, 14.009]
-    marketStrangle25DeltaVols = [0.35, 0.325, 0.300, 0.225, 0.175, 0.100]
-    riskReversal25DeltaVols = [-8.350, -8.650, -8.950, -9.250, -9.550, -9.500]
+    mkt_strangle_25d_vols = [0.35, 0.325, 0.300, 0.225, 0.175, 0.100]
+    rsk_reversal_25d_vols = [-8.350, -8.650, -8.950, -9.250, -9.550, -9.500]
 
-    notional_currency = forName
+    notional_currency = for_name
 
-    atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ
+    atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ
     delta_method = FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ
 
-    fxMarket = FXVolSurface(value_dt,
+    fx_market = FXVolSurface(value_dt,
                             spot_fx_rate,
                             currency_pair,
                             notional_currency,
-                            dom_discount_curve,
-                            for_discount_curve,
+                            domestic_curve,
+                            foreign_curve,
                             tenors,
                             atm_vols,
-                            marketStrangle25DeltaVols,
-                            riskReversal25DeltaVols,
-                            atmMethod,
+                            mkt_strangle_25d_vols,
+                            rsk_reversal_25d_vols,
+                            atm_method,
                             delta_method)
 
-    fxMarket.check_calibration(verboseCalibration, tol=0.0005)
+    fx_market.check_calibration(verboseCalibration, tol=0.0005)
     captured = capsys.readouterr()
     assert captured.out == ""
 
 
 def test_FinFXMktVolSurface3(capsys):
     # EURUSD Example from Paper by Uwe Wystup using Tables 4
     #        print("EURUSD EXAMPLE WYSTUP")
 
     value_dt = Date(20, 1, 2009)
 
-    forName = "EUR"
-    domName = "USD"
-    forCCRate = 0.020113  # EUR
-    domCCRate = 0.003525  # USD
+    for_name = "EUR"
+    dom_name = "USD"
+    for_cc_rate = 0.020113  # EUR
+    dom_cc_rate = 0.003525  # USD
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-    currency_pair = forName + domName
+    currency_pair = for_name + dom_name
     spot_fx_rate = 1.3088
 
     tenors = ['1M']
     atm_vols = [21.6215]
-    marketStrangle25DeltaVols = [0.7375]
-    riskReversal25DeltaVols = [-0.50]
+    mkt_strangle_25d_vols = [0.7375]
+    rsk_reversal_25d_vols = [-0.50]
 
-    notional_currency = forName
+    notional_currency = for_name
 
-    atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+    atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
     delta_method = FinFXDeltaMethod.SPOT_DELTA
 
-    fxMarket = FXVolSurface(value_dt,
+    fx_market = FXVolSurface(value_dt,
                             spot_fx_rate,
                             currency_pair,
                             notional_currency,
-                            dom_discount_curve,
-                            for_discount_curve,
+                            domestic_curve,
+                            foreign_curve,
                             tenors,
                             atm_vols,
-                            marketStrangle25DeltaVols,
-                            riskReversal25DeltaVols,
-                            atmMethod,
+                            mkt_strangle_25d_vols,
+                            rsk_reversal_25d_vols,
+                            atm_method,
                             delta_method)
 
-    fxMarket.check_calibration(verboseCalibration)
+    fx_market.check_calibration(verboseCalibration)
     captured = capsys.readouterr()
     assert captured.out == ""
 
 
 def test_FinFXMktVolSurface4(capsys):
     # USDJPY Example from Paper by Uwe Wystup using Tables 4
 
     value_dt = Date(20, 1, 2009)
 
-    forName = "USD"
-    domName = "JPY"
-    forCCRate = 0.003525  # USD
-    domCCRate = 0.0042875  # JPY
+    for_name = "USD"
+    dom_name = "JPY"
+    for_cc_rate = 0.003525  # USD
+    dom_cc_rate = 0.0042875  # JPY
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-    currency_pair = forName + domName
+    currency_pair = for_name + dom_name
     spot_fx_rate = 90.68
 
     tenors = ['1M']
     atm_vols = [21.00]
-    marketStrangle25DeltaVols = [0.184]
-    riskReversal25DeltaVols = [-5.30]
+    mkt_strangle_25d_vols = [0.184]
+    rsk_reversal_25d_vols = [-5.30]
 
-    notional_currency = forName
+    notional_currency = for_name
 
-    atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+    atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
     delta_method = FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ
 
-    fxMarket = FXVolSurface(value_dt,
+    fx_market = FXVolSurface(value_dt,
                             spot_fx_rate,
                             currency_pair,
                             notional_currency,
-                            dom_discount_curve,
-                            for_discount_curve,
+                            domestic_curve,
+                            foreign_curve,
                             tenors,
                             atm_vols,
-                            marketStrangle25DeltaVols,
-                            riskReversal25DeltaVols,
-                            atmMethod,
+                            mkt_strangle_25d_vols,
+                            rsk_reversal_25d_vols,
+                            atm_method,
                             delta_method)
 
-    fxMarket.check_calibration(verboseCalibration)
+    fx_market.check_calibration(verboseCalibration)
     captured = capsys.readouterr()
     assert captured.out == ""
```

### Comparing `financepy-0.350/tests/test_FinIborBermudanSwaption.py` & `financepy-0.360/tests/test_FinIborBermudanSwaption.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 
 
 value_dt = Date(1, 1, 2011)
 settle_dt = value_dt
 exercise_dt = settle_dt.add_years(1)
 swap_maturity_dt = settle_dt.add_years(4)
 
-swap_fixed_coupon = 0.060
+swap_fixed_cpn = 0.060
 swap_fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
 swapFixedDayCountType = DayCountTypes.ACT_365F
 
 libor_curve = DiscountCurveFlat(value_dt,
                                 0.0625,
                                 FrequencyTypes.SEMI_ANNUAL,
                                 DayCountTypes.ACT_365F)
@@ -39,27 +39,27 @@
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     a = 0.01
     model = BKTree(sigma, a, num_time_steps)
@@ -87,27 +87,27 @@
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     a = 0.01
     model = BKTree(sigma, a, num_time_steps)
@@ -135,27 +135,27 @@
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     sigma = 0.00001
     model = BDTTree(sigma, num_time_steps)
 
     valuePay = bermudan_swaption_pay.value(value_dt, libor_curve, model)
@@ -179,27 +179,27 @@
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     sigma = 0.00001
     model = BDTTree(sigma, num_time_steps)
 
     valuePay = bermudan_swaption_pay.value(value_dt, libor_curve, model)
@@ -223,27 +223,27 @@
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     sigma = 0.000001
     a = 0.01
     model = HWTree(sigma, a, num_time_steps)
 
@@ -269,27 +269,27 @@
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
                                                  swapFixedDayCountType)
 
     sigma = 0.000001
     a = 0.01
     model = HWTree(sigma, a, num_time_steps)
```

### Comparing `financepy-0.350/tests/test_FinIborCapFloor.py` & `financepy-0.360/tests/test_FinIborCapFloor.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinIborCapVolCurve.py` & `financepy-0.360/tests/test_FinIborCapVolCurve.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinIborDualCurve.py` & `financepy-0.360/tests/test_FinIborDualCurve.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,107 +29,107 @@
     fixed_leg_type = SwapTypes.PAY
 
     fras = []
     # 1 x 4 FRA
 
     swaps = []
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
 
     swap_rate = 0.000022
     maturity_dt = settle_dt.add_months(24)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
-               fixed_freq_type, fixedDCCType)
+               fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     swap_rate += 0.000
     fixed_leg_type = SwapTypes.PAY
     maturity_dt = settle_dt.add_months(36)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
-               fixed_freq_type, fixedDCCType)
+               fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     swap_rate += 0.000
     maturity_dt = settle_dt.add_months(48)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     swap_rate = 0.02
     maturity_dt = settle_dt.add_months(60)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(72)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(84)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(96)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(108)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(120)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(132)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(144)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(180)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(240)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(300)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(360)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     oisCurve = OISCurve(value_dt,
                         [],
                         fras,
                         swaps)
 
@@ -237,37 +237,37 @@
     swaps.append(swap)
 
     libor_curve = IborSingleCurve(
         value_dt, depos, fras, swaps, interp_type, True)
 
     assert round(swaps[0].value(
         value_dt, libor_curve, libor_curve, None), 4) == 0.0
-    assert round(swaps[0]._fixed_leg.value(
+    assert round(swaps[0].fixed_leg.value(
         value_dt, libor_curve), 4) == -53707.6667
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         value_dt, libor_curve, libor_curve, None), 4) == 53707.6667
 
     assert round(swaps[0].value(
         settle_dt, libor_curve, libor_curve, None), 4) == 0.0
-    assert round(swaps[0]._fixed_leg.value(
+    assert round(swaps[0].fixed_leg.value(
         settle_dt, libor_curve), 4) == -53714.5507
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         settle_dt, libor_curve, libor_curve, None), 4) == 53714.5507
 
     oisCurve = buildOIS(value_dt)
 
     liborDualCurve = IborDualCurve(value_dt, oisCurve, depos, fras, swaps,
                                    InterpTypes.FLAT_FWD_RATES, True)
 
     assert round(swaps[0].value(
         value_dt, oisCurve, liborDualCurve, None), 4) == 0.0
-    assert round(swaps[0]._fixed_leg.value(
+    assert round(swaps[0].fixed_leg.value(
         value_dt, oisCurve), 4) == -55524.5642
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         value_dt, oisCurve, liborDualCurve, None), 4) == 55524.5642
 
     assert round(swaps[0].value(
         settle_dt, oisCurve, liborDualCurve, None), 4) == 0.0
-    assert round(swaps[0]._fixed_leg.value(
+    assert round(swaps[0].fixed_leg.value(
         settle_dt, oisCurve), 4) == -55524.5709
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         settle_dt, oisCurve, liborDualCurve, None), 4) == 55524.5709
```

### Comparing `financepy-0.350/tests/test_FinIborFuture.py` & `financepy-0.360/tests/test_FinIborFuture.py`

 * *Files 11% similar despite different names*

```diff
@@ -11,27 +11,27 @@
 def test_FinIborFuture():
 
     todayDate = Date(5, 5, 2020)
 
     i = 1
     fut = IborFuture(todayDate, i, "3M")
     fra = fut.to_fra(0.020, 0.0)
-    assert fut._delivery_dt == Date(17, 6, 2020)
-    assert fra._start_dt == Date(17, 6, 2020)
+    assert fut.delivery_dt == Date(17, 6, 2020)
+    assert fra.start_dt == Date(17, 6, 2020)
 
     i = 4
     fut = IborFuture(todayDate, i, "3M")
     fra = fut.to_fra(0.020, 0.0)
-    assert fut._delivery_dt == Date(17, 3, 2021)
-    assert fra._start_dt == Date(17, 3, 2021)
+    assert fut.delivery_dt == Date(17, 3, 2021)
+    assert fra.start_dt == Date(17, 3, 2021)
 
     i = 7
     fut = IborFuture(todayDate, i, "3M")
     fra = fut.to_fra(0.020, 0.0)
-    assert fut._delivery_dt == Date(15, 12, 2021)
-    assert fra._start_dt == Date(15, 12, 2021)
+    assert fut.delivery_dt == Date(15, 12, 2021)
+    assert fra.start_dt == Date(15, 12, 2021)
 
     i = 10
     fut = IborFuture(todayDate, i, "3M")
     fra = fut.to_fra(0.020, 0.0)
-    assert fut._delivery_dt == Date(21, 9, 2022)
-    assert fra._start_dt == Date(21, 9, 2022)
+    assert fut.delivery_dt == Date(21, 9, 2022)
+    assert fra.start_dt == Date(21, 9, 2022)
```

### Comparing `financepy-0.350/tests/test_FinIborSingleCurve.py` & `financepy-0.360/tests/test_FinIborSingleCurve.py`

 * *Files 2% similar despite different names*

```diff
@@ -121,19 +121,19 @@
 
     # The valuation of 53714.55 is very close to the spreadsheet value 53713.96
     principal = 0.0
 
     # Pay fixed so make fixed leg value negative
     assert round(swaps[0].value(
         value_dt, libor_curve, libor_curve, None), 4) == 0.0
-    assert round(-swaps[0]._fixed_leg.value(
+    assert round(-swaps[0].fixed_leg.value(
         value_dt, libor_curve), 4) == 53707.6667
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         value_dt, libor_curve, libor_curve, None), 4) == 53707.6667
 
     # Pay fixed so make fixed leg value negative
     assert round(swaps[0].value(
         settle_dt, libor_curve, libor_curve, None), 4) == 0.0
-    assert round(-swaps[0]._fixed_leg.value(
+    assert round(-swaps[0].fixed_leg.value(
         settle_dt, libor_curve), 4) == 53714.5507
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         settle_dt, libor_curve, libor_curve, None), 4) == 53714.5507
```

### Comparing `financepy-0.350/tests/test_FinIborSwap.py` & `financepy-0.360/tests/test_FinIborSwap.py`

 * *Files 8% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 
 def test_LiborSwap():
     # I have tried to reproduce the example from the blog by Ioannis Rigopoulos
     # https://blog.deriscope.com/index.php/en/excel-interest-rate-swap-price-dual-bootstrapping-curve
     start_dt = Date(27, 12, 2017)
     end_dt = Date(27, 12, 2067)
 
-    fixed_coupon = 0.015
+    fixed_cpn = 0.015
     fixed_freq_type = FrequencyTypes.ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360
 
     float_spread = 0.0
     float_freq_type = FrequencyTypes.SEMI_ANNUAL
     float_dc_type = DayCountTypes.ACT_360
     firstFixing = -0.00268
@@ -41,15 +41,15 @@
     fixed_leg_type = SwapTypes.RECEIVE
 
     notional = 10.0 * ONE_MILLION
 
     swap = IborSwap(start_dt,
                     end_dt,
                     fixed_leg_type,
-                    fixed_coupon,
+                    fixed_cpn,
                     fixed_freq_type,
                     fixed_dc_type,
                     notional,
                     float_spread,
                     float_freq_type,
                     float_dc_type,
                     swap_cal_type,
@@ -75,21 +75,21 @@
     end_dt = Date(14, 11, 2016)
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     swap_cal_type = CalendarTypes.TARGET
     bd_type = BusDayAdjustTypes.MODIFIED_FOLLOWING
     dg_type = DateGenRuleTypes.BACKWARD
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     fixed_leg_type = SwapTypes.PAY
-    fixed_coupon = 0.0124
+    fixed_cpn = 0.0124
     notional = ONE_MILLION
 
     swap = IborSwap(start_dt,
                     end_dt,
                     fixed_leg_type,
-                    fixed_coupon=fixed_coupon,
+                    fixed_cpn=fixed_cpn,
                     fixed_freq_type=fixed_freq_type,
                     fixed_dc_type=fixed_dc_type,
                     float_freq_type=FrequencyTypes.SEMI_ANNUAL,
                     float_dc_type=DayCountTypes.ACT_360,
                     notional=notional,
                     cal_type=swap_cal_type,
                     bd_type=bd_type,
```

### Comparing `financepy-0.350/tests/test_FinIborSwaption.py` & `financepy-0.360/tests/test_FinIborSwaption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinInflationBond.py` & `financepy-0.360/tests/test_FinInflationBond.py`

 * *Files 0% similar despite different names*

```diff
@@ -59,18 +59,18 @@
 
     dirty_price = bond.dirty_price_from_ytm(settle_dt, ytm)
     assert round(dirty_price, 4) == 104.0554
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     assert round(clean_price, 4) == 104.0350
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     assert accddays == 6.0
 
-    accrued_interest = bond._accrued_interest
+    accrued_interest = bond.accrued_int
     assert round(accrued_interest, 4) == 0.0204
 
     # Inflation functions that calculate nominal yield with CPI adjustment
     refCPIValue = 244.65884
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     assert round(clean_price, 4) == 104.0350
```

### Comparing `financepy-0.350/tests/test_FinInflationIndexCurve.py` & `financepy-0.360/tests/test_FinInflationIndexCurve.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinInterpolate.py` & `financepy-0.360/tests/test_FinInterpolate.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinInterpolatedForwards.py` & `financepy-0.360/tests/test_FinInterpolatedForwards.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinLossDbnBuilder.py` & `financepy-0.360/tests/test_FinLossDbnBuilder.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinMath.py` & `financepy-0.360/tests/test_FinMath.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinModelBlack.py` & `financepy-0.360/tests/test_FinModelBlack.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinModelBlackScholes.py` & `financepy-0.360/tests/test_FinModelBlackScholes.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinModelCIR.py` & `financepy-0.360/tests/test_FinModelCIR.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-from financepy.models.cir_mc import CIRNumericalScheme
-from financepy.models.cir_mc import zero_price_mc, zero_price
+from financepy.models.cir_montecarlo import CIRNumericalScheme
+from financepy.models.cir_montecarlo import zero_price_mc, zero_price
 import numpy as np
 
 r0 = 0.05
 a = 0.20
 b = 0.05
 sigma = 0.20
 t = 5.0
```

### Comparing `financepy-0.350/tests/test_FinModelHeston.py` & `financepy-0.360/tests/test_FinModelHeston.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 from financepy.utils.global_types import OptionTypes
 from financepy.models.heston import Heston, HestonNumericalScheme
 import numpy as np
 
 
 # Reference see table 4.1 of Rouah book
 value_dt = Date(1, 1, 2015)
-expiry_date = Date(1, 4, 2015)
+expiry_dt = Date(1, 4, 2015)
 v0 = 0.05  # initial variance of volatility
 theta = 0.05  # long term variance
 kappa = 2.0  # speed of variance reversion
 sigma = 0.10  # volatility of variance
 rho = -0.9  # correlation
 interest_rate = 0.05
 dividend_yield = 0.01
@@ -29,15 +29,15 @@
 def test_heston():
     rho = -0.90000
     sigma = 0.75000
     strike_price = 105.00
     hestonModel = Heston(v0, kappa, theta, sigma, rho)
 
     call_option = EquityVanillaOption(
-        expiry_date, strike_price, OptionTypes.EUROPEAN_CALL)
+        expiry_dt, strike_price, OptionTypes.EUROPEAN_CALL)
 
     value_mc_Heston = hestonModel.value_mc(
         value_dt,
         call_option,
         stock_price,
         interest_rate,
         dividend_yield,
```

### Comparing `financepy-0.350/tests/test_FinModelMerton.py` & `financepy-0.360/tests/test_FinModelMerton.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,68 +6,68 @@
 from financepy.models.merton_firm import MertonFirm
 
 
 def test_merton():
     # Input Equity values and equity vols
     equity_value = [2.6406, 2.6817, 3.977, 2.947, 2.528]
     equity_vol = [0.7103, 0.3929, 0.3121, 0.4595, 0.6181]
-    bondFace = [4.0, 3.5, 3.5, 3.2, 4.0]
+    bond_face = [4.0, 3.5, 3.5, 3.2, 4.0]
     risk_free_rate = [0.05, 0.05, 0.05, 0.05, 0.05]
-    assetGrowthRate = [0.0306, 0.03, 0.031, 0.0302, 0.0305]
-    timeToMaturity = 1.0  # np.linspace(0.1, 10, 100)
+    asset_growth_rate = [0.0306, 0.03, 0.031, 0.0302, 0.0305]
+    years_to_maturity = 1.0  # np.linspace(0.1, 10, 100)
 
     model = MertonFirmMkt(equity_value,
-                          bondFace,
-                          timeToMaturity,
+                          bond_face,
+                          years_to_maturity,
                           risk_free_rate,
-                          assetGrowthRate,
+                          asset_growth_rate,
                           equity_vol)
 
     assert [round(x, 4) for x in model.debt_value()] == [
         3.7804, 3.3292, 3.3293, 3.0436, 3.7951]
     assert [round(x*1e4, 4) for x in model.credit_spread()
             ] == [64.6893, 0.2289, .0009, 1.2398, 25.7203]
     assert [round(x, 4) for x in model.leverage()] == [
         1.6052, 1.7174, 2.0875, 1.8720, 1.5808]
     assert [round(x*1e2, 4) for x in model.prob_default()
             ] == [6.3791, .0768, 0.0005, 0.2622, 3.4408]
 
-    assetValue = model._A
-    assetVol = model._vA
+    asset_value = model._A
+    asset_vol = model._vA
 
-    model = MertonFirm(assetValue,
-                       bondFace,
-                       timeToMaturity,
+    model = MertonFirm(asset_value,
+                       bond_face,
+                       years_to_maturity,
                        risk_free_rate,
-                       assetGrowthRate,
-                       assetVol)
+                       asset_growth_rate,
+                       asset_vol)
 
     assert [round(x, 4) for x in model.debt_value()] == [
         3.7804, 3.3292, 3.3293, 3.0436, 3.7951]
     assert [round(x*1e4, 4) for x in model.credit_spread()
             ] == [64.6893, 0.2289, 0.0009, 1.2398, 25.7203]
     assert [round(x, 4) for x in model.leverage()] == [
         1.6052, 1.7174, 2.0875, 1.8720, 1.5808]
     assert [round(x*1e2, 4) for x in model.prob_default()
             ] == [6.3791, 0.0768, 0.0005, 0.2622, 3.4408]
     assert [round(x, 4) for x in model.dist_default()] == [
         1.5237, 3.1679, 4.4298, 2.7916, 1.8196]
 
-    assetValue = 140.0
-    bondFace = 100.0
-    timeToMaturity = 1.0
+    asset_value = 140.0
+    bond_face = 100.0
+    years_to_maturity = 1.0
     risk_free_rate = 0.05
-    assetGrowthRate = 0.05
-    assetVol = 0.20
+    asset_growth_rate = 0.05
+    asset_vol = 0.20
 
-    model = MertonFirm(assetValue,
-                       bondFace,
-                       timeToMaturity,
+    model = MertonFirm(asset_value,
+                       bond_face,
+                       years_to_maturity,
                        risk_free_rate,
-                       assetGrowthRate,
-                       assetVol)
+                       asset_growth_rate,
+                       asset_vol)
 
     assert round(model.debt_value(), 4) == 94.8894
     assert round(model.credit_spread()*10000, 4) == 24.5829
     assert model.leverage() == 1.4
     assert round(model.prob_default(), 4) == 0.0334
     assert round(model.dist_default(), 4) == 1.8324
```

### Comparing `financepy-0.350/tests/test_FinModelRatesBDT.py` & `financepy-0.360/tests/test_FinModelRatesBDT.py`

 * *Files 6% similar despite different names*

```diff
@@ -31,26 +31,26 @@
     coupon = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
-    cpn = bond._cpn / bond._freq
-    num_flows = len(bond._cpn_dts)
+    cpn = bond.cpn / bond.freq
+    num_flows = len(bond.cpn_dts)
 
     for i in range(1, num_flows):
-        pcd = bond._cpn_dts[i-1]
-        ncd = bond._cpn_dts[i]
+        pcd = bond.cpn_dts[i-1]
+        ncd = bond.cpn_dts[i]
         if pcd < settle_dt and ncd > settle_dt:
             flow_time = (pcd - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
-    for flow_dt in bond._cpn_dts:
+    for flow_dt in bond.cpn_dts:
         if flow_dt > settle_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
     cpn_flows = np.array(cpn_flows)
@@ -104,32 +104,32 @@
     num_time_steps = 200
 
     exercise_type = FinExerciseTypes.EUROPEAN
     years_to_maturity = 4.0
     expiryYears = 2.0
 
     maturity_dt = settle_dt.add_years(years_to_maturity)
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
 
     sigma = 0.2012
 
     expiry_dt = settle_dt.add_years(expiryYears)
 
     t_mat = (maturity_dt - settle_dt) / gDaysInYear
     t_exp = (expiry_dt - settle_dt) / gDaysInYear
 
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
 
-    cpn = bond._cpn / bond._freq
+    cpn = bond.cpn / bond.freq
 
-    for flow_dt in bond._cpn_dts:
+    for flow_dt in bond.cpn_dts:
         if flow_dt > expiry_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
     cpn_flows = np.array(cpn_flows)
@@ -153,32 +153,32 @@
     assert round(v['rec']*100, 2) == 8883.21
 
     exercise_type = FinExerciseTypes.BERMUDAN
     years_to_maturity = 10.0
     expiryYears = 5.0
 
     maturity_dt = settle_dt.add_years(years_to_maturity)
-    issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+    issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
 
     sigma = 0.1522
 
     expiry_dt = settle_dt.add_years(expiryYears)
 
     t_mat = (maturity_dt - settle_dt) / gDaysInYear
     t_exp = (expiry_dt - settle_dt) / gDaysInYear
 
     bond = Bond(issue_dt, maturity_dt,
                 coupon, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
 
-    cpn = bond._cpn / bond._freq
+    cpn = bond.cpn / bond.freq
 
-    for flow_dt in bond._cpn_dts:
+    for flow_dt in bond.cpn_dts:
         if flow_dt > expiry_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
     cpn_flows = np.array(cpn_flows)
```

### Comparing `financepy-0.350/tests/test_FinModelRatesBK.py` & `financepy-0.360/tests/test_FinModelRatesBK.py`

 * *Files 8% similar despite different names*

```diff
@@ -25,27 +25,27 @@
     sigma = 0.25
     a = 0.22
     num_time_steps = 3
     t_mat = (end_dt - start_dt)/gDaysInYear
     model = BKTree(sigma, a, num_time_steps)
     model.build_tree(t_mat, times, dfs)
 
-    assert [round(x, 4) for x in model._Q[2]] == \
+    assert [round(x, 4) for x in model.Q[2]] == \
         [0.0190, 0.2126, 0.5009, 0.2112, 0.0187]
 
-    assert [round(x, 4) for x in model._rt[2]] == \
+    assert [round(x, 4) for x in model.rt[2]] == \
         [0.0259, 0.0351, 0.0477, 0.0648, 0.0881]
 
-    assert [round(x, 4) for x in model._pu] == \
+    assert [round(x, 4) for x in model.pu] == \
         [0.0808, 0.2278, 0.1667, 0.1177, 0.8606]
 
-    assert [round(x, 4) for x in model._pm] == \
+    assert [round(x, 4) for x in model.pm] == \
         [0.0586, 0.6545, 0.6667, 0.6545, 0.0586]
 
-    assert [round(x, 4) for x in model._pd] == \
+    assert [round(x, 4) for x in model.pd] == \
         [0.8606, 0.1177, 0.1667, 0.2278, 0.0808]
 
 
 def test_BKExampleTwo():
     # Valuation of a European option on a coupon bearing bond
     # This follows example in Fig 28.11 of John Hull's book but does not
     # have the exact same dt so there are some differences
@@ -58,27 +58,27 @@
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
 
-    cpn = bond._cpn / bond._freq
+    cpn = bond.cpn / bond.freq
 
-    num_flows = len(bond._cpn_dts)
+    num_flows = len(bond.cpn_dts)
 
     for i in range(1, num_flows):
-        pcd = bond._cpn_dts[i-1]
-        ncd = bond._cpn_dts[i]
+        pcd = bond.cpn_dts[i-1]
+        ncd = bond.cpn_dts[i]
         if pcd < settle_dt and ncd > settle_dt:
             flow_time = (pcd - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
-    for flow_dt in bond._cpn_dts:
+    for flow_dt in bond.cpn_dts:
         if flow_dt > settle_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
     cpn_flows = np.array(cpn_flows)
@@ -115,7 +115,9 @@
     model.build_tree(t_mat, times, dfs)
     v = model.bond_option(t_exp, strike_price,
                           face, cpn_times, cpn_flows, exercise_type)
     treeVector.append(v)
 
     assert round(v['call'], 4) == 0.6998
     assert round(v['put'], 4) == 7.9605
+
+test_BKExampleOne()
```

### Comparing `financepy-0.350/tests/test_FinModelRatesHW.py` & `financepy-0.360/tests/test_FinModelRatesHW.py`

 * *Files 1% similar despite different names*

```diff
@@ -44,19 +44,19 @@
     model = HWTree(sigma, a, num_time_steps)
     vAnal = model.option_on_zcb(t_exp, t_mat, strike, face, times, dfs)
 
     num_time_steps = 200
 
     model = HWTree(sigma, a, num_time_steps)
     model.build_tree(t_exp, times, dfs)
-    vTree1 = model.option_on_zero_coupon_bond_tree(t_exp, t_mat, strike, face)
+    vTree1 = model.option_on_zero_cpn_bond_tree(t_exp, t_mat, strike, face)
 
     model = HWTree(sigma, a, num_time_steps+1)
     model.build_tree(t_exp, times, dfs)
-    vTree2 = model.option_on_zero_coupon_bond_tree(t_exp, t_mat, strike, face)
+    vTree2 = model.option_on_zero_cpn_bond_tree(t_exp, t_mat, strike, face)
 
     vTreeCall = (vTree1['call'] + vTree2['call']) / 2.0
     vTreePut = (vTree1['put'] + vTree2['put']) / 2.0
 
     assert round(vTreeCall, 4) == 1.0450
     assert round(vAnal['call'], 4) == 1.0448
     assert round(vTreePut, 4) == 1.8237
```

### Comparing `financepy-0.350/tests/test_FinModelRatesLMM.py` & `financepy-0.360/tests/test_FinModelRatesLMM.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,25 +31,25 @@
     spread = 0.0025  # basis points
 
     ###########################################################################
     # HULL TABLE 32.1
     ###########################################################################
 
     use_sobol = 1
-    numeraireIndex = 0
+    numeraire_index = 0
 
     # We need the volatility for the forward rates out to the one starting in
     # 10 years. So we have 11 elements. The one starting today has zero vol.
-    numFactors = 1
+    num_factors = 1
     gammas1FList = [0.00, 0.1550, 0.2063674, 0.1720986, 0.1721993, 0.1524579,
                     0.1414779, 0.1297711, 0.1381053, 0.135955, 0.1339842]
     gammas1F = np.array(gammas1FList)
 
     # One factor model
-    fwds1F = lmm_simulate_fwds_1f(numFwds, num_paths, numeraireIndex, fwd0,
+    fwds1F = lmm_simulate_fwds_1f(numFwds, num_paths, numeraire_index, fwd0,
                                   gammas1F, taus, use_sobol, seed)
 
 #    LMMPrintForwards(fwds1F)
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwds1F, taus) * 100.0
 
@@ -64,21 +64,21 @@
                                               fwd0, fwds1F, taus) * 100.0
 
     hullStickyCaplets1F = [0.0, 0.196, 0.336, 0.412, 0.458, 0.484,
                            0.498, 0.502, 0.501, 0.497, 0.488]
 
     check_vector_differences(vStickyCaplets, hullStickyCaplets1F, 1e-2)
 
-    numFactors = 1
+    num_factors = 1
     lambdas1FList = [[0.0, 0.1550, 0.2064, 0.1721, 0.1722, 0.1525,
                       0.1415, 0.1298, 0.1381, 0.1360, 0.1340]]
     lambdas1F = np.array(lambdas1FList)
 
     # One factor model
-    fwdsMF = lmm_simulate_fwds_mf(numFwds, numFactors, num_paths, numeraireIndex,
+    fwdsMF = lmm_simulate_fwds_mf(numFwds, num_factors, num_paths, numeraire_index,
                                   fwd0, lambdas1F, taus, use_sobol, seed)
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwdsMF, taus) * 100.0
 
     hullRatchetCaplets1F = [0.0, 0.196, 0.207, 0.201, 0.194, 0.187,
                             0.1890, 0.172, 0.167, 0.160, 0.153]
@@ -89,25 +89,25 @@
                                               fwd0, fwdsMF, taus) * 100.0
 
     hullStickyCaplets1F = [0.00, 0.196, 0.336, 0.412, 0.458, 0.484, 0.498,
                            0.502, 0.501, 0.497, 0.488]
 
     check_vector_differences(vStickyCaplets, hullStickyCaplets1F, 1e-2)
 
-    numFactors = 3
+    num_factors = 3
     lambdas3FList = [[0.00, 0.1365, 0.1928, 0.1672, 0.1698, 0.1485,
                       0.1395, 0.1261, 0.1290, 0.1197, 0.1097],
                      [0.0, -0.0662, -0.0702, -0.0406, -0.0206, 0.00,
                       0.0169, 0.0306, 0.0470, 0.0581, 0.0666],
                      [0.0, 0.0319, 0.0225, 0.000, -0.0198, -0.0347,
                       -0.0163, 0.000, 0.0151, 0.0280, 0.0384]]
     lambdas3F = np.array(lambdas3FList)
 
     # Three factor model
-    fwds3F = lmm_simulate_fwds_mf(numFwds, numFactors, num_paths, numeraireIndex,
+    fwds3F = lmm_simulate_fwds_mf(numFwds, num_factors, num_paths, numeraire_index,
                                   fwd0, lambdas3F, taus, use_sobol, seed)
 
     hullRatchetCaplets3F = [0.00, 0.194, 0.207, 0.205, 0.198, 0.193,
                             0.189, 0.180, 0.174, 0.168, 0.162]
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwds3F, taus) * 100.0
```

### Comparing `financepy-0.350/tests/test_FinModelSABR.py` & `financepy-0.360/tests/test_FinModelSABR.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinModelShiftedSABR.py` & `financepy-0.360/tests/test_FinModelShiftedSABR.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinOIS.py` & `financepy-0.360/tests/test_FinOIS.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinOISCurve.py` & `financepy-0.360/tests/test_FinOISCurve.py`

 * *Files 4% similar despite different names*

```diff
@@ -23,18 +23,18 @@
     https://github.com/vilen22/curve-building/blob/master/Bloomberg%20Curve%20Building%20Replication.xlsx
     """
 
     value_dt = Date(6, 6, 2018)
 
     # We do the O/N rate which settles on trade date
     spot_days = 0
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
     accrual = DayCountTypes.THIRTY_E_360
 
-    depo = IborDeposit(settleDt, "1D", 1.712 / 100.0, accrual)
+    depo = IborDeposit(settle_dt, "1D", 1.712 / 100.0, accrual)
     depos = [depo]
 
     futs = []
     fut = IborFuture(value_dt, 1)
     futs.append(fut)
     fut = IborFuture(value_dt, 2)
     futs.append(fut)
@@ -54,78 +54,78 @@
     fras[3] = futs[3].to_fra(97.2450, -0.00263)
     fras[4] = futs[4].to_fra(97.1450, -0.00411)
     fras[5] = futs[5].to_fra(97.0750, -0.00589)
 
     accrual = DayCountTypes.THIRTY_E_360
     freq = FrequencyTypes.SEMI_ANNUAL
     spot_days = 2
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
     payRec = SwapTypes.PAY
     lag = 1  # Not used
 
     swaps = []
-    swap = OIS(settleDt, "2Y", payRec,
+    swap = OIS(settle_dt, "2Y", payRec,
                (2.77417 + 2.77844) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "3Y", payRec,
+    swap = OIS(settle_dt, "3Y", payRec,
                (2.86098 + 2.86582) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "4Y", payRec,
+    swap = OIS(settle_dt, "4Y", payRec,
                (2.90240 + 2.90620) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "5Y", payRec,
+    swap = OIS(settle_dt, "5Y", payRec,
                (2.92944 + 2.92906) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "6Y", payRec,
+    swap = OIS(settle_dt, "6Y", payRec,
                (2.94001 + 2.94499) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "7Y", payRec,
+    swap = OIS(settle_dt, "7Y", payRec,
                (2.95352 + 2.95998) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "8Y", payRec,
+    swap = OIS(settle_dt, "8Y", payRec,
                (2.96830 + 2.97400) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "9Y", payRec,
+    swap = OIS(settle_dt, "9Y", payRec,
                (2.98403 + 2.98817) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "10Y", payRec,
+    swap = OIS(settle_dt, "10Y", payRec,
                (2.99716 + 3.00394) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "11Y", payRec,
+    swap = OIS(settle_dt, "11Y", payRec,
                (3.01344 + 3.01596) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "12Y", payRec,
+    swap = OIS(settle_dt, "12Y", payRec,
                (3.02276 + 3.02684) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "15Y", payRec,
+    swap = OIS(settle_dt, "15Y", payRec,
                (3.04092 + 3.04508) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "20Y", payRec,
+    swap = OIS(settle_dt, "20Y", payRec,
                (3.04417 + 3.05183) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "25Y", payRec,
+    swap = OIS(settle_dt, "25Y", payRec,
                (3.03219 + 3.03621) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "30Y", payRec,
+    swap = OIS(settle_dt, "30Y", payRec,
                (3.01030 + 3.01370) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "40Y", payRec,
+    swap = OIS(settle_dt, "40Y", payRec,
                (2.96946 + 2.97354) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "50Y", payRec,
+    swap = OIS(settle_dt, "50Y", payRec,
                (2.91552 + 2.93748) / 200, freq, accrual)
     swaps.append(swap)
 
     oisCurve = OISCurve(value_dt, depos, fras, swaps)
 
     # The valuation of 53714.55 is very close to the spreadsheet value 53713.96
     assert round(swaps[0].value(value_dt, oisCurve, None), 4) == 0.0
-    assert round(-swaps[0]._fixed_leg.value(value_dt,
+    assert round(-swaps[0].fixed_leg.value(value_dt,
                                             oisCurve), 4) == 53708.2780
-    assert round(swaps[0]._float_leg.value(
+    assert round(swaps[0].float_leg.value(
         value_dt, oisCurve, None), 4) == 53708.2780
 
-    assert round(swaps[0].value(settleDt, oisCurve, None), 4) == 0.0
-    assert round(-swaps[0]._fixed_leg.value(settleDt,
+    assert round(swaps[0].value(settle_dt, oisCurve, None), 4) == 0.0
+    assert round(-swaps[0].fixed_leg.value(settle_dt,
                                             oisCurve), 4) == 53714.3020
-    assert round(swaps[0]._float_leg.value(
-        settleDt, oisCurve, None), 4) == 53714.3020
+    assert round(swaps[0].float_leg.value(
+        settle_dt, oisCurve, None), 4) == 53714.3020
```

### Comparing `financepy-0.350/tests/test_FinSchedule.py` & `financepy-0.360/tests/test_FinSchedule.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,16 +10,16 @@
 from financepy.utils.calendar import BusDayAdjustTypes
 
 
 termination_date_adjust = True
 
 
 def check_frequency(schedule, start=0):
-    dates = schedule._adjusted_dts
-    diff_d1d2 = (schedule._termination_dt - schedule._effective_dt) / 365.0
+    dates = schedule.adjusted_dts
+    diff_d1d2 = (schedule.termination_dt - schedule.effective_dt) / 365.0
 
     for i in range(start, len(dates) - 2):
         diff = (dates[i+1] - dates[i]) / 365.0
         err = diff - (diff_d1d2 / (len(dates) - 1))
         print(err)
         assert round(err, 1) == 0.0
 
@@ -36,39 +36,39 @@
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 5
     check_frequency(schedule)
 
     freq_type = FrequencyTypes.QUARTERLY
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 9
     check_frequency(schedule)
 
     freq_type = FrequencyTypes.MONTHLY
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 25
     check_frequency(schedule)
 
 
 def test_forward_frequencies():
     # FORWARD SCHEDULES TESTING DIFFERENT FREQUENCIES
     cal_type = CalendarTypes.WEEKEND
@@ -82,38 +82,38 @@
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 3
     check_frequency(schedule)
 
     freq_type = FrequencyTypes.SEMI_ANNUAL
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 5
     check_frequency(schedule)
 
     freq_type = FrequencyTypes.MONTHLY
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 25
     check_frequency(schedule)
 
 
 def test_backward_front_stub():
     # BACKWARD SHORT STUB AT FRONT
     d1 = Date(20, 8, 2018)
@@ -127,15 +127,15 @@
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 9
     check_frequency(schedule, start=1)
 
     # BACKWARD SUPER SHORT STUB AT FRONT
     d1 = Date(19, 9, 2018)
     d2 = Date(20, 6, 2020)
 
@@ -147,15 +147,15 @@
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 9
     check_frequency(schedule, start=1)
 
 def test_forward_end_stub():
     # FORWARD SHORT STUB AT END
     termination_date_adjust = True
 
@@ -170,15 +170,15 @@
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 5
     check_frequency(schedule)
 
     d1 = Date(19, 9, 2018)
     d2 = Date(20, 6, 2020)
 
     freq_type = FrequencyTypes.QUARTERLY
@@ -188,15 +188,15 @@
 
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 9
     check_frequency(schedule)
 
     d1 = Date(20, 6, 2018)
     d2 = Date(20, 6, 2020)
 
     freq_type = FrequencyTypes.SEMI_ANNUAL
@@ -208,10 +208,10 @@
     schedule = Schedule(d1,
                         d2,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type,
                         termination_date_adjust)
-    adjusted_dts = schedule._adjusted_dts
+    adjusted_dts = schedule.adjusted_dts
     assert len(adjusted_dts) == 5
     check_frequency(schedule)
```

### Comparing `financepy-0.350/tests/test_FinSobol.py` & `financepy-0.360/tests/test_FinSobol.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinStatistics.py` & `financepy-0.360/tests/test_FinStatistics.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinSwapLegs.py` & `financepy-0.360/tests/test_FinSwapLegs.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_FinVasicekRateModel.py` & `financepy-0.360/tests/test_FinVasicekRateModel.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_date.py` & `financepy-0.360/tests/test_date.py`

 * *Files 1% similar despite different names*

```diff
@@ -22,20 +22,20 @@
 
 
 def test_from_string():
     assert Date.from_string("1-1-2018", "%d-%m-%Y") == Date(1, 1, 2018)
 
 
 def test_weekday():
-    assert Date(3, 3, 2021)._weekday == Date.WED
+    assert Date(3, 3, 2021).weekday == Date.WED
 
 
 def test_excel_representation():
-    assert Date(5, 1, 1900)._excel_dt == 5
-    assert Date(1, 3, 2020)._excel_dt == 43891
+    assert Date(5, 1, 1900).excel_dt == 5
+    assert Date(1, 3, 2020).excel_dt == 43891
 
 
 # tests not refactored below
 # - print() should be assert to value
 # - do not need many values, just one call
 # - some tests may be "parametrised" (probably not todo now)
```

### Comparing `financepy-0.350/tests/test_finite_difference.py` & `financepy-0.360/tests/test_finite_difference.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_finite_difference_PSOR.py` & `financepy-0.360/tests/test_finite_difference_PSOR.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests/test_lsmc.py` & `financepy-0.360/tests/test_lsmc.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/FinTestCases.py` & `financepy-0.360/tests_golden/FinTestCases.py`

 * *Files 0% similar despite different names*

```diff
@@ -343,16 +343,16 @@
                 if time_column is True:
                     time1 = float(golden_fields[col_num])
                     time2 = float(compare_fields[col_num])
                     change = (time2 / abs(time1 + 1e-10) - 1.0) * 100.0
 
                     if abs(change) > 50.0:
                         self.print_log("Row# ", row_num,
-                                      " WARNING: Calculation time has changed by %5.2f"
-                                      % change, " percent.")
+                                       " WARNING: Calculation time has changed by %5.2f"
+                                       % change, " percent.")
 
                     num_warnings += 1
 
         return (num_warnings, num_errors)
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinAmount.py` & `financepy-0.360/tests_golden/TestFinAmount.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinBond.py` & `financepy-0.360/tests_golden/TestFinBond.py`

 * *Files 2% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 
 ##########################################################################
 
-def build_Ibor_Curve(value_dt):
+def build_ibor_curve(value_dt):
     depoDCCType = DayCountTypes.THIRTY_E_360_ISDA
     depos = []
     deposit_rate = 0.050
 
     depo0 = IborDeposit(
         value_dt,
         "1D",
@@ -83,150 +83,149 @@
     depos.append(depo1)
     depos.append(depo2)
     depos.append(depo3)
     depos.append(depo4)
     depos.append(depo5)
 
     fras = []
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
 
     swaps = []
 
     swap_rate = 0.05
     maturity_dt = settle_dt.add_months(24)
     swap1 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
 
-    #    print(swap1._fixed_leg._payment_dts)
+    #    print(swap1.fixed_leg._payment_dts)
 
     swaps.append(swap1)
 
     maturity_dt = settle_dt.add_months(36)
     swap2 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap2)
 
-    #    print(swap2._fixed_leg._payment_dts)
+    #    print(swap2.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(48)
     swap3 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap3)
 
-    #    print(swap3._fixed_leg._payment_dts)
+    #    print(swap3.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(60)
     swap4 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap4)
 
-    #    print(swap4._fixed_leg._payment_dts)
+    #    print(swap4.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(72)
     swap5 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap5)
 
-    #    print(swap5._fixed_leg._payment_dts)
+    #    print(swap5.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(84)
     swap6 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap6)
 
-    #    print(swap6._fixed_leg._payment_dts)
+    #    print(swap6.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(96)
     swap7 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap7)
 
-    #    print(swap7._fixed_leg._payment_dts)
+    #    print(swap7.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(108)
     swap8 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap8)
 
-    #    print(swap8._fixed_leg._payment_dts)
+    #    print(swap8.fixed_leg._payment_dts)
 
     maturity_dt = settle_dt.add_months(120)
     swap9 = IborSwap(
         settle_dt,
         maturity_dt,
         SwapTypes.PAY,
         swap_rate,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap9)
 
-    #    print(swap9._fixed_leg._payment_dts)
+    #    print(swap9.fixed_leg._payment_dts)
 
     libor_curve = IborSingleCurve(value_dt,
                                   depos,
                                   fras,
                                   swaps)
 
     if 1 == 0:
         import numpy as np
         num_steps = 40
         dt = 10 / num_steps
         times = np.linspace(0.0, 10.0, num_steps + 1)
 
         df0 = 1.0
         for t in times[1:]:
-            df1 = libor_curve.df(t)
+            df1 = libor_curve._df(t)
             fwd = (df0 / df1 - 1.0) / dt
             print(t, df1, fwd)
             df0 = df1
 
     return libor_curve
 
-
 ##########################################################################
 
 
 def test_bond():
 
     import pandas as pd
     path = os.path.join(os.path.dirname(__file__), './/data//giltBondPrices.txt')
@@ -244,28 +243,28 @@
         test_cases.header("MATURITY", "COUPON", "CLEAN_PRICE", "ACCD_DAYS",
                           "ACCRUED", "YTM")
 
         for _, bond in bondDataFrame.iterrows():
             date_string = bond['maturity']
             mat_dt_time = dt.datetime.strptime(date_string, '%d-%b-%y')
             maturity_dt = from_datetime(mat_dt_time)
-            issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+            issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
 
             coupon = bond['coupon'] / 100.0
             clean_price = bond['mid']
             bond = Bond(issue_dt, maturity_dt,
                         coupon, freq_type, dc_type, ex_div_days)
 
             ytm = bond.yield_to_maturity(settle_dt, clean_price)
-            accrued_interest = bond._accrued_interest
-            accd_days = bond._accrued_days
+            accrued_int = bond.accrued_int
+            accd_days = bond.accrued_days
 
             test_cases.print("%18s" % maturity_dt, "%8.4f" % coupon,
                             "%10.4f" % clean_price, "%6.0f" % accd_days,
-                            "%10.4f" % accrued_interest, "%8.4f" % ytm)
+                            "%10.4f" % accrued_int, "%8.4f" % ytm)
 
     ###########################################################################
     #  EXAMPLE FROM http://bondtutor.com/btchp4/topic6/topic6.htm
 
     accrualConvention = DayCountTypes.ACT_ACT_ICMA
     y = 0.062267
     settle_dt = Date(19, 4, 1994)
@@ -327,15 +326,15 @@
     test_cases.header("FIELD", "VALUE")
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     asw = bond.asset_swap_spread(settle_dt, clean_price, flat_curve)
     test_cases.print("Discounted on Bond Curve ASW:", asw * 10000)
 
     # When the libor curve is the Libor curve then the ASW is positive
-    libor_curve = build_Ibor_Curve(settle_dt)
+    libor_curve = build_ibor_curve(settle_dt)
     asw = bond.asset_swap_spread(settle_dt, clean_price, libor_curve)
     oas = bond.option_adjusted_spread(
         settle_dt, clean_price, libor_curve)
     test_cases.print("Discounted on LIBOR Curve ASW:", asw * 10000)
     test_cases.print("Discounted on LIBOR Curve OAS:", oas * 10000)
 
     p = 90.0
@@ -405,15 +404,15 @@
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm,
                                             YTMCalcType.US_TREASURY)
     test_cases.print("Clean Price = ", clean_price)
 
     accrued_interest = bond.accrued_interest(settle_dt, face)
     test_cases.print("Accrued = ", accrued_interest)
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     test_cases.print("Accrued Days = ", accddays)
 
     duration = bond.dollar_duration(settle_dt, ytm, YTMCalcType.US_STREET)
     test_cases.print("Dollar Duration = ", duration)
 
     modified_duration = bond.modified_duration(settle_dt, ytm)
     test_cases.print("Modified Duration = ", modified_duration)
@@ -461,15 +460,15 @@
 
     dirty_price = bond.dirty_price_from_ytm(settle_dt, ytm)
     test_cases.print("Dirty Price", dirty_price)
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     test_cases.print("Clean Price", clean_price)
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     test_cases.print("Accrued Days", accddays)
 
     accrued_interest = bond.accrued_interest(settle_dt, face)
     test_cases.print("Accrued", accrued_interest)
 
     duration = bond.dollar_duration(settle_dt, ytm)
     test_cases.print("Dollar Duration", duration)
@@ -483,15 +482,15 @@
     conv = bond.convexity_from_ytm(settle_dt, ytm)
     test_cases.print("Convexity", conv)
 
 
 ###############################################################################
 
 
-def test_BondExDividend():
+def test_bond_ex_dividend():
 
     issue_dt = Date(7, 9, 2000)
     maturity_dt = Date(7, 9, 2020)
     coupon = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
     face = 100.0
@@ -499,70 +498,67 @@
     test_cases.header("LABEL", "VALUE")
 
     bond = Bond(issue_dt, maturity_dt, coupon,
                 freq_type, dc_type, ex_div_days)
     settle_dt = Date(7, 9, 2003)
     accrued = bond.accrued_interest(settle_dt, face)
 
-    test_cases.print("SettlementDate:", settle_dt)
+    test_cases.print("settle_dt:", settle_dt)
     test_cases.print("Accrued:", accrued)
 
     ###########################################################################
     test_cases.banner("=======================================================")
     test_cases.header("SETTLEMENT", "DIRTY PRICE", "ACCRUED", "CLEAN PRICE")
 
     issue_dt = Date(7, 9, 2000)
     maturity_dt = Date(7, 9, 2020)
     coupon = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
     face = 100.0
     ex_div_days = 7
 
-    bond = Bond(issue_dt, maturity_dt, coupon,
-                freq_type, dc_type, ex_div_days)
+    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type, ex_div_days)
 
     settle_dt = Date(25, 8, 2010)
 
     ytm = 0.05
 
     for _ in range(0, 13):
         settle_dt = settle_dt.add_days(1)
-        accrued = bond.accrued_interest(
-            settle_dt, face)
-        dirty_price = bond.dirty_price_from_ytm(
-            settle_dt, ytm)
+        accrued = bond.accrued_interest(settle_dt, face)
+        dirty_price = bond.dirty_price_from_ytm(settle_dt, ytm)
         clean_price = dirty_price - accrued
         test_cases.print(settle_dt, dirty_price, accrued, clean_price)
 
 ###############################################################################
 
 
-def test_BondPaymentDates():
+def test_bond_payment_dates():
 
     from financepy.products.bonds.bond import Bond
     from financepy.utils import Date, DayCountTypes, FrequencyTypes
 
     bond = Bond(issue_dt=Date(7, 6, 2021),
                 maturity_dt=Date(7, 6, 2031),
                 coupon=0.0341,
                 freq_type=FrequencyTypes.ANNUAL,
                 dc_type=DayCountTypes.ACT_ACT_ISDA
     )
     bond._calculate_payment_dts()
 
     if 1 == 0:
-        print(bond._flow_amounts)
-        print(bond._cpn_dts)
+        print(bond.flow_amounts)
+        print(bond.cpn_dts)
         print(bond._payment_dts)
 
 ###############################################################################
 
 
-def test_Bond_ror():
+def test_bond_ror():
 
     test_case_file = 'test_cases_bond_ror.csv'
     df = pd.read_csv('.//data//' + test_case_file, parse_dates=['buy_date',
                                                                 'sell_date'])
     # A 10-year bond with 1 coupon per year. code: 210215
 
     bond = Bond(
@@ -587,15 +583,15 @@
         test_cases.print(row.bond_code, buy_date, row.buy_ytm, buy_price,
                          sell_date, row.sell_ytm, sell_price,
                          simple, irr)
 
 
 ###############################################################################
 
-def test_Bond_eom():
+def test_bond_eom():
 
     # Bonds that mature on an EOM date have flows on EOM dates
     issue_dt = Date(30, 11, 2022)
     settle_dt = Date(6, 2, 2023)
     maturity_dt = Date(30, 11, 2024)
     coupon = 0.045
     freq_type = FrequencyTypes.SEMI_ANNUAL
@@ -613,15 +609,15 @@
 def test_key_rate_durations():
 
     issue_dt = Date(31, 7, 2022)
     maturity_dt = Date(31, 7, 2027)
     coupon = 0.0275
     ex_div_days = 0
 
-    dc_type, freq_type, settlementDays, exDiv, calendar = \
+    dc_type, freq_type, settle_days, exDiv, calendar = \
         get_bond_market_conventions(BondMarkets.UNITED_STATES)
 
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type, ex_div_days)
 
     settle_dt = Date(24, 4, 2023)
 
     ytm = 3.725060 / 100.0
@@ -630,26 +626,26 @@
 
 #    print(key_rate_tenors)
 #    print(key_rate_durations)
 
 ###############################################################################
 
 
-def test_key_rate_durations_Bloomberg_example():
+def test_key_rate_durations_bloomberg_example():
 
-    dc_type, frequencyType, settlementDays, exDiv, calendar =\
+    dc_type, frequencyType, settle_days, exDiv, calendar =\
         get_bond_market_conventions(BondMarkets.UNITED_STATES)
 
     # interest accrues on this date. Issue date is 01/08/2022
     issue_dt = Date(31, 7, 2022)
     maturity_dt = Date(31, 7, 2027)
     coupon = 2.75/100.0
     ex_div_days = 0
 
-    dc_type, freq_type, settlementDays, exDiv, calendar =\
+    dc_type, freq_type, settle_days, exDiv, calendar =\
         get_bond_market_conventions(BondMarkets.UNITED_STATES)
 
     bond = Bond(issue_dt, maturity_dt, coupon,
                 freq_type, dc_type, ex_div_days)
 
     settle_dt = Date(24, 4, 2023)
 
@@ -718,29 +714,29 @@
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type,
                 accrual_type, ex_div_days)
 
     print(bond)
 
     clean_price = 99.7808417  # if face is 1 then this must be 0.99780842
 
-    settlementDate = Date(15, 5, 2023)
-    print(bond.bond_payments(settlementDate, face))
+    settle_dt = Date(15, 5, 2023)
+    print(bond.bond_payments(settle_dt, face))
 
     current_yield = bond.current_yield(clean_price)*100
     print("Currnt Yield: %10.5f %%" % (current_yield))
 
-    ytm = bond.yield_to_maturity(settlementDate, clean_price) * 100.0
+    ytm = bond.yield_to_maturity(settle_dt, clean_price) * 100.0
     print("Yield to Mat: %10.5f %%" % (ytm))
 
 ###############################################################################
 
 
 test_bond()
 test_oas()
-test_BondExDividend()
-test_BondPaymentDates()
-test_Bond_ror()
-test_Bond_eom()
+test_bond_ex_dividend()
+test_bond_payment_dates()
+test_bond_ror()
+test_bond_eom()
 test_key_rate_durations()
-test_key_rate_durations_Bloomberg_example()
+test_key_rate_durations_bloomberg_example()
 
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinBondAnnuity.py` & `financepy-0.360/tests_golden/TestFinBondAnnuity.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,18 +45,18 @@
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
     test_cases.header("Date", "Flow")
-    num_flows = len(annuity._cpn_dts)
+    num_flows = len(annuity.cpn_dts)
     for i in range(1, num_flows):
-        dt = annuity._cpn_dts[i]
-        flow = annuity._flow_amounts[i]
+        dt = annuity.cpn_dts[i]
+        flow = annuity.flow_amounts[i]
         test_cases.print(dt, flow)
 
 #    print("===============================================================")
 #    print("QUARTERLY FREQUENCY")
 #    print("===============================================================")
 
     maturity_dt = Date(20, 6, 2028)
@@ -74,18 +74,18 @@
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
     test_cases.header("Date", "Flow")
-    num_flows = len(annuity._cpn_dts)
+    num_flows = len(annuity.cpn_dts)
     for i in range(1, num_flows):
-        dt = annuity._cpn_dts[i]
-        flow = annuity._flow_amounts[i]
+        dt = annuity.cpn_dts[i]
+        flow = annuity.flow_amounts[i]
         test_cases.print(dt, flow)
 
 #    print("==================================================================")
 #    print("MONTHLY FREQUENCY")
 #    print("==================================================================")
 
     maturity_dt = Date(20, 6, 2028)
@@ -103,18 +103,18 @@
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
     test_cases.header("Date", "Flow")
-    num_flows = len(annuity._cpn_dts)
+    num_flows = len(annuity.cpn_dts)
     for i in range(1, num_flows):
-        dt = annuity._cpn_dts[i]
-        flow = annuity._flow_amounts[i]
+        dt = annuity.cpn_dts[i]
+        flow = annuity.flow_amounts[i]
         test_cases.print(dt, flow)
 
 #    print("==================================================================")
 #    print("FORWARD GEN")
 #    print("==================================================================")
 
     maturity_dt = Date(20, 6, 2028)
@@ -132,18 +132,18 @@
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
     test_cases.header("Date", "Flow")
-    num_flows = len(annuity._cpn_dts)
+    num_flows = len(annuity.cpn_dts)
     for i in range(1, num_flows):
-        dt = annuity._cpn_dts[i]
-        flow = annuity._flow_amounts[i]
+        dt = annuity.cpn_dts[i]
+        flow = annuity.flow_amounts[i]
         test_cases.print(dt, flow)
 
 #    print("==================================================================")
 #    print("BACKWARD GEN WITH SHORT END STUB")
 #    print("==================================================================")
 
     maturity_dt = Date(20, 6, 2028)
@@ -161,18 +161,18 @@
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
     test_cases.header("Date", "Flow")
-    num_flows = len(annuity._cpn_dts)
+    num_flows = len(annuity.cpn_dts)
     for i in range(1, num_flows):
-        dt = annuity._cpn_dts[i]
-        flow = annuity._flow_amounts[i]
+        dt = annuity.cpn_dts[i]
+        flow = annuity.flow_amounts[i]
         test_cases.print(dt, flow)
 
 #    print("==================================================================")
 #    print("FORWARD GEN WITH LONG END STUB")
 #    print("==================================================================")
 
     maturity_dt = Date(20, 6, 2028)
@@ -190,18 +190,18 @@
                           bd_type,
                           dg_type,
                           basis_type)
 
     annuity.calculate_payments(settle_dt, face)
 
     test_cases.header("Date", "Flow")
-    num_flows = len(annuity._cpn_dts)
+    num_flows = len(annuity.cpn_dts)
     for i in range(1, num_flows):
-        dt = annuity._cpn_dts[i]
-        flow = annuity._flow_amounts[i]
+        dt = annuity.cpn_dts[i]
+        flow = annuity.flow_amounts[i]
         test_cases.print(dt, flow)
 
 ##########################################################################
 
 
 test_BondAnnuity()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinBondConvertible.py` & `financepy-0.360/tests_golden/TestFinBondConvertible.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,33 +28,33 @@
     maturity_dt = Date(15, 3, 2022)
     conversion_ratio = 38.4615  # adjust for face
     coupon = 0.0575
     freq_type = FrequencyTypes.SEMI_ANNUAL
     accrualBasis = DayCountTypes.ACT_365F
 
     call_price = 1100
-    call_dates = [Date(20, 3, 2007),
+    call_dts = [Date(20, 3, 2007),
                   Date(15, 3, 2012),
                   Date(15, 3, 2017)]
     call_prices = np.array([call_price, call_price, call_price])
 
     putPrice = 90
-    put_dates = [Date(20, 3, 2007),
+    put_dts = [Date(20, 3, 2007),
                  Date(15, 3, 2012),
                  Date(15, 3, 2017)]
     put_prices = np.array([putPrice, putPrice, putPrice])
 
     bond = BondConvertible(maturity_dt,
                            coupon,
                            freq_type,
                            start_convert_date,
                            conversion_ratio,
-                           call_dates,
+                           call_dts,
                            call_prices,
-                           put_dates,
+                           put_dts,
                            put_prices,
                            accrualBasis)
 #    print(bond)
 
     dividend_dts = [Date(20, 3, 2007),
                       Date(15, 3, 2008),
                       Date(15, 3, 2009),
```

### Comparing `financepy-0.350/tests_golden/TestFinBondEmbeddedOptionBK.py` & `financepy-0.360/tests_golden/TestFinBondEmbeddedOptionBK.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinBondEmbeddedOptionHW.py` & `financepy-0.360/tests_golden/TestFinBondFutures.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,187 +1,183 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-import matplotlib.pyplot as plt
-import time
-
 import sys
 sys.path.append("..")
 
 from FinTestCases import FinTestCases, globalTestCaseMode
-from financepy.products.bonds.bond_callable import BondEmbeddedOption
-from financepy.products.bonds.bond import Bond
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.products.rates.ibor_single_curve import IborSingleCurve
-from financepy.products.rates.ibor_swap import IborSwap
-from financepy.models.hw_tree import HWTree
+from financepy.utils.date import Date
 from financepy.utils.day_count import DayCountTypes
 from financepy.utils.frequency import FrequencyTypes
-from financepy.utils.date import Date
-from financepy.utils.global_types import SwapTypes
-
-test_cases = FinTestCases(__file__, globalTestCaseMode)
-
-plotGraphs = False
-
-###############################################################################
-
+from financepy.products.bonds.bond import Bond
+from financepy.products.bonds.bond_future import BondFuture
 
-def test_BondEmbeddedOptionMATLAB():
 
-    # https://fr.mathworks.com/help/fininst/optembndbyhw.html
-    # I FIND THAT THE PRICE CONVERGES TO 102.88 WHICH IS CLOSE TO 102.9127
-    # FOUND BY MATLAB ALTHOUGH THEY DO NOT EXAMINE THE ASYMPTOTIC PRICE
-    # WHICH MIGHT BE A BETTER MATCH
-
-    settle_dt = Date(1, 1, 2007)
-    value_dt = settle_dt
-
-    ###########################################################################
-
-    dcType = DayCountTypes.THIRTY_E_360
-    fixedFreq = FrequencyTypes.ANNUAL
-    fixed_leg_type = SwapTypes.PAY
-    swap1 = IborSwap(settle_dt, "1Y", fixed_leg_type,
-                     0.0350, fixedFreq, dcType)
-    swap2 = IborSwap(settle_dt, "2Y", fixed_leg_type,
-                     0.0400, fixedFreq, dcType)
-    swap3 = IborSwap(settle_dt, "3Y", fixed_leg_type,
-                     0.0450, fixedFreq, dcType)
-    swaps = [swap1, swap2, swap3]
-    discount_curve = IborSingleCurve(value_dt, [], [], swaps)
-
-    ###########################################################################
-
-    issue_dt = Date(1, 1, 2004)
-    maturity_dt = Date(1, 1, 2010)
-
-    coupon = 0.0525
-    freq_type = FrequencyTypes.ANNUAL
-    dc_type = DayCountTypes.ACT_ACT_ICMA
-    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
-
-    call_dts = []
-    call_prices = []
-    put_dts = []
-    put_prices = []
-
-    put_dt = Date(1, 1, 2008)
-    for _ in range(0, 24):
-        put_dts.append(put_dt)
-        put_prices.append(100)
-        put_dt = put_dt.add_months(1)
-
-    test_cases.header("BOND PRICE", "PRICE")
-    v = bond.clean_price_from_discount_curve(settle_dt, discount_curve)
-    test_cases.print("Bond Pure Price:", v)
-
-    sigma = 0.01  # basis point volatility
-    a = 0.1
-
-    puttable_bond = BondEmbeddedOption(issue_dt,
-                                       maturity_dt, coupon,
-                                       freq_type, dc_type,
-                                       call_dts, call_prices,
-                                       put_dts, put_prices)
-
-    test_cases.header("TIME", "Numtime_steps", "BondWithOption", "BondPure")
-
-    time_steps = range(50, 1000, 50)
-    values = []
-    for num_time_steps in time_steps:
-        model = HWTree(sigma, a, num_time_steps)
-        start = time.time()
-        v = puttable_bond.value(settle_dt, discount_curve, model)
-        end = time.time()
-        period = end - start
-        test_cases.print(period, num_time_steps, v['bondwithoption'],
-                         v['bondpure'])
-        values.append(v['bondwithoption'])
-
-    if plotGraphs:
-        plt.figure()
-        plt.plot(time_steps, values)
+test_cases = FinTestCases(__file__, globalTestCaseMode)
 
-###############################################################################
 
+def test_BondFuture():
 
-def test_BondEmbeddedOptionQUANTLIB():
+    # Example taken from Martellini and Priaulet page 360
+    freq = FrequencyTypes.SEMI_ANNUAL
+    basis = DayCountTypes.ACT_ACT_ICMA
+    issue_dt = Date(15, 2, 2004)
+
+    bond1 = Bond(issue_dt, Date(15, 8, 2011), 0.0500, freq, basis)
+    bond2 = Bond(issue_dt, Date(15, 2, 2011), 0.0500, freq, basis)
+    bond3 = Bond(issue_dt, Date(15, 8, 2010), 0.0575, freq, basis)
+    bond4 = Bond(issue_dt, Date(15, 2, 2010), 0.0650, freq, basis)
+    bond5 = Bond(issue_dt, Date(15, 8, 2009), 0.0600, freq, basis)
+    bond6 = Bond(issue_dt, Date(15, 5, 2009), 0.0550, freq, basis)
+    bond7 = Bond(issue_dt, Date(15, 11, 2008), 0.0475, freq, basis)
+
+    bonds = []
+    bonds.append(bond1)
+    bonds.append(bond2)
+    bonds.append(bond3)
+    bonds.append(bond4)
+    bonds.append(bond5)
+    bonds.append(bond6)
+    bonds.append(bond7)
+
+    first_delivery_dt = Date(1, 3, 2002)
+    last_delivery_dt = Date(28, 3, 2002)
+    contract_size = 100000
+    contractCoupon = 0.06
+
+    bondFutureContract = BondFuture("TYH2",
+                                    first_delivery_dt,
+                                    last_delivery_dt,
+                                    contract_size,
+                                    contractCoupon)
+
+    settle_dt = Date(10, 12, 2001)
+
+    # Get the Conversion Factors
+    test_cases.header("Bond Maturity", "Coupon", "Conversion Factor")
+    for bond in bonds:
+        cf = bondFutureContract.conversion_factor(bond)
+        test_cases.print(bond.maturity_dt, bond.cpn * 100, cf)
+
+    # Example from
+    # https://www.cmegroup.com/education/files/understanding-treasury-futures.pdf
+
+    test_cases.banner("EXAMPLE FROM CME")
+    test_cases.banner("================")
+    settle_dt = Date(10, 10, 2017)
+
+    bonds = []
+    prices = []
+
+    bond = Bond(issue_dt, Date(15, 8, 2027), 0.0225, freq, basis)
+    bonds.append(bond)
+    prices.append(99 + 1 / 32)
+
+    bond = Bond(issue_dt, Date(15, 5, 2027), 0.02375, freq, basis)
+    bonds.append(bond)
+    prices.append(100 + 5 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 2, 2027), 0.0225, freq, basis)
+    bonds.append(bond)
+    prices.append(99 + 5 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 11, 2026), 0.02, freq, basis)
+    bonds.append(bond)
+    prices.append(97 + 7 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 8, 2026), 0.015, freq, basis)
+    bonds.append(bond)
+    prices.append(93 + 14 / 32)
+
+    bond = Bond(issue_dt, Date(15, 5, 2026), 0.01625, freq, basis)
+    bonds.append(bond)
+    prices.append(94 + 21 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 2, 2026), 0.01625, freq, basis)
+    bonds.append(bond)
+    prices.append(94 + 29 / 32)
+
+    bond = Bond(issue_dt, Date(15, 11, 2025), 0.0225, freq, basis)
+    bonds.append(bond)
+    prices.append(99 + 25 / 32)
+
+    bond = Bond(issue_dt, Date(15, 8, 2025), 0.02, freq, basis)
+    bonds.append(bond)
+    prices.append(98 + 3 / 32)
+
+    bond = Bond(issue_dt, Date(15, 5, 2025), 0.02125, freq, basis)
+    bonds.append(bond)
+    prices.append(99 + 5 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 2, 2025), 0.02, freq, basis)
+    bonds.append(bond)
+    prices.append(98 + 14 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 11, 2024), 0.0225, freq, basis)
+    bonds.append(bond)
+    prices.append(100 + 9 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 8, 2024), 0.02375, freq, basis)
+    bonds.append(bond)
+    prices.append(101 + 7 / 32 + 1 / 64)
+
+    bond = Bond(issue_dt, Date(15, 8, 2024), 0.01875, freq, basis)
+    bonds.append(bond)
+    # There may be an error in the document says 98-01+
+    prices.append(98 + 1 / 32)
+
+    bonds.reverse()
+    prices.reverse()
+
+    test_cases.header("BOND MATURITY", "COUPON", "PRICE")
+    for bond, clean_price in zip(bonds, prices):
+        test_cases.print(str(bond.maturity_dt), str(bond.cpn), clean_price)
+
+    test_cases.header("BOND MATURITY", "COUPON", "YIELD")
+    for bond, clean_price in zip(bonds, prices):
+        yld = bond.yield_to_maturity(settle_dt, clean_price)
+        test_cases.print(str(bond.maturity_dt), str(bond.cpn), yld)
+
+    first_delivery_dt = Date(1, 12, 2017)
+    last_delivery_dt = Date(28, 12, 2017)
+
+    contract_size = 100000
+    contractCoupon = 0.06
+
+    bondFutureContract = BondFuture("TYZ7",
+                                    first_delivery_dt,
+                                    last_delivery_dt,
+                                    contract_size,
+                                    contractCoupon)
+
+    test_cases.header("BOND MATURITY", "COUPON", "CF")
+    for bond in bonds:
+        cf = bondFutureContract.conversion_factor(bond)
+        test_cases.print(str(bond.maturity_dt), str(bond.cpn), cf)
+
+    # Get the Invoice Prices
+    futures_price = 125.265625
+
+    test_cases.header("BOND MATURITY", "PRINCIPAL INVOICE PRICE")
+    for bond in bonds:
+        pip = bondFutureContract.principal_invoice_price(bond, futures_price)
+        test_cases.print(str(bond.maturity_dt), pip)
+
+    test_cases.header("BOND MATURITY", "TOTAL INVOICE AMOUNT")
+    for bond in bonds:
+        tia = bondFutureContract.total_invoice_amount(
+            settle_dt, bond, futures_price)
+        test_cases.print(str(bond.maturity_dt), tia)
+
+    ctd = bondFutureContract.cheapest_to_deliver(bonds,
+                                                 prices,
+                                                 futures_price)
 
-    # Based on example at the nice blog on Quantlib at
-    # http://gouthamanbalaraman.com/blog/callable-bond-quantlib-python.html
-    # I get a price of 68.97 for 1000 time steps which is higher than the
-    # 68.38 found in blog article. But this is for 40 grid points.
-    # Note also that a basis point vol of 0.120 is 12% which is VERY HIGH!
-
-    value_dt = Date(16, 8, 2016)
-    settle_dt = value_dt.add_weekdays(3)
-
-    ###########################################################################
-
-    discount_curve = DiscountCurveFlat(value_dt, 0.035,
-                                       FrequencyTypes.SEMI_ANNUAL)
-
-    ###########################################################################
-
-    issue_dt = Date(15, 9, 2010)
-    maturity_dt = Date(15, 9, 2022)
-    coupon = 0.025
-    freq_type = FrequencyTypes.QUARTERLY
-    dc_type = DayCountTypes.ACT_ACT_ICMA
-    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
-
-    ###########################################################################
-    # Set up the call and put times and prices
-    ###########################################################################
-
-    nextCallDate = Date(15, 9, 2016)
-    call_dts = [nextCallDate]
-    call_prices = [100.0]
-
-    for _ in range(1, 24):
-        nextCallDate = nextCallDate.add_months(3)
-        call_dts.append(nextCallDate)
-        call_prices.append(100.0)
-
-    put_dts = []
-    put_prices = []
-
-    # the value used in blog of 12% bp vol is unrealistic
-    sigma = 0.12  # basis point volatility
-    a = 0.03
-
-    puttable_bond = BondEmbeddedOption(issue_dt,
-                                      maturity_dt, coupon,
-                                      freq_type, dc_type,
-                                      call_dts, call_prices,
-                                      put_dts, put_prices)
-
-    test_cases.header("BOND PRICE", "PRICE")
-    v = bond.clean_price_from_discount_curve(settle_dt, discount_curve)
-    test_cases.print("Bond Pure Price:", v)
-
-    test_cases.header("TIME", "Numtime_steps", "BondWithOption", "BondPure")
-    time_steps = range(100, 200, 50)
-    values = []
-    for num_time_steps in time_steps:
-        model = HWTree(sigma, a, num_time_steps)
-        start = time.time()
-        v = puttable_bond.value(settle_dt, discount_curve, model)
-        end = time.time()
-        period = end - start
-        test_cases.print(period, num_time_steps,
-                        v['bondwithoption'], v['bondpure'])
-        values.append(v['bondwithoption'])
-
-    if plotGraphs:
-        plt.figure()
-        plt.title("Puttable Bond Price Convergence")
-        plt.plot(time_steps, values)
+    test_cases.header("CTD MATURITY", "CTD COUPON")
+    test_cases.print(str(ctd.maturity_dt), ctd.cpn)
 
-###############################################################################
+##########################################################################
 
 
-test_BondEmbeddedOptionMATLAB()
-test_BondEmbeddedOptionQUANTLIB()
+test_BondFuture()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinBondFRN.py` & `financepy-0.360/tests_golden/TestFinBondFRN.py`

 * *Files 11% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 
 
 def build_Ibor_Curve(value_dt):
 
     depoDCCType = DayCountTypes.THIRTY_E_360_ISDA
     depos = []
 
-    payFixed = SwapTypes.PAY
+    pay_fixed = SwapTypes.PAY
 
     spot_days = 2
     settle_dt = value_dt.add_weekdays(spot_days)
 
     deposit_rate = 0.050
     maturity_dt = settle_dt.add_months(1)
     depo1 = IborDeposit(
@@ -70,108 +70,108 @@
     depos.append(depo1)
     depos.append(depo2)
     depos.append(depo3)
     depos.append(depo4)
     depos.append(depo5)
 
     fras = []
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
 
     swaps = []
 
     swap_rate = 0.05
     maturity_dt = settle_dt.add_months(24)
     swap1 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap1)
 
     maturity_dt = settle_dt.add_months(36)
     swap2 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap2)
 
     maturity_dt = settle_dt.add_months(48)
     swap3 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap3)
 
     maturity_dt = settle_dt.add_months(60)
     swap4 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap4)
 
     maturity_dt = settle_dt.add_months(72)
     swap5 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap5)
 
     maturity_dt = settle_dt.add_months(84)
     swap6 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap6)
 
     maturity_dt = settle_dt.add_months(96)
     swap7 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap7)
 
     maturity_dt = settle_dt.add_months(108)
     swap8 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap8)
 
     maturity_dt = settle_dt.add_months(120)
     swap9 = IborSwap(
         settle_dt,
         maturity_dt,
         swap_rate,
-        payFixed,
+        pay_fixed,
         fixed_freq_type,
-        fixedDCCType)
+        fixed_dcc_type)
     swaps.append(swap9)
 
     libor_curve = IborSingleCurve(value_dt,
                                   depos,
                                   fras,
                                   swaps)
 
@@ -179,15 +179,15 @@
         import numpy as np
         num_steps = 40
         dt = 10 / num_steps
         times = np.linspace(0.0, 10.0, num_steps + 1)
 
         df0 = 1.0
         for t in times[1:]:
-            df1 = libor_curve.df(t)
+            df1 = libor_curve._df(t)
             fwd = (df0 / df1 - 1.0) / dt
             print(t, df1, fwd)
             df0 = df1
 
     return libor_curve
 
 ##########################################################################
@@ -237,21 +237,21 @@
                                          resetIbor,
                                          current_ibor,
                                          future_ibors,
                                          dm)
 
     test_cases.print("Dirty Price = ", dirty_price)
 
-    lastCouponDt = bond._pcd
+    lastCouponDt = bond.pcd
     test_cases.print("Last Coupon Date = ", str(lastCouponDt))
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     test_cases.print("Accrued Days = ", accddays)
 
-    accdAmount = bond._accrued_interest
+    accdAmount = bond.accrued_int
     test_cases.print("Accrued Amount = ", accdAmount)
 
     principal = bond.principal(settle_dt,
                                resetIbor,
                                current_ibor,
                                future_ibors,
                                dm)
@@ -344,21 +344,21 @@
                                          resetIbor,
                                          current_ibor,
                                          future_ibors,
                                          dm)
 
     test_cases.print("Dirty Price = ", dirty_price)
 
-    lastCouponDt = bond._pcd
+    lastCouponDt = bond.pcd
     test_cases.print("Last Coupon Date = ", str(lastCouponDt))
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     test_cases.print("Accrued Days = ", accddays)
 
-    accdAmount = bond._accrued_interest
+    accdAmount = bond.accrued_int
     test_cases.print("Accrued Amount = ", accdAmount)
 
     principal = bond.principal(settle_dt,
                                resetIbor,
                                current_ibor,
                                future_ibors,
                                dm)
```

### Comparing `financepy-0.350/tests_golden/TestFinBondMortgage.py` & `financepy-0.360/tests_golden/TestFinBondMortgage.py`

 * *Files 11% similar despite different names*

```diff
@@ -23,37 +23,37 @@
     start_dt = Date(23, 2, 2018)
     end_dt = start_dt.add_tenor("10Y")
     mortgage = BondMortgage(start_dt, end_dt, principal)
 
     rate = 0.035
     mortgage.generate_flows(rate, BondMortgageTypes.REPAYMENT)
 
-    num_flows = len(mortgage._schedule._adjusted_dts)
+    num_flows = len(mortgage.schedule.adjusted_dts)
 
     test_cases.header("PAYMENT DATE", "INTEREST", "PRINCIPAL", "OUTSTANDING",
                       "TOTAL")
 
     for i in range(0, num_flows):
-        test_cases.print(mortgage._schedule._adjusted_dts[i],
-                         mortgage._interest_flows[i],
-                         mortgage._principal_flows[i],
-                         mortgage._principal_remaining[i],
-                         mortgage._total_flows[i])
+        test_cases.print(mortgage.schedule.adjusted_dts[i],
+                         mortgage.interest_flows[i],
+                         mortgage.principal_flows[i],
+                         mortgage.principal_remaining[i],
+                         mortgage.total_flows[i])
 
     mortgage.generate_flows(rate, BondMortgageTypes.INTEREST_ONLY)
 
     test_cases.header("PAYMENT DATE", "INTEREST", "PRINCIPAL", "OUTSTANDING",
                       "TOTAL")
 
     for i in range(0, num_flows):
-        test_cases.print(mortgage._schedule._adjusted_dts[i],
-                         mortgage._interest_flows[i],
-                         mortgage._principal_flows[i],
-                         mortgage._principal_remaining[i],
-                         mortgage._total_flows[i])
+        test_cases.print(mortgage.schedule.adjusted_dts[i],
+                         mortgage.interest_flows[i],
+                         mortgage.principal_flows[i],
+                         mortgage.principal_remaining[i],
+                         mortgage.total_flows[i])
 
 
 ###############################################################################
 
 
 test_BondMortgage()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinBondOptionBDTModel.py` & `financepy-0.360/tests_golden/TestFinBondOptionBDTModel.py`

 * *Files 0% similar despite different names*

```diff
@@ -53,16 +53,15 @@
 
     strikes = [80, 100, 120]
 
     option_type = OptionTypes.EUROPEAN_CALL
 
     test_cases.header("LABEL", "VALUE")
 
-    price = bond.dirty_price_from_discount_curve(
-        settle_dt, discount_curve)
+    price = bond.dirty_price_from_discount_curve(settle_dt, discount_curve)
     test_cases.print("Fixed Income Price:", price)
 
     num_time_steps = 100
 
     test_cases.header("OPTION TYPE AND MODEL", "STRIKE", "VALUE")
 
     for strike_price in strikes:
@@ -342,16 +341,15 @@
 
 
 def test_BondOptionZEROVOLConvergence():
 
     # Build discount curve
     settle_dt = Date(1, 12, 2019)  # CHANGED
     rate = 0.05
-    discount_curve = DiscountCurveFlat(
-        settle_dt, rate, FrequencyTypes.ANNUAL)
+    discount_curve = DiscountCurveFlat(settle_dt, rate, FrequencyTypes.ANNUAL)
 
     # Bond details
     issue_dt = Date(1, 9, 2015)
     maturity_dt = Date(1, 9, 2025)
     coupon = 0.06
     freq_type = FrequencyTypes.ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
@@ -364,15 +362,15 @@
     dfExpiry = discount_curve.df(expiry_dt)
     spotCleanValue = bond.clean_price_from_discount_curve(
         settle_dt, discount_curve)
     fwdCleanValue = bond.clean_price_from_discount_curve(
         expiry_dt, discount_curve)
 #    print("BOND SpotCleanBondPx", spotCleanValue)
 #    print("BOND FwdCleanBondPx", fwdCleanValue)
-#    print("BOND Accrued:", bond._accrued_interest)
+#    print("BOND Accrued:", bond.accrued_int)
 
     spotCleanValue = bond.clean_price_from_discount_curve(
         settle_dt, discount_curve)
 
     test_cases.header("STRIKE", "STEPS",
                       "CALL_INT", "CALL_INT_PV", "CALL_EUR", "CALL_AMER",
                       "PUT_INT", "PUT_INT_PV", "PUT_EUR", "PUT_AMER")
```

### Comparing `financepy-0.350/tests_golden/TestFinBondOptionBKModel.py` & `financepy-0.360/tests_golden/TestFinBondOptionBKModel.py`

 * *Files 0% similar despite different names*

```diff
@@ -370,15 +370,15 @@
     dfExpiry = discount_curve.df(expiry_dt)
     fwdCleanValue = bond.clean_price_from_discount_curve(
         expiry_dt, discount_curve)
     fwdFullValue = bond.dirty_price_from_discount_curve(
         expiry_dt, discount_curve)
 #    print("BOND FwdCleanBondPx", fwdCleanValue)
 #    print("BOND FwdFullBondPx", fwdFullValue)
-#    print("BOND Accrued:", bond._accrued_interest)
+#    print("BOND Accrued:", bond.accrued_int)
 
     spotCleanValue = bond.clean_price_from_discount_curve(
         settle_dt, discount_curve)
 
     test_cases.header("STRIKE", "STEPS",
                      "CALL_INT", "CALL_INT_PV", "CALL_EUR", "CALL_AMER",
                      "PUT_INT", "PUT_INT_PV", "PUT_EUR", "PUT_AMER")
```

### Comparing `financepy-0.350/tests_golden/TestFinBondOptionHWModel.py` & `financepy-0.360/tests_golden/TestFinBondOptionHWModel.py`

 * *Files 1% similar despite different names*

```diff
@@ -397,15 +397,15 @@
 
     dfExpiry = discount_curve.df(expiry_dt)
     fwdCleanValue = bond.clean_price_from_discount_curve(
         expiry_dt, discount_curve)
 #    fwdFullValue = bond.dirty_price_from_discount_curve(expiry_dt, discount_curve)
 #    print("BOND FwdCleanBondPx", fwdCleanValue)
 #    print("BOND FwdFullBondPx", fwdFullValue)
-#    print("BOND Accrued:", bond._accrued_interest)
+#    print("BOND Accrued:", bond.accrued_int)
 
     spotCleanValue = bond.clean_price_from_discount_curve(
         settle_dt, discount_curve)
 
     test_cases.header("STRIKE", "STEPS",
                      "CALL_INT", "CALL_INT_PV", "CALL_EUR", "CALL_AMER",
                      "PUT_INT", "PUT_INT_PV", "PUT_EUR", "PUT_AMER")
@@ -491,21 +491,21 @@
 
     # ec = europeanCallBondOption.value(settle_dt, discount_curve, modelHW)
 
     ###########################################################################
 
     couponTimes = []
     couponFlows = []
-    cpn = bond._cpn / bond._freq
+    cpn = bond.cpn / bond.freq
 
-    numFlows = len(bond._cpn_dts)
+    numFlows = len(bond.cpn_dts)
     for i in range(0, numFlows):
 
-        pcd = bond._cpn_dts[i-1]
-        ncd = bond._cpn_dts[i]
+        pcd = bond.cpn_dts[i-1]
+        ncd = bond.cpn_dts[i]
 
         if ncd > settle_dt:
 
             if len(couponTimes) == 0:
                 flowTime = (pcd - settle_dt) / gDaysInYear
                 couponTimes.append(flowTime)
                 couponFlows.append(cpn)
@@ -531,15 +531,15 @@
 
     # Jamshidian approach
     vjam = model.european_bond_option_jamshidian(t_exp, strike_price, face,
                                                  couponTimes, couponFlows,
                                                  times, dfs)
     # print("Jamshidian:", vjam)
 
-    model._num_time_steps = 100
+    model.num_time_steps = 100
     model.build_tree(t_mat, times, dfs)
     exerciseType = FinExerciseTypes.EUROPEAN
 
     vHW = model.bond_option(t_exp, strike_price, face,
                             couponTimes, couponFlows, exerciseType)
 
     # print("Full Tree:", vHW)
```

### Comparing `financepy-0.350/tests_golden/TestFinBondPortfolio.py` & `financepy-0.360/tests_golden/TestFinBondPortfolio.py`

 * *Files 1% similar despite different names*

```diff
@@ -37,15 +37,15 @@
         if dc_type == DayCountTypes.ZERO:
             continue
         for _, bond in bondDataFrame.iterrows():
 
             date_string = bond['maturity']
             mat_date_time = dt.datetime.strptime(date_string, '%d-%b-%y')
             maturity_dt = from_datetime(mat_date_time)
-            issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+            issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
             coupon = bond['coupon']/100.0
             clean_price = bond['mid']
 
             bond = Bond(issue_dt, maturity_dt,
                         coupon, freq_type, dc_type)
 
             ytm = bond.yield_to_maturity(settle_dt, clean_price)
```

### Comparing `financepy-0.350/tests_golden/TestFinBondYieldCurve.py` & `financepy-0.360/tests_golden/TestFinBondYieldCurve.py`

 * *Files 10% similar despite different names*

```diff
@@ -44,15 +44,15 @@
     ylds = []
 
     for _, bond in bondDataFrame.iterrows():
 
         date_string = bond['maturity']
         mat_date_time = dt.datetime.strptime(date_string, '%d-%b-%y')
         maturity_dt = from_datetime(mat_date_time)
-        issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+        issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
         coupon = bond['coupon']/100.0
         clean_price = bond['mid']
         bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
         yld = bond.yield_to_maturity(settlement, clean_price)
         bonds.append(bond)
         ylds.append(yld)
 
@@ -77,37 +77,37 @@
     curve_fitter = CurveFitBSpline()
     fitted_curve5 = BondYieldCurve(settlement, bonds, ylds, curve_fitter)
 #    fitted_curve5.display("GBP Yield Curve")
 
 ###############################################################################
 
     test_cases.header("PARAMETER", "VALUE")
-    test_cases.print("values", fitted_curve1._curve_fit._coeffs)
+    test_cases.print("values", fitted_curve1.curve_fit.coeffs)
 
     test_cases.header("PARAMETER", "VALUE")
-    test_cases.print("values", fitted_curve2._curve_fit._coeffs)
+    test_cases.print("values", fitted_curve2.curve_fit.coeffs)
 
     test_cases.header("PARAMETER", "VALUE")
-    test_cases.print("beta_1", fitted_curve3._curve_fit._beta_1)
-    test_cases.print("beta_2", fitted_curve3._curve_fit._beta_2)
-    test_cases.print("beta_3", fitted_curve3._curve_fit._beta_3)
-    test_cases.print("tau", fitted_curve3._curve_fit._tau)
+    test_cases.print("beta_1", fitted_curve3.curve_fit.beta_1)
+    test_cases.print("beta_2", fitted_curve3.curve_fit.beta_2)
+    test_cases.print("beta_3", fitted_curve3.curve_fit.beta_3)
+    test_cases.print("tau", fitted_curve3.curve_fit.tau)
 
     test_cases.header("PARAMETER", "VALUE")
-    test_cases.print("beta_1", fitted_curve4._curve_fit._beta_1)
-    test_cases.print("beta_2", fitted_curve4._curve_fit._beta_2)
-    test_cases.print("beta_3", fitted_curve4._curve_fit._beta_3)
-    test_cases.print("beta_4", fitted_curve4._curve_fit._beta_4)
-    test_cases.print("tau_1", fitted_curve4._curve_fit._tau_1)
-    test_cases.print("tau_2", fitted_curve4._curve_fit._tau_2)
+    test_cases.print("beta_1", fitted_curve4.curve_fit.beta_1)
+    test_cases.print("beta_2", fitted_curve4.curve_fit.beta_2)
+    test_cases.print("beta_3", fitted_curve4.curve_fit.beta_3)
+    test_cases.print("beta_4", fitted_curve4.curve_fit.beta_4)
+    test_cases.print("tau_1", fitted_curve4.curve_fit.tau_1)
+    test_cases.print("tau_2", fitted_curve4.curve_fit.tau_2)
 
 ###############################################################################
 
     maturity_dt = Date(19, 9, 2030)
-    interpolated_yield = fitted_curve5.interpolated_yield(maturity_dt)
-    test_cases.print(maturity_dt, interpolated_yield)
+    interp_yield = fitted_curve5.interp_yield(maturity_dt)
+    test_cases.print(maturity_dt, interp_yield)
 
 ###############################################################################
 
 
 test_BondYieldCurve()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinBondZeroCoupon.py` & `financepy-0.360/tests_golden/TestFinBondZeroCoupon.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinBondZeroCurve.py` & `financepy-0.360/tests_golden/TestFinBondZeroCurve.py`

 * *Files 5% similar despite different names*

```diff
@@ -37,15 +37,15 @@
     bonds = []
     clean_prices = []
 
     for _, bondRow in bondDataFrame.iterrows():
         date_string = bondRow['maturity']
         mat_date_time = dt.datetime.strptime(date_string, '%d-%b-%y')
         maturity_dt = from_datetime(mat_date_time)
-        issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+        issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
         coupon = bondRow['coupon']/100.0
         clean_price = bondRow['mid']
         bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
         bonds.append(bond)
         clean_prices.append(clean_price)
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinCDS.py` & `financepy-0.360/tests_golden/TestFinCDS.py`

 * *Files 6% similar despite different names*

```diff
@@ -90,15 +90,15 @@
     value_dt = Date(20, 6, 2018)
     recovery_rate = 0.40
 
     cds_contracts, issuer_curve = test_IssuerCurveBuild()
     test_cases.header("CDS_MATURITY_dt", "PAR_SPREAD")
     for cds in cds_contracts:
         spd = cds.par_spread(value_dt, issuer_curve, recovery_rate)
-        test_cases.print(str(cds._maturity_dt), spd * 10000.0)
+        test_cases.print(str(cds.maturity_dt), spd * 10000.0)
 
 ##########################################################################
 
 
 def test_CDSCurveBuildTiming():
 
     num_curves = 1000
@@ -130,42 +130,42 @@
                                 dates,
                                 discount_factors,
                                 InterpTypes.FLAT_FWD_RATES)
     recovery_rate = 0.40
 
     cds_contracts = []
 
-    cds_coupon = 0.005  # 50 bps
+    cds_cpn = 0.005  # 50 bps
     maturity_dt = value_dt.add_months(12)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cds_contracts.append(cds)
 
-    cds_coupon = 0.0055
+    cds_cpn = 0.0055
     maturity_dt = value_dt.add_months(24)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cds_contracts.append(cds)
 
-    cds_coupon = 0.0060
+    cds_cpn = 0.0060
     maturity_dt = value_dt.add_months(36)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cds_contracts.append(cds)
 
-    cds_coupon = 0.0065
+    cds_cpn = 0.0065
     maturity_dt = value_dt.add_months(60)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cds_contracts.append(cds)
 
-    cds_coupon = 0.0070
+    cds_cpn = 0.0070
     maturity_dt = value_dt.add_months(84)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cds_contracts.append(cds)
 
-    cds_coupon = 0.0073
+    cds_cpn = 0.0073
     maturity_dt = value_dt.add_months(120)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cds_contracts.append(cds)
 
     issuer_curve = CDSCurve(value_dt,
                             cds_contracts,
                             libor_curve,
                             recovery_rate)
 
@@ -319,50 +319,50 @@
         dcType)
     swaps.append(swap10)
 
     libor_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     cdsMarketContracts = []
 
-    cds_coupon = 0.04 + mktSpreadBump
+    cds_cpn = 0.04 + mktSpreadBump
 
     maturity_dt = value_dt.next_cds_date(6)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(12)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(24)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(36)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(48)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(60)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(84)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(120)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     maturity_dt = value_dt.next_cds_date(180)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -377,26 +377,26 @@
 
     mktSpread = 0.040
 
     test_cases.header("Example", "Markit 9 Aug 2019")
 
     libor_curve, issuer_curve = buildFullIssuerCurve1(0.0, 0.0)
 
-    # This is the 10 year contract at an off market coupon
+    # This is the 10 year contract at an off market cpn
     maturity_dt = Date(20, 6, 2029)
-    cds_coupon = 0.0150
+    cds_cpn = 0.0150
     notional = ONE_MILLION
     long_protection = True
     tradeDate = Date(9, 8, 2019)
     value_dt = tradeDate.add_days(1)
     effective_dt = value_dt
 
     cds_contract = CDS(effective_dt,
                        maturity_dt,
-                       cds_coupon,
+                       cds_cpn,
                        notional,
                        long_protection)
 
     cdsRecovery = 0.40
 
     test_cases.header("LABEL", "VALUE")
     spd = cds_contract.par_spread(
@@ -416,26 +416,26 @@
 
     accrued_days = cds_contract.accrued_days()
     test_cases.print("ACCRUED_DAYS", accrued_days)
 
     accrued_interest = cds_contract.accrued_interest()
     test_cases.print("ACCRUED_COUPON", accrued_interest)
 
-    prot_pv = cds_contract.protection_leg_pv(
+    prot_pv = cds_contract.prot_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
-    test_cases.print("PROTECTION_PV", prot_pv)
+    test_cases.print("prot_PV", prot_pv)
 
     premPV = cds_contract.premium_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PREMIUM_PV", premPV)
 
-    dirtyRPV01, cleanRPV01 = cds_contract.risky_pv01(
+    dirty_rpv01, clean_rpv01 = cds_contract.risky_pv01(
         value_dt, issuer_curve)
-    test_cases.print("DIRTY_RPV01", dirtyRPV01)
-    test_cases.print("CLEAN_RPV01", cleanRPV01)
+    test_cases.print("DIRTY_RPV01", dirty_rpv01)
+    test_cases.print("CLEAN_RPV01", clean_rpv01)
 
     # cds_contract.print_payments(issuer_curve)
 
     bump = 1.0 / 10000.0  # 1 bp
 
     libor_curve, issuer_curve = buildFullIssuerCurve1(bump, 0)
     v_bump = cds_contract.value(value_dt, issuer_curve, cdsRecovery)
@@ -540,40 +540,40 @@
         m * 0.003290 + irBump,
         fixedFreq,
         dcType)
     swaps.append(swap4)
 
     libor_curve = IborSingleCurve(value_dt, depos, [], swaps)
 
-    cds_coupon = 0.01 + mktSpreadBump
+    cds_cpn = 0.01 + mktSpreadBump
 
     cdsMarketContracts = []
     effective_dt = Date(21, 8, 2020)
-    cds = CDS(effective_dt, "6M", cds_coupon)
+    cds = CDS(effective_dt, "6M", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "1Y", cds_coupon)
+    cds = CDS(effective_dt, "1Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "2Y", cds_coupon)
+    cds = CDS(effective_dt, "2Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "3Y", cds_coupon)
+    cds = CDS(effective_dt, "3Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "4Y", cds_coupon)
+    cds = CDS(effective_dt, "4Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "5Y", cds_coupon)
+    cds = CDS(effective_dt, "5Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "7Y", cds_coupon)
+    cds = CDS(effective_dt, "7Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds = CDS(effective_dt, "10Y", cds_coupon)
+    cds = CDS(effective_dt, "10Y", cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(settle_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -594,26 +594,26 @@
 
 def test_dirty_priceCDSModelCheck():
 
     test_cases.print("Example", "MARKIT CHECK 19 Aug 2020")
 
     libor_curve, issuer_curve = buildFullIssuerCurve2(0.0, 0.0)
 
-    # This is the 10 year contract at an off market coupon
+    # This is the 10 year contract at an off market cpn
     maturity_dt = Date(20, 6, 2025)
-    cds_coupon = 0.050
+    cds_cpn = 0.050
     notional = ONE_MILLION
     long_protection = True
     tradeDate = Date(20, 8, 2020)
     effective_dt = Date(21, 8, 2020)
     value_dt = tradeDate
 
     cds_contract = CDS(effective_dt,
                        maturity_dt,
-                       cds_coupon,
+                       cds_cpn,
                        notional,
                        long_protection)
 
     cdsRecovery = 0.40
 
     test_cases.header("LABEL", "VALUE")
     spd = cds_contract.par_spread(
@@ -631,17 +631,17 @@
 
     accrued_days = cds_contract.accrued_days()
     test_cases.print("ACCRUED_DAYS", accrued_days)
 
     accrued_interest = cds_contract.accrued_interest()
     test_cases.print("ACCRUED_COUPON", accrued_interest)
 
-    prot_pv = cds_contract.protection_leg_pv(
+    prot_pv = cds_contract.prot_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
-    test_cases.print("PROTECTION_PV", prot_pv)
+    test_cases.print("prot_PV", prot_pv)
 
     premPV = cds_contract.premium_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PREMIUM_PV", premPV)
 
     rpv01 = cds_contract.risky_pv01(value_dt, issuer_curve)
     test_cases.print("FULL_RPV01", rpv01['dirty_rpv01'])
@@ -676,25 +676,25 @@
 ##########################################################################
 
 
 def test_dirty_priceCDSConvergence():
 
     _, issuer_curve = buildFullIssuerCurve1(0.0, 0.0)
 
-    # This is the 10 year contract at an off market coupon
+    # This is the 10 year contract at an off market cpn
     maturity_dt = Date(20, 6, 2029)
-    cds_coupon = 0.0150
+    cds_cpn = 0.0150
     notional = ONE_MILLION
     long_protection = False
     tradeDate = Date(9, 8, 2019)
     value_dt = tradeDate.add_days(1)
 
     cds_contract = CDS(value_dt,
                        maturity_dt,
-                       cds_coupon,
+                       cds_cpn,
                        notional,
                        long_protection)
 
     cdsRecovery = 0.40
 
     test_cases.header("NumSteps", "Value")
     for n in [10, 50, 100, 500, 1000]:
@@ -703,38 +703,39 @@
         test_cases.print(n, v_dirty)
 
 ##########################################################################
 
 
 def test_CDSDateGeneration():
 
-    # This is the 10 year contract at an off market coupon
+    # This is the 10 year contract at an off market cpn
     maturity_dt = Date(20, 6, 2029)
-    cds_coupon = 0.0100
+    cds_cpn = 0.0100
 
     tradeDate = Date(9, 8, 2019)
     value_dt = tradeDate.add_days(1)
 
     cds_contract = CDS(value_dt,
                        maturity_dt,
-                       cds_coupon,
+                       cds_cpn,
                        ONE_MILLION,
                        True,
                        FrequencyTypes.QUARTERLY,
                        DayCountTypes.ACT_360,
                        CalendarTypes.WEEKEND,
                        BusDayAdjustTypes.FOLLOWING,
                        DateGenRuleTypes.BACKWARD)
 
     test_cases.header("Flow Date", "AccrualFactor", "Flow")
-    num_flows = len(cds_contract._payment_dts)
+    num_flows = len(cds_contract.payment_dts)
     for n in range(0, num_flows):
         test_cases.print(str(
-            cds_contract._payment_dts[n]), cds_contract._accrual_factors[n],
-            cds_contract._flows[n])
+            cds_contract.payment_dts[n]),
+            cds_contract.accrual_factors[n],
+            cds_contract.flows[n])
 
 ##########################################################################
 
 
 test_CDSCurveBuildTiming()
 test_dirty_priceCDSModelCheck()
 test_CDSDateGeneration()
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSBasket.py` & `financepy-0.360/tests_golden/TestFinCDSBasket.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinCDSCurve.py` & `financepy-0.360/tests_golden/TestFinCDSCurve.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-import numpy as np
-
 import sys
 sys.path.append("..")
 
+import numpy as np
+
 from FinTestCases import FinTestCases, globalTestCaseMode
 from financepy.utils.global_types import SwapTypes
 from financepy.utils.date import Date
 from financepy.utils.day_count import DayCountTypes
 from financepy.utils.frequency import FrequencyTypes
 from financepy.utils.calendar import CalendarTypes
 from financepy.utils.calendar import BusDayAdjustTypes
@@ -33,23 +33,23 @@
 
     swaps = []
     depos = []
     fras = []
 
     fixedDCC = DayCountTypes.ACT_365F
     fixedFreq = FrequencyTypes.SEMI_ANNUAL
-    fixed_coupon = 0.05
+    fixed_cpn = 0.05
 
     for i in range(1, 11):
 
         maturity_dt = curve_dt.add_months(12 * i)
         swap = IborSwap(curve_dt,
                         maturity_dt,
                         SwapTypes.PAY,
-                        fixed_coupon,
+                        fixed_cpn,
                         fixedFreq,
                         fixedDCC)
         swaps.append(swap)
 
     libor_curve = IborSingleCurve(curve_dt, depos, fras, swaps)
 
     cds_contracts = []
@@ -102,26 +102,26 @@
 
 
 def test_CDS_recovery_rate():
 
     value_dt = Date(15, 8, 2022)
     settle_dt = value_dt
 
-    swapType = SwapTypes.PAY
+    swap_type = SwapTypes.PAY
     dcType = DayCountTypes.ACT_360
     fixedFreq = FrequencyTypes.MONTHLY
-    swap1 = IborSwap(settle_dt,"2Y",swapType,0.03512100,fixedFreq,dcType)
-    swap2 = IborSwap(settle_dt,"3Y",swapType,0.03259300,fixedFreq,dcType)
-    swap3 = IborSwap(settle_dt,"4Y",swapType,0.03069300,fixedFreq,dcType)
-    swap4 = IborSwap(settle_dt,"5Y",swapType,0.02952200,fixedFreq,dcType)
-    swap5 = IborSwap(settle_dt,"6Y",swapType,0.02889300,fixedFreq,dcType)
-    swap6 = IborSwap(settle_dt,"7Y",swapType,0.02850200,fixedFreq,dcType)
-    swap7 = IborSwap(settle_dt,"8Y",swapType,0.02827400,fixedFreq,dcType)
-    swap8 = IborSwap(settle_dt,"9Y",swapType,0.02818500,fixedFreq,dcType)
-    swap9 = IborSwap(settle_dt,"10Y",swapType,0.02823000,fixedFreq,dcType)
+    swap1 = IborSwap(settle_dt,"2Y",swap_type,0.03512100,fixedFreq,dcType)
+    swap2 = IborSwap(settle_dt,"3Y",swap_type,0.03259300,fixedFreq,dcType)
+    swap3 = IborSwap(settle_dt,"4Y",swap_type,0.03069300,fixedFreq,dcType)
+    swap4 = IborSwap(settle_dt,"5Y",swap_type,0.02952200,fixedFreq,dcType)
+    swap5 = IborSwap(settle_dt,"6Y",swap_type,0.02889300,fixedFreq,dcType)
+    swap6 = IborSwap(settle_dt,"7Y",swap_type,0.02850200,fixedFreq,dcType)
+    swap7 = IborSwap(settle_dt,"8Y",swap_type,0.02827400,fixedFreq,dcType)
+    swap8 = IborSwap(settle_dt,"9Y",swap_type,0.02818500,fixedFreq,dcType)
+    swap9 = IborSwap(settle_dt,"10Y",swap_type,0.02823000,fixedFreq,dcType)
     swaps = [swap1,swap2,swap3,swap4,swap5,swap6,swap7,swap8,swap9]
 
     libor_curve = IborSingleCurve(value_dt, [], [], swaps)
 
     spreads = [0.000881720, 0.002246440, 0.004283100, 0.005730380, 0.006982450]
     tenors = ['1Y', '3Y', '5Y', '7Y', '10Y']
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSIndex.py` & `financepy-0.360/tests_golden/TestFinCDSIndex.py`

 * *Files 3% similar despite different names*

```diff
@@ -98,17 +98,17 @@
 
 def buildIssuerCurve(tradeDate, libor_curve):
 
     value_dt = tradeDate.add_days(1)
 
     cdsMarketContracts = []
 
-    cds_coupon = 0.0048375
+    cds_cpn = 0.0048375
     maturity_dt = Date(20, 6, 2010)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -127,19 +127,19 @@
     step_in_dt = tradeDate.add_days(1)
     value_dt = step_in_dt
     maturity_dt = Date(20, 6, 2010)
 
     cdsRecovery = 0.40
     notional = 10.0 * ONE_MILLION
     long_protection = True
-    index_coupon = 0.004
+    index_cpn = 0.004
 
     cdsIndexContract = CDS(step_in_dt,
                            maturity_dt,
-                           index_coupon,
+                           index_cpn,
                            notional,
                            long_protection)
 
 #    cdsIndexContract.print(value_dt)
 
     test_cases.header("LABEL", "VALUE")
 
@@ -156,25 +156,25 @@
 
     accrued_days = cdsIndexContract.accrued_days()
     test_cases.print("ACCRUED DAYS", accrued_days)
 
     accrued_interest = cdsIndexContract.accrued_interest()
     test_cases.print("ACCRUED COUPON", accrued_interest)
 
-    prot_pv = cdsIndexContract.protection_leg_pv(
+    prot_pv = cdsIndexContract.prot_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PROTECTION LEG PV", prot_pv)
 
     premPV = cdsIndexContract.premium_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PREMIUM LEG PV", premPV)
 
-    dirtyRPV01, cleanRPV01 = cdsIndexContract.risky_pv01(
+    dirty_rpv01, clean_rpv01 = cdsIndexContract.risky_pv01(
         value_dt, issuer_curve)
-    test_cases.print("DIRTY RPV01", dirtyRPV01)
-    test_cases.print("CLEAN RPV01", cleanRPV01)
+    test_cases.print("DIRTY RPV01", dirty_rpv01)
+    test_cases.print("CLEAN RPV01", clean_rpv01)
 
 #    cdsIndexContract.print_payments(issuer_curve)
 
 
 test_valueCDSIndex()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSIndexAdjustHazards.py` & `financepy-0.360/tests_golden/TestFinCDSIndexAdjustHazards.py`

 * *Files 2% similar despite different names*

```diff
@@ -96,17 +96,17 @@
 
 def buildIssuerCurve(tradeDate, libor_curve):
 
     value_dt = tradeDate.add_days(1)
 
     cdsMarketContracts = []
 
-    cds_coupon = 0.0048375
+    cds_cpn = 0.0048375
     maturity_dt = Date(29, 6, 2010)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -266,15 +266,15 @@
 
 #    num_credits = len(issuer_curves)
 #    test_cases.print("#","MATURITY","CDS_UNADJ","CDS_ADJ")
 #    for m in range(0,num_credits):
 #        for cds in cds_contracts:
 #            unadjustedSpread = cds.par_spread(value_dt,issuer_curves[m])
 #            adjustedSpread = cds.par_spread(value_dt,adjustedIssuerCurves[m])
-#            test_cases.print(m,str(cds._maturity_dt),"%10.3f"%(unadjustedSpread*10000),"%10.3f" %(adjustedSpread*10000))
+#            test_cases.print(m,str(cds.maturity_dt),"%10.3f"%(unadjustedSpread*10000),"%10.3f" %(adjustedSpread*10000))
 
     cdsIndex = CDSIndexPortfolio()
 
     intrinsicSpd3Y = cdsIndex.intrinsic_spread(value_dt,
                                                step_in_dt,
                                                index_maturity_dts[0],
                                                adjustedIssuerCurves) * 10000.0
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSIndexAdjustSpreads.py` & `financepy-0.360/tests_golden/TestFinCDSIndexAdjustSpreads.py`

 * *Files 1% similar despite different names*

```diff
@@ -95,17 +95,17 @@
 ##########################################################################
 
 
 def buildIssuerCurve(value_dt, libor_curve):
 
     cdsMarketContracts = []
 
-    cds_coupon = 0.0048375
+    cds_cpn = 0.0048375
     maturity_dt = Date(29, 6, 2010)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSIndexOption.py` & `financepy-0.360/tests_golden/TestFinCDSIndexOption.py`

 * *Files 1% similar despite different names*

```diff
@@ -166,23 +166,23 @@
         issuer_curves.append(issuer_curve)
 
     ##########################################################################
     ##########################################################################
 
     index_upfronts = [0.0, 0.0, 0.0, 0.0]
     index_maturity_dts = [Date(20, 12, 2009),
-                            Date(20, 12, 2011),
-                            Date(20, 12, 2013),
-                            Date(20, 12, 2016)]
+                          Date(20, 12, 2011),
+                          Date(20, 12, 2013),
+                          Date(20, 12, 2016)]
     index_recovery = 0.40
 
     test_cases.banner(
         "======================= CDS INDEX OPTION ==========================")
 
-    index_coupon = 0.004
+    index_cpn = 0.004
     volatility = 0.50
     expiry_dt = Date(1, 2, 2008)
     maturity_dt = Date(20, 12, 2011)
     notional = 10000.0
     tolerance = 1e-6
 
     test_cases.header(
@@ -251,15 +251,15 @@
 
         for strike in [20, 60]:
 
             start = time.time()
 
             option = CDSIndexOption(expiry_dt,
                                     maturity_dt,
-                                    index_coupon,
+                                    index_cpn,
                                     strike / 10000.0,
                                     notional)
 
             v_pay_1, v_rec_1, strike_value, mu, expH = option.value_anderson(
                 value_dt, adjustedIssuerCurves, index_recovery, volatility)
             end = time.time()
             elapsed = end - start
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSIndexPortfolio.py` & `financepy-0.360/tests_golden/TestFinCDSIndexPortfolio.py`

 * *Files 4% similar despite different names*

```diff
@@ -99,17 +99,17 @@
 
 def buildIssuerCurve(tradeDate, libor_curve):
 
     value_dt = tradeDate.add_days(1)
 
     cdsMarketContracts = []
 
-    cds_coupon = 0.0048375
+    cds_cpn = 0.0048375
     maturity_dt = Date(29, 6, 2010)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -162,32 +162,32 @@
 
         issuer_curves.append(issuer_curve)
 
     ##########################################################################
     # Now determine the average spread of the index
     ##########################################################################
 
-    cdsIndex = CDSIndexPortfolio()
+    cds_index = CDSIndexPortfolio()
 
-    averageSpd3Y = cdsIndex.average_spread(value_dt,
+    averageSpd3Y = cds_index.average_spread(value_dt,
                                            step_in_dt,
                                            maturity3Y,
                                            issuer_curves) * 10000.0
 
-    averageSpd5Y = cdsIndex.average_spread(value_dt,
+    averageSpd5Y = cds_index.average_spread(value_dt,
                                            step_in_dt,
                                            maturity5Y,
                                            issuer_curves) * 10000.0
 
-    averageSpd7Y = cdsIndex.average_spread(value_dt,
+    averageSpd7Y = cds_index.average_spread(value_dt,
                                            step_in_dt,
                                            maturity7Y,
                                            issuer_curves) * 10000.0
 
-    averageSpd10Y = cdsIndex.average_spread(value_dt,
+    averageSpd10Y = cds_index.average_spread(value_dt,
                                             step_in_dt,
                                             maturity10Y,
                                             issuer_curves) * 10000.0
 
     test_cases.header("LABEL", "VALUE")
     test_cases.print("AVERAGE SPD 3Y", averageSpd3Y)
     test_cases.print("AVERAGE SPD 5Y", averageSpd5Y)
@@ -195,32 +195,32 @@
     test_cases.print("AVERAGE SPD 10Y", averageSpd10Y)
 
     ##########################################################################
     # Now determine the intrinsic spread of the index to the same maturity
     # dates. As the single name CDS contracts
     ##########################################################################
 
-    cdsIndex = CDSIndexPortfolio()
+    cds_index = CDSIndexPortfolio()
 
-    intrinsicSpd3Y = cdsIndex.intrinsic_spread(value_dt,
+    intrinsicSpd3Y = cds_index.intrinsic_spread(value_dt,
                                                step_in_dt,
                                                maturity3Y,
                                                issuer_curves) * 10000.0
 
-    intrinsicSpd5Y = cdsIndex.intrinsic_spread(value_dt,
+    intrinsicSpd5Y = cds_index.intrinsic_spread(value_dt,
                                                step_in_dt,
                                                maturity5Y,
                                                issuer_curves) * 10000.0
 
-    intrinsicSpd7Y = cdsIndex.intrinsic_spread(value_dt,
+    intrinsicSpd7Y = cds_index.intrinsic_spread(value_dt,
                                                step_in_dt,
                                                maturity7Y,
                                                issuer_curves) * 10000.0
 
-    intrinsicSpd10Y = cdsIndex.intrinsic_spread(value_dt,
+    intrinsicSpd10Y = cds_index.intrinsic_spread(value_dt,
                                                 step_in_dt,
                                                 maturity10Y,
                                                 issuer_curves) * 10000.0
 
     ##########################################################################
     ##########################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSOption.py` & `financepy-0.360/tests_golden/TestFinCDSOption.py`

 * *Files 5% similar despite different names*

```diff
@@ -157,52 +157,52 @@
         fixedFreq,
         dcType)
     swaps.append(swap9)
 
     libor_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     cdsMarketContracts = []
-    cds_coupon = 0.005743
+    cds_cpn = 0.005743
     maturity_dt = value_dt.next_cds_date(6)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.007497
+    cds_cpn = 0.007497
     maturity_dt = value_dt.next_cds_date(12)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.011132
+    cds_cpn = 0.011132
     maturity_dt = value_dt.next_cds_date(24)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.013932
+    cds_cpn = 0.013932
     maturity_dt = value_dt.next_cds_date(36)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.015764
+    cds_cpn = 0.015764
     maturity_dt = value_dt.next_cds_date(48)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.017366
+    cds_cpn = 0.017366
     maturity_dt = value_dt.next_cds_date(60)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.020928
+    cds_cpn = 0.020928
     maturity_dt = value_dt.next_cds_date(84)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
-    cds_coupon = 0.022835
+    cds_cpn = 0.022835
     maturity_dt = value_dt.next_cds_date(120)
-    cds = CDS(value_dt, maturity_dt, cds_coupon)
+    cds = CDS(value_dt, maturity_dt, cds_cpn)
     cdsMarketContracts.append(cds)
 
     recovery_rate = 0.40
 
     issuer_curve = CDSCurve(value_dt,
                             cdsMarketContracts,
                             libor_curve,
@@ -222,19 +222,19 @@
     value_dt = step_in_dt
     expiry_dt = Date(20, 3, 2014)
     maturity_dt = Date(20, 6, 2019)
 
     cdsRecovery = 0.40
     notional = 100.0
     long_protection = False
-    cds_coupon = 0.0  # NOT KNOWN
+    cds_cpn = 0.0  # NOT KNOWN
 
     cds_contract = CDS(step_in_dt,
                        maturity_dt,
-                       cds_coupon,
+                       cds_cpn,
                        notional,
                        long_protection)
 
     test_cases.banner(
         "=============================== CDS ===============================")
 #    cds_contract.print(value_dt)
 
@@ -254,35 +254,35 @@
 
     accrued_days = cds_contract.accrued_days()
     test_cases.print("ACCRUED DAYS", accrued_days)
 
     accrued_interest = cds_contract.accrued_interest()
     test_cases.print("ACCRUED COUPON", accrued_interest)
 
-    prot_pv = cds_contract.protection_leg_pv(
+    prot_pv = cds_contract.prot_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PROTECTION LEG PV", prot_pv)
 
     premPV = cds_contract.premium_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PREMIUM LEG PV", premPV)
 
-    fullRPV01, cleanRPV01 = cds_contract.risky_pv01(
+    fullRPV01, clean_rpv01 = cds_contract.risky_pv01(
         value_dt, issuer_curve)
     test_cases.print("FULL  RPV01", fullRPV01)
-    test_cases.print("CLEAN RPV01", cleanRPV01)
+    test_cases.print("CLEAN RPV01", clean_rpv01)
 
 #    cds_contract.print_payments(issuer_curve)
 
     test_cases.banner(
         "=========================== FORWARD CDS ===========================")
 
     cds_contract = CDS(expiry_dt,
                        maturity_dt,
-                       cds_coupon,
+                       cds_cpn,
                        notional,
                        long_protection)
 
 #    cds_contract.print(value_dt)
 
     spd = cds_contract.par_spread(
         value_dt,
@@ -290,37 +290,37 @@
         cdsRecovery) * 10000.0
     test_cases.print("PAR SPREAD", spd)
 
     v = cds_contract.value(value_dt, issuer_curve, cdsRecovery)
     test_cases.print("DIRTY VALUE", v['dirty_pv'])
     test_cases.print("CLEAN VALUE", v['clean_pv'])
 
-    prot_pv = cds_contract.protection_leg_pv(
+    prot_pv = cds_contract.prot_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PROTECTION LEG PV", prot_pv)
 
     premPV = cds_contract.premium_leg_pv(
         value_dt, issuer_curve, cdsRecovery)
     test_cases.print("PREMIUM LEG PV", premPV)
 
-    dirtyRPV01, cleanRPV01 = cds_contract.risky_pv01(
+    dirty_rpv01, clean_rpv01 = cds_contract.risky_pv01(
         value_dt, issuer_curve)
-    test_cases.print("DIRTY RPV01", dirtyRPV01)
-    test_cases.print("CLEAN RPV01", cleanRPV01)
+    test_cases.print("DIRTY RPV01", dirty_rpv01)
+    test_cases.print("CLEAN RPV01", clean_rpv01)
 
 #    cds_contract.print_payments(issuer_curve)
 
     test_cases.banner(
         "========================== CDS OPTIONS ============================")
 
-    cds_coupon = 0.01
+    cds_cpn = 0.01
     volatility = 0.3
     test_cases.print("Expiry Date:", str(expiry_dt))
     test_cases.print("Maturity Date:", str(maturity_dt))
-    test_cases.print("CDS Coupon:", cds_coupon)
+    test_cases.print("CDS Coupon:", cds_cpn)
 
     test_cases.header("STRIKE", "LONG PROTECTION", "DIRTY VALUE", "IMPLIED VOL")
 
     for strike in np.linspace(100, 300, 41):
 
         long_protection = True  # long protection
```

### Comparing `financepy-0.350/tests_golden/TestFinCDSTranche.py` & `financepy-0.360/tests_golden/TestFinCDSTranche.py`

 * *Files 0% similar despite different names*

```diff
@@ -262,16 +262,16 @@
                     method)
                 end = time.time()
                 period = (end - start)
                 test_cases.print(
                     method,
                     period,
                     num_points,
-                    tranche._k1,
-                    tranche._k2,
+                    tranche.k1,
+                    tranche.k2,
                     v[3] * 10000)
 
 ##########################################################################
 
     test_cases.banner(
         "===================================================================")
     test_cases.banner(
@@ -309,16 +309,16 @@
                     method)
                 end = time.time()
                 period = (end - start)
                 test_cases.print(
                     method,
                     period,
                     num_points,
-                    tranche._k1,
-                    tranche._k2,
+                    tranche.k1,
+                    tranche.k2,
                     v[3] * 10000)
 
     test_cases.banner(
         "===================================================================")
 
 ##########################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinCalendar.py` & `financepy-0.360/tests_golden/TestFinCalendar.py`

 * *Files 1% similar despite different names*

```diff
@@ -31,15 +31,15 @@
 
         cal = Calendar(cal_type)
         next_dt = Date(31, 12, 2020)
 
         while next_dt < end_dt:
             next_dt = next_dt.add_days(1)
 
-            if next_dt._d == 1 and next_dt._m == 1:
+            if next_dt.d == 1 and next_dt.m == 1:
                 test_cases.banner("================================")
 #                print("=========================")
 
             is_holidayDay = cal.is_holiday(next_dt)
             if is_holidayDay is True:
                 test_cases.print(cal, next_dt)
 #                print(cal, next_dt)
```

### Comparing `financepy-0.350/tests_golden/TestFinDate.py` & `financepy-0.360/tests_golden/TestFinDate.py`

 * *Files 1% similar despite different names*

```diff
@@ -195,39 +195,39 @@
 def test_IntraDay():
 
     test_cases.header("Date1", "Date2", "Diff")
     d1 = Date(20, 10, 2019, 0, 0, 0)
     d2 = Date(25, 10, 2019, 0, 0, 0)
     diff = d2 - d1
     test_cases.print(d1, d2, diff)
-    test_cases.print(d1._excel_dt, d2._excel_dt, diff)
+    test_cases.print(d1.excel_dt, d2.excel_dt, diff)
 
     ###########################################################################
 
     d1 = Date(20, 10, 2019, 10, 0, 0)
     d2 = Date(25, 10, 2019, 10, 25, 0)
     diff = d2 - d1
     test_cases.print(d1, d2, diff)
-    test_cases.print(d1._excel_dt, d2._excel_dt, diff)
+    test_cases.print(d1.excel_dt, d2.excel_dt, diff)
 
     ###########################################################################
 
     d1 = Date(20, 10, 2019, 10, 0, 0)
     d2 = Date(20, 10, 2019, 10, 25, 30)
     diff = d2 - d1
     test_cases.print(d1, d2, diff)
-    test_cases.print(d1._excel_dt, d2._excel_dt, diff)
+    test_cases.print(d1.excel_dt, d2.excel_dt, diff)
 
     ###########################################################################
 
     d1 = Date(19, 10, 2019, 10, 0, 0)
     d2 = Date(20, 10, 2019, 10, 25, 40)
     diff = d2 - d1
     test_cases.print(d1, d2, diff)
-    test_cases.print(d1._excel_dt, d2._excel_dt, diff)
+    test_cases.print(d1.excel_dt, d2.excel_dt, diff)
 
 ###############################################################################
 
 
 def test_dtEOM():
 
     dt = Date(29, 2, 2000)
```

### Comparing `financepy-0.350/tests_golden/TestFinDateAdjust.py` & `financepy-0.360/tests_golden/TestFinDateAdjust.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,15 +33,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    for dt in schedule._adjusted_dts:
+    for dt in schedule.adjusted_dts:
         test_cases.print("Date:", dt)
 
     test_cases.banner("")
     test_cases.header("NO WEEKENDS AND FOLLOWING", "DATE")
     freq_type = FrequencyTypes.SEMI_ANNUAL
     cal_type = CalendarTypes.WEEKEND
     bd_type = BusDayAdjustTypes.FOLLOWING
@@ -50,15 +50,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    for dt in schedule._adjusted_dts:
+    for dt in schedule.adjusted_dts:
         test_cases.print("Date:", dt)
 
     test_cases.banner("")
     test_cases.header("NO WEEKENDS AND MODIFIED FOLLOWING", "DATE")
     freq_type = FrequencyTypes.SEMI_ANNUAL
     cal_type = CalendarTypes.WEEKEND
     bd_type = BusDayAdjustTypes.MODIFIED_FOLLOWING
@@ -67,15 +67,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    for dt in schedule._adjusted_dts:
+    for dt in schedule.adjusted_dts:
         test_cases.print("Date:", dt)
 
     test_cases.banner("")
     test_cases.header("NO WEEKENDS AND US HOLIDAYS AND MODIFIED FOLLOWING",
                      "DATE")
     freq_type = FrequencyTypes.SEMI_ANNUAL
     cal_type = CalendarTypes.UNITED_STATES
@@ -88,15 +88,15 @@
     schedule = Schedule(start_dt,
                         end_dt,
                         freq_type,
                         cal_type,
                         bd_type,
                         dg_type)
 
-    for dt in schedule._adjusted_dts:
+    for dt in schedule.adjusted_dts:
         test_cases.print("Date:", dt)
 
 ###############################################################################
 
 
 test_dt_adjust()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinDayCount.py` & `financepy-0.360/tests_golden/TestFinDayCount.py`

 * *Files 10% similar despite different names*

```diff
@@ -21,18 +21,18 @@
 
     finFreq = FrequencyTypes.ANNUAL
 
     for day_count_method in DayCountTypes:
 
         start_dt = Date(1, 1, 2019)
         next_dt = start_dt
-        numDays = 20
+        num_days = 20
         day_count = DayCount(day_count_method)
 
-        for _ in range(0, numDays):
+        for _ in range(0, num_days):
             next_dt = next_dt.add_days(7)
             dcf = day_count.year_frac(
                 start_dt, next_dt, next_dt, finFreq)
 
             test_cases.print(
                 str(day_count_method),
                 str(start_dt),
```

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurve.py` & `financepy-0.360/tests_golden/TestFinDiscountCurve.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurveFlat.py` & `financepy-0.360/tests_golden/TestFinDiscountCurveFlat.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurveNS.py` & `financepy-0.360/tests_golden/TestFinDiscountCurveNS.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurveNSS.py` & `financepy-0.360/tests_golden/TestFinDiscountCurveNSS.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurvePolynomial.py` & `financepy-0.360/tests_golden/TestFinDiscountCurvePolynomial.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurveZeros.py` & `financepy-0.360/tests_golden/TestFinDiscountCurveZeros.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinDiscountCurves.py` & `financepy-0.360/tests_golden/TestFinDiscountCurves.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityAmericanMC.py` & `financepy-0.360/tests_golden/TestFinEquityAmericanMC.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityAmericanOption.py` & `financepy-0.360/tests_golden/TestFinEquityAmericanOption.py`

 * *Files 5% similar despite different names*

```diff
@@ -18,28 +18,28 @@
 
 ###############################################################################
 
 
 def testEquityAmericanOption():
 
     value_dt = Date(1, 1, 2016)
-    expiry_date = Date(1, 1, 2017)
+    expiry_dt = Date(1, 1, 2017)
     stock_price = 50.0
     interest_rate = 0.06
     dividend_yield = 0.04
     volatility = 0.40
     strike_price = 50.0
 
     discount_curve = DiscountCurveFlat(value_dt, interest_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
     test_cases.banner("================== EUROPEAN PUT =======================")
 
     put_option = EquityAmericanOption(
-        expiry_date, strike_price, OptionTypes.EUROPEAN_PUT)
+        expiry_dt, strike_price, OptionTypes.EUROPEAN_PUT)
 
     num_steps = 4
 
     model = BlackScholes(volatility,
                          BlackScholesTypes.CRR_TREE,
                          num_steps)
 
@@ -52,15 +52,15 @@
     theta = put_option.theta(value_dt, stock_price,
                              discount_curve, dividend_curve, model)
 
     test_cases.header("OPTION_TYPE", "VALUE", "DELTA", "GAMMA", "THETA")
     test_cases.print("EUROPEAN_PUT_BS", value, delta, gamma, theta)
 
     option = EquityAmericanOption(
-        expiry_date, strike_price, OptionTypes.EUROPEAN_PUT)
+        expiry_dt, strike_price, OptionTypes.EUROPEAN_PUT)
 
     test_cases.header("OPTION_TYPE", "NUMSTEPS",
                      "VALUE DELTA GAMMA THETA", "TIME")
 
     num_steps_list = [100, 200, 1000]
 
     for num_steps in num_steps_list:
@@ -75,15 +75,15 @@
         end = time.time()
         duration = end - start
         test_cases.print("EUROPEAN_PUT_TREE", num_steps, results, duration)
 
     test_cases.banner("================== AMERICAN PUT =======================")
 
     option = EquityAmericanOption(
-        expiry_date,
+        expiry_dt,
         strike_price,
         OptionTypes.AMERICAN_PUT)
 
     test_cases.header(
         "OPTION_TYPE",
         "NUMSTEPS",
         "VALUE DELTA GAMMA THETA",
@@ -102,15 +102,15 @@
         duration = end - start
         test_cases.print("AMERICAN_PUT", num_steps, results, duration)
 
     test_cases.banner(
         "================== EUROPEAN CALL =======================")
 
     call_option = EquityAmericanOption(
-        expiry_date,
+        expiry_dt,
         strike_price,
         OptionTypes.EUROPEAN_CALL)
 
     value = call_option.value(value_dt, stock_price,
                               discount_curve, dividend_curve, model)
     delta = call_option.delta(value_dt, stock_price,
                               discount_curve, dividend_curve, model)
@@ -119,15 +119,15 @@
     theta = call_option.theta(value_dt, stock_price,
                               discount_curve, dividend_curve, model)
 
     test_cases.header("OPTION_TYPE", "VALUE", "DELTA", "GAMMA", "THETA")
     test_cases.print("EUROPEAN_CALL_BS", value, delta, gamma, theta)
 
     option = EquityAmericanOption(
-        expiry_date,
+        expiry_dt,
         strike_price,
         OptionTypes.EUROPEAN_CALL)
 
     test_cases.header(
         "OPTION_TYPE",
         "NUMSTEPS",
         "VALUE DELTA GAMMA THETA",
@@ -149,15 +149,15 @@
         "================== AMERICAN CALL =======================")
     test_cases.header(
         "OPTION_TYPE",
         "NUMSTEPS",
         "VALUE DELTA GAMMA THETA",
         "TIME")
 
-    option = EquityAmericanOption(expiry_date, strike_price,
+    option = EquityAmericanOption(expiry_dt, strike_price,
                                   OptionTypes.AMERICAN_CALL)
 
     for num_steps in num_steps_list:
 
         model = BlackScholes(volatility,
                              BlackScholesTypes.CRR_TREE,
                              num_steps)
@@ -175,15 +175,15 @@
         "================== AMERICAN PUT =======================")
     test_cases.header(
         "OPTION_TYPE",
         "NUMSTEPS",
         "VALUE DELTA GAMMA THETA",
         "TIME")
 
-    option = EquityAmericanOption(expiry_date, strike_price,
+    option = EquityAmericanOption(expiry_dt, strike_price,
                                   OptionTypes.AMERICAN_PUT)
 
     for num_steps in num_steps_list:
 
         model = BlackScholes(volatility,
                              BlackScholesTypes.CRR_TREE,
                              num_steps)
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityAsianOption.py` & `financepy-0.360/tests_golden/TestFinEquityAsianOption.py`

 * *Files 8% similar despite different names*

```diff
@@ -26,30 +26,30 @@
 
 ###############################################################################
 
 
 def testConvergence():
 
     value_dt = Date(1, 1, 2014)
-    startAveragingDate = Date(1, 6, 2014)
+    start_averaging_date = Date(1, 6, 2014)
     expiry_dt = Date(1, 1, 2015)
     stock_price = 100.0
     volatility = 0.20
     interest_rate = 0.30
     dividend_yield = 0.10
     num_observations = 120  # daily as we have a half year
     accruedAverage = None
     K = 100
     seed = 1976
 
     model = BlackScholes(volatility)
     discount_curve = DiscountCurveFlat(value_dt, interest_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
-    asianOption = EquityAsianOption(startAveragingDate,
+    asianOption = EquityAsianOption(start_averaging_date,
                                     expiry_dt,
                                     K,
                                     OptionTypes.EUROPEAN_CALL,
                                     num_observations)
 
     test_cases.header(
         "K",
@@ -140,28 +140,28 @@
 #    plt.show()
 
 ###############################################################################
 
 
 def testTimeEvolution():
 
-    startAveragingDate = Date(1, 1, 2015)
+    start_averaging_date = Date(1, 1, 2015)
     expiry_dt = Date(1, 1, 2016)
     stock_price = 100.0
     volatility = 0.20
     interest_rate = 0.30
     dividend_yield = 0.10
     num_observations = 100  # weekly as we have a year
     accruedAverage = None
     K = 100
     seed = 1976
 
     model = BlackScholes(volatility)
 
-    asianOption = EquityAsianOption(startAveragingDate,
+    asianOption = EquityAsianOption(start_averaging_date,
                                     expiry_dt,
                                     K,
                                     OptionTypes.EUROPEAN_CALL,
                                     num_observations)
 
     test_cases.header(
         "Date",
@@ -266,30 +266,30 @@
 
 ##########################################################################
 
 
 def testMCTimings():
 
     value_dt = Date(1, 1, 2014)
-    startAveragingDate = Date(1, 6, 2014)
+    start_averaging_date = Date(1, 6, 2014)
     expiry_dt = Date(1, 1, 2015)
     stock_price = 100.0
     volatility = 0.20
     interest_rate = 0.30
     dividend_yield = 0.10
     num_observations = 120  # daily as we have a half year
     accruedAverage = None
     K = 100
     seed = 1976
 
     model = BlackScholes(volatility)
     discount_curve = DiscountCurveFlat(value_dt, interest_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
-    asianOption = EquityAsianOption(startAveragingDate,
+    asianOption = EquityAsianOption(start_averaging_date,
                                     expiry_dt,
                                     K,
                                     OptionTypes.EUROPEAN_CALL,
                                     num_observations)
 
     test_cases.header(
         "NUMPATHS",
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityBarrierOption.py` & `financepy-0.360/tests_golden/TestFinEquityBarrierOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityBasketOption.py` & `financepy-0.360/tests_golden/TestFinEquityBasketOption.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import numpy as np
 from financepy.products.equity.equity_basket_option import EquityBasketOption
 from financepy.utils.global_types import OptionTypes
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.helpers import beta_vector_to_corr_matrix
 from financepy.utils.date import Date
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def test_EquityBasketOption():
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityBinomialTree.py` & `financepy-0.360/tests_golden/TestFinEquityBinomialTree.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import time
 import numpy as np
 from financepy.products.equity.equity_binomial_tree import EquityBinomialTree
 from financepy.products.equity.equity_binomial_tree import EquityTreeExerciseTypes
 from financepy.products.equity.equity_binomial_tree import EquityTreePayoffTypes
 from financepy.products.equity.equity_vanilla_option import EquityVanillaOption
 from financepy.utils.global_types import OptionTypes
 from financepy.utils.date import Date
 from financepy.models.black_scholes import BlackScholes
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
@@ -26,28 +27,28 @@
 
     stock_price = 50.0
     risk_free_rate = 0.06
     dividend_yield = 0.04
     volatility = 0.40
 
     value_dt = Date(1, 1, 2016)
-    expiry_date = Date(1, 1, 2017)
+    expiry_dt = Date(1, 1, 2017)
 
     model = BlackScholes(volatility)
     discount_curve = DiscountCurveFlat(value_dt, risk_free_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
     num_steps_list = [100, 500, 1000]
 
     strike_price = 50.0
 
     test_cases.banner("================== EUROPEAN PUT =======================")
 
     put_option = EquityVanillaOption(
-        expiry_date,
+        expiry_dt,
         strike_price,
         OptionTypes.EUROPEAN_PUT)
     value = put_option.value(value_dt, stock_price,
                              discount_curve, dividend_curve, model)
     delta = put_option.delta(value_dt, stock_price,
                              discount_curve, dividend_curve, model)
     gamma = put_option.gamma(value_dt, stock_price,
@@ -70,15 +71,15 @@
             stock_price,
             discount_curve,
             dividend_curve,
             volatility,
             num_steps,
             value_dt,
             payoff,
-            expiry_date,
+            expiry_dt,
             payoff,
             exercise,
             params)
         end = time.time()
         duration = end - start
         test_cases.print(num_steps, results, duration)
 
@@ -97,27 +98,27 @@
             stock_price,
             discount_curve,
             dividend_curve,
             volatility,
             num_steps,
             value_dt,
             payoff,
-            expiry_date,
+            expiry_dt,
             payoff,
             exercise,
             params)
         end = time.time()
         duration = end - start
         test_cases.print(num_steps, results, duration)
 
     test_cases.banner(
         "================== EUROPEAN CALL =======================")
 
     call_option = EquityVanillaOption(
-        expiry_date,
+        expiry_dt,
         strike_price,
         OptionTypes.EUROPEAN_CALL)
     value = call_option.value(value_dt, stock_price,
                               discount_curve, dividend_curve, model)
     delta = call_option.delta(value_dt, stock_price,
                               discount_curve, dividend_curve, model)
     gamma = call_option.gamma(value_dt, stock_price,
@@ -140,15 +141,15 @@
             stock_price,
             discount_curve,
             dividend_curve,
             volatility,
             num_steps,
             value_dt,
             payoff,
-            expiry_date,
+            expiry_dt,
             payoff,
             exercise,
             params)
 
         end = time.time()
         duration = end - start
         test_cases.print(num_steps, results, duration)
@@ -169,15 +170,15 @@
             stock_price,
             discount_curve,
             dividend_curve,
             volatility,
             num_steps,
             value_dt,
             payoff,
-            expiry_date,
+            expiry_dt,
             payoff,
             exercise,
             params)
 
         end = time.time()
         duration = end - start
         test_cases.print(num_steps, results, duration)
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityChooserOption.py` & `financepy-0.360/tests_golden/TestFinEquityChooserOption.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 from financepy.products.equity.equity_chooser_option import EquityChooserOption
 from financepy.models.black_scholes import BlackScholes
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.date import Date
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##############################################################################
 
 
 def test_EquityChooserOptionHaug():
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityCliquetOption.py` & `financepy-0.360/tests/test_FinEquityCliquetOption.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,36 +1,28 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-from financepy.products.equity.equity_cliquet_option import EquityCliquetOption
-from financepy.models.black_scholes import BlackScholes
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.utils.frequency import FrequencyTypes
-from financepy.utils.date import Date
 from financepy.utils.global_types import OptionTypes
-from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
-
-test_cases = FinTestCases(__file__, globalTestCaseMode)
-
-###############################################################################
+from financepy.utils.date import Date
+from financepy.utils.frequency import FrequencyTypes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.models.black_scholes import BlackScholes
+from financepy.products.equity.equity_cliquet_option import EquityCliquetOption
 
 
 def test_EquityCliquetOption():
 
     start_dt = Date(1, 1, 2014)
-    final_expiry_date = Date(1, 1, 2017)
+    final_expiry_dt = Date(1, 1, 2017)
     freq_type = FrequencyTypes.QUARTERLY
     option_type = OptionTypes.EUROPEAN_CALL
 
     cliquetOption = EquityCliquetOption(start_dt,
-                                        final_expiry_date,
+                                        final_expiry_dt,
                                         option_type,
                                         freq_type)
 
     value_dt = Date(1, 1, 2015)
     stock_price = 100.0
     volatility = 0.20
     interest_rate = 0.05
@@ -41,15 +33,8 @@
 
     v = cliquetOption.value(value_dt,
                             stock_price,
                             discount_curve,
                             dividend_curve,
                             model)
 
-    test_cases.header("LABEL", "VALUE")
-    test_cases.print("FINANCEPY", v)
-
-###############################################################################
-
-
-test_EquityCliquetOption()
-test_cases.compareTestCases()
+    assert round(v, 4) == 34.5287
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityCompoundOption.py` & `financepy-0.360/tests_golden/TestFinEquityCompoundOption.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 from financepy.products.equity.equity_compound_option import EquityCompoundOption
 from financepy.utils.global_types import OptionTypes
 from financepy.models.black_scholes import BlackScholes
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.date import Date
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
 def test_EquityCompoundOption():
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityDigitalOption.py` & `financepy-0.360/tests_golden/TestFinEquityDigitalOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityForward.py` & `financepy-0.360/tests_golden/TestFinEquityForward.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityLookbackOption.py` & `financepy-0.360/tests_golden/TestFinEquityLookbackOption.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,16 +22,16 @@
 def test_EquityLookBackOption():
     value_dt = Date(1, 1, 2015)
     expiry_dt = Date(1, 1, 2016)
     stock_price = 100.0
     volatility = 0.3
     interest_rate = 0.05
     dividend_yield = 0.01
-    num_pathsRange = [10000]
-    stock_priceRange = range(90, 110, 10)
+    num_paths_range = [10000]
+    stock_price_range = range(90, 110, 10)
     num_steps_per_year = 252
 
     discount_curve = DiscountCurveFlat(value_dt, interest_rate)
     dividend_curve = DiscountCurveFlat(value_dt, dividend_yield)
 
 ###############################################################################
 
@@ -42,16 +42,16 @@
         "SMIN",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFloatLookbackOption(expiry_dt, option_type)
             stockMin = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -87,16 +87,16 @@
         "SMIN",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFloatLookbackOption(expiry_dt, option_type)
             stockMin = stock_price - 10
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -132,16 +132,16 @@
         "SMAX",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFloatLookbackOption(expiry_dt, option_type)
             stockMax = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -177,16 +177,16 @@
         "SMAX",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFloatLookbackOption(expiry_dt, option_type)
             stockMax = stock_price + 10
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -214,15 +214,15 @@
                 value_mc,
                 diff,
                 time_elapsed)
 
 ###############################################################################
 ###############################################################################
 
-    stock_priceRange = range(90, 110, 10)
+    stock_price_range = range(90, 110, 10)
     num_steps_per_year = 252
 
     test_cases.header(
         "NUMPATHS",
         "OPTION_TYPE",
         "S",
         "K",
@@ -230,16 +230,16 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
     k = 95.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFixedLookbackOption(expiry_dt, option_type, k)
             stockMax = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -278,16 +278,16 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
     k = 100.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFixedLookbackOption(expiry_dt, option_type, k)
             stockMax = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -326,16 +326,16 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
     k = 105.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFixedLookbackOption(expiry_dt, option_type, k)
             stockMax = stock_price + 10.0
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -374,16 +374,16 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
     k = 95.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFixedLookbackOption(expiry_dt, option_type, k)
             stockMin = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -422,16 +422,16 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
     k = 100.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFixedLookbackOption(expiry_dt, option_type, k)
             stockMin = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
@@ -470,16 +470,16 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
     k = 105.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
             option = EquityFixedLookbackOption(expiry_dt, option_type, k)
             stockMin = stock_price - 10.0
             value = option.value(
                 value_dt,
                 stock_price,
                 discount_curve,
                 dividend_curve,
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityOneTouchOption.py` & `financepy-0.360/tests_golden/TestFinEquityOneTouchOption.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,15 +21,15 @@
 
 
 def test_EquityOneTouchOption():
     # Examples Haug Page 180 Table 4-22
     # Agreement not exact at t is not exactly 0.50
 
     value_dt = Date(1, 1, 2016)
-    expiry_date = Date(2, 7, 2016)
+    expiry_dt = Date(2, 7, 2016)
     interest_rate = 0.10
     volatility = 0.20
     barrier_level = 100.0  # H
     model = BlackScholes(volatility)
     dividend_yield = 0.03
     num_paths = 10000
     num_steps_per_year = 252
@@ -46,15 +46,15 @@
                  TouchOptionTypes.DOWN_AND_IN_CASH_AT_EXPIRY,
                  TouchOptionTypes.DOWN_AND_OUT_CASH_OR_NOTHING]
 
     test_cases.header("TYPE", "VALUE", "VALUE_MC")
 
     for downType in downTypes:
 
-        option = EquityOneTouchOption(expiry_date,
+        option = EquityOneTouchOption(expiry_dt,
                                       downType,
                                       barrier_level,
                                       payment_size)
 
         v = option.value(value_dt,
                          stock_price,
                          discount_curve,
@@ -80,15 +80,15 @@
                TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY,
                TouchOptionTypes.UP_AND_OUT_CASH_OR_NOTHING]
 
     test_cases.header("TYPE", "VALUE", "VALUE_MC")
 
     for upType in upTypes:
 
-        option = EquityOneTouchOption(expiry_date,
+        option = EquityOneTouchOption(expiry_dt,
                                       upType,
                                       barrier_level,
                                       payment_size)
 
         v = option.value(value_dt,
                          stock_price,
                          discount_curve,
@@ -116,15 +116,15 @@
     downTypes = [TouchOptionTypes.DOWN_AND_IN_ASSET_AT_HIT,
                  TouchOptionTypes.DOWN_AND_IN_ASSET_AT_EXPIRY,
                  TouchOptionTypes.DOWN_AND_OUT_ASSET_OR_NOTHING]
 
     test_cases.header("TYPE", "VALUE", "VALUE_MC")
     for downType in downTypes:
 
-        option = EquityOneTouchOption(expiry_date,
+        option = EquityOneTouchOption(expiry_dt,
                                       downType,
                                       barrier_level)
 
         v = option.value(value_dt,
                          stock_price,
                          discount_curve,
                          dividend_curve,
@@ -146,15 +146,15 @@
 
     upTypes = [TouchOptionTypes.UP_AND_IN_ASSET_AT_HIT,
                TouchOptionTypes.UP_AND_IN_ASSET_AT_EXPIRY,
                TouchOptionTypes.UP_AND_OUT_ASSET_OR_NOTHING]
 
     for upType in upTypes:
 
-        option = EquityOneTouchOption(expiry_date,
+        option = EquityOneTouchOption(expiry_dt,
                                       upType,
                                       barrier_level)
 
         v = option.value(value_dt,
                          stock_price,
                          discount_curve,
                          dividend_curve,
```

### Comparing `financepy-0.350/tests_golden/TestFinEquityRainbowOption.py` & `financepy-0.360/tests_golden/TestFinEquityRainbowOption.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import time
 from math import sqrt
 import numpy as np
 from financepy.products.equity.equity_rainbow_option import EquityRainbowOption
 from financepy.products.equity.equity_rainbow_option import EquityRainbowOptionTypes
 from financepy.utils.helpers import beta_vector_to_corr_matrix
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.utils.date import Date
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinEquitySwap.py` & `financepy-0.360/tests_golden/TestFinEquitySwap.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityVanillaOption.py` & `financepy-0.360/tests_golden/TestFinEquityVanillaOption.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityVarianceSwap.py` & `financepy-0.360/tests_golden/TestFinEquityVarianceSwap.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinEquityVolSurface.py` & `financepy-0.360/tests_golden/TestFinEquityVolSurface.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 
 def test_equity_vol_surface(verboseCalibration):
 
     value_dt = Date(11, 1, 2021)
 
     stock_price = 3800.0  # Check
 
-    expiry_dates = [Date(11, 2, 2021), Date(11, 3, 2021),
+    expiry_dts = [Date(11, 2, 2021), Date(11, 3, 2021),
                     Date(11, 4, 2021), Date(11, 7, 2021),
                     Date(11, 10, 2021), Date(11, 1, 2022),
                     Date(11, 1, 2023)]
 
     strikes = np.array([3037, 3418, 3608, 3703, 3798,
                         3893, 3988, 4178, 4557])
 
@@ -60,15 +60,15 @@
 
     vol_functionType = VolFuncTypes.SVI
 
     equitySurface = EquityVolSurface(value_dt,
                                      stock_price,
                                      discount_curve,
                                      dividend_curve,
-                                     expiry_dates,
+                                     expiry_dts,
                                      strikes,
                                      volSurface,
                                      vol_functionType)
 
 #    tol = 1e-4
 #    equitySurface.check_calibration(False, tol)
 
@@ -80,27 +80,27 @@
 
         mins = strikes[0] * 0.5
         maxs = strikes[-1] * 1.5
 
         dbns = equitySurface.implied_dbns(mins, maxs, 1000)
 
         for i in range(0, len(dbns)):
-            expiry_date_str = str(equitySurface._expiry_dates[i])
-            plt.plot(dbns[i]._x, dbns[i]._densitydx, label=expiry_date_str)
+            expiry_dt_str = str(equitySurface._expiry_dts[i])
+            plt.plot(dbns[i]._x, dbns[i]._densitydx, label=expiry_dt_str)
             plt.title(vol_functionType)
             plt.legend()
             print("SUM:", dbns[i].sum())
 
     deltas = np.linspace(0.10, 0.90, 9)
 
     test_cases.header("EXPIRY", "DELTA", "VOL", "STRIKE")
-    for expiry_date in expiry_dates:
+    for expiry_dt in expiry_dts:
         for delta in deltas:
-            vol = equitySurface.vol_from_delta_dt(delta, expiry_date)
-            test_cases.print(expiry_date, delta, vol[0], vol[1])
+            vol = equitySurface.vol_from_delta_date(delta, expiry_dt)
+            test_cases.print(expiry_dt, delta, vol[0], vol[1])
 
 ###############################################################################
 
 
 if __name__ == '__main__':
 
     start = time.time()
```

### Comparing `financepy-0.350/tests_golden/TestFinFXAmericanOption.py` & `financepy-0.360/tests_golden/TestFinFXOptionSABR.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,121 +1,132 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.models.black_scholes import BlackScholes
+from financepy.products.fx.fx_vanilla_option import FXVanillaOption
+from financepy.utils.global_types import OptionTypes
+from financepy.utils.date import Date
+import numpy as np
 import sys
 sys.path.append("..")
 
-import numpy as np
-from financepy.utils.date import Date
-from financepy.utils.global_types import OptionTypes
-from financepy.products.fx.fx_vanilla_option import FXVanillaOption
-from financepy.models.black_scholes import BlackScholes
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from FinTestCases import FinTestCases, globalTestCaseMode
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
-def test_FinFXAmericanOption():
+def test_FinFXOptionSABR():
 
+    # UNFINISHED
     # There is no FXAmericanOption class. It is embedded in the FXVanillaOption
     # class. This test just compares it to the European
 
     value_dt = Date(13, 2, 2018)
     expiry_dt = Date(13, 2, 2019)
 
     # In BS the FX rate is the price in domestic of one unit of foreign
     # In case of EURUSD = 1.3 the domestic currency is USD and foreign is EUR
     # DOM = USD , FOR = EUR
-    ccy1 = "EUR"
-    ccy2 = "USD"
     ccy1CCRate = 0.030  # EUR
     ccy2CCRate = 0.025  # USD
 
-    currency_pair = ccy1 + ccy2  # Always ccy1ccy2
     spot_fx_rate = 1.20
     strike_fx_rate = 1.250
     volatility = 0.10
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+    notional = 1000000.0
+
+    domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+    foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
     model = BlackScholes(volatility)
 
     # Two examples to show that changing the notional currency and notional
     # keeps the value unchanged
+    notional = 1000000.0
 
-    test_cases.header("SPOT FX RATE", "VALUE_BS", "VOL_IN", "IMPLD_VOL")
+    spot_fx_rates = np.arange(50, 200, 10)/100.0
 
-    spot_fx_rates = np.arange(50, 200, 20)/100.0
+    test_cases.header("OPTION", "FX_RATE", "VALUE_BS", "VOL_IN", "DIFF")
 
     for spot_fx_rate in spot_fx_rates:
 
         call_option = FXVanillaOption(expiry_dt,
                                       strike_fx_rate,
-                                      currency_pair,
+                                      "EURUSD",
                                       OptionTypes.EUROPEAN_CALL,
-                                      1000000,
+                                      notional,
                                       "USD")
 
         valueEuropean = call_option.value(value_dt,
                                           spot_fx_rate,
-                                          dom_discount_curve,
-                                          for_discount_curve,
+                                          domestic_curve,
+                                          foreign_curve,
                                           model)['v']
 
         call_option = FXVanillaOption(expiry_dt,
                                       strike_fx_rate,
                                       "EURUSD",
                                       OptionTypes.AMERICAN_CALL,
                                       1000000,
                                       "USD")
 
         valueAmerican = call_option.value(value_dt,
                                           spot_fx_rate,
-                                          dom_discount_curve,
-                                          for_discount_curve,
+                                          domestic_curve,
+                                          foreign_curve,
                                           model)['v']
 
         diff = (valueAmerican - valueEuropean)
-        test_cases.print(spot_fx_rate, valueEuropean, valueAmerican, diff)
+
+        test_cases.print("CALL:",
+                         "%9.6f" % spot_fx_rate,
+                         "%9.7f" % valueEuropean,
+                         "%9.7f" % valueAmerican,
+                         "%9.7f" % diff)
+
+    test_cases.header("OPTION", "FX_RATE", "VALUE_BS", "VOL_IN", "DIFF")
 
     for spot_fx_rate in spot_fx_rates:
 
         call_option = FXVanillaOption(expiry_dt,
                                       strike_fx_rate,
                                       "EURUSD",
                                       OptionTypes.EUROPEAN_PUT,
                                       1000000,
                                       "USD")
 
         valueEuropean = call_option.value(value_dt,
                                           spot_fx_rate,
-                                          dom_discount_curve,
-                                          for_discount_curve,
+                                          domestic_curve,
+                                          foreign_curve,
                                           model)['v']
 
         call_option = FXVanillaOption(expiry_dt,
                                       strike_fx_rate,
                                       "EURUSD",
                                       OptionTypes.AMERICAN_PUT,
                                       1000000,
                                       "USD")
 
         valueAmerican = call_option.value(value_dt,
                                           spot_fx_rate,
-                                          dom_discount_curve,
-                                          for_discount_curve,
+                                          domestic_curve,
+                                          foreign_curve,
                                           model)['v']
 
         diff = (valueAmerican - valueEuropean)
-        test_cases.print(spot_fx_rate, valueEuropean, valueAmerican, diff)
+        test_cases.print("PUT:",
+                         "%9.6f" % spot_fx_rate,
+                         "%9.7f" % valueEuropean,
+                         "%9.7f" % valueAmerican,
+                         "%9.7f" % diff)
 
 ###############################################################################
 
 
-test_FinFXAmericanOption()
+test_FinFXOptionSABR()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinFXBarrierOption.py` & `financepy-0.360/tests_golden/TestFinFXBarrierOption.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
 import sys
 sys.path.append("..")
 
-from financepy.models.process_simulator import ProcessTypes
-from financepy.models.process_simulator import FinGBMNumericalScheme
-from financepy.models.black_scholes import BlackScholes
-from financepy.products.fx.fx_barrier_option import FinFXBarrierTypes
-from financepy.products.fx.fx_barrier_option import FXBarrierOption
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.utils.date import Date
 from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.utils.date import Date
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.products.fx.fx_barrier_option import FXBarrierOption
+from financepy.products.fx.fx_barrier_option import FinFXBarrierTypes
+from financepy.models.black_scholes import BlackScholes
+from financepy.models.process_simulator import FinGBMNumericalScheme
+from financepy.models.process_simulator import ProcessTypes
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
@@ -24,140 +24,141 @@
 
     value_dt = Date(1, 1, 2015)
     expiry_dt = Date(1, 1, 2016)
     spot_fx_rate = 100.0
     currency_pair = "USDJPY"
     volatility = 0.20
     dom_interest_rate = 0.05
-    forInterestRate = 0.02
+    for_interest_rate = 0.02
     option_type = FinFXBarrierTypes.DOWN_AND_OUT_CALL
     notional = 100.0
     notional_currency = "USD"
 
-    drift = dom_interest_rate - forInterestRate
+    drift = dom_interest_rate - for_interest_rate
     scheme = FinGBMNumericalScheme.ANTITHETIC
     process_type = ProcessTypes.GBM
-    dom_discount_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forInterestRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_interest_rate)
     model = BlackScholes(volatility)
 
     ###########################################################################
 
     import time
     start = time.time()
     num_observations_per_year = 100
 
     for option_type in FinFXBarrierTypes:
 
         test_cases.header("Type", "K", "B", "S", "Value",
-                         "ValueMC", "TIME", "Diff")
+                          "ValueMC", "TIME", "Diff")
 
         for spot_fx_rate in range(60, 140, 20):
             B = 110.0
             K = 100.0
 
             option = FXBarrierOption(expiry_dt, K, currency_pair,
                                      option_type, B,
                                      num_observations_per_year,
                                      notional, notional_currency)
 
             value = option.value(value_dt, spot_fx_rate,
-                                 dom_discount_curve, for_discount_curve, model)
+                                 domestic_curve, foreign_curve, model)
 
             start = time.time()
             model_params = (spot_fx_rate, drift, volatility, scheme)
             value_mc = option.value_mc(value_dt, spot_fx_rate,
                                        dom_interest_rate, process_type,
                                        model_params)
 
             end = time.time()
             time_elapsed = round(end - start, 3)
             diff = value_mc - value
 
             test_cases.print(option_type, K, B, spot_fx_rate, value, value_mc,
-                            time_elapsed, diff)
+                             time_elapsed, diff)
 
         for spot_fx_rate in range(60, 140, 20):
             B = 100.0
             K = 110.0
 
             option = FXBarrierOption(expiry_dt, K, currency_pair,
                                      option_type, B,
                                      num_observations_per_year,
                                      notional, notional_currency)
 
             value = option.value(value_dt, spot_fx_rate,
-                                 dom_discount_curve, for_discount_curve, model)
+                                 domestic_curve, foreign_curve, model)
 
             start = time.time()
             model_params = (spot_fx_rate, drift, volatility, scheme)
             value_mc = option.value_mc(value_dt,
                                        spot_fx_rate,
                                        dom_interest_rate,
                                        process_type,
                                        model_params)
 
             end = time.time()
             time_elapsed = round(end - start, 3)
             diff = value_mc - value
 
             test_cases.print(option_type, K, B, spot_fx_rate, value, value_mc,
-                            time_elapsed, diff)
+                             time_elapsed, diff)
 
     end = time.time()
 
 ##########################################################################
 
     spot_fx_rates = range(50, 150, 50)
     B = 105.0
 
-    test_cases.header("Type", "K", "B", "S:", "Value", "Delta", "Vega", "Theta")
+    test_cases.header("Type", "K", "B", "S:", "Value",
+                      "Delta", "Vega", "Theta")
 
     for option_type in FinFXBarrierTypes:
         for spot_fx_rate in spot_fx_rates:
             barrier_option = FXBarrierOption(expiry_dt,
                                              100.0,
                                              currency_pair,
                                              option_type,
                                              B,
                                              num_observations_per_year,
                                              notional,
                                              notional_currency)
 
             value = barrier_option.value(value_dt,
                                          spot_fx_rate,
-                                         dom_discount_curve,
-                                         for_discount_curve,
+                                         domestic_curve,
+                                         foreign_curve,
                                          model)
 
             delta = barrier_option.delta(value_dt,
                                          spot_fx_rate,
-                                         dom_discount_curve,
-                                         for_discount_curve,
+                                         domestic_curve,
+                                         foreign_curve,
                                          model)
 
             vega = barrier_option.vega(value_dt,
                                        spot_fx_rate,
-                                       dom_discount_curve,
-                                       for_discount_curve,
+                                       domestic_curve,
+                                       foreign_curve,
                                        model)
 
             theta = barrier_option.theta(value_dt,
                                          spot_fx_rate,
-                                         dom_discount_curve,
-                                         for_discount_curve,
+                                         domestic_curve,
+                                         foreign_curve,
                                          model)
 
             test_cases.print(option_type,
-                            K,
-                            B,
-                            spot_fx_rate,
-                            value,
-                            delta,
-                            vega,
-                            theta)
+                             K,
+                             B,
+                             spot_fx_rate,
+                             value,
+                             delta,
+                             vega,
+                             theta)
 
 ###############################################################################
 
 
 test_FinFXBarrierOption()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinFXDigitalOption.py` & `financepy-0.360/tests_golden/TestFinFXDigitalOption.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,28 +1,27 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import time
 import sys
 sys.path.append("..")
 
-import time
 import numpy as np
 
-from FinTestCases import FinTestCases, globalTestCaseMode
-from financepy.utils.date import Date
-from financepy.products.rates.ibor_deposit import IborDeposit
-from financepy.products.rates.ibor_single_curve import IborSingleCurve
-from financepy.utils.calendar import CalendarTypes
-from financepy.utils.day_count import DayCountTypes
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.models.black_scholes import BlackScholes
-from financepy.products.fx.fx_digital_option import FXDigitalOption
 from financepy.utils.global_types import OptionTypes
-
+from financepy.products.fx.fx_digital_option import FXDigitalOption
+from financepy.models.black_scholes import BlackScholes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.utils.day_count import DayCountTypes
+from financepy.utils.calendar import CalendarTypes
+from financepy.products.rates.ibor_single_curve import IborSingleCurve
+from financepy.products.rates.ibor_deposit import IborDeposit
+from financepy.utils.date import Date
+from FinTestCases import FinTestCases, globalTestCaseMode
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
 def test_FinFXDigitalOption():
@@ -43,32 +42,32 @@
     currency_pair = ccy1 + ccy2  # Always ccy1ccy2
     spot_fx_rate = 1.20
     strike_fx_rate = 1.250
     volatility = 0.10
 
     notional = 1.0
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+    foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
     model = BlackScholes(volatility)
 
     digital_option = FXDigitalOption(expiry_dt,
                                      strike_fx_rate,
                                      currency_pair,
                                      OptionTypes.DIGITAL_CALL,
                                      notional,
                                      "USD")
 
     spot_fx_rate = np.linspace(0.01, 2.0, 10)
 
     value = digital_option.value(value_dt,
                                  spot_fx_rate,
-                                 dom_discount_curve,
-                                 for_discount_curve,
+                                 domestic_curve,
+                                 foreign_curve,
                                  model)
 
 ###############################################################################
 
 
 test_FinFXDigitalOption()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinFXDoubleDigitalOption.py` & `financepy-0.360/tests_golden/TestFinFXDoubleDigitalOption.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,70 +1,70 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
 import time
-import numpy as np
-
 import sys
 sys.path.append("..")
 
-from FinTestCases import FinTestCases, globalTestCaseMode
-from financepy.utils.date import Date
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.models.black_scholes import BlackScholes
+import numpy as np
+
 from financepy.products.fx.fx_double_digital_option import FXDoubleDigitalOption
+from financepy.models.black_scholes import BlackScholes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.utils.date import Date
+from FinTestCases import FinTestCases, globalTestCaseMode
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
 def test_FinFXDoubleDigitalOption():
 
     value_dt = Date(10, 4, 2020)
-    expiry_date = Date(18, 9, 2020)
+    expiry_dt = Date(18, 9, 2020)
 
-    forName = "EUR"
-    domName = "USD"
-    forCCRate = 0.03460  # EUR
-    domCCRate = 0.02940  # USD
+    for_name = "EUR"
+    dom_name = "USD"
+    for_cc_rate = 0.03460  # EUR
+    dom_cc_rate = 0.02940  # USD
 
-    currency_pair = forName + domName  # Always FORDOM
+    currency_pair = for_name + dom_name  # Always FORDOM
     spot_fx_rate = 1.20
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
     volatility = 0.20
 
     notional = 1.0
 
     upper_strike = 1.4
     lower_strike = 1.1
 
     model = BlackScholes(volatility)
 
     double_digital_option = FXDoubleDigitalOption(
-        expiry_date,
+        expiry_dt,
         upper_strike,
         lower_strike,
         currency_pair,
         notional,
         "USD",
     )
 
     spot_fx_rate = np.linspace(0.01, 2.0, 10)
 
     value = double_digital_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
 ###############################################################################
 
 
 test_FinFXDoubleDigitalOption()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinFXForward.py` & `financepy-0.360/tests_golden/TestFinFXForward.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,22 +1,21 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.utils.date import Date
+from financepy.products.rates.ibor_deposit import IborDeposit
+from financepy.products.rates.ibor_single_curve import IborSingleCurve
+from financepy.utils.calendar import CalendarTypes
+from financepy.utils.day_count import DayCountTypes
+from financepy.products.fx.fx_forward import FXForward
 import sys
 sys.path.append("..")
 
-from financepy.products.fx.fx_forward import FXForward
-from financepy.utils.day_count import DayCountTypes
-from financepy.utils.calendar import CalendarTypes
-from financepy.products.rates.ibor_single_curve import IborSingleCurve
-from financepy.products.rates.ibor_deposit import IborDeposit
-from financepy.utils.date import Date
-from FinTestCases import FinTestCases, globalTestCaseMode
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
 def test_FinFXForward():
@@ -24,17 +23,17 @@
     #  https://stackoverflow.com/questions/48778712
     #  /fx-vanilla-call-price-in-quantlib-doesnt-match-bloomberg
 
     value_dt = Date(13, 2, 2018)
     expiry_dt = value_dt.add_months(12)
     # Forward is on EURUSD which is expressed as number of USD per EUR
     # ccy1 = EUR and ccy2 = USD
-    forName = "EUR"
-    domName = "USD"
-    currency_pair = forName + domName  # Always ccy1ccy2
+    for_name = "EUR"
+    dom_name = "USD"
+    currency_pair = for_name + dom_name  # Always ccy1ccy2
     spot_fx_rate = 1.300  # USD per EUR
     strike_fx_rate = 1.365  # USD per EUR
     ccy1InterestRate = 0.02  # USD Rates
     ccy2InterestRate = 0.05  # EUR rates
 
     ###########################################################################
 
@@ -47,43 +46,43 @@
     depos = []
     fras = []
     swaps = []
     deposit_rate = ccy1InterestRate
     depo = IborDeposit(settle_dt, maturity_dt, deposit_rate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    for_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    foreign_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     depos = []
     fras = []
     swaps = []
     deposit_rate = ccy2InterestRate
     depo = IborDeposit(settle_dt, maturity_dt, deposit_rate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    dom_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    domestic_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     notional = 100.0
-    notional_currency = forName
+    notional_currency = for_name
 
     fxForward = FXForward(expiry_dt,
                           strike_fx_rate,
                           currency_pair,
                           notional,
                           notional_currency)
 
     test_cases.header("SPOT FX", "FX FWD", "VALUE_BS")
 
     fwdValue = fxForward.value(value_dt, spot_fx_rate,
-                               dom_discount_curve, for_discount_curve)
+                               domestic_curve, foreign_curve)
 
-    fwdFXRate = fxForward.forward(value_dt, spot_fx_rate,
-                                  dom_discount_curve,
-                                  for_discount_curve)
+    fwd_fx_rate = fxForward.forward(value_dt, spot_fx_rate,
+                                    domestic_curve,
+                                    foreign_curve)
 
-    test_cases.print(spot_fx_rate, fwdFXRate, fwdValue)
+    test_cases.print(spot_fx_rate, fwd_fx_rate, fwdValue)
 
 ###############################################################################
 
 
 test_FinFXForward()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinFXLookbackOption.py` & `financepy-0.360/tests_golden/TestFinFXLookbackOption.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,19 +16,19 @@
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def test_EquityLookBackOption():
     value_dt = Date(1, 1, 2015)
-    expiry_date = Date(1, 1, 2016)
+    expiry_dt = Date(1, 1, 2016)
     stock_price = 100.0
     volatility = 0.3
-    num_pathsRange = [10000]
-    stock_priceRange = range(90, 110, 5)
+    num_paths_range = [10000]
+    stock_price_range = range(90, 110, 5)
     num_steps_per_year = 252
 
     domesticRate = 0.05
     domestic_curve = DiscountCurveFlat(value_dt, domesticRate)
 
     foreignRate = 0.02
     foreign_curve = DiscountCurveFlat(value_dt, foreignRate)
@@ -42,17 +42,17 @@
         "SMIN",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFloatLookbackOption(expiry_date, option_type)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFloatLookbackOption(expiry_dt, option_type)
             stockMin = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -87,17 +87,17 @@
         "SMIN",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFloatLookbackOption(expiry_date, option_type)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFloatLookbackOption(expiry_dt, option_type)
             stockMin = stock_price - 10
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -132,17 +132,17 @@
         "SMAX",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFloatLookbackOption(expiry_date, option_type)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFloatLookbackOption(expiry_dt, option_type)
             stockMax = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -177,17 +177,17 @@
         "SMAX",
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFloatLookbackOption(expiry_date, option_type)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFloatLookbackOption(expiry_dt, option_type)
             stockMax = stock_price + 10
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -214,15 +214,15 @@
                 value_mc,
                 diff,
                 time_elapsed)
 
 ###############################################################################
 ###############################################################################
 
-    stock_priceRange = range(90, 110, 5)
+    stock_price_range = range(90, 110, 5)
     num_steps_per_year = 252
 
     test_cases.header(
         "NUMPATHS",
         "OPTION_TYPE",
         "S",
         "K",
@@ -230,17 +230,17 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
     k = 95.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFixedLookbackOption(expiry_date, option_type, k)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFixedLookbackOption(expiry_dt, option_type, k)
             stockMax = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -278,17 +278,17 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
     k = 100.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFixedLookbackOption(expiry_date, option_type, k)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFixedLookbackOption(expiry_dt, option_type, k)
             stockMax = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -326,17 +326,17 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_CALL
     k = 105.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFixedLookbackOption(expiry_date, option_type, k)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFixedLookbackOption(expiry_dt, option_type, k)
             stockMax = stock_price + 10.0
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -374,17 +374,17 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
     k = 95.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFixedLookbackOption(expiry_date, option_type, k)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFixedLookbackOption(expiry_dt, option_type, k)
             stockMin = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -422,17 +422,17 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
     k = 100.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFixedLookbackOption(expiry_date, option_type, k)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFixedLookbackOption(expiry_dt, option_type, k)
             stockMin = stock_price
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
@@ -470,17 +470,17 @@
         "VALUE",
         "VALUE_MC",
         "DIFF",
         "TIME")
 
     option_type = OptionTypes.EUROPEAN_PUT
     k = 105.0
-    for stock_price in stock_priceRange:
-        for num_paths in num_pathsRange:
-            option = FXFixedLookbackOption(expiry_date, option_type, k)
+    for stock_price in stock_price_range:
+        for num_paths in num_paths_range:
+            option = FXFixedLookbackOption(expiry_dt, option_type, k)
             stockMin = stock_price - 10.0
             value = option.value(
                 value_dt,
                 stock_price,
                 domestic_curve,
                 foreign_curve,
                 volatility,
```

### Comparing `financepy-0.350/tests_golden/TestFinFXOneTouchOption.py` & `financepy-0.360/tests_golden/TestFinFXOneTouchOption.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,16 +29,16 @@
 
     domesticRate = 0.10
     foreignRate = 0.03
 
     num_paths = 50000
     num_steps_per_year = 252 * 2
 
-    domCurve = DiscountCurveFlat(value_dt, domesticRate)
-    forCurve = DiscountCurveFlat(value_dt, foreignRate)
+    dom_curve = DiscountCurveFlat(value_dt, domesticRate)
+    for_curve = DiscountCurveFlat(value_dt, foreignRate)
 
     spot_fx_rate = 1.050
     payment_size = 1.5
 
     test_cases.header("================================= CASH ONLY")
 
     downTypes = [TouchOptionTypes.DOWN_AND_IN_CASH_AT_HIT,
@@ -52,22 +52,22 @@
         option = FXOneTouchOption(expiry_dt,
                                   downType,
                                   barrier_level,
                                   payment_size)
 
         v = option.value(value_dt,
                          spot_fx_rate,
-                         domCurve,
-                         forCurve,
+                         dom_curve,
+                         for_curve,
                          model)
 
         v_mc = option.value_mc(value_dt,
                                spot_fx_rate,
-                               domCurve,
-                               forCurve,
+                               dom_curve,
+                               for_curve,
                                model,
                                num_steps_per_year,
                                num_paths)
 
         test_cases.print("%60s " % downType,
                         "%9.5f" % v,
                         "%9.5f" % v_mc)
@@ -88,22 +88,22 @@
         option = FXOneTouchOption(expiry_dt,
                                   upType,
                                   barrier_level,
                                   payment_size)
 
         v = option.value(value_dt,
                          spot_fx_rate,
-                         domCurve,
-                         forCurve,
+                         dom_curve,
+                         for_curve,
                          model)
 
         v_mc = option.value_mc(value_dt,
                                spot_fx_rate,
-                               domCurve,
-                               forCurve,
+                               dom_curve,
+                               for_curve,
                                model,
                                num_steps_per_year,
                                num_paths)
 
         test_cases.print("%60s " % upType,
                         "%9.5f" % v,
                         "%9.5f" % v_mc)
@@ -128,56 +128,56 @@
 
     forRate = 0.00593 # EUR
     domRate = -0.00414 # USD
 
     num_paths = 50000
     num_steps_per_year = 252
 
-    domCurve = DiscountCurveFlat(value_dt, domRate)
-    forCurve = DiscountCurveFlat(value_dt, forRate)
+    dom_curve = DiscountCurveFlat(value_dt, domRate)
+    for_curve = DiscountCurveFlat(value_dt, forRate)
 
     payment_size = 1000000 # EUR
 
     optionType = TouchOptionTypes.UP_AND_IN_CASH_AT_EXPIRY
 
     option = FXOneTouchOption(expiry_dt,
                               optionType,
                               barrier_level,
                               payment_size)
 
     v = option.value(value_dt,
                      spot_fx_rate,
-                     domCurve,
-                     forCurve,
+                     dom_curve,
+                     for_curve,
                      model)
 
     v_mc = option.value_mc(value_dt,
                            spot_fx_rate,
-                           domCurve,
-                           forCurve,
+                           dom_curve,
+                           for_curve,
                            model,
                            num_steps_per_year,
                            num_paths)
 
     d = option.delta(value_dt,
                      spot_fx_rate,
-                     domCurve,
-                     forCurve,
+                     dom_curve,
+                     for_curve,
                      model)
 
     g = option.gamma(value_dt,
                      spot_fx_rate,
-                     domCurve,
-                     forCurve,
+                     dom_curve,
+                     for_curve,
                      model)
 
     v = option.vega(value_dt,
                      spot_fx_rate,
-                     domCurve,
-                     forCurve,
+                     dom_curve,
+                     for_curve,
                      model)
 
     # I SHOULD GET 49.4934% OR 494,934 in EUR
     # VEGA IS 68,777.26
     # GAMMA IS 916,285
     # DELTA IS -9560266
```

### Comparing `financepy-0.350/tests_golden/TestFinFXVanillaOption.py` & `financepy-0.360/tests_golden/TestFinFXVanillaOption.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import numpy as np
+import time
+
 import sys
 sys.path.append("..")
 
-from FinTestCases import FinTestCases, globalTestCaseMode
-from financepy.utils.date import Date
-from financepy.products.rates.ibor_deposit import IborDeposit
-from financepy.products.rates.ibor_single_curve import IborSingleCurve
-from financepy.utils.calendar import CalendarTypes
-from financepy.utils.day_count import DayCountTypes
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.models.black_scholes import BlackScholes
-from financepy.models.sabr import SABR
-from financepy.products.fx.fx_vanilla_option import FXVanillaOption
 from financepy.utils.global_types import OptionTypes
-import time
-import numpy as np
+from financepy.products.fx.fx_vanilla_option import FXVanillaOption
+from financepy.models.sabr import SABR
+from financepy.models.black_scholes import BlackScholes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.utils.day_count import DayCountTypes
+from financepy.utils.calendar import CalendarTypes
+from financepy.products.rates.ibor_single_curve import IborSingleCurve
+from financepy.products.rates.ibor_deposit import IborDeposit
+from financepy.utils.date import Date
+from FinTestCases import FinTestCases, globalTestCaseMode
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
@@ -46,53 +47,53 @@
     currency_pair = ccy1 + ccy2  # Always ccy1ccy2
     spot_fx_rate = 1.20
     strike_fx_rate = 1.250
     volatility = 0.10
 
     notional = 1000000.0
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+    foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
     model = BlackScholes(volatility)
 
     # Two examples to show that changing the notional currency and notional
     # keeps the value unchanged
     notional = 1000000.0
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   "EUR", 2)
 
     value = call_option.value(value_dt, spot_fx_rate,
-                              dom_discount_curve,
-                              for_discount_curve, model)
+                              domestic_curve,
+                              foreign_curve, model)
 
     notional = 1250000.0
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   "USD", 2)
 
     value = call_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     delta = call_option.delta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     test_cases.header("value", "delta")
     test_cases.print(value, delta)
 
 ###############################################################################
 
@@ -116,16 +117,16 @@
     currency_pair = ccy1 + ccy2  # Always ccy1ccy2
     spot_fx_rate = 0.9090
     strike_fx_rate = 0.9090
     volatility = 0.12
 
     notional = 1000000.0
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, ccy2CCRate)
+    foreign_curve = DiscountCurveFlat(value_dt, ccy1CCRate)
 
     model = BlackScholes(volatility)
 
     # Two examples to show that changing the notional currency and notional
     # keeps the value unchanged
     notional = 1000000.0
     call_option = FXVanillaOption(expiry_dt,
@@ -134,23 +135,23 @@
                                   OptionTypes.EUROPEAN_PUT,
                                   notional,
                                   "EUR", 2)
 
     value = call_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     delta = call_option.delta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     test_cases.header("value", "delta")
     test_cases.print(value, delta)
 
 ###############################################################################
 
@@ -162,20 +163,20 @@
 
     value_dt = Date(13, 2, 2018)
     expiry_dt = Date(15, 2, 2019)
 
     # In BS the FX rate is the price in domestic of one unit of foreign
     # In case of EURUSD = 1.3 the domestic currency is USD and foreign is EUR
     # DOM = USD , FOR = EUR
-    forName = "EUR"
-    domName = "USD"
+    for_name = "EUR"
+    dom_name = "USD"
     forDepoRate = 0.05  # EUR
     domDepoRate = 0.02  # USD
 
-    currency_pair = forName + domName  # Always FORDOM
+    currency_pair = for_name + dom_name  # Always FORDOM
     spot_fx_rate = 1.30
     strike_fx_rate = 1.3650
     volatility = 0.20
 
     spot_days = 0
     settle_dt = value_dt.add_weekdays(spot_days)
     maturity_dt = settle_dt.add_months(12)
@@ -185,45 +186,45 @@
 
     depos = []
     fras = []
     swaps = []
     depo = IborDeposit(settle_dt, maturity_dt, domDepoRate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    dom_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    domestic_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     depos = []
     fras = []
     swaps = []
     depo = IborDeposit(settle_dt, maturity_dt, forDepoRate,
                        DayCountTypes.ACT_360, notional, cal_type)
     depos.append(depo)
-    for_discount_curve = IborSingleCurve(value_dt, depos, fras, swaps)
+    foreign_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     model = BlackScholes(volatility)
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_fx_rate,
                                   currency_pair,
                                   OptionTypes.EUROPEAN_CALL,
                                   notional,
                                   notional_currency, 2)
 
     value = call_option.value(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     delta = call_option.delta(
         value_dt,
         spot_fx_rate,
-        dom_discount_curve,
-        for_discount_curve,
+        domestic_curve,
+        foreign_curve,
         model)
 
     test_cases.header("value", "delta")
     test_cases.print(value, delta)
 
 ###############################################################################
 
@@ -234,16 +235,16 @@
     value_dt = Date(1, 1, 2015)
     expiry_dt = value_dt.add_months(4)
     spot_fx_rate = 1.60
     volatility = 0.1411
     dom_interest_rate = 0.08
     forInterestRate = 0.11
     model = BlackScholes(volatility)
-    dom_discount_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forInterestRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_interest_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, forInterestRate)
 
     num_paths_list = [10000, 20000, 40000, 80000, 160000, 320000]
 
     test_cases.header("NUMPATHS", "VALUE_BS", "VALUE_MC")
     strike_fx_rate = 1.60
 
     for num_paths in num_paths_list:
@@ -254,25 +255,25 @@
                                       OptionTypes.EUROPEAN_CALL,
                                       1000000,
                                       "USD")
 
         value = call_option.value(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
 
         start = time.time()
 
         value_mc = call_option.value_mc(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model,
             num_paths)
 
         end = time.time()
         duration = end - start
         test_cases.print(num_paths, value, value_mc)
 
@@ -292,23 +293,23 @@
                                       OptionTypes.EUROPEAN_CALL,
                                       1000000,
                                       "USD")
 
         value = call_option.value(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         start = time.time()
         value_mc = call_option.value_mc(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model,
             num_paths)
         end = time.time()
         duration = end - start
         test_cases.print(num_paths, value, value_mc)
 
 ##########################################################################
@@ -326,23 +327,23 @@
                                      OptionTypes.EUROPEAN_PUT,
                                      1000000,
                                      "USD")
 
         value = put_option.value(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         start = time.time()
         value_mc = put_option.value_mc(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model,
             num_paths)
         end = time.time()
         duration = end - start
         test_cases.print(spot_fx_rate, value, value_mc)
 
 ##########################################################################
@@ -363,34 +364,34 @@
                                       "EURUSD",
                                       OptionTypes.EUROPEAN_CALL,
                                       1000000,
                                       "USD")
         value = call_option.value(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         delta = call_option.delta(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         vega = call_option.vega(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         theta = call_option.theta(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         #  call_option.rho(value_dt,stock_price, interest_rate,
         #  dividend_yield, modelType, model_params)
         rho = 999
         test_cases.print(spot_fx_rate, value, delta, vega, theta, rho)
 
     test_cases.header(
@@ -408,34 +409,34 @@
                                      OptionTypes.EUROPEAN_PUT,
                                      1000000,
                                      "USD")
 
         value = put_option.value(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         delta = put_option.delta(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         vega = put_option.vega(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         theta = put_option.theta(
             value_dt,
             spot_fx_rate,
-            dom_discount_curve,
-            for_discount_curve,
+            domestic_curve,
+            foreign_curve,
             model)
         # put_option.rho(value_dt,stock_price, interest_rate, dividend_yield,
         # modelType, model_params)
         rho = 999
         test_cases.print(spot_fx_rate, value, delta, vega, theta, rho)
 
 ##########################################################################
@@ -450,41 +451,42 @@
                                       "EURUSD",
                                       OptionTypes.EUROPEAN_CALL,
                                       1000000,
                                       "USD")
 
         value = call_option.value(value_dt,
                                   spot_fx_rate,
-                                  dom_discount_curve,
-                                  for_discount_curve,
+                                  domestic_curve,
+                                  foreign_curve,
                                   model)['v']
 
         impliedVol = call_option.implied_volatility(value_dt,
                                                     spot_fx_rate,
-                                                    dom_discount_curve,
-                                                    for_discount_curve,
+                                                    domestic_curve,
+                                                    foreign_curve,
                                                     value)
 
         test_cases.print(spot_fx_rate, value, volatility, impliedVol)
 
 ###############################################################################
 
+
 def test_FinFXVanillaOptionSABRExample():
     """
     Test case for FXVanilla option pricing with SABR model
     """
     # define option
     value_dt = Date(5, 4, 2023)
-    forName = "USD"
-    domName = "JPY"
-    forCCRate = 0.0381  # USD
-    domCCRate = 0.000396  # JPY
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
-    currency_pair = forName + domName
+    for_name = "USD"
+    dom_name = "JPY"
+    for_cc_rate = 0.0381  # USD
+    dom_cc_rate = 0.000396  # JPY
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
+    currency_pair = for_name + dom_name
     spot_fx_rate = 131.32
     strike_price = 130
     expiry_dt = value_dt.add_tenor("10M")
     notional = 70000000
 
     call_option = FXVanillaOption(expiry_dt,
                                   strike_price,
@@ -497,29 +499,29 @@
 
     alpha = 0.174
     beta = 0.5
     rho = -0.50
     nu = 0.5
 
     model = SABR(alpha, beta, rho, nu)
-    blackVol = volatility
+    black_vol = volatility
     t_exp = 0.8444  # 10M
-    model.set_alpha_from_black_vol(blackVol,
+    model.set_alpha_from_black_vol(black_vol,
                                    spot_fx_rate,
                                    strike_price,
                                    t_exp)
 
     spot_fx_rate = np.linspace(80, 300, 1000)
 
     call_values = []
 
     for f in spot_fx_rate:
 
-        call_value = call_option.value(value_dt, f, dom_discount_curve,
-                                       for_discount_curve, model)['cash_dom']
+        call_value = call_option.value(value_dt, f, domestic_curve,
+                                       foreign_curve, model)['cash_dom']
 
         call_values.append(call_value)
 
     test_cases.header("spot fx rate", "value")
     test_cases.print(spot_fx_rate, call_value)
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinFXVolSurfacePlus.py` & `financepy-0.360/tests_golden/TestFinFXVolSurfacePlus.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import time
+import matplotlib.pyplot as plt
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.models.volatility_fns import VolFuncTypes
+from financepy.utils.date import Date
+from financepy.market.volatility.fx_vol_surface_plus import FinFXDeltaMethod
+from financepy.market.volatility.fx_vol_surface_plus import FinFXATMMethod
+from financepy.market.volatility.fx_vol_surface_plus import FXVolSurfacePlus
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+import numpy as np
 import sys
 sys.path.append("..")
 
-import numpy as np
-
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.market.volatility.fx_vol_surface_plus import FXVolSurfacePlus
-from financepy.market.volatility.fx_vol_surface_plus import FinFXATMMethod
-from financepy.market.volatility.fx_vol_surface_plus import FinFXDeltaMethod
-from financepy.utils.date import Date
-from financepy.models.volatility_fns import VolFuncTypes
-from FinTestCases import FinTestCases, globalTestCaseMode
-import matplotlib.pyplot as plt
-import time
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 PLOT_GRAPHS = False
 
@@ -35,66 +34,66 @@
     if 1 == 1:
 
         # Example from Book extract by Iain Clark using Tables 3.3 and 3.4
         # print("EURUSD EXAMPLE CLARK")
 
         value_dt = Date(10, 4, 2020)
 
-        forName = "EUR"
-        domName = "USD"
-        forCCRate = 0.03460  # EUR
-        domCCRate = 0.02940  # USD
+        for_name = "EUR"
+        dom_name = "USD"
+        for_cc_rate = 0.03460  # EUR
+        dom_cc_rate = 0.02940  # USD
 
-        dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-        for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+        domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+        foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-        currency_pair = forName + domName
+        currency_pair = for_name + dom_name
         spot_fx_rate = 1.3465
 
         tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
         atm_vols = [21.00, 21.00, 20.750, 19.400, 18.250, 17.677]
-        marketStrangle25DeltaVols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
-        riskReversal25DeltaVols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
-        marketStrangle10DeltaVols = [2.433, 2.83, 3.228, 3.485, 3.806, 3.208]
-        riskReversal10DeltaVols = [-1.258, -
+        mkt_strangle_25d_vols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
+        rsk_reversal_25d_vols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
+        mkt_strangle_10d_vols = [2.433, 2.83, 3.228, 3.485, 3.806, 3.208]
+        rsk_reversal_10d_vols = [-1.258, -
                                    1.297, -1.332, -1.408, -1.359, -1.208]
 
-        notional_currency = forName
+        notional_currency = for_name
 
-        atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+        atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
         delta_method = FinFXDeltaMethod.SPOT_DELTA
         vol_functionType = VolFuncTypes.CLARK5
         alpha = 0.5  # FIT WINGS AT 10D if ALPHA = 1.0
 
-        fxMarketPlus = FXVolSurfacePlus(value_dt,
+        fx_market_plus = FXVolSurfacePlus(value_dt,
                                         spot_fx_rate,
                                         currency_pair,
                                         notional_currency,
-                                        dom_discount_curve,
-                                        for_discount_curve,
+                                        domestic_curve,
+                                        foreign_curve,
                                         tenors,
                                         atm_vols,
-                                        marketStrangle25DeltaVols,
-                                        riskReversal25DeltaVols,
-                                        marketStrangle10DeltaVols,
-                                        riskReversal10DeltaVols,
+                                        mkt_strangle_25d_vols,
+                                        rsk_reversal_25d_vols,
+                                        mkt_strangle_10d_vols,
+                                        rsk_reversal_10d_vols,
                                         alpha,
-                                        atmMethod,
+                                        atm_method,
                                         delta_method,
                                         vol_functionType)
 
-        fxMarketPlus.check_calibration(False)
+        fx_market_plus.check_calibration(False)
 
         if 1 == 0:  # PLOT_GRAPHS:
 
-            fxMarketPlus.plot_vol_curves()
+            fx_market_plus.plot_vol_curves()
 
             plt.figure()
 
-            dbns = fxMarketPlus.implied_dbns(0.5, 2.0, 1000)
+            dbns = fx_market_plus.implied_dbns(0.5, 2.0, 1000)
 
             for i in range(0, len(dbns)):
                 plt.plot(dbns[i]._x, dbns[i]._densitydx)
                 plt.title(vol_functionType)
                 print("SUM:", dbns[i].sum())
 
 ###############################################################################
@@ -105,65 +104,65 @@
     # print("==============================================================")
 
     # Example from Book extract by Iain Clarke using Tables 3.3 and 3.4
     # print("EURJPY EXAMPLE CLARK")
 
     value_dt = Date(10, 4, 2020)
 
-    forName = "EUR"
-    domName = "JPY"
-    forCCRate = 0.0294  # EUR
-    domCCRate = 0.0171  # USD
+    for_name = "EUR"
+    dom_name = "JPY"
+    for_cc_rate = 0.0294  # EUR
+    dom_cc_rate = 0.0171  # USD
 
-    dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-    for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+    domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+    foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-    currency_pair = forName + domName
+    currency_pair = for_name + dom_name
     spot_fx_rate = 90.72
 
     tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
     atm_vols = [21.50, 20.50, 19.85, 18.00, 15.95, 14.009]
-    marketStrangle25DeltaVols = [0.35, 0.325, 0.300, 0.225, 0.175, 0.100]
-    riskReversal25DeltaVols = [-8.350, -8.650, -8.950, -9.250, -9.550, -9.500]
-    marketStrangle10DeltaVols = [3.704, 4.047, 4.396, 4.932, 5.726, 5.709]
-    riskReversal10DeltaVols = [-15.855, -
+    mkt_strangle_25d_vols = [0.35, 0.325, 0.300, 0.225, 0.175, 0.100]
+    rsk_reversal_25d_vols = [-8.350, -8.650, -8.950, -9.250, -9.550, -9.500]
+    mkt_strangle_10d_vols = [3.704, 4.047, 4.396, 4.932, 5.726, 5.709]
+    rsk_reversal_10d_vols = [-15.855, -
                                16.467, -17.114, -17.882, -18.855, -18.217]
     alpha = 0.50  # Equally fit 10 and 25 Delta
 
-    notional_currency = forName
+    notional_currency = for_name
 
-    atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ
+    atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL_PREM_ADJ
     delta_method = FinFXDeltaMethod.SPOT_DELTA_PREM_ADJ
     vol_functionType = VolFuncTypes.CLARK5
 
-    fxMarketPlus = FXVolSurfacePlus(value_dt,
+    fx_market_plus = FXVolSurfacePlus(value_dt,
                                     spot_fx_rate,
                                     currency_pair,
                                     notional_currency,
-                                    dom_discount_curve,
-                                    for_discount_curve,
+                                    domestic_curve,
+                                    foreign_curve,
                                     tenors,
                                     atm_vols,
-                                    marketStrangle25DeltaVols,
-                                    riskReversal25DeltaVols,
-                                    marketStrangle10DeltaVols,
-                                    riskReversal10DeltaVols,
+                                    mkt_strangle_25d_vols,
+                                    rsk_reversal_25d_vols,
+                                    mkt_strangle_10d_vols,
+                                    rsk_reversal_10d_vols,
                                     alpha,
-                                    atmMethod,
+                                    atm_method,
                                     delta_method,
                                     vol_functionType)
 
-#        fxMarketPlus.check_calibration(True)
+#        fx_market_plus.check_calibration(True)
 
     if PLOT_GRAPHS:
-        fxMarketPlus.plot_vol_curves()
+        fx_market_plus.plot_vol_curves()
 
         plt.figure()
 
-        dbns = fxMarketPlus.implied_dbns(30, 120, 1000)
+        dbns = fx_market_plus.implied_dbns(30, 120, 1000)
 
         for i in range(0, len(dbns)):
             plt.plot(dbns[i]._x, dbns[i]._densitydx)
             plt.title(vol_functionType)
             print("SUM:", dbns[i].sum())
 
 
@@ -176,68 +175,68 @@
     if 1 == 1:
 
         # Example from Book extract by Iain Clark using Tables 4.4 and 4.5
         # where we examine the calibration to a full surface in Chapter 4
 
         value_dt = Date(10, 4, 2020)
 
-        forName = "EUR"
-        domName = "USD"
-        forCCRate = 0.03460  # EUR
-        domCCRate = 0.02940  # USD
+        for_name = "EUR"
+        dom_name = "USD"
+        for_cc_rate = 0.03460  # EUR
+        dom_cc_rate = 0.02940  # USD
 
-        dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-        for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+        domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+        foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-        currency_pair = forName + domName
+        currency_pair = for_name + dom_name
         spot_fx_rate = 1.3465
 
         tenors = ['1Y', '2Y']
         atm_vols = [18.250, 17.677]
-        marketStrangle25DeltaVols = [0.95, 0.85]
-        riskReversal25DeltaVols = [-0.60, -0.562]
-        marketStrangle10DeltaVols = [3.806, 3.208]
-        riskReversal10DeltaVols = [-1.359, -1.208]
+        mkt_strangle_25d_vols = [0.95, 0.85]
+        rsk_reversal_25d_vols = [-0.60, -0.562]
+        mkt_strangle_10d_vols = [3.806, 3.208]
+        rsk_reversal_10d_vols = [-1.359, -1.208]
 
-        notional_currency = forName
+        notional_currency = for_name
 
         # I HAVE NO YET MADE DELTA METHOD A VECTOR FOR EACH TERM AS I WOULD
         # NEED TO DO AS DESCRIBED IN CLARK PAGE 70
 
-        atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+        atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
         delta_method = FinFXDeltaMethod.FORWARD_DELTA  # THIS IS DIFFERENT
         vol_functionType = VolFuncTypes.CLARK5
         alpha = 0.5  # FIT WINGS AT 10D if ALPHA = 1.0
 
-        fxMarketPlus = FXVolSurfacePlus(value_dt,
+        fx_market_plus = FXVolSurfacePlus(value_dt,
                                         spot_fx_rate,
                                         currency_pair,
                                         notional_currency,
-                                        dom_discount_curve,
-                                        for_discount_curve,
+                                        domestic_curve,
+                                        foreign_curve,
                                         tenors,
                                         atm_vols,
-                                        marketStrangle25DeltaVols,
-                                        riskReversal25DeltaVols,
-                                        marketStrangle10DeltaVols,
-                                        riskReversal10DeltaVols,
+                                        mkt_strangle_25d_vols,
+                                        rsk_reversal_25d_vols,
+                                        mkt_strangle_10d_vols,
+                                        rsk_reversal_10d_vols,
                                         alpha,
-                                        atmMethod,
+                                        atm_method,
                                         delta_method,
                                         vol_functionType)
 
-        fxMarketPlus.check_calibration(False)
+        fx_market_plus.check_calibration(False)
 
         if 1 == 0:  # PLOT_GRAPHS:
 
-            fxMarketPlus.plot_vol_curves()
+            fx_market_plus.plot_vol_curves()
 
             plt.figure()
 
-            dbns = fxMarketPlus.implied_dbns(0.5, 2.0, 1000)
+            dbns = fx_market_plus.implied_dbns(0.5, 2.0, 1000)
 
             for i in range(0, len(dbns)):
                 plt.plot(dbns[i]._x, dbns[i]._densitydx)
                 plt.title(vol_functionType)
                 print("SUM:", dbns[i].sum())
 
         # Test interpolation
@@ -248,15 +247,15 @@
         strikes = np.linspace(1.0, 2.0, 20)
 
         if 1 == 0:
             volSurface = []
             for k in strikes:
                 volSmile = []
                 for dt in dates:
-                    vol = fxMarketPlus.volatility_from_strike_dt(k, dt)
+                    vol = fx_market_plus.volatility_from_strike_dt(k, dt)
                     volSmile.append(vol*100.0)
 
                     print(k, dt, vol*100.0)
                 volSurface.append(volSmile)
 
             fig = plt.figure()
             ax = fig.add_subplot(111, projection='3d')
@@ -277,15 +276,15 @@
         deltas = np.linspace(0.10, 0.90, 17)
 
         if 1 == 0:
             volSurface = []
             for delta in deltas:
                 volSmile = []
                 for dt in dates:
-                    (vol, k) = fxMarketPlus.vol_from_delta_dt(delta, dt)
+                    (vol, k) = fx_market_plus.vol_from_delta_date(delta, dt)
                     volSmile.append(vol*100.0)
                     print(delta, k, dt, vol*100.0)
 
                 volSurface.append(volSmile)
 
             fig = plt.figure()
             ax = fig.add_subplot(111, projection='3d')
@@ -313,74 +312,74 @@
     if 1 == 1:
 
         # Example from Book extract by Iain Clark using Tables 3.3 and 3.4
         # print("EURUSD EXAMPLE CLARK")
 
         value_dt = Date(10, 4, 2020)
 
-        forName = "EUR"
-        domName = "USD"
-        forCCRate = 0.03460  # EUR
-        domCCRate = 0.02940  # USD
+        for_name = "EUR"
+        dom_name = "USD"
+        for_cc_rate = 0.03460  # EUR
+        dom_cc_rate = 0.02940  # USD
 
-        dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-        for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+        domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+        foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-        currency_pair = forName + domName
+        currency_pair = for_name + dom_name
         spot_fx_rate = 1.3465
 
         tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
         atm_vols = [21.00, 21.00, 20.750, 19.400, 18.250, 17.677]
-        marketStrangle25DeltaVols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
-        riskReversal25DeltaVols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
-        marketStrangle10DeltaVols = [2.433, 2.83, 3.228, 3.485, 3.806, 3.208]
-        riskReversal10DeltaVols = [-1.258, -
+        mkt_strangle_25d_vols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
+        rsk_reversal_25d_vols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
+        mkt_strangle_10d_vols = [2.433, 2.83, 3.228, 3.485, 3.806, 3.208]
+        rsk_reversal_10d_vols = [-1.258, -
                                    1.297, -1.332, -1.408, -1.359, -1.208]
 
-        marketStrangle25DeltaVols = None
-        riskReversal25DeltaVols = None
+        mkt_strangle_25d_vols = None
+        rsk_reversal_25d_vols = None
 
-        notional_currency = forName
+        notional_currency = for_name
 
-        atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+        atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
         delta_method = FinFXDeltaMethod.SPOT_DELTA
         vol_functionType = VolFuncTypes.CLARK
         alpha = 0.50  # FIT WINGS AT 10D if ALPHA = 1.0
 
-        fxMarketPlus = FXVolSurfacePlus(value_dt,
+        fx_market_plus = FXVolSurfacePlus(value_dt,
                                         spot_fx_rate,
                                         currency_pair,
                                         notional_currency,
-                                        dom_discount_curve,
-                                        for_discount_curve,
+                                        domestic_curve,
+                                        foreign_curve,
                                         tenors,
                                         atm_vols,
-                                        marketStrangle25DeltaVols,
-                                        riskReversal25DeltaVols,
-                                        marketStrangle10DeltaVols,
-                                        riskReversal10DeltaVols,
+                                        mkt_strangle_25d_vols,
+                                        rsk_reversal_25d_vols,
+                                        mkt_strangle_10d_vols,
+                                        rsk_reversal_10d_vols,
                                         alpha,
-                                        atmMethod,
+                                        atm_method,
                                         delta_method,
                                         vol_functionType)
 
-        fxMarketPlus.check_calibration(False)
+        fx_market_plus.check_calibration(False)
 
         years = [1.0/12.0, 2./12., 0.25, 0.5, 1.0, 2.0]
 
         dates = value_dt.add_years(years)
 
         deltas = np.linspace(0.10, 0.90, 17)
 
         if 1 == 0:
             volSurface = []
             for delta in deltas:
                 volSmile = []
                 for dt in dates:
-                    (vol, k) = fxMarketPlus.vol_from_delta_dt(delta, dt)
+                    (vol, k) = fx_market_plus.vol_from_delta_date(delta, dt)
                     volSmile.append(vol*100.0)
                     print(delta, k, dt, vol*100.0)
 
                 volSurface.append(volSmile)
 
             fig = plt.figure()
             ax = fig.add_subplot(111, projection='3d')
@@ -408,61 +407,60 @@
     if 1 == 1:
 
         # Example from Book extract by Iain Clark using Tables 3.3 and 3.4
         # print("EURUSD EXAMPLE CLARK")
 
         value_dt = Date(10, 4, 2020)
 
-        forName = "EUR"
-        domName = "USD"
-        forCCRate = 0.03460  # EUR
-        domCCRate = 0.02940  # USD
+        for_name = "EUR"
+        dom_name = "USD"
+        for_cc_rate = 0.03460  # EUR
+        dom_cc_rate = 0.02940  # USD
 
-        dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-        for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+        domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+        foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-        currency_pair = forName + domName
+        currency_pair = for_name + dom_name
         spot_fx_rate = 1.3465
 
         tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
         atm_vols = [21.00, 21.00, 20.750, 19.400, 18.250, 17.677]
-        marketStrangle25DeltaVols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
-        riskReversal25DeltaVols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
-        marketStrangle10DeltaVols = [2.433, 2.83, 3.228, 3.485, 3.806, 3.208]
-        riskReversal10DeltaVols = [-1.258, -
-                                   1.297, -1.332, -1.408, -1.359, -1.208]
+        mkt_strangle_25d_vols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
+        rsk_reversal_25d_vols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
+        mkt_strangle_10d_vols = [2.433, 2.83, 3.228, 3.485, 3.806, 3.208]
+        rsk_reversal_10d_vols = [-1.258, -1.297, -1.332, -1.408, -1.359, -1.208]
 
-        marketStrangle10DeltaVols = None
-        riskReversal10DeltaVols = None
+        mkt_strangle_10d_vols = None
+        rsk_reversal_10d_vols = None
 
-        notional_currency = forName
+        notional_currency = for_name
 
-        atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+        atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
         delta_method = FinFXDeltaMethod.SPOT_DELTA
         vol_functionType = VolFuncTypes.CLARK
         alpha = 0.50  # FIT WINGS AT 10D if ALPHA = 1.0
 
-        fxMarketPlus = FXVolSurfacePlus(value_dt,
+        fx_market_plus = FXVolSurfacePlus(value_dt,
                                         spot_fx_rate,
                                         currency_pair,
                                         notional_currency,
-                                        dom_discount_curve,
-                                        for_discount_curve,
+                                        domestic_curve,
+                                        foreign_curve,
                                         tenors,
                                         atm_vols,
-                                        marketStrangle25DeltaVols,
-                                        riskReversal25DeltaVols,
-                                        marketStrangle10DeltaVols,
-                                        riskReversal10DeltaVols,
+                                        mkt_strangle_25d_vols,
+                                        rsk_reversal_25d_vols,
+                                        mkt_strangle_10d_vols,
+                                        rsk_reversal_10d_vols,
                                         alpha,
-                                        atmMethod,
+                                        atm_method,
                                         delta_method,
                                         vol_functionType)
 
-        fxMarketPlus.check_calibration(False)
+        fx_market_plus.check_calibration(False)
 
 ###############################################################################
 
 
 if __name__ == '__main__':
 
     start = time.time()
```

### Comparing `financepy-0.350/tests_golden/TestFinIborBermudanSwaption.py` & `financepy-0.360/tests_golden/TestFinIborBermudanSwaption.py`

 * *Files 9% similar despite different names*

```diff
@@ -31,81 +31,81 @@
     file:///C:/Users/Dominic/Downloads/SSRN-id155208.pdf """
 
     value_dt = Date(1, 1, 2011)
     settle_dt = value_dt
     exercise_dt = settle_dt.add_years(1)
     swap_maturity_dt = settle_dt.add_years(4)
 
-    swap_fixed_coupon = 0.060
+    swap_fixed_cpn = 0.060
     swap_fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
-    swapFixedDayCountType = DayCountTypes.ACT_365F
+    swap_fixed_day_count_type = DayCountTypes.ACT_365F
 
     libor_curve = DiscountCurveFlat(value_dt,
                                     0.0625,
                                     FrequencyTypes.SEMI_ANNUAL,
                                     DayCountTypes.ACT_365F)
 
     fwdPAYSwap = IborSwap(exercise_dt,
                           swap_maturity_dt,
                           SwapTypes.PAY,
-                          swap_fixed_coupon,
+                          swap_fixed_cpn,
                           swap_fixed_freq_type,
-                          swapFixedDayCountType)
+                          swap_fixed_day_count_type)
 
     fwdSwapValue = fwdPAYSwap.value(settle_dt, libor_curve, libor_curve)
 
     test_cases.header("LABEL", "VALUE")
     test_cases.print("FWD SWAP VALUE", fwdSwapValue)
 
     # fwdPAYSwap.print_fixed_leg_pv()
 
     # Now we create the European swaptions
     fixed_leg_type = SwapTypes.PAY
     europeanSwaptionPay = IborSwaption(settle_dt,
                                        exercise_dt,
                                        swap_maturity_dt,
                                        fixed_leg_type,
-                                       swap_fixed_coupon,
+                                       swap_fixed_cpn,
                                        swap_fixed_freq_type,
-                                       swapFixedDayCountType)
+                                       swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     europeanSwaptionRec = IborSwaption(settle_dt,
                                        exercise_dt,
                                        swap_maturity_dt,
                                        fixed_leg_type,
-                                       swap_fixed_coupon,
+                                       swap_fixed_cpn,
                                        swap_fixed_freq_type,
-                                       swapFixedDayCountType)
+                                       swap_fixed_day_count_type)
 
     ###########################################################################
     ###########################################################################
     ###########################################################################
     # BLACK'S MODEL
     ###########################################################################
     ###########################################################################
     ###########################################################################
 
     test_cases.banner("======= ZERO VOLATILITY ========")
     model = Black(0.0000001)
-    test_cases.print("Black Model", model._volatility)
+    test_cases.print("Black Model", model.volatility)
 
     valuePay = europeanSwaptionPay.value(settle_dt, libor_curve, model)
     test_cases.print("EUROPEAN BLACK PAY VALUE ZERO VOL:", valuePay)
 
     valueRec = europeanSwaptionRec.value(settle_dt, libor_curve, model)
     test_cases.print("EUROPEAN BLACK REC VALUE ZERO VOL:", valueRec)
 
     payRec = valuePay - valueRec
     test_cases.print("PAY MINUS RECEIVER :", payRec)
 
     test_cases.banner("======= 20%% BLACK VOLATILITY ========")
 
     model = Black(0.20)
-    test_cases.print("Black Model", model._volatility)
+    test_cases.print("Black Model", model.volatility)
 
     valuePay = europeanSwaptionPay.value(settle_dt, libor_curve, model)
     test_cases.print("EUROPEAN BLACK PAY VALUE:", valuePay)
 
     valueRec = europeanSwaptionRec.value(settle_dt, libor_curve, model)
     test_cases.print("EUROPEAN BLACK REC VALUE:", valueRec)
 
@@ -169,29 +169,29 @@
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     test_cases.banner(
         "======= 0% VOLATILITY BERMUDAN SWAPTION EUROPEAN EXERCISE BK MODEL ========")
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     a = 0.01
@@ -233,29 +233,29 @@
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     test_cases.banner(
         "======= ZERO VOLATILITY BERMUDAN SWAPTION BERMUDAN EXERCISE BK MODEL ========")
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     a = 0.01
@@ -344,27 +344,27 @@
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     test_cases.banner(
         "======= 0% VOLATILITY BERMUDAN SWAPTION EUROPEAN EXERCISE BDT MODEL ========")
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     model = BDTTree(sigma, num_time_steps)
@@ -404,27 +404,27 @@
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     test_cases.banner(
         "======= ZERO VOLATILITY BERMUDAN SWAPTION BERMUDAN EXERCISE BDT MODEL ========")
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     a = 0.01
@@ -513,27 +513,27 @@
     exercise_type = FinExerciseTypes.EUROPEAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     test_cases.banner(
         "======= 0% VOLATILITY BERMUDAN SWAPTION EUROPEAN EXERCISE HW MODEL ========")
 
     sigma = 0.000001
     model = HWTree(sigma, a, num_time_steps)
 
@@ -572,27 +572,27 @@
     exercise_type = FinExerciseTypes.BERMUDAN
 
     bermudan_swaption_pay = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     fixed_leg_type = SwapTypes.RECEIVE
     bermudan_swaption_rec = IborBermudanSwaption(settle_dt,
                                                  exercise_dt,
                                                  swap_maturity_dt,
                                                  fixed_leg_type,
                                                  exercise_type,
-                                                 swap_fixed_coupon,
+                                                 swap_fixed_cpn,
                                                  swap_fixed_freq_type,
-                                                 swapFixedDayCountType)
+                                                 swap_fixed_day_count_type)
 
     test_cases.banner(
         "======= ZERO VOLATILITY BERMUDAN SWAPTION BERMUDAN EXERCISE HW MODEL ========")
 
     # Used BK with constant short-rate volatility
     sigma = 0.000001
     a = 0.01
```

### Comparing `financepy-0.350/tests_golden/TestFinIborCapFloor.py` & `financepy-0.360/tests_golden/TestFinIborCapFloor.py`

 * *Files 0% similar despite different names*

```diff
@@ -230,18 +230,18 @@
     vol = volCurve.cap_vol(maturity_dt)
     model = Black(vol)
     valueCap = capFloor.value(value_dt, libor_curve, model)
 #    print("CAP T", tcap, "VOL:", vol, "VALUE OF CAP:", valueCap)
 
     # Value cap by breaking it down into caplets using caplet vols
     vCaplets = 0.0
-    capletstart_dt = capFloor._capFloorLetDates[1]
+    capletstart_dt = capFloor.capFloorLetDates[1]
     test_cases.header("START", "END", "VOL", "VALUE")
 
-    for caplet_end_dt in capFloor._capFloorLetDates[2:]:
+    for caplet_end_dt in capFloor.capFloorLetDates[2:]:
         vol = volCurve.caplet_vol(caplet_end_dt)
         modelCaplet = Black(vol)
         vCaplet = capFloor.value_caplet_floor_let(value_dt,
                                                   capletstart_dt,
                                                   caplet_end_dt,
                                                   libor_curve,
                                                   modelCaplet)
@@ -338,16 +338,16 @@
     option_type = FinCapFloorTypes.CAP
     strike_rate = 0.02
 
     cap = IborCapFloor(start_dt, end_dt, option_type, strike_rate,
                        last_fixing, freq_type, dc_type, notional,
                        cal_type, bd_type, dg_type)
 
-    blackVol = 0.547295
-    model = Black(blackVol)
+    black_vol = 0.547295
+    model = Black(black_vol)
 
     start = time.time()
     numRepeats = 10
     for i in range(0, numRepeats):
         v = cap.value(value_dt, discount_curve, model)
 
     end = time.time()
```

### Comparing `financepy-0.350/tests_golden/TestFinIborCapVolCurve.py` & `financepy-0.360/tests_golden/TestFinIborCapVolCurve.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
 import numpy as np
+
+import sys
+sys.path.append("..")
+
 from financepy.utils.day_count import DayCountTypes
 from financepy.utils.date import Date
 from financepy.market.volatility.ibor_cap_vol_curve import IborCapVolCurve
 from FinTestCases import FinTestCases, globalTestCaseMode
 
-import sys
-sys.path.append("..")
-
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
 def test_FinCapVolCurve():
```

### Comparing `financepy-0.350/tests_golden/TestFinIborDualCurve.py` & `financepy-0.360/tests_golden/TestFinIborDualCurve.py`

 * *Files 11% similar despite different names*

```diff
@@ -44,107 +44,107 @@
     fixed_leg_type = SwapTypes.PAY
 
     fras = []
     # 1 x 4 FRA
 
     swaps = []
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
 
     swap_rate = 0.000022
     maturity_dt = settle_dt.add_months(24)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
-               fixed_freq_type, fixedDCCType)
+               fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     swap_rate += 0.000
     fixed_leg_type = SwapTypes.PAY
     maturity_dt = settle_dt.add_months(36)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
-               fixed_freq_type, fixedDCCType)
+               fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     swap_rate += 0.000
     maturity_dt = settle_dt.add_months(48)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     swap_rate = 0.02
     maturity_dt = settle_dt.add_months(60)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(72)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(84)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(96)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(108)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(120)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(132)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(144)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(180)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(240)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(300)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(360)
     swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     oisCurve = OISCurve(value_dt,
                         [],
                         fras,
                         swaps)
 
@@ -258,27 +258,27 @@
         value_dt, depos, fras, swaps, interp_type, True)
 
     test_cases.banner("======================================================")
     test_cases.banner("SINGLE CURVE VALUATION")
     test_cases.header("LABEL", "VALUE")
     test_cases.print("VALUE:", swaps[0].value(
         value_dt, libor_curve, libor_curve, None))
-    test_cases.print("FIXED:", swaps[0]._fixed_leg.value(
+    test_cases.print("FIXED:", swaps[0].fixed_leg.value(
         value_dt, libor_curve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         value_dt, libor_curve, libor_curve, None))
 
     test_cases.banner("======================================================")
     test_cases.banner("SINGLE CURVE VALUATION TO SWAP SETTLEMENT DATE")
     test_cases.header("LABEL", "VALUE")
     test_cases.print("VALUE:", swaps[0].value(
         settle_dt, libor_curve, libor_curve, None))
-    test_cases.print("FIXED:", swaps[0]._fixed_leg.value(
+    test_cases.print("FIXED:", swaps[0].fixed_leg.value(
         settle_dt, libor_curve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         settle_dt, libor_curve, libor_curve, None))
     test_cases.banner("======================================================")
 
 #    swaps[0].print_fixed_leg_pv()
 #    swaps[0].print_float_leg_pv()
 
     oisCurve = buildOIS(value_dt)
@@ -289,25 +289,25 @@
 #    print(liborDualCurve)
 
     # The valuation of 53714.55 is very close to the spreadsheet value 53713.96
 
     test_cases.header("VALUATION TO TODAY DATE", " PV")
     test_cases.print("VALUE:", swaps[0].value(
         value_dt, oisCurve, liborDualCurve, None))
-    test_cases.print("FIXED:", swaps[0]._fixed_leg.value(
+    test_cases.print("FIXED:", swaps[0].fixed_leg.value(
         value_dt, oisCurve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         value_dt, oisCurve, libor_curve, None))
 
     test_cases.header("VALUATION TO SWAP SETTLEMENT DATE", " PV")
     test_cases.print("VALUE:", swaps[0].value(
         settle_dt, oisCurve, liborDualCurve, None))
-    test_cases.print("FIXED:", swaps[0]._fixed_leg.value(
+    test_cases.print("FIXED:", swaps[0].fixed_leg.value(
         settle_dt, oisCurve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         settle_dt, oisCurve, liborDualCurve, None, ))
 
 #    swaps[0].print_fixed_leg_pv()
 #    swaps[0].print_float_leg_pv()
 
     PLOT = False
     if PLOT is True:
@@ -343,25 +343,25 @@
 
     start_dt = Date(27, 12, 2017)
     maturity_dt = Date(27, 12, 2067)
     notional = 10 * ONE_MILLION
     fixed_leg_type = SwapTypes.RECEIVE
 
     fixedRate = 0.0150
-    fixedDCCType = DayCountTypes.THIRTY_360_BOND
+    fixed_dcc_type = DayCountTypes.THIRTY_360_BOND
     fixed_freq_type = FrequencyTypes.ANNUAL
 
     float_spread = 0.0
-    floatDCCType = DayCountTypes.ACT_360
+    float_dcc_type = DayCountTypes.ACT_360
     float_freq_type = FrequencyTypes.SEMI_ANNUAL
 
     offMarketSwap = IborSwap(start_dt, maturity_dt, fixed_leg_type,
-                             fixedRate, fixed_freq_type, fixedDCCType,
+                             fixedRate, fixed_freq_type, fixed_dcc_type,
                              notional,
-                             float_spread, float_freq_type, floatDCCType)
+                             float_spread, float_freq_type, float_dcc_type)
 
     interp_type = InterpTypes.LINEAR_ZERO_RATES
 
     depoDCCType = DayCountTypes.ACT_360
     depos = []
 
     ###########################################################################
@@ -411,73 +411,73 @@
     fras.append(fra)
     fra = IborFRA(settle_dt.add_tenor("12M"),
                   "6M", -0.1360 / 100.0, fraDCCType)
     fras.append(fra)
 
     swaps = []
     fixed_leg_type = SwapTypes.PAY
-    fixedDCCType = DayCountTypes.THIRTY_360_BOND
+    fixed_dcc_type = DayCountTypes.THIRTY_360_BOND
     fixed_freq_type = FrequencyTypes.ANNUAL
 
     swap = IborSwap(settle_dt, "2Y", fixed_leg_type, -
-                    0.1525 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.1525 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "3Y", fixed_leg_type, -
-                    0.0185 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.0185 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "4Y", fixed_leg_type,
-                    0.1315 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.1315 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "5Y", fixed_leg_type,
-                    0.2745 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.2745 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "6Y", fixed_leg_type,
-                    0.4135 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.4135 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "7Y", fixed_leg_type,
-                    0.5439 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.5439 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "8Y", fixed_leg_type,
-                    0.6652 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.6652 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "9Y", fixed_leg_type,
-                    0.7784 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.7784 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "10Y", fixed_leg_type,
-                    0.8799 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.8799 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "11Y", fixed_leg_type,
-                    0.9715 / 100.0, fixed_freq_type, fixedDCCType)
+                    0.9715 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "12Y", fixed_leg_type,
-                    1.0517 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.0517 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "15Y", fixed_leg_type,
-                    1.2369 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.2369 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "20Y", fixed_leg_type,
-                    1.3965 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.3965 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "25Y", fixed_leg_type,
-                    1.4472 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.4472 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "30Y", fixed_leg_type,
-                    1.4585 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.4585 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "35Y", fixed_leg_type,
-                    1.4595 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.4595 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "40Y", fixed_leg_type,
-                    1.4535 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.4535 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "45Y", fixed_leg_type,
-                    1.4410 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.4410 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = IborSwap(settle_dt, "50Y", fixed_leg_type,
-                    1.4335 / 100.0, fixed_freq_type, fixedDCCType)
+                    1.4335 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     iborDepos = depos.copy()
     iborFras = fras.copy()
     ibor_swaps = swaps.copy()
 
     iborCurve = IborSingleCurve(
@@ -500,117 +500,117 @@
     depo = IborDeposit(settle_dt, "1D", -0.3490 / 100.0, depoDCCType)
     depos.append(depo)
 
     fras = []
 
     swaps = []
     fixed_leg_type = SwapTypes.PAY
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
     fixed_freq_type = FrequencyTypes.ANNUAL
 
     # Standard OIS with standard annual terms
     swap = OIS(settle_dt, "2W", fixed_leg_type, -
-               0.3600 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3600 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "1M", fixed_leg_type, -
-               0.3560 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3560 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "2M", fixed_leg_type, -
-               0.3570 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3570 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "3M", fixed_leg_type, -
-               0.3580 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3580 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "4M", fixed_leg_type, -
-               0.3575 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3575 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "5M", fixed_leg_type, -
-               0.3578 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3578 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "6M", fixed_leg_type, -
-               0.3580 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3580 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "7M", fixed_leg_type, -
-               0.3600 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3600 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "8M", fixed_leg_type, -
-               0.3575 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3575 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "9M", fixed_leg_type, -
-               0.3569 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3569 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "10M", fixed_leg_type, -
-               0.3553 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3553 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "11M", fixed_leg_type, -
-               0.3534 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3534 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "12M", fixed_leg_type, -
-               0.3496 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3496 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "18M", fixed_leg_type, -
-               0.3173 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3173 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     swap = OIS(settle_dt, "2Y", fixed_leg_type, -
-               0.2671 / 100.0, fixed_freq_type, fixedDCCType)
+               0.2671 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "30M", fixed_leg_type, -
-               0.2070 / 100.0, fixed_freq_type, fixedDCCType)
+               0.2070 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "3Y", fixed_leg_type, -
-               0.1410 / 100.0, fixed_freq_type, fixedDCCType)
+               0.1410 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "4Y", fixed_leg_type, -
-               0.0060 / 100.0, fixed_freq_type, fixedDCCType)
+               0.0060 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "5Y", fixed_leg_type,
-               0.1285 / 100.0, fixed_freq_type, fixedDCCType)
+               0.1285 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "6Y", fixed_leg_type,
-               0.2590 / 100.0, fixed_freq_type, fixedDCCType)
+               0.2590 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "7Y", fixed_leg_type,
-               0.3830 / 100.0, fixed_freq_type, fixedDCCType)
+               0.3830 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "8Y", fixed_leg_type,
-               0.5020 / 100.0, fixed_freq_type, fixedDCCType)
+               0.5020 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "9Y", fixed_leg_type,
-               0.6140 / 100.0, fixed_freq_type, fixedDCCType)
+               0.6140 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "10Y", fixed_leg_type,
-               0.7160 / 100.0, fixed_freq_type, fixedDCCType)
+               0.7160 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "11Y", fixed_leg_type,
-               0.8070 / 100.0, fixed_freq_type, fixedDCCType)
+               0.8070 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "12Y", fixed_leg_type,
-               0.8890 / 100.0, fixed_freq_type, fixedDCCType)
+               0.8890 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "15Y", fixed_leg_type,
-               1.0790 / 100.0, fixed_freq_type, fixedDCCType)
+               1.0790 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "20Y", fixed_leg_type,
-               1.2460 / 100.0, fixed_freq_type, fixedDCCType)
+               1.2460 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "25Y", fixed_leg_type,
-               1.3055 / 100.0, fixed_freq_type, fixedDCCType)
+               1.3055 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "30Y", fixed_leg_type,
-               1.3270 / 100.0, fixed_freq_type, fixedDCCType)
+               1.3270 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "35Y", fixed_leg_type,
-               1.3315 / 100.0, fixed_freq_type, fixedDCCType)
+               1.3315 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "40Y", fixed_leg_type,
-               1.3300 / 100.0, fixed_freq_type, fixedDCCType)
+               1.3300 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
     swap = OIS(settle_dt, "50Y", fixed_leg_type,
-               1.3270 / 100.0, fixed_freq_type, fixedDCCType)
+               1.3270 / 100.0, fixed_freq_type, fixed_dcc_type)
     swaps.append(swap)
 
     oisDepos = depos.copy()
     oisFras = fras.copy()
     oisSwaps = swaps.copy()
 
 #    oisCurveFF = OISCurve(value_dt, oisDepos, oisFras, oisSwaps, interp_type)
```

### Comparing `financepy-0.350/tests_golden/TestFinIborFuture.py` & `financepy-0.360/tests_golden/TestFinIborFuture.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinIborLMMProducts.py` & `financepy-0.360/tests_golden/TestFinIborLMMProducts.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,29 +1,28 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.products.rates.ibor_cap_floor import IborCapFloor
+from financepy.products.rates.ibor_lmm_products import IborLMMProducts
+from financepy.utils.global_types import FinCapFloorTypes
+from financepy.products.rates.ibor_swaption import IborSwaption
+from financepy.products.rates.ibor_swaption import SwapTypes
+from financepy.utils.frequency import FrequencyTypes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.models.black import Black
+from financepy.utils.day_count import DayCountTypes
+from financepy.utils.date import Date
+from financepy.market.volatility.ibor_cap_vol_curve import IborCapVolCurve
 import numpy as np
 
 import sys
 sys.path.append("..")
 
-from financepy.market.volatility.ibor_cap_vol_curve import IborCapVolCurve
-from financepy.utils.date import Date
-from financepy.utils.day_count import DayCountTypes
-from financepy.models.black import Black
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.utils.frequency import FrequencyTypes
-from financepy.products.rates.ibor_swaption import SwapTypes
-from financepy.products.rates.ibor_swaption import IborSwaption
-from financepy.utils.global_types import FinCapFloorTypes
-from financepy.products.rates.ibor_lmm_products import IborLMMProducts
-from financepy.products.rates.ibor_cap_floor import IborCapFloor
-from FinTestCases import FinTestCases, globalTestCaseMode
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 # This is in progress and needs to be completed
 
 ###############################################################################
 
@@ -33,32 +32,32 @@
 
 #     startYear = 2020
 #     endYear = 2030
 #     value_dt = Date(1, 1, startYear)
 #     exercise_dt = Date(1, 1, 2023)
 #     settle_dt = value_dt
 #     maturity_dt = Date(1, 1, endYear)
-#     fixed_coupon = 0.04
+#     fixed_cpn = 0.04
 
 #     # DEFINE THE DISCOUNT CURVE
 #     discount_curve = FinDiscountCurveFlat(value_dt,
 #                                          0.04,
 #                                          FrequencyTypes.ANNUAL)
 
-#     swaptionVol = 15.54
+#     swaption_vol = 15.54
 
 #     liborSwaption = IborSwaption(settle_dt,
 #                                      exercise_dt,
 #                                      maturity_dt,
 #                                      IborSwaptionTypes.PAY,
-#                                      fixed_coupon,
+#                                      fixed_cpn,
 #                                      FrequencyTypes.ANNUAL,
 #                                      DayCountTypes.ACT_360)
 
-#     model = Black(swaptionVol/100.0)
+#     model = Black(swaption_vol/100.0)
 #     v_BLK = liborSwaption.value(value_dt, discount_curve, model)
 
 #     dt = 0.5
 #     t_exp = 3.0
 #     t_mat = 10.0
 #     a = int(2*t_exp)
 #     b = int(2*t_mat)
@@ -75,70 +74,70 @@
 #     seed = 1489
 #     num_paths = 2000 # 100000
 #     fwdsNF = LMMSimulateFwdsNF(numFwds, num_paths, fwd0,
 #                                zetas, correl, taus, seed)
 #     strike = r
 #     PAYSwaption = 1
 #     use_sobol = 0
-#     numeraireIndex = 0
+#     numeraire_index = 0
 
-#     fwds1F = LMMSimulateFwds1F(numFwds, num_paths, numeraireIndex, fwd0,
+#     fwds1F = LMMSimulateFwds1F(numFwds, num_paths, numeraire_index, fwd0,
 #                                zetas, taus, use_sobol, seed)
 
 #     for iExp in range(1, 10):
 
 #         t_exp = float(iExp)
 #         a = int(2*t_exp)
 #         print(a, b)
 
 #         swaption_price1F = LMMSwaptionPricer(strike, a, b, num_paths,
 #                                             fwd0, fwds1F, taus, PAYSwaption)
 
 #         swaption_priceNF = LMMSwaptionPricer(strike, a, b, num_paths,
 #                                             fwd0, fwdsNF, taus, PAYSwaption)
 
-#         swaptionVol = LMMSwaptionVolApprox(a, b, fwd0, taus, zetas, correl)
+#         swaption_vol = LMMSwaptionVolApprox(a, b, fwd0, taus, zetas, correl)
 
 #         swapVolSim1F = LMMSimSwaptionVol(a, b, fwd0, fwds1F, taus)
 #         swapVolSimNF = LMMSimSwaptionVol(a, b, fwd0, fwdsNF, taus)
 
 #         value_dt = Date(1, 1, 2010)
 #         libor_curve = FinDiscountCurveFlat(value_dt, r,
 #                                           FrequencyTypes.QUARTERLY)
 #         settle_dt = value_dt
 #         exercise_dt = settle_dt.add_months(a*3)
 #         maturity_dt = settle_dt.add_months(b*3)
 
-#         fixed_coupon = strike
+#         fixed_cpn = strike
 #         fixed_freq_type = FrequencyTypes.QUARTERLY
 #         fixed_dc_type = DayCountTypes.ACT_ACT_ISDA
 #         float_freq_type = FrequencyTypes.QUARTERLY
 #         float_dc_type = DayCountTypes.ACT_ACT_ISDA
 #         notional = 1.0
 
 #         # Pricing a PAY
 #         swaptionType = IborSwaptionTypes.PAY
 #         swaption = IborSwaption(settle_dt,
 #                                     exercise_dt,
 #                                     maturity_dt,
 #                                     swaptionType,
-#                                     fixed_coupon,
+#                                     fixed_cpn,
 #                                     fixed_freq_type,
 #                                     fixed_dc_type,
 #                                     notional,
 #                                     float_freq_type,
 #                                     float_dc_type)
 
-#         model = Black(swaptionVol)
+#         model = Black(swaption_vol)
 #         blackSwaptionPrice = swaption.value(value_dt, libor_curve, model)
 
 #         test_cases.print("K:%6.5f t_exp:%8.2f FwdVol:%9.5f SimVol1F:%9.5f " +
 #                         " SimVolNF:%9.5f RebVol:%9.5f SimPx1F:%9.5f SimPxNF:%9.5f Black Px:%9.5f"
 #               % (strike, t_exp, fwd_rateVol, swapVolSim1F, swapVolSimNF,
-#                  swaptionVol, swaption_price1F, swaption_priceNF,
+#                  swaption_vol, swaption_price1F, swaption_priceNF,
 #                  blackSwaptionPrice))
 
 ###############################################################################
 
 
 # def test_CapsFloors():
 
@@ -181,24 +180,24 @@
 #                                       freq_type,
 #                                       dc_type)
 
 #     # Set up forward rate vol structure
 #     capVolDates = []
 #     capletVolTenor = "1Y"
 #     capletDt = value_dt
-#     numForwards = endYear - startYear
+#     num_fwds = endYear - startYear
 
-#     # Capvol dates has numForwards + 1 elements including today
+#     # Capvol dates has num_fwds + 1 elements including today
 #     capVolDates.append(value_dt)
-#     for i in range(0, numForwards):
+#     for i in range(0, num_fwds):
 #         capletDt = capletDt.add_tenor(capletVolTenor)
 #         capVolDates.append(capletDt)
 
-#     # Capvol dates has numForwards + 1 elements including zero today
-#     capVolatilities = [capVol] * (numForwards+1)
+#     # Capvol dates has num_fwds + 1 elements including zero today
+#     capVolatilities = [capVol] * (num_fwds+1)
 #     capVolatilities[0] = 0.0
 #     capVolatilities = np.array(capVolatilities)/100.0
 
 #     dc_type = DayCountTypes.ACT_ACT_ISDA
 #     volCurve = IborCapVolCurve(value_dt,
 #                                    capVolDates,
 #                                    capVolatilities,
@@ -207,24 +206,24 @@
 #     lambdas2FList = [[0.00, 0.1410, 0.1952, 0.1678, 0.1711, 0.1525,
 #                       0.1406, 0.1265, 0.1306, 0.1236],
 #                      [0.00, -0.0645, -0.0670, -0.0384, -0.0196, 0.00,
 #                      0.0161, 0.0289, 0.0448, 0.0565]]
 #     lambdas2F = np.array(lambdas2FList)
 
 #     # Simulate paths of future Libor rates
-#     numFactors = 1
+#     num_factors = 1
 
 #     test_cases.header("NUMPATHS", "VLMM", "VBLK", "ERROR")
 
 #     for num_paths in [10000, 20000, 50000, 100000, 200000, 400000, 1000000]:
 
-#         if numFactors == 1:
+#         if num_factors == 1:
 #             lmmProducts.simulate1F(discount_curve, volCurve, num_paths, 0, True)
-#         elif numFactors == 2:
-#             lmmProducts.simulateMF(discount_curve, numFactors, lambdas2F,
+#         elif num_factors == 2:
+#             lmmProducts.simulateMF(discount_curve, num_factors, lambdas2F,
 #                                    num_paths, 0, True)
 
 #         v_lmm = lmmProducts.valueCapFloor(settle_dt,
 #                                           capMaturityDate,
 #                                           IborCapFloorTypes.CAP,
 #                                           capFloorRate,
 #                                           FrequencyTypes.ANNUAL,
```

### Comparing `financepy-0.350/tests_golden/TestFinIborSingleCurve.py` & `financepy-0.360/tests_golden/TestFinIborSingleCurve.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,30 +1,32 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import time as time
 import numpy as np
 import matplotlib.pyplot as plt
+
 from financepy.utils.date import Date
 from financepy.utils.day_count import DayCountTypes
 from financepy.utils.frequency import FrequencyTypes
 from financepy.utils.calendar import CalendarTypes
 from financepy.products.rates.ibor_single_curve import IborSingleCurve
 from financepy.products.rates.ibor_fra import IborFRA
 from financepy.products.rates.ibor_future import IborFuture
 from financepy.products.rates.ibor_deposit import IborDeposit
 from financepy.products.rates.ibor_swap import IborSwap
 from financepy.utils.calendar import BusDayAdjustTypes
 from financepy.market.curves.interpolator import InterpTypes
 from financepy.utils.math import ONE_MILLION
 from financepy.utils.global_types import SwapTypes
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 PLOT_GRAPHS = False
 
 ###############################################################################
@@ -82,15 +84,15 @@
                                   swaps)
 
     test_cases.header("LABEL", "DATE", "VALUE")
 
     """ Check calibration """
     for depo in depos:
         v = depo.value(settle_dt, libor_curve)
-        test_cases.print("DEPO", depo._maturity_dt, v)
+        test_cases.print("DEPO", depo.maturity_dt, v)
 
 ###############################################################################
 
 
 def test_FinIborFRAsOnly():
 
     # TO DO FIX THIS
@@ -98,33 +100,33 @@
 
     spot_days = 0
     settle_dt = value_dt.add_weekdays(spot_days)
 
     depoDCCType = DayCountTypes.ACT_360
     notional = 100.0
 
-    payFixed = True
+    pay_fixed = True
 
     cal_type = CalendarTypes.TARGET
     fras = []
 
     # 1 x 4 FRA
-    fraRate = 0.04
+    fra_rate = 0.04
     fraSettlementDate = settle_dt.add_months(1)
     fraMaturityDate = settle_dt.add_months(4)
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate,
-                  depoDCCType, notional, payFixed, cal_type)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate,
+                  depoDCCType, notional, pay_fixed, cal_type)
     fras.append(fra)
 
     # 4 x 7 FRA
-    fraRate = 0.08
+    fra_rate = 0.08
     fraSettlementDate = settle_dt.add_months(4)
     fraMaturityDate = settle_dt.add_months(7)
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate,
-                  depoDCCType, notional, payFixed, cal_type)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate,
+                  depoDCCType, notional, pay_fixed, cal_type)
     fras.append(fra)
 
     depos = []
     swaps = []
 
     libor_curve = IborSingleCurve(value_dt,
                                   depos,
@@ -132,15 +134,15 @@
                                   swaps)
 
     test_cases.header("DATE", "MATDATE", "VALUE")
 
     """ Check calibration """
     for fra in fras:
         v = fra.value(settle_dt, libor_curve)
-        test_cases.print("FRA:", fra._maturity_dt, v)
+        test_cases.print("FRA:", fra.maturity_dt, v)
 
 ###############################################################################
 
 
 def test_ibor_depositsFRAsSwaps():
 
     value_dt = Date(18, 9, 2019)
@@ -174,165 +176,165 @@
 
     maturity_dt = settle_dt.add_months(12)
     depo = IborDeposit(settle_dt, maturity_dt, deposit_rate, dccType)
     depos.append(depo)
 
     fras = []
     # 1 x 4 FRA
-    fraRate = 0.04
+    fra_rate = 0.04
     fraSettlementDate = settle_dt.add_months(9)
     fraMaturityDate = settle_dt.add_months(13)
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, dccType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, dccType)
     fras.append(fra)
 
     # 4 x 7 FRA
-    fraRate = 0.03
+    fra_rate = 0.03
     fraSettlementDate = settle_dt.add_months(13)
     fraMaturityDate = settle_dt.add_months(17)
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, dccType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, dccType)
     fras.append(fra)
 
     # 4 x 7 FRA
-    fraRate = 0.07
+    fra_rate = 0.07
     fraSettlementDate = settle_dt.add_months(17)
     fraMaturityDate = settle_dt.add_months(21)
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, dccType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, dccType)
     fras.append(fra)
 
     swaps = []
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
 
     swap_rate = 0.05
 #    maturity_dt = settle_dt.add_months(24)
 #    swap = IborSwap(settle_dt, maturity_dt, swap_rate, fixed_freq_type,
-#                        fixedDCCType)
+#                        fixed_dcc_type)
 #    swaps.append(swap)
 
     fixed_leg_type = SwapTypes.PAY
     maturity_dt = settle_dt.add_months(36)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(48)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(60)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(72)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(84)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(96)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(108)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(120)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(132)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(144)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(180)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(240)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(300)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     maturity_dt = settle_dt.add_months(360)
     swap = IborSwap(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                     fixed_freq_type,
-                    fixedDCCType)
+                    fixed_dcc_type)
     swaps.append(swap)
 
     libor_curve = IborSingleCurve(value_dt,
                                   depos,
                                   fras,
                                   swaps)
 
     df = libor_curve.df(settle_dt)
 
     test_cases.header("SETTLEMENT DATE", "DF")
     test_cases.print(str(settle_dt), df)
     test_cases.header("DATE", "DF")
 
     for deposit in depos:
-        df = libor_curve.df(deposit._maturity_dt)
-        test_cases.print(str(deposit._maturity_dt), df)
+        df = libor_curve.df(deposit.maturity_dt)
+        test_cases.print(str(deposit.maturity_dt), df)
 
     for swap in swaps:
-        df = libor_curve.df(swap._maturity_dt)
-        test_cases.print(str(swap._maturity_dt), df)
+        df = libor_curve.df(swap.maturity_dt)
+        test_cases.print(str(swap.maturity_dt), df)
 
 
 ###############################################################################
 ###############################################################################
 # https://github.com/vilen22/curve-building/blob/master/Bloomberg%20Curve%20Building%20Replication.xlsx
 ###############################################################################
 ###############################################################################
 # AGREEMENT IS VERY CLOSE - NOT SURE ABOUT SIZE OF LAST PAYMENT ON FIXED LEG!
 
 
-def futureToFRARate(price, convexity):
+def futureTofra_rate(price, convexity):
     futRate = (100-price)/100
     if convexity < 0:
-        fraRate = futRate + convexity/100.0
+        fra_rate = futRate + convexity/100.0
     else:
-        fraRate = futRate - convexity/100.0
+        fra_rate = futRate - convexity/100.0
 
-    return fraRate
+    return fra_rate
 
 ###############################################################################
 
 
 def test_ibor_depositsFuturesSwaps():
 
     spot_dt = Date(6, 6, 2018)
@@ -354,73 +356,72 @@
     depo = IborDeposit(settle_dt, "2M", 0.0235, depoDCCType)
     depos.append(depo)
     depo = IborDeposit(settle_dt, "3M", 0.0240, depoDCCType)
     depos.append(depo)
 
     fras = []
 
-    fraRate = futureToFRARate(97.6675, -0.00005)
+    fra_rate = futureTofra_rate(97.6675, -0.00005)
     fraSettlementDate = spot_dt.next_imm_date()
     fraMaturityDate = fraSettlementDate.next_imm_date()
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, depoDCCType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.5200, -0.00060)
+    fra_rate = futureTofra_rate(97.5200, -0.00060)
     fraSettlementDate = fraMaturityDate
     fraMaturityDate = fraSettlementDate.next_imm_date()
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, depoDCCType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.3550, -0.00146)
+    fra_rate = futureTofra_rate(97.3550, -0.00146)
     fraSettlementDate = fraMaturityDate
     fraMaturityDate = fraSettlementDate.next_imm_date()
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, depoDCCType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.2450, -0.00263)
+    fra_rate = futureTofra_rate(97.2450, -0.00263)
     fraSettlementDate = fraMaturityDate
     fraMaturityDate = fraSettlementDate.next_imm_date()
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, depoDCCType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.1450, -0.00411)
+    fra_rate = futureTofra_rate(97.1450, -0.00411)
     fraSettlementDate = fraMaturityDate
     fraMaturityDate = fraSettlementDate.next_imm_date()
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, depoDCCType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.0750, -0.00589)
+    fra_rate = futureTofra_rate(97.0750, -0.00589)
     fraSettlementDate = fraSettlementDate.next_imm_date()
     fraMaturityDate = fraSettlementDate.next_imm_date()
-    fra = IborFRA(fraSettlementDate, fraMaturityDate, fraRate, depoDCCType)
+    fra = IborFRA(fraSettlementDate, fraMaturityDate, fra_rate, depoDCCType)
     fras.append(fra)
 
     ###########################################################################
 
     spot_days = 2
     start_dt = spot_dt.add_weekdays(spot_days)
 
     swaps = []
     fixed_leg_type = SwapTypes.PAY
-    fixedDCCType = DayCountTypes.THIRTY_E_360
+    fixed_dcc_type = DayCountTypes.THIRTY_E_360
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     float_freq_type = FrequencyTypes.QUARTERLY
     notional = 1000000
-    principal = 0.0
     float_spread = 0.0
-    floatDCCType = DayCountTypes.ACT_360
+    float_dcc_type = DayCountTypes.ACT_360
     cal_type = CalendarTypes.UNITED_STATES
-    busDayAdjustRule = BusDayAdjustTypes.PRECEDING
+    bus_day_adjust_rule = BusDayAdjustTypes.PRECEDING
 
     swap_rate = 0.02776305
 
     swap = IborSwap(start_dt, "2Y", fixed_leg_type, swap_rate,
-                    fixed_freq_type, fixedDCCType, notional,
-                    float_spread, float_freq_type, floatDCCType,
-                    cal_type, busDayAdjustRule)
+                    fixed_freq_type, fixed_dcc_type, notional,
+                    float_spread, float_freq_type, float_dcc_type,
+                    cal_type, bus_day_adjust_rule)
 
     swaps.append(swap)
 
     libor_curve = IborSingleCurve(spot_dt, depos, fras, swaps)
 
     times = np.linspace(0.0, 2.0, 25)
     dates = spot_dt.add_years(times)
@@ -449,25 +450,25 @@
         print(end_dt, df)
 
         end_dt = Date(20, 6, 2018)
         df = libor_curve.df(end_dt)
         print(end_dt, df)
 
         for depo in depos:
-            end_dt = depo._maturity_dt
+            end_dt = depo.maturity_dt
             df = libor_curve.df(end_dt)
             print(end_dt, df)
 
         for fra in fras:
-            end_dt = fra._maturity_dt
+            end_dt = fra.maturity_dt
             df = libor_curve.df(end_dt)
             print(end_dt, df)
 
         for swap in swaps:
-            end_dt = swap._maturity_dt
+            end_dt = swap.maturity_dt
             df = libor_curve.df(end_dt)
             print(end_dt, df)
 
         swap.print_fixed_leg_pv(spot_dt)
         swap.print_float_leg_pv(spot_dt)
 
 #        print(libor_curve)
@@ -734,25 +735,25 @@
     principal = 0.0
 
     # Pay fixed so make fixed leg value negative
     test_cases.header("VALUATION TO TODAY DATE", " PV")
     test_cases.print("VALUE:", swaps[0].value(
         value_dt, libor_curve, libor_curve, None))
     test_cases.print(
-        "FIXED:", -swaps[0]._fixed_leg.value(value_dt, libor_curve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+        "FIXED:", -swaps[0].fixed_leg.value(value_dt, libor_curve))
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         value_dt, libor_curve, libor_curve, None))
 
     # Pay fixed so make fixed leg value negative
     test_cases.header("VALUATION TO SWAP SETTLEMENT DATE", " PV")
     test_cases.print("VALUE:", swaps[0].value(
         settle_dt, libor_curve, libor_curve, None))
     test_cases.print(
-        "FIXED:", -swaps[0]._fixed_leg.value(settle_dt, libor_curve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+        "FIXED:", -swaps[0].fixed_leg.value(settle_dt, libor_curve))
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         settle_dt, libor_curve, libor_curve, None))
 
     # swaps[0].print_fixed_leg_pv()
     # swaps[0].print_float_leg_pv()
 
     if 1 == 0:
         plt.figure()
```

### Comparing `financepy-0.350/tests_golden/TestFinIborSwap.py` & `financepy-0.360/tests_golden/TestFinIborSwap.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,14 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import numpy as np
 from financepy.utils.math import ONE_MILLION
 from financepy.products.rates.ibor_single_curve import IborSingleCurve
 from financepy.products.rates.ibor_swap import IborSwap
 from financepy.products.rates.ibor_fra import IborFRA
 from financepy.products.rates.ibor_deposit import IborDeposit
 from financepy.utils.calendar import BusDayAdjustTypes
@@ -14,16 +17,14 @@
 from financepy.utils.frequency import FrequencyTypes
 from financepy.utils.day_count import DayCountTypes
 from financepy.utils.date import Date
 from financepy.utils.global_types import SwapTypes
 from financepy.market.curves.discount_curve import DiscountCurve
 from financepy.market.curves.interpolator import InterpTypes
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
@@ -248,37 +249,37 @@
     libor_curve = IborSingleCurve(value_dt, depos, fras, swaps)
 
     test_cases.header("LABEL", "DATE", "VALUE")
 
     """ Check calibration """
     for depo in depos:
         v = depo.value(settle_dt, libor_curve)
-        test_cases.print("DEPO VALUE:", depo._maturity_dt, v)
+        test_cases.print("DEPO VALUE:", depo.maturity_dt, v)
 
     for fra in fras:
         v = fra.value(settle_dt, libor_curve)
-        test_cases.print("FRA VALUE:", fra._maturity_dt, v)
+        test_cases.print("FRA VALUE:", fra.maturity_dt, v)
 
     for swap in swaps:
         v = swap.value(settle_dt, libor_curve)
-        test_cases.print("SWAP VALUE:", swap._maturity_dt, v)
+        test_cases.print("SWAP VALUE:", swap.maturity_dt, v)
 
     return libor_curve
 
 ###############################################################################
 
 
 def test_LiborSwap():
 
     # I have tried to reproduce the example from the blog by Ioannis Rigopoulos
     # https://blog.deriscope.com/index.php/en/excel-interest-rate-swap-price-dual-bootstrapping-curve
     start_dt = Date(27, 12, 2017)
     end_dt = Date(27, 12, 2067)
 
-    fixed_coupon = 0.015
+    fixed_cpn = 0.015
     fixed_freq_type = FrequencyTypes.ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360
 
     float_spread = 0.0
     float_freq_type = FrequencyTypes.SEMI_ANNUAL
     float_dc_type = DayCountTypes.ACT_360
     firstFixing = -0.00268
@@ -289,15 +290,15 @@
     fixed_leg_type = SwapTypes.RECEIVE
 
     notional = 10.0 * ONE_MILLION
 
     swap = IborSwap(start_dt,
                     end_dt,
                     fixed_leg_type,
-                    fixed_coupon,
+                    fixed_cpn,
                     fixed_freq_type,
                     fixed_dc_type,
                     notional,
                     float_spread,
                     float_freq_type,
                     float_dc_type,
                     swap_cal_type,
@@ -330,21 +331,21 @@
     end_dt = Date(14, 11, 2016)
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     swap_cal_type = CalendarTypes.TARGET
     bd_type = BusDayAdjustTypes.MODIFIED_FOLLOWING
     dg_type = DateGenRuleTypes.BACKWARD
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     fixed_leg_type = SwapTypes.PAY
-    fixed_coupon = 0.0124
+    fixed_cpn = 0.0124
     notional = ONE_MILLION
 
     swap = IborSwap(start_dt,
                     end_dt,
                     fixed_leg_type,
-                    fixed_coupon=fixed_coupon,
+                    fixed_cpn=fixed_cpn,
                     fixed_freq_type=fixed_freq_type,
                     fixed_dc_type=fixed_dc_type,
                     float_freq_type=FrequencyTypes.SEMI_ANNUAL,
                     float_dc_type=DayCountTypes.ACT_360,
                     notional=notional,
                     cal_type=swap_cal_type,
                     bd_type=bd_type,
```

### Comparing `financepy-0.350/tests_golden/TestFinIborSwaption.py` & `financepy-0.360/tests_golden/TestFinIborSwaption.py`

 * *Files 4% similar despite different names*

```diff
@@ -207,27 +207,27 @@
     swaps.append(swap)
 
     libor_curve = IborSingleCurve(value_dt, depos, [], swaps,
                                   InterpTypes.LINEAR_ZERO_RATES)
 
     exercise_dt = settle_dt.add_tenor("5Y")
     swap_maturity_dt = exercise_dt.add_tenor("5Y")
-    swap_fixed_coupon = 0.040852
+    swap_fixed_cpn = 0.040852
     swap_fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     swapFixedDayCountType = DayCountTypes.THIRTY_E_360_ISDA
     swapFloatFrequencyType = FrequencyTypes.QUARTERLY
     swapFloatDayCountType = DayCountTypes.ACT_360
     swapNotional = 1000000
     swaptionType = SwapTypes.PAY
 
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             swap_maturity_dt,
                             swaptionType,
-                            swap_fixed_coupon,
+                            swap_fixed_cpn,
                             swap_fixed_freq_type,
                             swapFixedDayCountType,
                             swapNotional,
                             swapFloatFrequencyType,
                             swapFloatDayCountType)
 
     test_cases.header("MODEL", "VALUE")
@@ -320,59 +320,59 @@
     swaps.append(swap)
 
     libor_curve = IborSingleCurve(value_dt, depos, [], swaps,
                                   InterpTypes.LINEAR_ZERO_RATES)
 
     exercise_dt = settle_dt.add_tenor("5Y")
     swap_maturity_dt = exercise_dt.add_tenor("5Y")
-    swap_fixed_coupon = 0.040852
+    swap_fixed_cpn = 0.040852
     swap_fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     swapFixedDayCountType = DayCountTypes.THIRTY_E_360_ISDA
     swapFloatFrequencyType = FrequencyTypes.QUARTERLY
     swapFloatDayCountType = DayCountTypes.ACT_360
     swapNotional = 1000000
     fixed_leg_type = SwapTypes.PAY
 
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             swap_maturity_dt,
                             fixed_leg_type,
-                            swap_fixed_coupon,
+                            swap_fixed_cpn,
                             swap_fixed_freq_type,
                             swapFixedDayCountType,
                             swapNotional,
                             swapFloatFrequencyType,
                             swapFloatDayCountType)
 
     model = Black(0.1533)
     v = swaption.value(settle_dt, libor_curve, model)
     test_cases.print("Swaption No-Arb Value:", v)
 
-    fwdSwapRate1 = libor_curve.swap_rate(exercise_dt,
+    fwd_swap_rate1 = libor_curve.swap_rate(exercise_dt,
                                          swap_maturity_dt,
                                          swap_fixed_freq_type,
                                          swapFixedDayCountType)
 
-    test_cases.print("Curve Fwd Swap Rate:", fwdSwapRate1)
+    test_cases.print("Curve Fwd Swap Rate:", fwd_swap_rate1)
 
     fwdSwap = IborSwap(exercise_dt,
                        swap_maturity_dt,
                        fixed_leg_type,
-                       swap_fixed_coupon,
+                       swap_fixed_cpn,
                        swap_fixed_freq_type,
                        swapFixedDayCountType)
 
-    fwdSwapRate2 = fwdSwap.swap_rate(settle_dt, libor_curve)
-    test_cases.print("Fwd Swap Swap Rate:", fwdSwapRate2)
+    fwd_swap_rate2 = fwdSwap.swap_rate(settle_dt, libor_curve)
+    test_cases.print("Fwd Swap Swap Rate:", fwd_swap_rate2)
 
     model = Black(0.1533)
 
     v = swaption.cash_settled_value(value_dt,
                                     libor_curve,
-                                    fwdSwapRate2,
+                                    fwd_swap_rate2,
                                     model)
 
     test_cases.print("Swaption Cash Settled Value:", v)
 
 ###############################################################################
 
 
@@ -390,26 +390,26 @@
                                     FrequencyTypes.CONTINUOUS,
                                     DayCountTypes.THIRTY_E_360)
 
     settle_dt = Date(1, 1, 2011)
     exercise_dt = Date(1, 1, 2016)
     maturity_dt = Date(1, 1, 2019)
 
-    fixed_coupon = 0.062
+    fixed_cpn = 0.062
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     notional = 100.0
 
     # Pricing a PAY
     swaptionType = SwapTypes.PAY
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional)
 
     model = Black(0.20)
     v_finpy = swaption.value(value_dt, libor_curve, model)
     v_matlab = 2.071
@@ -439,29 +439,29 @@
     libor_curve = DiscountCurveZeros(value_dt, dates,
                                      zero_rates, contFreq,
                                      dc_type, interp_type)
 
     settle_dt = Date(1, 1, 2011)
     exercise_dt = Date(1, 1, 2012)
     maturity_dt = Date(1, 1, 2017)
-    fixed_coupon = 0.03
+    fixed_cpn = 0.03
 
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360
     float_freq_type = FrequencyTypes.SEMI_ANNUAL
     float_dc_type = DayCountTypes.THIRTY_E_360
     notional = 1000.0
 
     # Pricing a put
     swaptionType = SwapTypes.RECEIVE
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional,
                             float_freq_type,
                             float_dc_type)
 
     model = Black(0.21)
@@ -492,29 +492,29 @@
 
     libor_curve = DiscountCurveZeros(value_dt, dates, zero_rates,
                                      contFreq, dc_type, interp_type)
 
     settle_dt = Date(1, 1, 2016)
     exercise_dt = Date(1, 1, 2017)
     maturity_dt = Date(1, 1, 2020)
-    fixed_coupon = -0.003
+    fixed_cpn = -0.003
 
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     float_freq_type = FrequencyTypes.SEMI_ANNUAL
     float_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     notional = 1000.0
 
     # Pricing a PAY
     swaptionType = SwapTypes.PAY
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional,
                             float_freq_type,
                             float_dc_type)
 
     model = BlackShifted(0.31, 0.008)
@@ -549,26 +549,26 @@
     libor_curve = DiscountCurveZeros(value_dt, dates, zero_rates,
                                      contFreq,
                                      dc_type, interp_type)
 
     settle_dt = value_dt
     exercise_dt = Date(1, 1, 2010)
     maturity_dt = Date(1, 1, 2012)
-    fixed_coupon = 0.04
+    fixed_cpn = 0.04
 
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     notional = 100.0
 
     swaptionType = SwapTypes.RECEIVE
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional)
 
     model = HWTree(0.05, 0.01)
     v_finpy = swaption.value(value_dt, libor_curve, model)
     v_matlab = 2.9201
@@ -607,40 +607,40 @@
 
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     notional = 100.0
 
     model = BKTree(0.1, 0.05, 200)
 
-    fixed_coupon = 0.07
+    fixed_cpn = 0.07
     swaptionType = SwapTypes.PAY
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional)
 
     v_finpy = swaption.value(value_dt, libor_curve, model)
     v_matlab = 0.3634
 
     test_cases.header("LABEL", "VALUE")
     test_cases.print("FP Price:", v_finpy)
     test_cases.print("MATLAB Prix:", v_matlab)
     test_cases.print("DIFF:", v_finpy - v_matlab)
 
-    fixed_coupon = 0.0725
+    fixed_cpn = 0.0725
     swaptionType = SwapTypes.RECEIVE
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional)
 
     v_finpy = swaption.value(value_dt, libor_curve, model)
     v_matlab = 0.4798
 
@@ -677,21 +677,21 @@
     exercise_dt = Date(1, 1, 2012)
     maturity_dt = Date(1, 1, 2015)
 
     fixed_freq_type = FrequencyTypes.ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     notional = 100.0
 
-    fixed_coupon = 0.062
+    fixed_cpn = 0.062
     swaptionType = SwapTypes.PAY
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional)
 
     model = BDTTree(0.20, 200)
     v_finpy = swaption.value(value_dt, libor_curve, model)
     v_matlab = 2.0592
```

### Comparing `financepy-0.350/tests_golden/TestFinInflationBond.py` & `financepy-0.360/tests_golden/TestFinInflationBond.py`

 * *Files 0% similar despite different names*

```diff
@@ -78,36 +78,36 @@
 
     dirty_price = bond.dirty_price_from_ytm(settle_dt, ytm)
     test_cases.print("Dirty Price from REAL YTM = ", dirty_price)
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     test_cases.print("Clean Price from Real YTM = ", clean_price)
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     test_cases.print("Accrued Days = ", accddays)
 
-    accrued_interest = bond._accrued_interest
+    accrued_interest = bond.accrued_int
     test_cases.print("REAL Accrued Interest = ", accrued_interest)
 
     ###########################################################################
     # Inflation functions that calculate nominal yield with CPI adjustment
     ###########################################################################
 
     refCPIValue = 244.65884
 
     ###########################################################################
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     test_cases.print("Clean Price from Real YTM = ", clean_price)
 
-    inflationAccd = bond.inflation_accrued_interest(settle_dt,
-                                                    face,
-                                                    refCPIValue)
+    inflation_accd = bond.inflation_accrued_interest(settle_dt,
+                                                     face,
+                                                     refCPIValue)
 
-    test_cases.print("Inflation Accrued = ", inflationAccd)
+    test_cases.print("Inflation Accrued = ", inflation_accd)
 
     lastCpnCPIValue = 244.61839
 
     clean_price = bond.flat_price_from_yield_to_maturity(settle_dt, ytm,
                                                          lastCpnCPIValue,
                                                          YTMCalcType.US_TREASURY)
 
@@ -294,18 +294,18 @@
 
     dirty_price = bond.dirty_price_from_discount_curve(settle_dt, ytm)
     test_cases.print("Dirty Price from REAL YTM = ", dirty_price)
 
     clean_price = bond.clean_price_from_ytm(settle_dt, ytm)
     test_cases.print("Clean Price from Real YTM = ", clean_price)
 
-    accddays = bond._accrued_days
+    accddays = bond.accrued_days
     test_cases.print("Accrued Days = ", accddays)
 
-    accrued_interest = bond._accrued_interest
+    accrued_interest = bond.accrued_int
     test_cases.print("REAL Accrued Interest = ", accrued_interest)
 
     ###########################################################################
     # Inflation functions that calculate nominal yield with CPI adjustment
     ###########################################################################
 
     ###########################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinInflationIndexCurve.py` & `financepy-0.360/tests_golden/TestFinInflationIndexCurve.py`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-from financepy.utils.date import Date
-from financepy.products.inflation.FinInflationIndexCurve import FinInflationIndexCurve
-from FinTestCases import FinTestCases, globalTestCaseMode
 import sys
 sys.path.append("..")
 
+from financepy.utils.date import Date
+from financepy.products.inflation.FinInflationIndexCurve import FinInflationIndexCurve
+from FinTestCases import FinTestCases, globalTestCaseMode
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##############################################################################
 
 
 def test_FinInflationIndexCurve():
```

### Comparing `financepy-0.350/tests_golden/TestFinInterpolate.py` & `financepy-0.360/tests_golden/TestFinInterpolate.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinInterpolatedForwards.py` & `financepy-0.360/tests_golden/TestFinInterpolatedForwards.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import numpy as np
 from financepy.utils.date import Date
 from financepy.market.curves.interpolator import InterpTypes
 from financepy.market.curves.discount_curve import DiscountCurve
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 PLOT_GRAPHS = False
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinLossDbnBuilder.py` & `financepy-0.360/tests_golden/TestFinLossDbnBuilder.py`

 * *Ordering differences only*

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import time
 import numpy as np
 import matplotlib.pyplot as plt
 from financepy.models.gauss_copula_onefactor import loss_dbn_recursion_gcd
 from financepy.models.gauss_copula_onefactor import loss_dbn_hetero_adj_binomial
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 plotGraphs = False
 
 ##########################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinMath.py` & `financepy-0.360/tests_golden/TestFinMath.py`

 * *Ordering differences only*

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import time
 import numpy as np
 from financepy.utils.math import normcdf_integrate
 from financepy.utils.math import N
 from financepy.utils.math import normcdf_slow
 from financepy.utils.math import norminvcdf
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
 
 
 def test_FinMath():
```

### Comparing `financepy-0.350/tests_golden/TestFinMathAccruedInterp.py` & `financepy-0.360/tests_golden/TestFinMathAccruedInterp.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
+import sys
+sys.path.append("..")
+
 import matplotlib.pyplot as plt
 import numpy as np
 from financepy.utils.math import accrued_interpolator
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 pltGraph = False
 
 ##########################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinModelBlack.py` & `financepy-0.360/tests_golden/TestFinModelBlack.py`

 * *Ordering differences only*

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 # Guillaume Lefieux
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import numpy as np
 from financepy.models.black import Black
 from financepy.utils.global_types import OptionTypes
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 
 def test_Black():
 
     forward = 0.034
```

### Comparing `financepy-0.350/tests_golden/TestFinModelBlackScholes.py` & `financepy-0.360/tests_golden/TestFinModelBlackScholes.py`

 * *Files 5% similar despite different names*

```diff
@@ -23,32 +23,32 @@
 
 # TODO Complete output of results to log files
 
 
 def testBlackScholes():
 
     value_dt = Date(8, 5, 2015)
-    expiry_date = Date(15, 1, 2016)
+    expiry_dt = Date(15, 1, 2016)
 
     strike_price = 130.0
     stock_price = 127.62
     volatility = 0.20
     interest_rate = 0.001
     dividend_yield = 0.0163
 
     option_type = OptionTypes.AMERICAN_CALL
     euOptionType = OptionTypes.EUROPEAN_CALL
 
-    amOption = EquityAmericanOption(expiry_date, strike_price,
+    amOption = EquityAmericanOption(expiry_dt, strike_price,
                                     option_type)
 
-    ameuOption = EquityAmericanOption(expiry_date, strike_price,
+    ameuOption = EquityAmericanOption(expiry_dt, strike_price,
                                       euOptionType)
 
-    euOption = EquityVanillaOption(expiry_date, strike_price,
+    euOption = EquityVanillaOption(expiry_dt, strike_price,
                                    euOptionType)
 
     discount_curve = DiscountCurveFlat(value_dt, interest_rate,
                                        FrequencyTypes.CONTINUOUS,
                                        DayCountTypes.ACT_365F)
 
     dividend_curve = DiscountCurveFlat(value_dt, dividend_yield,
```

### Comparing `financepy-0.350/tests_golden/TestFinModelBlack_SABR_HW.py` & `financepy-0.360/tests_golden/TestFinModelBlack_SABR_HW.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import matplotlib.pyplot as plt
 import numpy as np
 from financepy.models.sabr import SABR
 from financepy.models.sabr_shifted import SABRShifted
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 PLOT_GRAPHS = False
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinModelCIR.py` & `financepy-0.360/tests_golden/TestFinModelCIR.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-import time
-import numpy as np
-from financepy.models.cir_mc import zero_price_mc, zero_price
-from financepy.models.cir_mc import CIRNumericalScheme
-from FinTestCases import FinTestCases, globalTestCaseMode
 import sys
 sys.path.append("..")
 
+import time
+import numpy as np
+from financepy.models.cir_montecarlo import zero_price_mc, zero_price
+from financepy.models.cir_montecarlo import CIRNumericalScheme
+from FinTestCases import FinTestCases, globalTestCaseMode
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def test_FinModelRatesCIR():
```

### Comparing `financepy-0.350/tests_golden/TestFinModelHeston.py` & `financepy-0.360/tests_golden/TestFinModelHeston.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
+
 import numpy as np
 import time
 from financepy.models.heston import Heston, HestonNumericalScheme
 from financepy.utils.global_types import OptionTypes
 from financepy.products.equity.equity_vanilla_option import EquityVanillaOption
 from financepy.utils.date import Date
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
 
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ##########################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinModelMerton.py` & `financepy-0.360/tests_golden/TestFinModelMerton.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,62 +1,61 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.models.merton_firm_mkt import MertonFirmMkt
+from financepy.models.merton_firm import MertonFirm
 import sys
 sys.path.append("..")
 
-from financepy.models.merton_firm import MertonFirm
-from financepy.models.merton_firm_mkt import MertonFirmMkt
-from FinTestCases import FinTestCases, globalTestCaseMode
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def test_FinModelMertonCredit():
 
     # Input Equity values and equity vols
     equity_value = [2.6406, 2.6817, 3.977, 2.947, 2.528]
     equity_vol = [0.7103, 0.3929, 0.3121, 0.4595, 0.6181]
-    bondFace = [4.0, 3.5, 3.5, 3.2, 4.0]
+    bond_face = [4.0, 3.5, 3.5, 3.2, 4.0]
     risk_free_rate = [0.05, 0.05, 0.05, 0.05, 0.05]
-    assetGrowthRate = [0.0306, 0.03, 0.031, 0.0302, 0.0305]
-    timeToMaturity = 1.0  # np.linspace(0.1, 10, 100)
+    asset_growth_rate = [0.0306, 0.03, 0.031, 0.0302, 0.0305]
+    years_to_maturity = 1.0  # np.linspace(0.1, 10, 100)
 
     model = MertonFirmMkt(equity_value,
-                          bondFace,
-                          timeToMaturity,
+                          bond_face,
+                          years_to_maturity,
                           risk_free_rate,
-                          assetGrowthRate,
+                          asset_growth_rate,
                           equity_vol)
 
     test_cases.header("MERTON MARKET MODEL", "VALUE")
     test_cases.print("ASSET VALUE", model._A)
     test_cases.print("EQUITY VALUE", model._E)
     test_cases.print("DEBT VALUE", model.debt_value())
 
     test_cases.print("ASSET VOLATILITY", model._vA)
     test_cases.print("EQUITY VOL", model._vE)
 
     test_cases.print("CREDIT SPREAD", model.credit_spread())
     test_cases.print("LEVERAGE", model.leverage())
     test_cases.print("PROD DEFAULT", model.prob_default())
 
-    assetValue = model._A
-    assetVol = model._vA
+    asset_value = model._A
+    asset_vol = model._vA
 
-    model = MertonFirm(assetValue,
-                       bondFace,
-                       timeToMaturity,
+    model = MertonFirm(asset_value,
+                       bond_face,
+                       years_to_maturity,
                        risk_free_rate,
-                       assetGrowthRate,
-                       assetVol)
+                       asset_growth_rate,
+                       asset_vol)
 
     test_cases.header("BASIC MERTON MODEL", "VALUE")
 
     test_cases.print("ASSET VALUE", model._A)
     test_cases.print("EQUITY VALUE", model._E)
     test_cases.print("DEBT VALUE", model.debt_value())
 
@@ -64,27 +63,27 @@
     test_cases.print("EQUITY VOL", model._vE)
 
     test_cases.print("CREDIT SPREAD", model.credit_spread())
     test_cases.print("LEVERAGE", model.leverage())
     test_cases.print("PROD DEFAULT", model.prob_default())
     test_cases.print("DISTANCE DEFAULT", model.dist_default())
 
-    assetValue = 140.0
-    bondFace = 100.0
-    timeToMaturity = 1.0
+    asset_value = 140.0
+    bond_face = 100.0
+    years_to_maturity = 1.0
     risk_free_rate = 0.05
-    assetGrowthRate = 0.05
-    assetVol = 0.20
+    asset_growth_rate = 0.05
+    asset_vol = 0.20
 
-    model = MertonFirm(assetValue,
-                       bondFace,
-                       timeToMaturity,
+    model = MertonFirm(asset_value,
+                       bond_face,
+                       years_to_maturity,
                        risk_free_rate,
-                       assetGrowthRate,
-                       assetVol)
+                       asset_growth_rate,
+                       asset_vol)
 
     test_cases.header("BASIC MERTON MODEL", "VALUE")
 
     test_cases.print("ASSET VALUE", model._A)
     test_cases.print("EQUITY VALUE", model._E)
     test_cases.print("DEBT VALUE", model.debt_value())
```

### Comparing `financepy-0.350/tests_golden/TestFinModelRatesBDT.py` & `financepy-0.360/tests_golden/TestFinModelRatesBDT.py`

 * *Files 4% similar despite different names*

```diff
@@ -41,26 +41,26 @@
     libor_curve = DiscountCurveFlat(value_dt, 0.06,
                                     FrequencyTypes.SEMI_ANNUAL)
 
     settle_dt = Date(1, 1, 2020)
     exercise_dt = Date(1, 1, 2021)
     maturity_dt = Date(1, 1, 2024)
 
-    fixed_coupon = 0.06
+    fixed_cpn = 0.06
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_dc_type = DayCountTypes.THIRTY_E_360_ISDA
     notional = 100.0
 
     # Pricing a PAY
     swaptionType = SwapTypes.PAY
     swaption = IborSwaption(settle_dt,
                             exercise_dt,
                             maturity_dt,
                             swaptionType,
-                            fixed_coupon,
+                            fixed_cpn,
                             fixed_freq_type,
                             fixed_dc_type,
                             notional)
 
     model = Black(0.20)
     v = swaption.value(value_dt, libor_curve, model)
     test_cases.header("LABEL", "VALUE")
@@ -104,43 +104,43 @@
     model = BDTTree(yieldVol, num_time_steps)
     model.build_tree(t_mat, years, dfs)
 
 ###############################################################################
 
 
 def test_BDTExampleTwo():
-    # Valuation of a European option on a coupon bearing bond
+    # Valuation of a European option on a cpn bearing bond
     # This follows example in Fig 28.11 of John Hull's book (6th Edition)
     # but does not have the exact same dt so there are some differences
 
     test_cases.banner("===================== FIG 28.11 HULL BOOK =============")
 
     settle_dt = Date(1, 12, 2019)
     issue_dt = Date(1, 12, 2015)
     expiry_dt = settle_dt.add_tenor("18m")
     maturity_dt = settle_dt.add_tenor("10Y")
-    coupon = 0.05
+    cpn = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
-    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
+    bond = Bond(issue_dt, maturity_dt, cpn, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
-    cpn = bond._cpn / bond._freq
-    num_flows = len(bond._cpn_dts)
+    cpn = bond.cpn / bond.freq
+    num_flows = len(bond.cpn_dts)
 
     for i in range(1, num_flows):
-        pcd = bond._cpn_dts[i-1]
-        ncd = bond._cpn_dts[i]
+        pcd = bond.cpn_dts[i-1]
+        ncd = bond.cpn_dts[i]
         if pcd < settle_dt and ncd > settle_dt:
             flow_time = (pcd - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
-    for flow_dt in bond._cpn_dts:
+    for flow_dt in bond.cpn_dts:
         if flow_dt > settle_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
     cpn_flows = np.array(cpn_flows)
@@ -205,15 +205,15 @@
     settle_dt = Date(1, 1, 2020)
     times = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0])
     dates = settle_dt.add_years(times)
     rate = 0.06
     dfs = 1.0 / (1.0 + rate/2.0)**(2.0*times)
     curve = DiscountCurve(settle_dt, dates, dfs)
 
-    coupon = 0.06
+    cpn = 0.06
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
     strike_price = 100.0
     face = 100.0
     # Andersen paper
     num_time_steps = 200
 
@@ -222,15 +222,15 @@
 
     for exercise_type in [FinExerciseTypes.EUROPEAN,
                           FinExerciseTypes.BERMUDAN]:
 
         for years_to_maturity in [4.0, 5.0, 10.0, 20.0]:
 
             maturity_dt = settle_dt.add_years(years_to_maturity)
-            issue_dt = Date(maturity_dt._d, maturity_dt._m, 2000)
+            issue_dt = Date(maturity_dt.d, maturity_dt.m, 2000)
 
             if years_to_maturity == 4.0 or years_to_maturity == 5.0:
                 sigma = 0.2012
             elif years_to_maturity == 10.0:
                 sigma = 0.1522
             elif years_to_maturity == 20.0:
                 sigma = 0.1035
@@ -239,20 +239,20 @@
 
                 expiry_dt = settle_dt.add_years(expiryYears)
 
                 t_mat = (maturity_dt - settle_dt) / gDaysInYear
                 t_exp = (expiry_dt - settle_dt) / gDaysInYear
 
                 bond = Bond(issue_dt, maturity_dt,
-                            coupon, freq_type, dc_type)
+                            cpn, freq_type, dc_type)
 
                 cpn_times = []
                 cpn_flows = []
-                cpn = bond._cpn / bond._freq
-                for flow_dt in bond._cpn_dts:
+                cpn = bond.cpn / bond.freq
+                for flow_dt in bond.cpn_dts:
                     if flow_dt > expiry_dt:
                         flow_time = (flow_dt - settle_dt) / gDaysInYear
                         cpn_times.append(flow_time)
                         cpn_flows.append(cpn)
 
                 cpn_times = np.array(cpn_times)
                 cpn_flows = np.array(cpn_flows)
```

### Comparing `financepy-0.350/tests_golden/TestFinModelRatesBK.py` & `financepy-0.360/tests_golden/TestFinModelRatesBK.py`

 * *Files 3% similar despite different names*

```diff
@@ -42,20 +42,20 @@
     t_mat = (end_dt - start_dt)/gDaysInYear
     model = BKTree(sigma, a, num_time_steps)
     model.build_tree(t_mat, times, dfs)
 
     # Agrees with Figure 28.10 - Not exact as we have dt not exactly 0.50
     if num_time_steps < 5:
         test_cases.header("LABEL", "VALUE")
-        test_cases.print("QTREE", model._Q)
-        test_cases.print("RTREE", model._rt)
+        test_cases.print("QTREE", model.Q)
+        test_cases.print("RTREE", model.rt)
 #        print_tree(model._rt)
-        test_cases.print("PU AT LAST TIME", model._pu)
-        test_cases.print("PDM AT LAST TIME", model._pm)
-        test_cases.print("PD AT LAST TIME", model._pd)
+        test_cases.print("PU AT LAST TIME", model.pu)
+        test_cases.print("PDM AT LAST TIME", model.pm)
+        test_cases.print("PD AT LAST TIME", model.pd)
 
 ###############################################################################
 
 
 def test_BKExampleTwo():
     # Valuation of a European option on a coupon bearing bond
     # This follows example in Fig 28.11 of John Hull's book but does not
@@ -68,26 +68,26 @@
     coupon = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
     bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
-    cpn = bond._cpn / bond._freq
-    num_flows = len(bond._cpn_dts)
+    cpn = bond.cpn / bond.freq
+    num_flows = len(bond.cpn_dts)
 
     for i in range(1, num_flows):
-        pcd = bond._cpn_dts[i-1]
-        ncd = bond._cpn_dts[i]
+        pcd = bond.cpn_dts[i-1]
+        ncd = bond.cpn_dts[i]
         if pcd < settle_dt and ncd > settle_dt:
             flow_time = (pcd - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
-    for flow_dt in bond._cpn_dts:
+    for flow_dt in bond.cpn_dts:
         if flow_dt > settle_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
     cpn_flows = np.array(cpn_flows)
@@ -135,17 +135,17 @@
 
 #    plt.plot(num_steps_list, treeVector)
 
     # Value in Hill converges to 0.699 with 100 time steps while I get 0.700
 
     if 1 == 0:
         print("RT")
-        print_tree(model._rt, 5)
+        print_tree(model.rt, 5)
         print("Q")
-        print_tree(model._Q, 5)
+        print_tree(model.Q, 5)
 
 ###############################################################################
 
 
 test_BKExampleOne()
 test_BKExampleTwo()
 test_cases.compareTestCases()
```

### Comparing `financepy-0.350/tests_golden/TestFinModelRatesHW.py` & `financepy-0.360/tests_golden/TestFinModelRatesHW.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,16 +35,16 @@
 
     start_dt = Date(1, 12, 2019)
     end_dt = Date(1, 12, 2022)
     sigma = 0.01
     a = 0.1
     num_time_steps = 3
     model = HWTree(sigma, a, num_time_steps)
-    treeMat = (end_dt - start_dt)/gDaysInYear
-    model.build_tree(treeMat, times, dfs)
+    tree_mat = (end_dt - start_dt)/gDaysInYear
+    model.build_tree(tree_mat, times, dfs)
 #   print_tree(model._Q)
 #   print("")
 #   print_tree(model._rt)
 #   print("")
 
 ###############################################################################
 
@@ -92,62 +92,62 @@
 
     for num_time_steps in num_steps_list:
 
         start = time.time()
 
         model = HWTree(sigma, a, num_time_steps)
         model.build_tree(t_exp, times, dfs)
-        vTree1 = model.option_on_zero_coupon_bond_tree(
+        vTree1 = model.option_on_zero_cpn_bond_tree(
             t_exp, t_mat, strike, face)
 
         model = HWTree(sigma, a, num_time_steps+1)
         model.build_tree(t_exp, times, dfs)
-        vTree2 = model.option_on_zero_coupon_bond_tree(
+        vTree2 = model.option_on_zero_cpn_bond_tree(
             t_exp, t_mat, strike, face)
 
         end = time.time()
         period = end-start
         treeVector.append(vTree1['put'])
         analVector.append(vAnal['put'])
         vTreeCall = (vTree1['call'] + vTree2['call']) / 2.0
         vTreePut = (vTree1['put'] + vTree2['put']) / 2.0
         diffC = vTreeCall - vAnal['call']
         diffP = vTreePut - vAnal['put']
 
         test_cases.print(num_time_steps, period, vTreeCall, vAnal['call'],
-                        vTreePut, vAnal['put'], diffC, diffP)
+                         vTreePut, vAnal['put'], diffC, diffP)
 
  #   plt.plot(num_steps_list, treeVector)
  #   plt.plot(num_steps_list, analVector)
 
 ###############################################################################
 
 
 def test_HullWhiteBondOption():
-    # Valuation of a European option on a coupon bearing bond
+    # Valuation of a European option on a cpn bearing bond
 
     settle_dt = Date(1, 12, 2019)
     issue_dt = Date(1, 12, 2018)
     expiry_dt = settle_dt.add_tenor("18m")
     maturity_dt = settle_dt.add_tenor("10Y")
-    coupon = 0.05
+    cpn = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
-    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
+    bond = Bond(issue_dt, maturity_dt, cpn, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
-    cpn = bond._cpn / bond._freq
+    cpn = bond.cpn / bond.freq
 
-    num_flows = len(bond._cpn_dts)
+    num_flows = len(bond.cpn_dts)
 
     for i in range(1, num_flows):
 
-        pcd = bond._cpn_dts[i-1]
-        ncd = bond._cpn_dts[i]
+        pcd = bond.cpn_dts[i-1]
+        ncd = bond.cpn_dts[i]
 
         if ncd > settle_dt:
 
             if len(cpn_times) == 0:
                 flow_time = (pcd - settle_dt) / gDaysInYear
                 cpn_times.append(flow_time)
                 cpn_flows.append(cpn)
@@ -218,29 +218,29 @@
         print_tree(model._option_values, 5)
 
 
 ###############################################################################
 
 
 def test_HullWhiteCallableBond():
-    # Valuation of a European option on a coupon bearing bond
+    # Valuation of a European option on a cpn bearing bond
 
     settle_dt = Date(1, 12, 2019)
     issue_dt = Date(1, 12, 2018)
     maturity_dt = settle_dt.add_tenor("10Y")
-    coupon = 0.05
+    cpn = 0.05
     freq_type = FrequencyTypes.SEMI_ANNUAL
     dc_type = DayCountTypes.ACT_ACT_ICMA
-    bond = Bond(issue_dt, maturity_dt, coupon, freq_type, dc_type)
+    bond = Bond(issue_dt, maturity_dt, cpn, freq_type, dc_type)
 
     cpn_times = []
     cpn_flows = []
-    cpn = bond._cpn / bond._freq
+    cpn = bond.cpn / bond.freq
 
-    for flow_dt in bond._cpn_dts[1:]:
+    for flow_dt in bond.cpn_dts[1:]:
 
         if flow_dt > settle_dt:
             flow_time = (flow_dt - settle_dt) / gDaysInYear
             cpn_times.append(flow_time)
             cpn_flows.append(cpn)
 
     cpn_times = np.array(cpn_times)
@@ -300,15 +300,15 @@
 
     t_mat = (maturity_dt - settle_dt) / gDaysInYear
     curve = DiscountCurveFlat(settle_dt, 0.05, FrequencyTypes.CONTINUOUS)
 
     dfs = []
     times = []
 
-    for dt in bond._cpn_dts:
+    for dt in bond.cpn_dts:
         if dt > settle_dt:
             t = (dt - settle_dt) / gDaysInYear
             df = curve.df(dt)
             times.append(t)
             dfs.append(df)
 
     dfs = np.array(dfs)
```

### Comparing `financepy-0.350/tests_golden/TestFinModelRatesLMM.py` & `financepy-0.360/tests_golden/TestFinModelRatesLMM.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 ##############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ##############################################################################
 
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.models.lmm_mc import lmm_sticky_caplet_pricer
+from financepy.models.lmm_mc import lmm_ratchet_caplet_pricer
+from financepy.models.lmm_mc import lmm_fwd_fwd_correlation
+from financepy.models.lmm_mc import lmm_swap_pricer
+from financepy.models.lmm_mc import lmm_price_caps_black
+from financepy.models.lmm_mc import lmm_cap_flr_pricer
+from financepy.models.lmm_mc import lmm_swaption_vol_approx
+from financepy.models.lmm_mc import lmm_sim_swaption_vol
+from financepy.models.lmm_mc import lmm_swaption_pricer
+from financepy.models.lmm_mc import lmm_simulate_fwds_mf
+from financepy.models.lmm_mc import lmm_simulate_fwds_1f
+from financepy.models.lmm_mc import lmm_simulate_fwds_nf
+from financepy.utils.helpers import check_vector_differences
+from financepy.products.rates.ibor_swaption import IborSwaption
+from financepy.products.rates.ibor_swaption import SwapTypes
+from financepy.utils.frequency import FrequencyTypes
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+from financepy.models.black import Black
+from financepy.utils.day_count import DayCountTypes
+from financepy.utils.date import Date
+from financepy.market.volatility.ibor_cap_vol_curve import IborCapVolCurve
 import numpy as np
 import time as time
 import sys
 sys.path.append("..")
 
-from financepy.market.volatility.ibor_cap_vol_curve import IborCapVolCurve
-from financepy.utils.date import Date
-from financepy.utils.day_count import DayCountTypes
-from financepy.models.black import Black
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.utils.frequency import FrequencyTypes
-from financepy.products.rates.ibor_swaption import SwapTypes
-from financepy.products.rates.ibor_swaption import IborSwaption
-from financepy.utils.helpers import check_vector_differences
-from financepy.models.lmm_mc import lmm_simulate_fwds_nf
-from financepy.models.lmm_mc import lmm_simulate_fwds_1f
-from financepy.models.lmm_mc import lmm_simulate_fwds_mf
-from financepy.models.lmm_mc import lmm_swaption_pricer
-from financepy.models.lmm_mc import lmm_sim_swaption_vol
-from financepy.models.lmm_mc import lmm_swaption_vol_approx
-from financepy.models.lmm_mc import lmm_cap_flr_pricer
-from financepy.models.lmm_mc import lmm_price_caps_black
-from financepy.models.lmm_mc import lmm_swap_pricer
-from financepy.models.lmm_mc import lmm_fwd_fwd_correlation
-from financepy.models.lmm_mc import lmm_ratchet_caplet_pricer
-from financepy.models.lmm_mc import lmm_sticky_caplet_pricer
-from FinTestCases import FinTestCases, globalTestCaseMode
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def getCorrelationMatrix(numFwds, beta, dt):
@@ -121,69 +121,69 @@
 #     seed = 1489
 #     num_paths = 2000  # 100000
 #     fwdsNF = LMMSimulateFwdsNF(numFwds, num_paths, fwd0,
 #                                zetas, correl, taus, seed)
 #     strike = r
 #     PAYSwaption = 1
 #     use_sobol = 0
-#     numeraireIndex = 0
+#     numeraire_index = 0
 
-#     fwds1F = LMMSimulateFwds1F(numFwds, num_paths, numeraireIndex, fwd0,
+#     fwds1F = LMMSimulateFwds1F(numFwds, num_paths, numeraire_index, fwd0,
 #                                zetas, taus, use_sobol, seed)
 
 #     for iExp in range(1, 10):
 
 #         t_exp = float(iExp)
 #         a = int(2*t_exp)
 #         print(a, b)
 
 #         swaption_price1F = LMMSwaptionPricer(strike, a, b, num_paths,
 #                                             fwd0, fwds1F, taus, PAYSwaption)
 
 #         swaption_priceNF = LMMSwaptionPricer(strike, a, b, num_paths,
 #                                             fwd0, fwdsNF, taus, PAYSwaption)
 
-#         swaptionVol = LMMSwaptionVolApprox(a, b, fwd0, taus, zetas, correl)
+#         swaption_vol = LMMSwaptionVolApprox(a, b, fwd0, taus, zetas, correl)
 
 #         swapVolSim1F = LMMSimSwaptionVol(a, b, fwd0, fwds1F, taus)
 #         swapVolSimNF = LMMSimSwaptionVol(a, b, fwd0, fwdsNF, taus)
 
 #         value_dt = Date(1, 1, 2010)
 #         libor_curve = FinDiscountCurveFlat(value_dt, r,
 #                                           FrequencyTypes.QUARTERLY)
 
 #         settle_dt = value_dt
 #         exercise_dt = settle_dt.add_months(a*3)
 #         maturity_dt = settle_dt.add_months(b*3)
 
-#         fixed_coupon = strike
+#         fixed_cpn = strike
 #         fixed_freq_type = FrequencyTypes.QUARTERLY
 #         fixed_dc_type = DayCountTypes.ACT_ACT_ISDA
 #         float_freq_type = FrequencyTypes.QUARTERLY
 #         float_dc_type = DayCountTypes.ACT_ACT_ISDA
 #         notional = 1.0
 
 #         # Pricing a PAY
 #         swaptionType = IborSwaptionTypes.PAY
 #         swaption = IborSwaption(settle_dt,
 #                                     exercise_dt,
 #                                     maturity_dt,
 #                                     swaptionType,
-#                                     fixed_coupon,
+#                                     fixed_cpn,
 #                                     fixed_freq_type,
 #                                     fixed_dc_type,
 #                                     notional,
 #                                     float_freq_type,
 #                                     float_dc_type)
 
-#         model = Black(swaptionVol)
+#         model = Black(swaption_vol)
 #         blackSwaptionPrice = swaption.value(value_dt, libor_curve, model)
 
 #         print("K:%6.5f t_exp:%8.2f FwdVol:%9.5f SimVol1F:%9.5f SimVolNF:%9.5f RebVol:%9.5f SimPx1F:%9.5f SimPxNF:%9.5f Black Px:%9.5f"
-#               % (strike, t_exp, fwd_rateVol, swapVolSim1F, swapVolSimNF, swaptionVol,
+#               % (strike, t_exp, fwd_rateVol, swapVolSim1F, swapVolSimNF, swaption_vol,
 #                  swaption_price1F, swaption_priceNF, blackSwaptionPrice))
 
 # #        print(swaption)
 
 ###############################################################################
 
 
@@ -203,25 +203,25 @@
 
 #     correl = getCorrelationMatrix(numFwds, 100.0, dt)
 
 #     # At the money
 #     K = r
 #     capletPricesBlack = LMMPriceCapsBlack(fwd0, zetas, numFwds, K, taus)
 
-#     numFactors = 1
-#     numeraireIndex = 1
+#     num_factors = 1
+#     numeraire_index = 1
 #     use_sobol = 1
 
 #     # Examine variance for different seeds
 #     for seed in seeds:
 
 #         print("=============================================================")
 #         print("Seed:", seed)
 
-#         fwds1F = LMMSimulateFwds1F(numFwds, num_paths, numeraireIndex, fwd0,
+#         fwds1F = LMMSimulateFwds1F(numFwds, num_paths, numeraire_index, fwd0,
 #                                    zetas, taus, use_sobol, seed)
 
 #         sumCap1F = LMMCapFlrPricer(numFwds, num_paths, K, fwd0, fwds1F, taus, 1)
 #         sumFlr1F = LMMCapFlrPricer(numFwds, num_paths, K, fwd0, fwds1F, taus, 0)
 
 #         fwdsNF = LMMSimulateFwdsNF(numFwds, num_paths, fwd0,
 #                                    zetas, correl, taus, seed)
@@ -266,25 +266,25 @@
     test_cases.header("COMMENTS", "VALUES")
 
     ###########################################################################
     # HULL TABLE 32.1
     ###########################################################################
 
     use_sobol = 1
-    numeraireIndex = 0
+    numeraire_index = 0
 
     # We need the volatility for the forward rates out to the one starting in
     # 10 years. So we have 11 elements. The one starting today has zero vol.
-    numFactors = 1
+    num_factors = 1
     gammas1FList = [0.00, 0.1550, 0.2063674, 0.1720986, 0.1721993, 0.1524579,
                     0.1414779, 0.1297711, 0.1381053, 0.135955, 0.1339842]
     gammas1F = np.array(gammas1FList)
 
     # One factor model
-    fwds1F = lmm_simulate_fwds_1f(numFwds, num_paths, numeraireIndex, fwd0,
+    fwds1F = lmm_simulate_fwds_1f(numFwds, num_paths, numeraire_index, fwd0,
                                   gammas1F, taus, use_sobol, seed)
 
 #    LMMPrintForwards(fwds1F)
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwds1F, taus) * 100.0
 
@@ -308,21 +308,21 @@
     if verbose:
         test_cases.banner("STICKY CAPLETS ONE FACTOR IMPLEMENTATION")
         test_cases.print("FINANCEPY GETS:", vStickyCaplets)
         test_cases.print("HULL GETS:", hullStickyCaplets1F)
 
     check_vector_differences(vStickyCaplets, hullStickyCaplets1F, 1e-2)
 
-    numFactors = 1
+    num_factors = 1
     lambdas1FList = [[0.0, 0.1550, 0.2064, 0.1721, 0.1722, 0.1525,
                       0.1415, 0.1298, 0.1381, 0.1360, 0.1340]]
     lambdas1F = np.array(lambdas1FList)
 
     # One factor model
-    fwdsMF = lmm_simulate_fwds_mf(numFwds, numFactors, num_paths, numeraireIndex,
+    fwdsMF = lmm_simulate_fwds_mf(numFwds, num_factors, num_paths, numeraire_index,
                                   fwd0, lambdas1F, taus, use_sobol, seed)
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwdsMF, taus) * 100.0
 
     hullRatchetCaplets1F = [0.0, 0.196, 0.207, 0.201, 0.194, 0.187,
                             0.1890, 0.172, 0.167, 0.160, 0.153]
@@ -343,23 +343,23 @@
     check_vector_differences(vStickyCaplets, hullStickyCaplets1F, 1e-2)
 
     if verbose:
         test_cases.banner("STICKY RATCHET - NUM FACTORS 1")
         test_cases.print("FINANCEPY GETS:", vStickyCaplets)
         test_cases.print("HULL GETS:", hullStickyCaplets1F)
 
-    numFactors = 2
+    num_factors = 2
     lambdas2FList = [[0.00, 0.1410, 0.1952, 0.1678, 0.1711, 0.1525,
                       0.1406, 0.1265, 0.1306, 0.1236, 0.1163],
                      [0.00, -0.0645, -0.0670, -0.0384, -0.0196, 0.00,
                       0.0161, 0.0289, 0.0448, 0.0565, 0.0665]]
     lambdas2F = np.array(lambdas2FList)
 
     # Two factor model
-    fwds2F = lmm_simulate_fwds_mf(numFwds, numFactors, num_paths, numeraireIndex,
+    fwds2F = lmm_simulate_fwds_mf(numFwds, num_factors, num_paths, numeraire_index,
                                   fwd0, lambdas2F, taus, use_sobol, seed)
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwds2F, taus) * 100.0
     hullRatchetCaplets2F = [0.00, 0.194, 0.207, 0.205, 0.198, 0.193,
                             0.189, 0.180, 0.174, 0.168, 0.162]
 
@@ -379,25 +379,25 @@
     if verbose:
         test_cases.banner("STICKY RATCHET - NUM FACTORS:2")
         test_cases.print("FINANCEPY GETS:", vStickyCaplets)
         test_cases.print("HULL GETS:", hullStickyCaplets2F)
 
     check_vector_differences(vStickyCaplets, hullStickyCaplets2F, 1e-2)
 
-    numFactors = 3
+    num_factors = 3
     lambdas3FList = [[0.00, 0.1365, 0.1928, 0.1672, 0.1698, 0.1485,
                       0.1395, 0.1261, 0.1290, 0.1197, 0.1097],
                      [0.0, -0.0662, -0.0702, -0.0406, -0.0206, 0.00,
                       0.0169, 0.0306, 0.0470, 0.0581, 0.0666],
                      [0.0, 0.0319, 0.0225, 0.000, -0.0198, -0.0347,
                       -0.0163, 0.000, 0.0151, 0.0280, 0.0384]]
     lambdas3F = np.array(lambdas3FList)
 
     # Three factor model
-    fwds3F = lmm_simulate_fwds_mf(numFwds, numFactors, num_paths, numeraireIndex,
+    fwds3F = lmm_simulate_fwds_mf(numFwds, num_factors, num_paths, numeraire_index,
                                   fwd0, lambdas3F, taus, use_sobol, seed)
 
     hullRatchetCaplets3F = [0.00, 0.194, 0.207, 0.205, 0.198, 0.193,
                             0.189, 0.180, 0.174, 0.168, 0.162]
 
     vRatchetCaplets = lmm_ratchet_caplet_pricer(spread, numFwds, num_paths,
                                                 fwd0, fwds3F, taus) * 100.0
```

### Comparing `financepy-0.350/tests_golden/TestFinModelSABR.py` & `financepy-0.360/tests_golden/TestFinModelSABR.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinModelShiftedSABR.py` & `financepy-0.360/tests_golden/TestFinModelShiftedSABR.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinNumbaNumpySpeed.py` & `financepy-0.360/tests_golden/TestFinNumbaNumpySpeed.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinOIS.py` & `financepy-0.360/tests_golden/TestFinOIS.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinOISCurve.py` & `financepy-0.360/tests_golden/TestFinOISCurve.py`

 * *Files 24% similar despite different names*

```diff
@@ -32,306 +32,306 @@
 
 def test_OISFRAsOnly():
 
     # TO DO FIX THIS
     value_dt = Date(23, 2, 2018)
 
     spot_days = 0
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
 
     depoDCCType = DayCountTypes.ACT_360
     notional = 100.0
 
-    payFixed = True
+    pay_fixed = True
 
     cal_type = CalendarTypes.TARGET
     fras = []
 
     # 1 x 4 FRA
-    fraRate = 0.04
-    frasettleDt = settleDt.add_months(1)
-    fraMaturityDate = settleDt.add_months(4)
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate,
-                  depoDCCType, notional, payFixed, cal_type)
+    fra_rate = 0.04
+    fra_settle_dt = settle_dt.add_months(1)
+    fra_maturity_dt = settle_dt.add_months(4)
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate,
+                  depoDCCType, notional, pay_fixed, cal_type)
     fras.append(fra)
 
     # 4 x 7 FRA
-    fraRate = 0.08
-    frasettleDt = settleDt.add_months(4)
-    fraMaturityDate = settleDt.add_months(7)
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate,
-                  depoDCCType, notional, payFixed, cal_type)
+    fra_rate = 0.08
+    fra_settle_dt = settle_dt.add_months(4)
+    fra_maturity_dt = settle_dt.add_months(7)
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate,
+                  depoDCCType, notional, pay_fixed, cal_type)
     fras.append(fra)
 
     swaps = []
 
-    libor_curve = OISCurve(settleDt,
+    libor_curve = OISCurve(settle_dt,
                            fras,
                            swaps)
 
     test_cases.header("DATE", "MATDATE", "VALUE")
 
     """ Check calibration """
     for fra in fras:
-        v = fra.value(settleDt, libor_curve)
-        test_cases.print("FRA:", fra._maturity_dt, v)
+        v = fra.value(settle_dt, libor_curve)
+        test_cases.print("FRA:", fra.maturity_dt, v)
 
 ###############################################################################
 
 
 def test_OISDepositsFRAsSwaps():
 
     value_dt = Date(18, 9, 2019)
 
     dccType = DayCountTypes.THIRTY_E_360_ISDA
     depos = []
 
     spot_days = 0
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
 
     depoDCCType = DayCountTypes.ACT_360
     notional = 100.0
     cal_type = CalendarTypes.TARGET
     depos = []
 
     # 1 month
     deposit_rate = 0.04
-    maturity_dt = settleDt.add_months(1)
-    depo = IborDeposit(settleDt, maturity_dt, deposit_rate,
+    maturity_dt = settle_dt.add_months(1)
+    depo = IborDeposit(settle_dt, maturity_dt, deposit_rate,
                        depoDCCType, notional, cal_type)
     depos.append(depo)
 
     fras = []
     # 1 x 4 FRA
-    fraRate = 0.04
-    frasettleDt = settleDt.add_months(9)
-    fraMaturityDate = settleDt.add_months(13)
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, dccType)
+    fra_rate = 0.04
+    fra_settle_dt = settle_dt.add_months(9)
+    fra_maturity_dt = settle_dt.add_months(13)
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, dccType)
     fras.append(fra)
 
     # 4 x 7 FRA
-    fraRate = 0.03
-    frasettleDt = settleDt.add_months(13)
-    fraMaturityDate = settleDt.add_months(17)
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, dccType)
+    fra_rate = 0.03
+    fra_settle_dt = settle_dt.add_months(13)
+    fra_maturity_dt = settle_dt.add_months(17)
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, dccType)
     fras.append(fra)
 
     # 4 x 7 FRA
-    fraRate = 0.07
-    frasettleDt = settleDt.add_months(17)
-    fraMaturityDate = settleDt.add_months(21)
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, dccType)
+    fra_rate = 0.07
+    fra_settle_dt = settle_dt.add_months(17)
+    fra_maturity_dt = settle_dt.add_months(21)
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, dccType)
     fras.append(fra)
 
     swaps = []
-    fixedDCCType = DayCountTypes.ACT_365F
+    fixed_dcc_type = DayCountTypes.ACT_365F
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
 
     swap_rate = 0.05
-#    maturity_dt = settleDt.add_months(24)
-#    swap = IborSwap(settleDt, maturity_dt, swap_rate, fixed_freq_type,
-#                        fixedDCCType)
+#    maturity_dt = settle_dt.add_months(24)
+#    swap = IborSwap(settle_dt, maturity_dt, swap_rate, fixed_freq_type,
+#                        fixed_dcc_type)
 #    swaps.append(swap)
 
     fixed_leg_type = SwapTypes.PAY
-    maturity_dt = settleDt.add_months(36)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(36)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(48)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(48)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(60)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(60)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(72)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(72)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(84)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(84)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(96)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(96)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(108)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(108)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(120)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(120)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(132)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(132)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(144)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(144)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(180)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(180)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(240)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(240)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(300)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(300)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
-    maturity_dt = settleDt.add_months(360)
-    swap = OIS(settleDt, maturity_dt, fixed_leg_type, swap_rate,
+    maturity_dt = settle_dt.add_months(360)
+    swap = OIS(settle_dt, maturity_dt, fixed_leg_type, swap_rate,
                fixed_freq_type,
-               fixedDCCType)
+               fixed_dcc_type)
     swaps.append(swap)
 
     libor_curve = OISCurve(value_dt,
                            depos,
                            fras,
                            swaps)
 
-    df = libor_curve.df(settleDt)
+    df = libor_curve.df(settle_dt)
 
     test_cases.header("SETTLEMENT DATE", "DF")
-    test_cases.print(str(settleDt), df)
+    test_cases.print(str(settle_dt), df)
     test_cases.header("DATE", "DF")
 
     for deposit in depos:
-        df = libor_curve.df(deposit._maturity_dt)
-        test_cases.print(str(deposit._maturity_dt), df)
+        df = libor_curve.df(deposit.maturity_dt)
+        test_cases.print(str(deposit.maturity_dt), df)
 
     for swap in swaps:
-        df = libor_curve.df(swap._maturity_dt)
-        test_cases.print(str(swap._maturity_dt), df)
+        df = libor_curve.df(swap.maturity_dt)
+        test_cases.print(str(swap.maturity_dt), df)
 
 
 ###############################################################################
 ###############################################################################
 # https://github.com/vilen22/curve-building/blob/master/Bloomberg%20Curve%20Building%20Replication.xlsx
 ###############################################################################
 ###############################################################################
 # AGREEMENT IS VERY CLOSE - NOT SURE ABOUT SIZE OF LAST PAYMENT ON FIXED LEG!
 
 
-def futureToFRARate(price, convexity):
+def futureTofra_rate(price, convexity):
     futRate = (100-price)/100
     if convexity < 0:
-        fraRate = futRate + convexity/100.0
+        fra_rate = futRate + convexity/100.0
     else:
-        fraRate = futRate - convexity/100.0
+        fra_rate = futRate - convexity/100.0
 
-    return fraRate
+    return fra_rate
 
 ###############################################################################
 
 
 def test_OISDepositsFuturesSwaps():
 
     spot_dt = Date(6, 6, 2018)
     spot_days = 0
-    settleDt = spot_dt.add_weekdays(spot_days)
+    settle_dt = spot_dt.add_weekdays(spot_days)
     depoDCCType = DayCountTypes.THIRTY_E_360_ISDA
 
-    depo = IborDeposit(settleDt, "1D", 1.712 / 100.0, depoDCCType)
+    depo = IborDeposit(settle_dt, "1D", 1.712 / 100.0, depoDCCType)
     depos = [depo]
 
     fras = []
 
-    fraRate = futureToFRARate(97.6675, -0.00005)
-    frasettleDt = spot_dt.next_imm_date()
-    fraMaturityDate = frasettleDt.next_imm_date()
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, depoDCCType)
+    fra_rate = futureTofra_rate(97.6675, -0.00005)
+    fra_settle_dt = spot_dt.next_imm_date()
+    fra_maturity_dt = fra_settle_dt.next_imm_date()
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.5200, -0.00060)
-    frasettleDt = fraMaturityDate
-    fraMaturityDate = frasettleDt.next_imm_date()
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, depoDCCType)
+    fra_rate = futureTofra_rate(97.5200, -0.00060)
+    fra_settle_dt = fra_maturity_dt
+    fra_maturity_dt = fra_settle_dt.next_imm_date()
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.3550, -0.00146)
-    frasettleDt = fraMaturityDate
-    fraMaturityDate = frasettleDt.next_imm_date()
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, depoDCCType)
+    fra_rate = futureTofra_rate(97.3550, -0.00146)
+    fra_settle_dt = fra_maturity_dt
+    fra_maturity_dt = fra_settle_dt.next_imm_date()
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.2450, -0.00263)
-    frasettleDt = fraMaturityDate
-    fraMaturityDate = frasettleDt.next_imm_date()
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, depoDCCType)
+    fra_rate = futureTofra_rate(97.2450, -0.00263)
+    fra_settle_dt = fra_maturity_dt
+    fra_maturity_dt = fra_settle_dt.next_imm_date()
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.1450, -0.00411)
-    frasettleDt = fraMaturityDate
-    fraMaturityDate = frasettleDt.next_imm_date()
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, depoDCCType)
+    fra_rate = futureTofra_rate(97.1450, -0.00411)
+    fra_settle_dt = fra_maturity_dt
+    fra_maturity_dt = fra_settle_dt.next_imm_date()
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, depoDCCType)
     fras.append(fra)
 
-    fraRate = futureToFRARate(97.0750, -0.00589)
-    frasettleDt = frasettleDt.next_imm_date()
-    fraMaturityDate = frasettleDt.next_imm_date()
-    fra = IborFRA(frasettleDt, fraMaturityDate, fraRate, depoDCCType)
+    fra_rate = futureTofra_rate(97.0750, -0.00589)
+    fra_settle_dt = fra_settle_dt.next_imm_date()
+    fra_maturity_dt = fra_settle_dt.next_imm_date()
+    fra = IborFRA(fra_settle_dt, fra_maturity_dt, fra_rate, depoDCCType)
     fras.append(fra)
 
     ###########################################################################
 
     spot_days = 2
     start_dt = spot_dt.add_weekdays(spot_days)
 
     swaps = []
     fixed_leg_type = SwapTypes.PAY
-    fixedDCCType = DayCountTypes.THIRTY_E_360
+    fixed_dcc_type = DayCountTypes.THIRTY_E_360
     fixed_freq_type = FrequencyTypes.SEMI_ANNUAL
     float_freq_type = FrequencyTypes.QUARTERLY
     notional = 1000000
     float_spread = 0.0
-    floatDCCType = DayCountTypes.ACT_360
+    float_dcc_type = DayCountTypes.ACT_360
     cal_type = CalendarTypes.UNITED_STATES
-    busDayAdjustRule = BusDayAdjustTypes.PRECEDING
+    bus_day_adjust_rule = BusDayAdjustTypes.PRECEDING
 
     swap_rate = 0.02776305
     payment_lag = 1
 
     swap = OIS(start_dt, "2Y", fixed_leg_type,
-               swap_rate, fixed_freq_type, fixedDCCType, notional,
-               payment_lag, float_spread, float_freq_type, floatDCCType,
-               cal_type, busDayAdjustRule)
+               swap_rate, fixed_freq_type, fixed_dcc_type, notional,
+               payment_lag, float_spread, float_freq_type, float_dcc_type,
+               cal_type, bus_day_adjust_rule)
 
     swaps.append(swap)
 
     libor_curve = OISCurve(spot_dt, depos, fras, swaps)
 
     times = np.linspace(0.0, 2.0, 25)
     dates = spot_dt.add_years(times)
@@ -351,29 +351,29 @@
             print(fra)
         print("==============================================================")
 
         end_dt = spot_dt
         df = libor_curve.df(end_dt)
         print(end_dt, df)
 
-        end_dt = settleDt
+        end_dt = settle_dt
         df = libor_curve.df(end_dt)
         print(end_dt, df)
 
         end_dt = Date(20, 6, 2018)
         df = libor_curve.df(end_dt)
         print(end_dt, df)
 
         for fra in fras:
-            end_dt = fra._maturity_dt
+            end_dt = fra.maturity_dt
             df = libor_curve.df(end_dt)
             print(end_dt, df)
 
         for swap in swaps:
-            end_dt = swap._maturity_dt
+            end_dt = swap.maturity_dt
             df = libor_curve.df(end_dt)
             print(end_dt, df)
 
         swap.print_fixed_leg_pv(spot_dt)
         swap.print_float_leg_pv(spot_dt)
 
 #        print(libor_curve)
@@ -383,61 +383,61 @@
 
 def test_derivativePricingExample():
 
     value_dt = Date(10, 11, 2011)
 
     # We do the O/N rate which settles on trade date
     spot_days = 0
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
 
     fras = []
 
     swaps = []
     dc_type = DayCountTypes.THIRTY_E_360_ISDA
 #    dc_type = DayCountTypes.ACT_360
     freq_type = FrequencyTypes.SEMI_ANNUAL
     fixed_leg_type = SwapTypes.PAY
 
     swap_rate = 0.0058
-    swap = OIS(settleDt, "1Y", fixed_leg_type,
+    swap = OIS(settle_dt, "1Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0060
-    swap = OIS(settleDt, "2Y", fixed_leg_type,
+    swap = OIS(settle_dt, "2Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0072
-    swap = OIS(settleDt, "3Y", fixed_leg_type,
+    swap = OIS(settle_dt, "3Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0096
-    swap = OIS(settleDt, "4Y", fixed_leg_type,
+    swap = OIS(settle_dt, "4Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0124
-    swap = OIS(settleDt, "5Y", fixed_leg_type,
+    swap = OIS(settle_dt, "5Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0173
-    swap = OIS(settleDt, "7Y", fixed_leg_type,
+    swap = OIS(settle_dt, "7Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0219
-    swap = OIS(settleDt, "10Y", fixed_leg_type,
+    swap = OIS(settle_dt, "10Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     swap_rate = 0.0283
-    swap = OIS(settleDt, "30Y", fixed_leg_type,
+    swap = OIS(settle_dt, "30Y", fixed_leg_type,
                swap_rate, freq_type, dc_type)
     swaps.append(swap)
 
     numRepeats = 10
     start = time.time()
 
     for _ in range(0, numRepeats):
@@ -468,18 +468,18 @@
     https://github.com/vilen22/curve-building/blob/master/Bloomberg%20Curve%20Building%20Replication.xlsx
     """
 
     value_dt = Date(6, 6, 2018)
 
     # We do the O/N rate which settles on trade date
     spot_days = 0
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
     accrual = DayCountTypes.THIRTY_E_360
 
-    depo = IborDeposit(settleDt, "1D", 1.712 / 100.0, accrual)
+    depo = IborDeposit(settle_dt, "1D", 1.712 / 100.0, accrual)
     depos = [depo]
 
     futs = []
     fut = IborFuture(value_dt, 1)
     futs.append(fut)
     fut = IborFuture(value_dt, 2)
     futs.append(fut)
@@ -499,90 +499,90 @@
     fras[3] = futs[3].to_fra(97.2450, -0.00263)
     fras[4] = futs[4].to_fra(97.1450, -0.00411)
     fras[5] = futs[5].to_fra(97.0750, -0.00589)
 
     accrual = DayCountTypes.THIRTY_E_360
     freq = FrequencyTypes.SEMI_ANNUAL
     spot_days = 2
-    settleDt = value_dt.add_weekdays(spot_days)
+    settle_dt = value_dt.add_weekdays(spot_days)
     payRec = SwapTypes.PAY
     lag = 1  # Not used
 
     swaps = []
-    swap = OIS(settleDt, "2Y", payRec,
+    swap = OIS(settle_dt, "2Y", payRec,
                (2.77417 + 2.77844) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "3Y", payRec,
+    swap = OIS(settle_dt, "3Y", payRec,
                (2.86098 + 2.86582) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "4Y", payRec,
+    swap = OIS(settle_dt, "4Y", payRec,
                (2.90240 + 2.90620) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "5Y", payRec,
+    swap = OIS(settle_dt, "5Y", payRec,
                (2.92944 + 2.92906) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "6Y", payRec,
+    swap = OIS(settle_dt, "6Y", payRec,
                (2.94001 + 2.94499) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "7Y", payRec,
+    swap = OIS(settle_dt, "7Y", payRec,
                (2.95352 + 2.95998) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "8Y", payRec,
+    swap = OIS(settle_dt, "8Y", payRec,
                (2.96830 + 2.97400) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "9Y", payRec,
+    swap = OIS(settle_dt, "9Y", payRec,
                (2.98403 + 2.98817) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "10Y", payRec,
+    swap = OIS(settle_dt, "10Y", payRec,
                (2.99716 + 3.00394) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "11Y", payRec,
+    swap = OIS(settle_dt, "11Y", payRec,
                (3.01344 + 3.01596) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "12Y", payRec,
+    swap = OIS(settle_dt, "12Y", payRec,
                (3.02276 + 3.02684) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "15Y", payRec,
+    swap = OIS(settle_dt, "15Y", payRec,
                (3.04092 + 3.04508) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "20Y", payRec,
+    swap = OIS(settle_dt, "20Y", payRec,
                (3.04417 + 3.05183) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "25Y", payRec,
+    swap = OIS(settle_dt, "25Y", payRec,
                (3.03219 + 3.03621) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "30Y", payRec,
+    swap = OIS(settle_dt, "30Y", payRec,
                (3.01030 + 3.01370) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "40Y", payRec,
+    swap = OIS(settle_dt, "40Y", payRec,
                (2.96946 + 2.97354) / 200, freq, accrual)
     swaps.append(swap)
-    swap = OIS(settleDt, "50Y", payRec,
+    swap = OIS(settle_dt, "50Y", payRec,
                (2.91552 + 2.93748) / 200, freq, accrual)
     swaps.append(swap)
 
     oisCurve = OISCurve(value_dt, depos, fras, swaps)
 
 #    swaps[0]._fixed_leg.print_valuation()
 #    swaps[0]._float_leg.print_valuation()
 
     # The valuation of 53714.55 is very close to the spreadsheet value 53713.96
 
     test_cases.header("VALUATION TO TODAY DATE", " PV")
     test_cases.print("VALUE:", swaps[0].value(value_dt, oisCurve, None))
     test_cases.print(
-        "FIXED:", -swaps[0]._fixed_leg.value(value_dt, oisCurve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
+        "FIXED:", -swaps[0].fixed_leg.value(value_dt, oisCurve))
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
         value_dt, oisCurve, None))
 
     test_cases.header("VALUATION TO SWAP SETTLEMENT DATE", " PV")
-    test_cases.print("VALUE:", swaps[0].value(settleDt, oisCurve, None))
-    test_cases.print("FIXED:", -swaps[0]._fixed_leg.value(settleDt, oisCurve))
-    test_cases.print("FLOAT:", swaps[0]._float_leg.value(
-        settleDt, oisCurve, None))
+    test_cases.print("VALUE:", swaps[0].value(settle_dt, oisCurve, None))
+    test_cases.print("FIXED:", -swaps[0].fixed_leg.value(settle_dt, oisCurve))
+    test_cases.print("FLOAT:", swaps[0].float_leg.value(
+        settle_dt, oisCurve, None))
 
     # swaps[0].print_fixed_leg_pv()
     # swaps[0].print_float_leg_pv()
 
 ###############################################################################
```

### Comparing `financepy-0.350/tests_golden/TestFinOptionImpliedDbn.py` & `financepy-0.360/tests_golden/TestFinOptionImpliedDbn.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,101 +1,99 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+from FinTestCases import FinTestCases, globalTestCaseMode
+from financepy.market.volatility.fx_vol_surface import FinFXDeltaMethod
+from financepy.market.volatility.fx_vol_surface import FinFXATMMethod
+from financepy.market.volatility.fx_vol_surface import FXVolSurface
+from financepy.models.volatility_fns import vol_function_clark
+from financepy.utils.date import Date
+from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
+import numpy as np
 import sys
 sys.path.append("..")
 
-import numpy as np
-from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
-from financepy.utils.date import Date
-from financepy.models.volatility_fns import vol_function_clark
-from financepy.market.volatility.fx_vol_surface import FXVolSurface
-from financepy.market.volatility.fx_vol_surface import FinFXATMMethod
-from financepy.market.volatility.fx_vol_surface import FinFXDeltaMethod
-from FinTestCases import FinTestCases, globalTestCaseMode
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def test_FinOptionImpliedDbn():
 
     if 1 == 1:
 
         # Example from Book extract by Iain Clark using Tables 3.3 and 3.4
         # print("EURUSD EXAMPLE CLARK")
 
         value_dt = Date(10, 4, 2020)
+        for_name = "EUR"
+        dom_name = "USD"
+        for_cc_rate = 0.03460  # EUR
+        dom_cc_rate = 0.02940  # USD
 
-        forName = "EUR"
-        domName = "USD"
-        forCCRate = 0.03460  # EUR
-        domCCRate = 0.02940  # USD
-
-        dom_discount_curve = DiscountCurveFlat(value_dt, domCCRate)
-        for_discount_curve = DiscountCurveFlat(value_dt, forCCRate)
+        domestic_curve = DiscountCurveFlat(value_dt, dom_cc_rate)
+        foreign_curve = DiscountCurveFlat(value_dt, for_cc_rate)
 
-        currency_pair = forName + domName
+        currency_pair = for_name + dom_name
         spot_fx_rate = 1.3465
 
         tenors = ['1M', '2M', '3M', '6M', '1Y', '2Y']
         atm_vols = [21.00, 21.00, 20.750, 19.400, 18.250, 17.677]
-        marketStrangle25DeltaVols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
-        riskReversal25DeltaVols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
+        mkt_strangle_25d_vols = [0.65, 0.75, 0.85, 0.90, 0.95, 0.85]
+        rsk_reversal_25d_vols = [-0.20, -0.25, -0.30, -0.50, -0.60, -0.562]
 
-        notional_currency = forName
+        notional_currency = for_name
 
-        atmMethod = FinFXATMMethod.FWD_DELTA_NEUTRAL
+        atm_method = FinFXATMMethod.FWD_DELTA_NEUTRAL
         delta_method = FinFXDeltaMethod.SPOT_DELTA
 
-        fxMarket = FXVolSurface(value_dt,
+        fx_market = FXVolSurface(value_dt,
                                 spot_fx_rate,
                                 currency_pair,
                                 notional_currency,
-                                dom_discount_curve,
-                                for_discount_curve,
+                                domestic_curve,
+                                foreign_curve,
                                 tenors,
                                 atm_vols,
-                                marketStrangle25DeltaVols,
-                                riskReversal25DeltaVols,
-                                atmMethod,
+                                mkt_strangle_25d_vols,
+                                rsk_reversal_25d_vols,
+                                atm_method,
                                 delta_method)
 
-#        fxMarket.check_calibration(True)
+#        fx_market.check_calibration(True)
 
         PLOT_GRAPHS = False
         if PLOT_GRAPHS:
-            fxMarket.plot_vol_curves()
+            fx_market.plot_vol_curves()
 
-        for iTenor in range(0, len(fxMarket._tenors)):
+        for iTenor in range(0, len(fx_market.tenors)):
 
-            F = fxMarket._F0T[iTenor]
-            t_exp = fxMarket._t_exp[iTenor]
+            F = fx_market.fwd[iTenor]
+            t_exp = fx_market.t_exp[iTenor]
 
-            startFX = F * 0.05
-            endFX = F * 5.0
+            start_fx = F * 0.05
+            end_fx = F * 5.0
 
             num_steps = 10000
-            dFX = (endFX - startFX) / num_steps
+            dFX = (end_fx - start_fx) / num_steps
 
-#            dom_df = dom_discount_curve._df(t_exp)
-#            for_df = for_discount_curve._df(t_exp)
+#            dom_df = domestic_curve._df(t_exp)
+#            for_df = foreign_curve._df(t_exp)
 #            r_d = -np.log(dom_df) / t_exp
 #            r_f = -np.log(for_df) / t_exp
 
-            params = fxMarket._parameters[iTenor]
+            params = fx_market.parameters[iTenor]
 
             strikes = []
             vols = []
 
             for iK in range(0, num_steps):
-                strike = startFX + iK*dFX
+                strike = start_fx + iK*dFX
                 vol = vol_function_clark(params, F, strike, t_exp)
                 strikes.append(strike)
                 vols.append(vol)
 
             strikes = np.array(strikes)
             vols = np.array(vols)
```

### Comparing `financepy-0.350/tests_golden/TestFinPieceCurve.py` & `financepy-0.360/tests_golden/TestFinPieceCurve.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinProcessSimulator.py` & `financepy-0.360/tests_golden/TestFinProcessSimulator.py`

 * *Files 6% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 
 
 def test_FinProcessSimulator():
 
     import time
 
     num_paths = 20000
-    numAnnSteps = 100
+    num_annual_steps = 100
     seed = 1919
     t = 1.0
     modelSim = FinProcessSimulator()
     printPaths = False
 
     test_cases.banner(
         "######################## GBM NORMAL ###############################")
@@ -37,15 +37,15 @@
     scheme = FinGBMNumericalScheme.NORMAL
     model_params = (stock_price, drift, sigma, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.GBM,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.header("PROCESS", "TIME")
     test_cases.print("GBM NORMAL", elapsed)
     if printPaths:
@@ -59,15 +59,15 @@
     scheme = FinGBMNumericalScheme.ANTITHETIC
     model_params = (stock_price, drift, sigma, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.GBM,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("GBM ANTITHETIC", elapsed)
     if printPaths:
         print(paths)
@@ -83,15 +83,15 @@
     scheme = FinHestonNumericalScheme.EULER
     model_params = (stock_price, drift, v0, kappa, theta, sigma, rho, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.HESTON,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("HESTON EULER", elapsed)
     if printPaths:
         print(paths)
@@ -107,15 +107,15 @@
     scheme = FinHestonNumericalScheme.EULERLOG
     model_params = (stock_price, drift, v0, kappa, theta, sigma, rho, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.HESTON,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("HESTON EULERLOG", elapsed)
     if printPaths:
         print(paths)
@@ -131,15 +131,15 @@
     scheme = FinHestonNumericalScheme.QUADEXP
     model_params = (stock_price, drift, v0, kappa, theta, sigma, rho, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.HESTON,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("HESTON QUADEXP", elapsed)
     if printPaths:
         print(paths)
@@ -153,15 +153,15 @@
     scheme = FinVasicekNumericalScheme.NORMAL
     model_params = (r0, kappa, theta, sigma, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.VASICEK,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("VASICEK_NORMAL", elapsed)
     if printPaths:
         print(paths)
@@ -175,15 +175,15 @@
     scheme = FinVasicekNumericalScheme.ANTITHETIC
     model_params = (r0, kappa, theta, sigma, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.VASICEK,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("VASICEK_NORMAL ANTI", elapsed)
     if printPaths:
         print(paths)
@@ -197,15 +197,15 @@
     scheme = CIRNumericalScheme.MILSTEIN
     model_params = (r0, kappa, theta, sigma, scheme)
     start = time.time()
     paths = modelSim.get_process(
         ProcessTypes.CIR,
         t,
         model_params,
-        numAnnSteps,
+        num_annual_steps,
         num_paths,
         seed)
     end = time.time()
     elapsed = end - start
     test_cases.print("CIR", elapsed)
     if printPaths:
         print(paths)
```

### Comparing `financepy-0.350/tests_golden/TestFinSchedule.py` & `financepy-0.360/tests_golden/TestFinSchedule.py`

 * *Files 1% similar despite different names*

```diff
@@ -26,29 +26,29 @@
     test_cases.banner(desc)
     test_cases.banner("=======================================================")
     test_cases.header("OBJ")
     test_cases.print(schedule)
 
     test_cases.header("NUM", "TYPE", "DATE", "YEAR", "DIFF")
 
-    num_flows = len(schedule._adjusted_dts)
-    effDate = schedule._adjusted_dts[0]
+    num_flows = len(schedule.adjusted_dts)
+    effDate = schedule.adjusted_dts[0]
     years = 0.0
     diff = 0.0
     test_cases.print(0, "EFCT DATE", str(effDate), years, diff)
 
-    prev_dt = schedule._adjusted_dts[0]
+    prev_dt = schedule.adjusted_dts[0]
     for i_flow in range(1, num_flows-1):
-        adjustedDate = schedule._adjusted_dts[i_flow]
+        adjustedDate = schedule.adjusted_dts[i_flow]
         years = (adjustedDate - effDate) / 365.0
         diff = (adjustedDate - prev_dt) / 365.0
         test_cases.print(i_flow, "FLOW DATE", str(adjustedDate), years, diff)
         prev_dt = adjustedDate
 
-    termDate = schedule._adjusted_dts[-1]
+    termDate = schedule.adjusted_dts[-1]
     years = (termDate - effDate) / 365.0
     diff = (termDate - prev_dt) / 365.0
 
     test_cases.print(num_flows-1, "TERM DATE", str(termDate), years, diff)
 
 ###############################################################################
 
@@ -306,15 +306,15 @@
                         Date(30, 4, 2024),
                         FrequencyTypes.ANNUAL,
                         CalendarTypes.UNITED_STATES,
                         BusDayAdjustTypes.MODIFIED_FOLLOWING,
                         DateGenRuleTypes.BACKWARD)
 
 #    print(schedule)
-#    print(schedule._adjusted_dts)
+#    print(schedule.adjusted_dts)
 
 ###############################################################################
 
 
 def test_FinScheduleAlignment(eomFlag):
 
     value_dt = Date(29, 3, 2005)
@@ -355,21 +355,21 @@
                       freq_type,
                       cal_type,
                       bd_type,
                       dg_type,
                       adjust_termination_dt,
                       eomFlag)
 
-#    print(sched1._adjusted_dts[-1])
-#    print(sched2._adjusted_dts[len(sched1._adjusted_dts)-1])
+#    print(sched1.adjusted_dts[-1])
+#    print(sched2.adjusted_dts[len(sched1.adjusted_dts)-1])
 
 # THIS TEST IS NO LONGER CORRECT AS I HAVE CHANGED THE  LOGIC TO STEP IN MULTIPLES
 
     compare = (
-        sched1._adjusted_dts[-1] == sched2._adjusted_dts[len(sched1._adjusted_dts)-1])
+        sched1.adjusted_dts[-1] == sched2.adjusted_dts[len(sched1.adjusted_dts)-1])
 
 
 #    print(compare, eomFlag)
 #    assert(compare == eomFlag)
 
 ###############################################################################
 
@@ -403,19 +403,19 @@
                       freq_type,
                       cal_type,
                       bd_type,
                       dg_type,
                       adjust_termination_dt,
                       eomFlag)
 
-#    print(sched1._adjusted_dts)
-#    print(sched2._adjusted_dts[:len(sched1._adjusted_dts)])
+#    print(sched1.adjusted_dts)
+#    print(sched2.adjusted_dts[:len(sched1.adjusted_dts)])
 
     compare = (
-        sched1._adjusted_dts[-1] == sched2._adjusted_dts[len(sched1._adjusted_dts)-1])
+        sched1.adjusted_dts[-1] == sched2.adjusted_dts[len(sched1.adjusted_dts)-1])
     assert(compare == eomFlag)
 
 ###############################################################################
 
 
 def test_FinScheduleAlignmentLeapYearNotEOM():
     """ Effective date on leap year. Not EOM. """
@@ -449,19 +449,19 @@
                       freq_type,
                       cal_type,
                       bd_type,
                       dg_type,
                       adjust_termination_dt,
                       eomFlag)
 
-#    print(sched1._adjusted_dts)
-#    print(sched2._adjusted_dts[:len(sched1._adjusted_dts)])
+#    print(sched1.adjusted_dts)
+#    print(sched2.adjusted_dts[:len(sched1.adjusted_dts)])
 
     compare = (
-        sched1._adjusted_dts[-1] == sched2._adjusted_dts[len(sched1._adjusted_dts)-1])
+        sched1.adjusted_dts[-1] == sched2.adjusted_dts[len(sched1.adjusted_dts)-1])
     assert( compare == True )
 
 ###############################################################################
 
 
 def test_FinScheduleAlignmentEff31():
     """ EOM schedule so all unadjusted dates fall on month end."""
@@ -494,19 +494,19 @@
                       freq_type,
                       cal_type,
                       bd_type,
                       dg_type,
                       adjust_termination_dt,
                       eomFlag)
 
-#    print(sched1._adjusted_dts)
-#    print(sched2._adjusted_dts[:len(sched1._adjusted_dts)])
+#    print(sched1.adjusted_dts)
+#    print(sched2.adjusted_dts[:len(sched1.adjusted_dts)])
 
     compare = (
-        sched1._adjusted_dts[-1] == sched2._adjusted_dts[len(sched1._adjusted_dts)-1])
+        sched1.adjusted_dts[-1] == sched2.adjusted_dts[len(sched1.adjusted_dts)-1])
     assert(compare == True)
 
 ###############################################################################
 
 
 test_FinSchedule()
 test_FinScheduleAlignment(True)
```

### Comparing `financepy-0.350/tests_golden/TestFinSobol.py` & `financepy-0.360/tests_golden/TestFinSobol.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinStatistics.py` & `financepy-0.360/tests_golden/TestFinStatistics.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinSwapLegs.py` & `financepy-0.360/tests_golden/TestFinSwapLegs.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/TestFinSwaptionVolSurface.py` & `financepy-0.360/tests_golden/TestFinSwaptionVolSurface.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,121 +1,107 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
-import numpy as np
 import sys
 sys.path.append("..")
 
+import time
+import numpy as np
+
 from financepy.market.curves.discount_curve_flat import DiscountCurveFlat
 from financepy.market.volatility.swaption_vol_surface import SwaptionVolSurface
 from financepy.utils.date import Date
 from financepy.models.volatility_fns import VolFuncTypes
 from FinTestCases import FinTestCases, globalTestCaseMode
-import time
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 
 ###############################################################################
 
 PLOT_GRAPHS = False
 
 ###############################################################################
 # TODO: ADD LOGGING TO TEST CASES
 ###############################################################################
 
 
-def test_FinSwaptionVolSurface1(verboseCalibration):
+def test_FinSwaptionVolSurface1():
 
     ###########################################################################
 
-    if 1 == 1:
+    # https://fr.mathworks.com/help/fininst/pricing-a-swaption-using-the-sabr-model.html
+
+    value_dt = Date(12, 6, 2013)
 
-        # https://fr.mathworks.com/help/fininst/pricing-a-swaption-using-the-sabr-model.html
+    # These are 3M, 1Y, 2Y, 3Y, 4Y, 5Y, 7Y, 10Y
+    exercise_dts = [Date(12, 9, 2013), Date(12, 6, 2014),
+                      Date(12, 6, 2015), Date(12, 6, 2016),
+                      Date(12, 6, 2017), Date(12, 6, 2018),
+                      Date(12, 6, 2020), Date(12, 6, 2023)]
+
+    # First dimension is the strike, then the expiry date
+    market_volatilities = [[57.6, 53.7, 49.4, 45.6, 44.1, 41.1, 35.2, 32.0],
+                          [46.6, 46.9, 44.8, 41.6, 39.8, 37.4, 33.4, 31.0],
+                          [35.9, 39.3, 39.6, 37.9, 37.2, 34.7, 30.5, 28.9],
+                          [34.1, 36.5, 37.8, 36.6, 35.0, 31.9, 28.1, 26.6],
+                          [41.0, 41.3, 39.5, 37.8, 36.0, 32.6, 29.0, 26.0],
+                          [45.8, 43.4, 41.9, 39.2, 36.9, 33.2, 29.6, 26.3],
+                          [50.3, 46.9, 44.0, 40.0, 37.5, 33.8, 30.2, 27.3]]
+
+    market_volatilities = np.array(market_volatilities) / 100.0
+
+    # First dimension is the strike, then the expiry date
+    market_strikes = [[1.00, 1.25, 1.68, 2.00, 2.26, 2.41, 2.58, 2.62],
+                     [1.50, 1.75, 2.18, 2.50, 2.76, 2.91, 3.08, 3.12],
+                     [2.00, 2.25, 2.68, 3.00, 3.26, 3.41, 3.58, 3.62],
+                     [2.50, 2.75, 3.18, 3.50, 3.76, 3.91, 4.08, 4.12],
+                     [3.00, 3.25, 3.68, 4.00, 4.26, 4.41, 4.58, 4.62],
+                     [3.50, 3.75, 4.18, 4.50, 4.76, 4.91, 5.08, 5.12],
+                     [4.00, 4.25, 4.68, 5.00, 5.26, 5.41, 5.58, 5.62]]
+
+    market_strikes = np.array(market_strikes) / 100.0
+
+    fwd_swap_rates = market_strikes[3]
+    atm_vols = market_volatilities[3]
+
+    rfrRate = 0.020  # USD
+    discount_curve = DiscountCurveFlat(value_dt, rfrRate)
+
+    divRate = 0.010  # USD
+    dividend_curve = DiscountCurveFlat(value_dt, divRate)
+
+    vol_functionType = VolFuncTypes.SABR_BETA_HALF
+
+    swaptionSurface = SwaptionVolSurface(value_dt,
+                                         exercise_dts,
+                                         fwd_swap_rates,
+                                         market_strikes,
+                                         market_volatilities,
+                                         vol_functionType)
 
-        value_dt = Date(12, 6, 2013)
 
-        # These are 3M, 1Y, 2Y, 3Y, 4Y, 5Y, 7Y, 10Y
-        exercise_dts = [Date(12, 9, 2013), Date(12, 6, 2014),
-                          Date(12, 6, 2015), Date(12, 6, 2016),
-                          Date(12, 6, 2017), Date(12, 6, 2018),
-                          Date(12, 6, 2020), Date(12, 6, 2023)]
-
-        # First dimension is the strike, then the expiry date
-        marketVolatilities = [[57.6, 53.7, 49.4, 45.6, 44.1, 41.1, 35.2, 32.0],
-                              [46.6, 46.9, 44.8, 41.6, 39.8, 37.4, 33.4, 31.0],
-                              [35.9, 39.3, 39.6, 37.9, 37.2, 34.7, 30.5, 28.9],
-                              [34.1, 36.5, 37.8, 36.6, 35.0, 31.9, 28.1, 26.6],
-                              [41.0, 41.3, 39.5, 37.8, 36.0, 32.6, 29.0, 26.0],
-                              [45.8, 43.4, 41.9, 39.2, 36.9, 33.2, 29.6, 26.3],
-                              [50.3, 46.9, 44.0, 40.0, 37.5, 33.8, 30.2, 27.3]]
-
-        marketVolatilities = np.array(marketVolatilities) / 100.0
-
-        # First dimension is the strike, then the expiry date
-        marketStrikes = [[1.00, 1.25, 1.68, 2.00, 2.26, 2.41, 2.58, 2.62],
-                         [1.50, 1.75, 2.18, 2.50, 2.76, 2.91, 3.08, 3.12],
-                         [2.00, 2.25, 2.68, 3.00, 3.26, 3.41, 3.58, 3.62],
-                         [2.50, 2.75, 3.18, 3.50, 3.76, 3.91, 4.08, 4.12],
-                         [3.00, 3.25, 3.68, 4.00, 4.26, 4.41, 4.58, 4.62],
-                         [3.50, 3.75, 4.18, 4.50, 4.76, 4.91, 5.08, 5.12],
-                         [4.00, 4.25, 4.68, 5.00, 5.26, 5.41, 5.58, 5.62]]
-
-        marketStrikes = np.array(marketStrikes) / 100.0
-
-        fwd_swap_rates = marketStrikes[3]
-        atm_vols = marketVolatilities[3]
-
-        rfrRate = 0.020  # USD
-        discount_curve = DiscountCurveFlat(value_dt, rfrRate)
-
-        divRate = 0.010  # USD
-        dividend_curve = DiscountCurveFlat(value_dt, divRate)
-
-        vol_functionType = VolFuncTypes.SABR_BETA_HALF
-
-        swaptionSurface = SwaptionVolSurface(value_dt,
-                                             exercise_dts,
-                                             fwd_swap_rates,
-                                             marketStrikes,
-                                             marketVolatilities,
-                                             vol_functionType)
+    if 1 == 0:  # PLOT_GRAPHS:
 
         tol = 1e-4
         swaptionSurface.check_calibration(False, tol)
 
-        if 1 == 1:  # PLOT_GRAPHS:
+        swaptionSurface.plot_vol_curves()
 
-            swaptionSurface.plot_vol_curves()
+        # plt.figure()
 
-            # plt.figure()
+        # mins = 0.5
+        # maxs = 5.0
 
-            # mins = 0.5
-            # maxs = 5.0
+        # dbns = swaptionSurface.implied_dbns(mins, maxs, 1000)
 
-            # dbns = swaptionSurface.implied_dbns(mins, maxs, 1000)
-
-            # for i in range(0, len(dbns)):
-            #     expiry_dt_str = str(equitySurface._expiry_dts[i])
-            #     plt.plot(dbns[i]._x, dbns[i]._densitydx, label = expiry_dt_str)
-            #     plt.title(vol_functionType)
-            #     plt.legend()
-            #     print("SUM:", dbns[i].sum())
+        # for i in range(0, len(dbns)):
+        #     expiry_dt_str = str(equitySurface._expiry_dts[i])
+        #     plt.plot(dbns[i]._x, dbns[i]._densitydx, label = expiry_dt_str)
+        #     plt.title(vol_functionType)
+        #     plt.legend()
+        #     print("SUM:", dbns[i].sum())
 
 ###############################################################################
 
-
-if __name__ == '__main__':
-
-    start = time.time()
-
-    verboseCalibration = False
-
-    test_FinSwaptionVolSurface1(verboseCalibration)
-
-    end = time.time()
-
-    elapsed = end - start
-    print("Elapsed Time:", elapsed)
-    test_cases.compareTestCases()
+test_FinSwaptionVolSurface1()
```

### Comparing `financepy-0.350/tests_golden/TestFinVasicekRateModel.py` & `financepy-0.360/tests_golden/TestFinVasicekRateModel.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 ###############################################################################
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
+import sys
+sys.path.append("..")
 import time
+
 import numpy as np
 from financepy.models.vasicek_mc import zero_price, zero_price_mc
 from FinTestCases import FinTestCases, globalTestCaseMode
-import sys
-sys.path.append("..")
-
 
 test_cases = FinTestCases(__file__, globalTestCaseMode)
 
 ###############################################################################
 
 
 def test_FinModelRatesVasicek():
```

### Comparing `financepy-0.350/tests_golden/TestFinVolatilityCurve.py` & `financepy-0.360/tests_golden/TestFinVolatilityCurve.py`

 * *Files identical despite different names*

### Comparing `financepy-0.350/tests_golden/run_all_tests.py` & `financepy-0.360/tests_golden/run_all_tests.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (C) 2018, 2019, 2020 Dominic O'Kane
 ###############################################################################
 
 import glob
 from os.path import dirname, basename, join
 
 import sys
-sys.path.append("./..")
+sys.path.append("..")
 
 from financepy.utils.date import set_date_format, DateFormatTypes
 from financepy.utils.error import FinError
 
 # This only works if I have an init.py in the parent folder
 
 set_date_format(DateFormatTypes.UK_LONG)
```

